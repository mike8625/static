var __defProp = Object.defineProperty,
  __hasOwnProp = Object.prototype.hasOwnProperty,
  __getOwnPropSymbols = Object.getOwnPropertySymbols,
  __propIsEnum = Object.prototype.propertyIsEnumerable,
  __defNormalProp = (e, t, i) =>
    t in e
      ? __defProp(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i })
      : (e[t] = i),
  __assign2 = (e, t) => {
    for (var i in t || (t = {})) __hasOwnProp.call(t, i) && __defNormalProp(e, i, t[i])
    if (__getOwnPropSymbols)
      for (var i of __getOwnPropSymbols(t)) __propIsEnum.call(t, i) && __defNormalProp(e, i, t[i])
    return e
  }
import {
  d as defineComponent,
  k as ref,
  l as onMounted,
  o as openBlock,
  c as createBlock,
  j as h,
  K as onUpdated,
  w as watch,
  A as onBeforeUnmount,
  n as nextTick$1,
  I as onBeforeUpdate,
  h as computed,
  r as reactive,
  M as toRefs,
  a as resolveComponent,
  b as createVNode,
  f as withCtx,
  G as createTextVNode,
  N as toDisplayString,
  P as createCommentVNode,
  F as Fragment,
  O as renderList
} from './vendor.bdbfe8c2.js'
import { h as http } from './http.00eab765.js'
import { u as useRouter, a as useRoute } from './index.1917a777.js'
function createCommonjsModule(e) {
  var t = { exports: {} }
  return e(t, t.exports), t.exports
}
var lottie = createCommonjsModule(function (module) {
    var root, factory
    'undefined' != typeof navigator &&
      ((root = window || {}),
      (factory = function (window) {
        var svgNS = 'http://www.w3.org/2000/svg',
          locationHref = '',
          initialDefaultFrame = -999999,
          subframeEnabled = !0,
          expressionsPlugin,
          isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
          bmPow = Math.pow,
          bmSqrt = Math.sqrt,
          bmFloor = Math.floor,
          bmMax = Math.max,
          bmMin = Math.min,
          BMMath = {}
        function ProjectInterface() {
          return {}
        }
        !(function () {
          var e,
            t = [
              'abs',
              'acos',
              'acosh',
              'asin',
              'asinh',
              'atan',
              'atanh',
              'atan2',
              'ceil',
              'cbrt',
              'expm1',
              'clz32',
              'cos',
              'cosh',
              'exp',
              'floor',
              'fround',
              'hypot',
              'imul',
              'log',
              'log1p',
              'log2',
              'log10',
              'max',
              'min',
              'pow',
              'random',
              'round',
              'sign',
              'sin',
              'sinh',
              'sqrt',
              'tan',
              'tanh',
              'trunc',
              'E',
              'LN10',
              'LN2',
              'LOG10E',
              'LOG2E',
              'PI',
              'SQRT1_2',
              'SQRT2'
            ],
            i = t.length
          for (e = 0; e < i; e += 1) BMMath[t[e]] = Math[t[e]]
        })(),
          (BMMath.random = Math.random),
          (BMMath.abs = function (e) {
            if ('object' == typeof e && e.length) {
              var t,
                i = createSizedArray(e.length),
                r = e.length
              for (t = 0; t < r; t += 1) i[t] = Math.abs(e[t])
              return i
            }
            return Math.abs(e)
          })
        var defaultCurveSegments = 150,
          degToRads = Math.PI / 180,
          roundCorner = 0.5519
        function styleDiv(e) {
          ;(e.style.position = 'absolute'),
            (e.style.top = 0),
            (e.style.left = 0),
            (e.style.display = 'block'),
            (e.style.transformOrigin = '0 0'),
            (e.style.webkitTransformOrigin = '0 0'),
            (e.style.backfaceVisibility = 'visible'),
            (e.style.webkitBackfaceVisibility = 'visible'),
            (e.style.transformStyle = 'preserve-3d'),
            (e.style.webkitTransformStyle = 'preserve-3d'),
            (e.style.mozTransformStyle = 'preserve-3d')
        }
        function BMEnterFrameEvent(e, t, i, r) {
          ;(this.type = e),
            (this.currentTime = t),
            (this.totalTime = i),
            (this.direction = r < 0 ? -1 : 1)
        }
        function BMCompleteEvent(e, t) {
          ;(this.type = e), (this.direction = t < 0 ? -1 : 1)
        }
        function BMCompleteLoopEvent(e, t, i, r) {
          ;(this.type = e),
            (this.currentLoop = i),
            (this.totalLoops = t),
            (this.direction = r < 0 ? -1 : 1)
        }
        function BMSegmentStartEvent(e, t, i) {
          ;(this.type = e), (this.firstFrame = t), (this.totalFrames = i)
        }
        function BMDestroyEvent(e, t) {
          ;(this.type = e), (this.target = t)
        }
        function BMRenderFrameErrorEvent(e, t) {
          ;(this.type = 'renderFrameError'), (this.nativeError = e), (this.currentTime = t)
        }
        function BMConfigErrorEvent(e) {
          ;(this.type = 'configError'), (this.nativeError = e)
        }
        var createElementID =
            ((_count = 0),
            function () {
              return '__lottie_element_' + (_count += 1)
            }),
          _count
        function HSVtoRGB(e, t, i) {
          var r, n, a, o, s, l, h, u
          switch (
            ((l = i * (1 - t)),
            (h = i * (1 - (s = 6 * e - (o = Math.floor(6 * e))) * t)),
            (u = i * (1 - (1 - s) * t)),
            o % 6)
          ) {
            case 0:
              ;(r = i), (n = u), (a = l)
              break
            case 1:
              ;(r = h), (n = i), (a = l)
              break
            case 2:
              ;(r = l), (n = i), (a = u)
              break
            case 3:
              ;(r = l), (n = h), (a = i)
              break
            case 4:
              ;(r = u), (n = l), (a = i)
              break
            case 5:
              ;(r = i), (n = l), (a = h)
          }
          return [r, n, a]
        }
        function RGBtoHSV(e, t, i) {
          var r,
            n = Math.max(e, t, i),
            a = Math.min(e, t, i),
            o = n - a,
            s = 0 === n ? 0 : o / n,
            l = n / 255
          switch (n) {
            case a:
              r = 0
              break
            case e:
              ;(r = t - i + o * (t < i ? 6 : 0)), (r /= 6 * o)
              break
            case t:
              ;(r = i - e + 2 * o), (r /= 6 * o)
              break
            case i:
              ;(r = e - t + 4 * o), (r /= 6 * o)
          }
          return [r, s, l]
        }
        function addSaturationToRGB(e, t) {
          var i = RGBtoHSV(255 * e[0], 255 * e[1], 255 * e[2])
          return (
            (i[1] += t), i[1] > 1 ? (i[1] = 1) : i[1] <= 0 && (i[1] = 0), HSVtoRGB(i[0], i[1], i[2])
          )
        }
        function addBrightnessToRGB(e, t) {
          var i = RGBtoHSV(255 * e[0], 255 * e[1], 255 * e[2])
          return (
            (i[2] += t), i[2] > 1 ? (i[2] = 1) : i[2] < 0 && (i[2] = 0), HSVtoRGB(i[0], i[1], i[2])
          )
        }
        function addHueToRGB(e, t) {
          var i = RGBtoHSV(255 * e[0], 255 * e[1], 255 * e[2])
          return (
            (i[0] += t / 360),
            i[0] > 1 ? (i[0] -= 1) : i[0] < 0 && (i[0] += 1),
            HSVtoRGB(i[0], i[1], i[2])
          )
        }
        var rgbToHex = (function () {
          var e,
            t,
            i = []
          for (e = 0; e < 256; e += 1) (t = e.toString(16)), (i[e] = 1 === t.length ? '0' + t : t)
          return function (e, t, r) {
            return e < 0 && (e = 0), t < 0 && (t = 0), r < 0 && (r = 0), '#' + i[e] + i[t] + i[r]
          }
        })()
        function BaseEvent() {}
        BaseEvent.prototype = {
          triggerEvent: function (e, t) {
            if (this._cbs[e])
              for (var i = this._cbs[e].length, r = 0; r < i; r += 1) this._cbs[e][r](t)
          },
          addEventListener: function (e, t) {
            return (
              this._cbs[e] || (this._cbs[e] = []),
              this._cbs[e].push(t),
              function () {
                this.removeEventListener(e, t)
              }.bind(this)
            )
          },
          removeEventListener: function (e, t) {
            if (t) {
              if (this._cbs[e]) {
                for (var i = 0, r = this._cbs[e].length; i < r; )
                  this._cbs[e][i] === t && (this._cbs[e].splice(i, 1), (i -= 1), (r -= 1)), (i += 1)
                this._cbs[e].length || (this._cbs[e] = null)
              }
            } else this._cbs[e] = null
          }
        }
        var createTypedArray = (function () {
          function e(e, t) {
            var i,
              r = 0,
              n = []
            switch (e) {
              case 'int16':
              case 'uint8c':
                i = 1
                break
              default:
                i = 1.1
            }
            for (r = 0; r < t; r += 1) n.push(i)
            return n
          }
          return 'function' == typeof Uint8ClampedArray && 'function' == typeof Float32Array
            ? function (t, i) {
                return 'float32' === t
                  ? new Float32Array(i)
                  : 'int16' === t
                  ? new Int16Array(i)
                  : 'uint8c' === t
                  ? new Uint8ClampedArray(i)
                  : e(t, i)
              }
            : e
        })()
        function createSizedArray(e) {
          return Array.apply(null, { length: e })
        }
        function createNS(e) {
          return document.createElementNS(svgNS, e)
        }
        function createTag(e) {
          return document.createElement(e)
        }
        function DynamicPropertyContainer() {}
        DynamicPropertyContainer.prototype = {
          addDynamicProperty: function (e) {
            ;-1 === this.dynamicProperties.indexOf(e) &&
              (this.dynamicProperties.push(e),
              this.container.addDynamicProperty(this),
              (this._isAnimated = !0))
          },
          iterateDynamicProperties: function () {
            var e
            this._mdf = !1
            var t = this.dynamicProperties.length
            for (e = 0; e < t; e += 1)
              this.dynamicProperties[e].getValue(),
                this.dynamicProperties[e]._mdf && (this._mdf = !0)
          },
          initDynamicPropertyContainer: function (e) {
            ;(this.container = e),
              (this.dynamicProperties = []),
              (this._mdf = !1),
              (this._isAnimated = !1)
          }
        }
        var getBlendMode =
            ((blendModeEnums = {
              0: 'source-over',
              1: 'multiply',
              2: 'screen',
              3: 'overlay',
              4: 'darken',
              5: 'lighten',
              6: 'color-dodge',
              7: 'color-burn',
              8: 'hard-light',
              9: 'soft-light',
              10: 'difference',
              11: 'exclusion',
              12: 'hue',
              13: 'saturation',
              14: 'color',
              15: 'luminosity'
            }),
            function (e) {
              return blendModeEnums[e] || ''
            }),
          blendModeEnums,
          Matrix = (function () {
            var e = Math.cos,
              t = Math.sin,
              i = Math.tan,
              r = Math.round
            function n() {
              return (
                (this.props[0] = 1),
                (this.props[1] = 0),
                (this.props[2] = 0),
                (this.props[3] = 0),
                (this.props[4] = 0),
                (this.props[5] = 1),
                (this.props[6] = 0),
                (this.props[7] = 0),
                (this.props[8] = 0),
                (this.props[9] = 0),
                (this.props[10] = 1),
                (this.props[11] = 0),
                (this.props[12] = 0),
                (this.props[13] = 0),
                (this.props[14] = 0),
                (this.props[15] = 1),
                this
              )
            }
            function a(i) {
              if (0 === i) return this
              var r = e(i),
                n = t(i)
              return this._t(r, -n, 0, 0, n, r, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function o(i) {
              if (0 === i) return this
              var r = e(i),
                n = t(i)
              return this._t(1, 0, 0, 0, 0, r, -n, 0, 0, n, r, 0, 0, 0, 0, 1)
            }
            function s(i) {
              if (0 === i) return this
              var r = e(i),
                n = t(i)
              return this._t(r, 0, n, 0, 0, 1, 0, 0, -n, 0, r, 0, 0, 0, 0, 1)
            }
            function l(i) {
              if (0 === i) return this
              var r = e(i),
                n = t(i)
              return this._t(r, -n, 0, 0, n, r, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function h(e, t) {
              return this._t(1, t, e, 1, 0, 0)
            }
            function u(e, t) {
              return this.shear(i(e), i(t))
            }
            function p(r, n) {
              var a = e(n),
                o = t(n)
              return this._t(a, o, 0, 0, -o, a, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                ._t(1, 0, 0, 0, i(r), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
                ._t(a, -o, 0, 0, o, a, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            }
            function c(e, t, i) {
              return (
                i || 0 === i || (i = 1),
                1 === e && 1 === t && 1 === i
                  ? this
                  : this._t(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1)
              )
            }
            function d(e, t, i, r, n, a, o, s, l, h, u, p, c, d, f, m) {
              return (
                (this.props[0] = e),
                (this.props[1] = t),
                (this.props[2] = i),
                (this.props[3] = r),
                (this.props[4] = n),
                (this.props[5] = a),
                (this.props[6] = o),
                (this.props[7] = s),
                (this.props[8] = l),
                (this.props[9] = h),
                (this.props[10] = u),
                (this.props[11] = p),
                (this.props[12] = c),
                (this.props[13] = d),
                (this.props[14] = f),
                (this.props[15] = m),
                this
              )
            }
            function f(e, t, i) {
              return (
                (i = i || 0),
                0 !== e || 0 !== t || 0 !== i
                  ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e, t, i, 1)
                  : this
              )
            }
            function m(e, t, i, r, n, a, o, s, l, h, u, p, c, d, f, m) {
              var g = this.props
              if (
                1 === e &&
                0 === t &&
                0 === i &&
                0 === r &&
                0 === n &&
                1 === a &&
                0 === o &&
                0 === s &&
                0 === l &&
                0 === h &&
                1 === u &&
                0 === p
              )
                return (
                  (g[12] = g[12] * e + g[15] * c),
                  (g[13] = g[13] * a + g[15] * d),
                  (g[14] = g[14] * u + g[15] * f),
                  (g[15] *= m),
                  (this._identityCalculated = !1),
                  this
                )
              var y = g[0],
                v = g[1],
                _ = g[2],
                x = g[3],
                S = g[4],
                b = g[5],
                T = g[6],
                A = g[7],
                w = g[8],
                M = g[9],
                C = g[10],
                P = g[11],
                E = g[12],
                I = g[13],
                D = g[14],
                L = g[15]
              return (
                (g[0] = y * e + v * n + _ * l + x * c),
                (g[1] = y * t + v * a + _ * h + x * d),
                (g[2] = y * i + v * o + _ * u + x * f),
                (g[3] = y * r + v * s + _ * p + x * m),
                (g[4] = S * e + b * n + T * l + A * c),
                (g[5] = S * t + b * a + T * h + A * d),
                (g[6] = S * i + b * o + T * u + A * f),
                (g[7] = S * r + b * s + T * p + A * m),
                (g[8] = w * e + M * n + C * l + P * c),
                (g[9] = w * t + M * a + C * h + P * d),
                (g[10] = w * i + M * o + C * u + P * f),
                (g[11] = w * r + M * s + C * p + P * m),
                (g[12] = E * e + I * n + D * l + L * c),
                (g[13] = E * t + I * a + D * h + L * d),
                (g[14] = E * i + I * o + D * u + L * f),
                (g[15] = E * r + I * s + D * p + L * m),
                (this._identityCalculated = !1),
                this
              )
            }
            function g() {
              return (
                this._identityCalculated ||
                  ((this._identity = !(
                    1 !== this.props[0] ||
                    0 !== this.props[1] ||
                    0 !== this.props[2] ||
                    0 !== this.props[3] ||
                    0 !== this.props[4] ||
                    1 !== this.props[5] ||
                    0 !== this.props[6] ||
                    0 !== this.props[7] ||
                    0 !== this.props[8] ||
                    0 !== this.props[9] ||
                    1 !== this.props[10] ||
                    0 !== this.props[11] ||
                    0 !== this.props[12] ||
                    0 !== this.props[13] ||
                    0 !== this.props[14] ||
                    1 !== this.props[15]
                  )),
                  (this._identityCalculated = !0)),
                this._identity
              )
            }
            function y(e) {
              for (var t = 0; t < 16; ) {
                if (e.props[t] !== this.props[t]) return !1
                t += 1
              }
              return !0
            }
            function v(e) {
              var t
              for (t = 0; t < 16; t += 1) e.props[t] = this.props[t]
              return e
            }
            function _(e) {
              var t
              for (t = 0; t < 16; t += 1) this.props[t] = e[t]
            }
            function x(e, t, i) {
              return {
                x: e * this.props[0] + t * this.props[4] + i * this.props[8] + this.props[12],
                y: e * this.props[1] + t * this.props[5] + i * this.props[9] + this.props[13],
                z: e * this.props[2] + t * this.props[6] + i * this.props[10] + this.props[14]
              }
            }
            function S(e, t, i) {
              return e * this.props[0] + t * this.props[4] + i * this.props[8] + this.props[12]
            }
            function b(e, t, i) {
              return e * this.props[1] + t * this.props[5] + i * this.props[9] + this.props[13]
            }
            function T(e, t, i) {
              return e * this.props[2] + t * this.props[6] + i * this.props[10] + this.props[14]
            }
            function A() {
              var e = this.props[0] * this.props[5] - this.props[1] * this.props[4],
                t = this.props[5] / e,
                i = -this.props[1] / e,
                r = -this.props[4] / e,
                n = this.props[0] / e,
                a = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / e,
                o = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / e,
                s = new Matrix()
              return (
                (s.props[0] = t),
                (s.props[1] = i),
                (s.props[4] = r),
                (s.props[5] = n),
                (s.props[12] = a),
                (s.props[13] = o),
                s
              )
            }
            function w(e) {
              return this.getInverseMatrix().applyToPointArray(e[0], e[1], e[2] || 0)
            }
            function M(e) {
              var t,
                i = e.length,
                r = []
              for (t = 0; t < i; t += 1) r[t] = w(e[t])
              return r
            }
            function C(e, t, i) {
              var r = createTypedArray('float32', 6)
              if (this.isIdentity())
                (r[0] = e[0]),
                  (r[1] = e[1]),
                  (r[2] = t[0]),
                  (r[3] = t[1]),
                  (r[4] = i[0]),
                  (r[5] = i[1])
              else {
                var n = this.props[0],
                  a = this.props[1],
                  o = this.props[4],
                  s = this.props[5],
                  l = this.props[12],
                  h = this.props[13]
                ;(r[0] = e[0] * n + e[1] * o + l),
                  (r[1] = e[0] * a + e[1] * s + h),
                  (r[2] = t[0] * n + t[1] * o + l),
                  (r[3] = t[0] * a + t[1] * s + h),
                  (r[4] = i[0] * n + i[1] * o + l),
                  (r[5] = i[0] * a + i[1] * s + h)
              }
              return r
            }
            function P(e, t, i) {
              return this.isIdentity()
                ? [e, t, i]
                : [
                    e * this.props[0] + t * this.props[4] + i * this.props[8] + this.props[12],
                    e * this.props[1] + t * this.props[5] + i * this.props[9] + this.props[13],
                    e * this.props[2] + t * this.props[6] + i * this.props[10] + this.props[14]
                  ]
            }
            function E(e, t) {
              if (this.isIdentity()) return e + ',' + t
              var i = this.props
              return (
                Math.round(100 * (e * i[0] + t * i[4] + i[12])) / 100 +
                ',' +
                Math.round(100 * (e * i[1] + t * i[5] + i[13])) / 100
              )
            }
            function I() {
              for (var e = 0, t = this.props, i = 'matrix3d('; e < 16; )
                (i += r(1e4 * t[e]) / 1e4), (i += 15 === e ? ')' : ','), (e += 1)
              return i
            }
            function D(e) {
              return (e < 1e-6 && e > 0) || (e > -1e-6 && e < 0) ? r(1e4 * e) / 1e4 : e
            }
            function L() {
              var e = this.props
              return (
                'matrix(' +
                D(e[0]) +
                ',' +
                D(e[1]) +
                ',' +
                D(e[4]) +
                ',' +
                D(e[5]) +
                ',' +
                D(e[12]) +
                ',' +
                D(e[13]) +
                ')'
              )
            }
            return function () {
              ;(this.reset = n),
                (this.rotate = a),
                (this.rotateX = o),
                (this.rotateY = s),
                (this.rotateZ = l),
                (this.skew = u),
                (this.skewFromAxis = p),
                (this.shear = h),
                (this.scale = c),
                (this.setTransform = d),
                (this.translate = f),
                (this.transform = m),
                (this.applyToPoint = x),
                (this.applyToX = S),
                (this.applyToY = b),
                (this.applyToZ = T),
                (this.applyToPointArray = P),
                (this.applyToTriplePoints = C),
                (this.applyToPointStringified = E),
                (this.toCSS = I),
                (this.to2dCSS = L),
                (this.clone = v),
                (this.cloneFromProps = _),
                (this.equals = y),
                (this.inversePoints = M),
                (this.inversePoint = w),
                (this.getInverseMatrix = A),
                (this._t = this.transform),
                (this.isIdentity = g),
                (this._identity = !0),
                (this._identityCalculated = !1),
                (this.props = createTypedArray('float32', 16)),
                this.reset()
            }
          })()
        /*!
     Transformation Matrix v2.0
     (c) Epistemex 2014-2015
     www.epistemex.com
     By Ken Fyrstenberg
     Contributions by leeoniya.
     License: MIT, header required.
     */ !(function (e, t) {
          var i = this,
            r = 256,
            n = t.pow(r, 6),
            a = t.pow(2, 52),
            o = 2 * a,
            s = 255
          function l(e) {
            var t,
              i = e.length,
              n = this,
              a = 0,
              o = (n.i = n.j = 0),
              l = (n.S = [])
            for (i || (e = [i++]); a < r; ) l[a] = a++
            for (a = 0; a < r; a++) (l[a] = l[(o = s & (o + e[a % i] + (t = l[a])))]), (l[o] = t)
            n.g = function (e) {
              for (var t, i = 0, a = n.i, o = n.j, l = n.S; e--; )
                (t = l[(a = s & (a + 1))]),
                  (i = i * r + l[s & ((l[a] = l[(o = s & (o + t))]) + (l[o] = t))])
              return (n.i = a), (n.j = o), i
            }
          }
          function h(e, t) {
            return (t.i = e.i), (t.j = e.j), (t.S = e.S.slice()), t
          }
          function u(e, t) {
            var i,
              r = [],
              n = typeof e
            if (t && 'object' == n)
              for (i in e)
                try {
                  r.push(u(e[i], t - 1))
                } catch (a) {}
            return r.length ? r : 'string' == n ? e : e + '\0'
          }
          function p(e, t) {
            for (var i, r = e + '', n = 0; n < r.length; )
              t[s & n] = s & ((i ^= 19 * t[s & n]) + r.charCodeAt(n++))
            return c(t)
          }
          function c(e) {
            return String.fromCharCode.apply(0, e)
          }
          ;(t.seedrandom = function (s, d, f) {
            var m = [],
              g = p(
                u(
                  (d = !0 === d ? { entropy: !0 } : d || {}).entropy
                    ? [s, c(e)]
                    : null === s
                    ? (function () {
                        try {
                          var t = new Uint8Array(r)
                          return (i.crypto || i.msCrypto).getRandomValues(t), c(t)
                        } catch (o) {
                          var n = i.navigator,
                            a = n && n.plugins
                          return [+new Date(), i, a, i.screen, c(e)]
                        }
                      })()
                    : s,
                  3
                ),
                m
              ),
              y = new l(m),
              v = function () {
                for (var e = y.g(6), t = n, i = 0; e < a; )
                  (e = (e + i) * r), (t *= r), (i = y.g(1))
                for (; e >= o; ) (e /= 2), (t /= 2), (i >>>= 1)
                return (e + i) / t
              }
            return (
              (v.int32 = function () {
                return 0 | y.g(4)
              }),
              (v.quick = function () {
                return y.g(4) / 4294967296
              }),
              (v.double = v),
              p(c(y.S), e),
              (
                d.pass ||
                f ||
                function (e, i, r, n) {
                  return (
                    n &&
                      (n.S && h(n, y),
                      (e.state = function () {
                        return h(y, {})
                      })),
                    r ? ((t.random = e), i) : e
                  )
                }
              )(v, g, 'global' in d ? d.global : this == t, d.state)
            )
          }),
            p(t.random(), e)
        })([], BMMath)
        var BezierFactory = (function () {
          var e = {
              getBezierEasing: function (e, i, r, n, a) {
                var o = a || ('bez_' + e + '_' + i + '_' + r + '_' + n).replace(/\./g, 'p')
                if (t[o]) return t[o]
                var s = new h([e, i, r, n])
                return (t[o] = s), s
              }
            },
            t = {},
            i = 0.1,
            r = 'function' == typeof Float32Array
          function n(e, t) {
            return 1 - 3 * t + 3 * e
          }
          function a(e, t) {
            return 3 * t - 6 * e
          }
          function o(e) {
            return 3 * e
          }
          function s(e, t, i) {
            return ((n(t, i) * e + a(t, i)) * e + o(t)) * e
          }
          function l(e, t, i) {
            return 3 * n(t, i) * e * e + 2 * a(t, i) * e + o(t)
          }
          function h(e) {
            ;(this._p = e),
              (this._mSampleValues = r ? new Float32Array(11) : new Array(11)),
              (this._precomputed = !1),
              (this.get = this.get.bind(this))
          }
          return (
            (h.prototype = {
              get: function (e) {
                var t = this._p[0],
                  i = this._p[1],
                  r = this._p[2],
                  n = this._p[3]
                return (
                  this._precomputed || this._precompute(),
                  t === i && r === n ? e : 0 === e ? 0 : 1 === e ? 1 : s(this._getTForX(e), i, n)
                )
              },
              _precompute: function () {
                var e = this._p[0],
                  t = this._p[1],
                  i = this._p[2],
                  r = this._p[3]
                ;(this._precomputed = !0), (e === t && i === r) || this._calcSampleValues()
              },
              _calcSampleValues: function () {
                for (var e = this._p[0], t = this._p[2], r = 0; r < 11; ++r)
                  this._mSampleValues[r] = s(r * i, e, t)
              },
              _getTForX: function (e) {
                for (
                  var t = this._p[0], r = this._p[2], n = this._mSampleValues, a = 0, o = 1;
                  10 !== o && n[o] <= e;
                  ++o
                )
                  a += i
                var h = a + ((e - n[--o]) / (n[o + 1] - n[o])) * i,
                  u = l(h, t, r)
                return u >= 0.001
                  ? (function (e, t, i, r) {
                      for (var n = 0; n < 4; ++n) {
                        var a = l(t, i, r)
                        if (0 === a) return t
                        t -= (s(t, i, r) - e) / a
                      }
                      return t
                    })(e, h, t, r)
                  : 0 === u
                  ? h
                  : (function (e, t, i, r, n) {
                      var a,
                        o,
                        l = 0
                      do {
                        ;(a = s((o = t + (i - t) / 2), r, n) - e) > 0 ? (i = o) : (t = o)
                      } while (Math.abs(a) > 1e-7 && ++l < 10)
                      return o
                    })(e, a, a + i, t, r)
              }
            }),
            e
          )
        })()
        function extendPrototype(e, t) {
          var i,
            r,
            n = e.length
          for (i = 0; i < n; i += 1)
            for (var a in (r = e[i].prototype))
              Object.prototype.hasOwnProperty.call(r, a) && (t.prototype[a] = r[a])
        }
        function getDescriptor(e, t) {
          return Object.getOwnPropertyDescriptor(e, t)
        }
        function createProxyFunction(e) {
          function t() {}
          return (t.prototype = e), t
        }
        function bezFunction() {
          var e = Math
          function t(e, t, i, r, n, a) {
            var o = e * r + t * n + i * a - n * r - a * e - i * t
            return o > -0.001 && o < 0.001
          }
          var i = function (e, t, i, r) {
            var n,
              a,
              o,
              s,
              l,
              h,
              u = defaultCurveSegments,
              p = 0,
              c = [],
              d = [],
              f = bezierLengthPool.newElement()
            for (o = i.length, n = 0; n < u; n += 1) {
              for (l = n / (u - 1), h = 0, a = 0; a < o; a += 1)
                (s =
                  bmPow(1 - l, 3) * e[a] +
                  3 * bmPow(1 - l, 2) * l * i[a] +
                  3 * (1 - l) * bmPow(l, 2) * r[a] +
                  bmPow(l, 3) * t[a]),
                  (c[a] = s),
                  null !== d[a] && (h += bmPow(c[a] - d[a], 2)),
                  (d[a] = c[a])
              h && (p += h = bmSqrt(h)), (f.percents[n] = l), (f.lengths[n] = p)
            }
            return (f.addedLength = p), f
          }
          function r(e) {
            ;(this.segmentLength = 0), (this.points = new Array(e))
          }
          function n(e, t) {
            ;(this.partialLength = e), (this.point = t)
          }
          var a,
            o =
              ((a = {}),
              function (e, i, o, s) {
                var l = (
                  e[0] +
                  '_' +
                  e[1] +
                  '_' +
                  i[0] +
                  '_' +
                  i[1] +
                  '_' +
                  o[0] +
                  '_' +
                  o[1] +
                  '_' +
                  s[0] +
                  '_' +
                  s[1]
                ).replace(/\./g, 'p')
                if (!a[l]) {
                  var h,
                    u,
                    p,
                    c,
                    d,
                    f,
                    m,
                    g = defaultCurveSegments,
                    y = 0,
                    v = null
                  2 === e.length &&
                    (e[0] !== i[0] || e[1] !== i[1]) &&
                    t(e[0], e[1], i[0], i[1], e[0] + o[0], e[1] + o[1]) &&
                    t(e[0], e[1], i[0], i[1], i[0] + s[0], i[1] + s[1]) &&
                    (g = 2)
                  var _ = new r(g)
                  for (p = o.length, h = 0; h < g; h += 1) {
                    for (m = createSizedArray(p), d = h / (g - 1), f = 0, u = 0; u < p; u += 1)
                      (c =
                        bmPow(1 - d, 3) * e[u] +
                        3 * bmPow(1 - d, 2) * d * (e[u] + o[u]) +
                        3 * (1 - d) * bmPow(d, 2) * (i[u] + s[u]) +
                        bmPow(d, 3) * i[u]),
                        (m[u] = c),
                        null !== v && (f += bmPow(m[u] - v[u], 2))
                    ;(y += f = bmSqrt(f)), (_.points[h] = new n(f, m)), (v = m)
                  }
                  ;(_.segmentLength = y), (a[l] = _)
                }
                return a[l]
              })
          function s(e, t) {
            var i = t.percents,
              r = t.lengths,
              n = i.length,
              a = bmFloor((n - 1) * e),
              o = e * t.addedLength,
              s = 0
            if (a === n - 1 || 0 === a || o === r[a]) return i[a]
            for (var l = r[a] > o ? -1 : 1, h = !0; h; )
              if (
                (r[a] <= o && r[a + 1] > o
                  ? ((s = (o - r[a]) / (r[a + 1] - r[a])), (h = !1))
                  : (a += l),
                a < 0 || a >= n - 1)
              ) {
                if (a === n - 1) return i[a]
                h = !1
              }
            return i[a] + (i[a + 1] - i[a]) * s
          }
          var l = createTypedArray('float32', 8)
          return {
            getSegmentsLength: function (e) {
              var t,
                r = segmentsLengthPool.newElement(),
                n = e.c,
                a = e.v,
                o = e.o,
                s = e.i,
                l = e._length,
                h = r.lengths,
                u = 0
              for (t = 0; t < l - 1; t += 1)
                (h[t] = i(a[t], a[t + 1], o[t], s[t + 1])), (u += h[t].addedLength)
              return (
                n && l && ((h[t] = i(a[t], a[0], o[t], s[0])), (u += h[t].addedLength)),
                (r.totalLength = u),
                r
              )
            },
            getNewSegment: function (t, i, r, n, a, o, h) {
              a < 0 ? (a = 0) : a > 1 && (a = 1)
              var u,
                p = s(a, h),
                c = s((o = o > 1 ? 1 : o), h),
                d = t.length,
                f = 1 - p,
                m = 1 - c,
                g = f * f * f,
                y = p * f * f * 3,
                v = p * p * f * 3,
                _ = p * p * p,
                x = f * f * m,
                S = p * f * m + f * p * m + f * f * c,
                b = p * p * m + f * p * c + p * f * c,
                T = p * p * c,
                A = f * m * m,
                w = p * m * m + f * c * m + f * m * c,
                M = p * c * m + f * c * c + p * m * c,
                C = p * c * c,
                P = m * m * m,
                E = c * m * m + m * c * m + m * m * c,
                I = c * c * m + m * c * c + c * m * c,
                D = c * c * c
              for (u = 0; u < d; u += 1)
                (l[4 * u] = e.round(1e3 * (g * t[u] + y * r[u] + v * n[u] + _ * i[u])) / 1e3),
                  (l[4 * u + 1] = e.round(1e3 * (x * t[u] + S * r[u] + b * n[u] + T * i[u])) / 1e3),
                  (l[4 * u + 2] = e.round(1e3 * (A * t[u] + w * r[u] + M * n[u] + C * i[u])) / 1e3),
                  (l[4 * u + 3] = e.round(1e3 * (P * t[u] + E * r[u] + I * n[u] + D * i[u])) / 1e3)
              return l
            },
            getPointInSegment: function (t, i, r, n, a, o) {
              var l = s(a, o),
                h = 1 - l
              return [
                e.round(
                  1e3 *
                    (h * h * h * t[0] +
                      (l * h * h + h * l * h + h * h * l) * r[0] +
                      (l * l * h + h * l * l + l * h * l) * n[0] +
                      l * l * l * i[0])
                ) / 1e3,
                e.round(
                  1e3 *
                    (h * h * h * t[1] +
                      (l * h * h + h * l * h + h * h * l) * r[1] +
                      (l * l * h + h * l * l + l * h * l) * n[1] +
                      l * l * l * i[1])
                ) / 1e3
              ]
            },
            buildBezierData: o,
            pointOnLine2D: t,
            pointOnLine3D: function (i, r, n, a, o, s, l, h, u) {
              if (0 === n && 0 === s && 0 === u) return t(i, r, a, o, l, h)
              var p,
                c = e.sqrt(e.pow(a - i, 2) + e.pow(o - r, 2) + e.pow(s - n, 2)),
                d = e.sqrt(e.pow(l - i, 2) + e.pow(h - r, 2) + e.pow(u - n, 2)),
                f = e.sqrt(e.pow(l - a, 2) + e.pow(h - o, 2) + e.pow(u - s, 2))
              return (
                (p = c > d ? (c > f ? c - d - f : f - d - c) : f > d ? f - d - c : d - c - f) >
                  -1e-4 && p < 1e-4
              )
            }
          }
        }
        !(function () {
          for (
            var e = 0, t = ['ms', 'moz', 'webkit', 'o'], i = 0;
            i < t.length && !window.requestAnimationFrame;
            ++i
          )
            (window.requestAnimationFrame = window[t[i] + 'RequestAnimationFrame']),
              (window.cancelAnimationFrame =
                window[t[i] + 'CancelAnimationFrame'] ||
                window[t[i] + 'CancelRequestAnimationFrame'])
          window.requestAnimationFrame ||
            (window.requestAnimationFrame = function (t) {
              var i = new Date().getTime(),
                r = Math.max(0, 16 - (i - e)),
                n = setTimeout(function () {
                  t(i + r)
                }, r)
              return (e = i + r), n
            }),
            window.cancelAnimationFrame ||
              (window.cancelAnimationFrame = function (e) {
                clearTimeout(e)
              })
        })()
        var bez = bezFunction()
        function dataFunctionManager() {
          function e(n, a, o) {
            var s,
              l,
              h,
              u,
              p,
              c,
              d,
              f = n.length
            for (l = 0; l < f; l += 1)
              if ('ks' in (s = n[l]) && !s.completed) {
                if (((s.completed = !0), s.tt && (n[l - 1].td = s.tt), s.hasMask)) {
                  var m = s.masksProperties
                  for (u = m.length, h = 0; h < u; h += 1)
                    if (m[h].pt.k.i) r(m[h].pt.k)
                    else
                      for (c = m[h].pt.k.length, p = 0; p < c; p += 1)
                        m[h].pt.k[p].s && r(m[h].pt.k[p].s[0]),
                          m[h].pt.k[p].e && r(m[h].pt.k[p].e[0])
                }
                0 === s.ty
                  ? ((s.layers = t(s.refId, a)), e(s.layers, a))
                  : 4 === s.ty
                  ? i(s.shapes)
                  : 5 === s.ty && (0 !== (d = s).t.a.length || 'm' in d.t.p || (d.singleShape = !0))
              }
          }
          function t(e, t) {
            for (var i = 0, r = t.length; i < r; ) {
              if (t[i].id === e)
                return t[i].layers.__used
                  ? JSON.parse(JSON.stringify(t[i].layers))
                  : ((t[i].layers.__used = !0), t[i].layers)
              i += 1
            }
            return null
          }
          function i(e) {
            var t, n, a
            for (t = e.length - 1; t >= 0; t -= 1)
              if ('sh' === e[t].ty)
                if (e[t].ks.k.i) r(e[t].ks.k)
                else
                  for (a = e[t].ks.k.length, n = 0; n < a; n += 1)
                    e[t].ks.k[n].s && r(e[t].ks.k[n].s[0]), e[t].ks.k[n].e && r(e[t].ks.k[n].e[0])
              else 'gr' === e[t].ty && i(e[t].it)
          }
          function r(e) {
            var t,
              i = e.i.length
            for (t = 0; t < i; t += 1)
              (e.i[t][0] += e.v[t][0]),
                (e.i[t][1] += e.v[t][1]),
                (e.o[t][0] += e.v[t][0]),
                (e.o[t][1] += e.v[t][1])
          }
          function n(e, t) {
            var i = t ? t.split('.') : [100, 100, 100]
            return (
              e[0] > i[0] ||
              (!(i[0] > e[0]) &&
                (e[1] > i[1] || (!(i[1] > e[1]) && (e[2] > i[2] || (!(i[2] > e[2]) && null)))))
            )
          }
          var a,
            o = (function () {
              var e = [4, 4, 14]
              function t(e) {
                var t,
                  i,
                  r,
                  n = e.length
                for (t = 0; t < n; t += 1)
                  5 === e[t].ty &&
                    ((i = e[t]), (r = void 0), (r = i.t.d), (i.t.d = { k: [{ s: r, t: 0 }] }))
              }
              return function (i) {
                if (n(e, i.v) && (t(i.layers), i.assets)) {
                  var r,
                    a = i.assets.length
                  for (r = 0; r < a; r += 1) i.assets[r].layers && t(i.assets[r].layers)
                }
              }
            })(),
            s =
              ((a = [4, 7, 99]),
              function (e) {
                if (e.chars && !n(a, e.v)) {
                  var t,
                    i,
                    o,
                    s,
                    l,
                    h = e.chars.length
                  for (t = 0; t < h; t += 1)
                    if (e.chars[t].data && e.chars[t].data.shapes)
                      for (o = (l = e.chars[t].data.shapes[0].it).length, i = 0; i < o; i += 1)
                        (s = l[i].ks.k).__converted || (r(l[i].ks.k), (s.__converted = !0))
                }
              }),
            l = (function () {
              var e = [4, 1, 9]
              function t(e) {
                var i,
                  r,
                  n,
                  a = e.length
                for (i = 0; i < a; i += 1)
                  if ('gr' === e[i].ty) t(e[i].it)
                  else if ('fl' === e[i].ty || 'st' === e[i].ty)
                    if (e[i].c.k && e[i].c.k[0].i)
                      for (n = e[i].c.k.length, r = 0; r < n; r += 1)
                        e[i].c.k[r].s &&
                          ((e[i].c.k[r].s[0] /= 255),
                          (e[i].c.k[r].s[1] /= 255),
                          (e[i].c.k[r].s[2] /= 255),
                          (e[i].c.k[r].s[3] /= 255)),
                          e[i].c.k[r].e &&
                            ((e[i].c.k[r].e[0] /= 255),
                            (e[i].c.k[r].e[1] /= 255),
                            (e[i].c.k[r].e[2] /= 255),
                            (e[i].c.k[r].e[3] /= 255))
                    else
                      (e[i].c.k[0] /= 255),
                        (e[i].c.k[1] /= 255),
                        (e[i].c.k[2] /= 255),
                        (e[i].c.k[3] /= 255)
              }
              function i(e) {
                var i,
                  r = e.length
                for (i = 0; i < r; i += 1) 4 === e[i].ty && t(e[i].shapes)
              }
              return function (t) {
                if (n(e, t.v) && (i(t.layers), t.assets)) {
                  var r,
                    a = t.assets.length
                  for (r = 0; r < a; r += 1) t.assets[r].layers && i(t.assets[r].layers)
                }
              }
            })(),
            h = (function () {
              var e = [4, 4, 18]
              function t(e) {
                var i, r, n
                for (i = e.length - 1; i >= 0; i -= 1)
                  if ('sh' === e[i].ty)
                    if (e[i].ks.k.i) e[i].ks.k.c = e[i].closed
                    else
                      for (n = e[i].ks.k.length, r = 0; r < n; r += 1)
                        e[i].ks.k[r].s && (e[i].ks.k[r].s[0].c = e[i].closed),
                          e[i].ks.k[r].e && (e[i].ks.k[r].e[0].c = e[i].closed)
                  else 'gr' === e[i].ty && t(e[i].it)
              }
              function i(e) {
                var i,
                  r,
                  n,
                  a,
                  o,
                  s,
                  l = e.length
                for (r = 0; r < l; r += 1) {
                  if ((i = e[r]).hasMask) {
                    var h = i.masksProperties
                    for (a = h.length, n = 0; n < a; n += 1)
                      if (h[n].pt.k.i) h[n].pt.k.c = h[n].cl
                      else
                        for (s = h[n].pt.k.length, o = 0; o < s; o += 1)
                          h[n].pt.k[o].s && (h[n].pt.k[o].s[0].c = h[n].cl),
                            h[n].pt.k[o].e && (h[n].pt.k[o].e[0].c = h[n].cl)
                  }
                  4 === i.ty && t(i.shapes)
                }
              }
              return function (t) {
                if (n(e, t.v) && (i(t.layers), t.assets)) {
                  var r,
                    a = t.assets.length
                  for (r = 0; r < a; r += 1) t.assets[r].layers && i(t.assets[r].layers)
                }
              }
            })()
          var u = {
            completeData: function (t, i) {
              t.__complete || (l(t), o(t), s(t), h(t), e(t.layers, t.assets), (t.__complete = !0))
            }
          }
          return (
            (u.checkColors = l), (u.checkChars = s), (u.checkShapes = h), (u.completeLayers = e), u
          )
        }
        var dataManager = dataFunctionManager()
        function getFontProperties(e) {
          for (
            var t = e.fStyle ? e.fStyle.split(' ') : [],
              i = 'normal',
              r = 'normal',
              n = t.length,
              a = 0;
            a < n;
            a += 1
          )
            switch (t[a].toLowerCase()) {
              case 'italic':
                r = 'italic'
                break
              case 'bold':
                i = '700'
                break
              case 'black':
                i = '900'
                break
              case 'medium':
                i = '500'
                break
              case 'regular':
              case 'normal':
                i = '400'
                break
              case 'light':
              case 'thin':
                i = '200'
            }
          return { style: r, weight: e.fWeight || i }
        }
        var FontManager = (function () {
            var e = { w: 0, size: 0, shapes: [] },
              t = []
            function i(e, t) {
              var i = createTag('span')
              i.setAttribute('aria-hidden', !0), (i.style.fontFamily = t)
              var r = createTag('span')
              ;(r.innerText = 'giItT1WQy@!-/#'),
                (i.style.position = 'absolute'),
                (i.style.left = '-10000px'),
                (i.style.top = '-10000px'),
                (i.style.fontSize = '300px'),
                (i.style.fontVariant = 'normal'),
                (i.style.fontStyle = 'normal'),
                (i.style.fontWeight = 'normal'),
                (i.style.letterSpacing = '0'),
                i.appendChild(r),
                document.body.appendChild(i)
              var n = r.offsetWidth
              return (
                (r.style.fontFamily =
                  (function (e) {
                    var t,
                      i = e.split(','),
                      r = i.length,
                      n = []
                    for (t = 0; t < r; t += 1)
                      'sans-serif' !== i[t] && 'monospace' !== i[t] && n.push(i[t])
                    return n.join(',')
                  })(e) +
                  ', ' +
                  t),
                { node: r, w: n, parent: i }
              )
            }
            function r(e, t) {
              var i = createNS('text')
              i.style.fontSize = '100px'
              var r = getFontProperties(t)
              return (
                i.setAttribute('font-family', t.fFamily),
                i.setAttribute('font-style', r.style),
                i.setAttribute('font-weight', r.weight),
                (i.textContent = '1'),
                t.fClass
                  ? ((i.style.fontFamily = 'inherit'), i.setAttribute('class', t.fClass))
                  : (i.style.fontFamily = t.fFamily),
                e.appendChild(i),
                (createTag('canvas').getContext('2d').font =
                  t.fWeight + ' ' + t.fStyle + ' 100px ' + t.fFamily),
                i
              )
            }
            t = t.concat([
              2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371,
              2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388,
              2389, 2390, 2391, 2402, 2403
            ])
            var n = function () {
              ;(this.fonts = []),
                (this.chars = null),
                (this.typekitLoaded = 0),
                (this.isLoaded = !1),
                (this._warned = !1),
                (this.initTime = Date.now()),
                (this.setIsLoadedBinded = this.setIsLoaded.bind(this)),
                (this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this))
            }
            return (
              (n.getCombinedCharacterCodes = function () {
                return t
              }),
              (n.prototype = {
                addChars: function (e) {
                  if (e) {
                    var t
                    this.chars || (this.chars = [])
                    var i,
                      r,
                      n = e.length,
                      a = this.chars.length
                    for (t = 0; t < n; t += 1) {
                      for (i = 0, r = !1; i < a; )
                        this.chars[i].style === e[t].style &&
                          this.chars[i].fFamily === e[t].fFamily &&
                          this.chars[i].ch === e[t].ch &&
                          (r = !0),
                          (i += 1)
                      r || (this.chars.push(e[t]), (a += 1))
                    }
                  }
                },
                addFonts: function (e, t) {
                  if (e) {
                    if (this.chars) return (this.isLoaded = !0), void (this.fonts = e.list)
                    var n,
                      a = e.list,
                      o = a.length,
                      s = o
                    for (n = 0; n < o; n += 1) {
                      var l,
                        h,
                        u = !0
                      if (
                        ((a[n].loaded = !1),
                        (a[n].monoCase = i(a[n].fFamily, 'monospace')),
                        (a[n].sansCase = i(a[n].fFamily, 'sans-serif')),
                        a[n].fPath)
                      ) {
                        if ('p' === a[n].fOrigin || 3 === a[n].origin) {
                          if (
                            ((l = document.querySelectorAll(
                              'style[f-forigin="p"][f-family="' +
                                a[n].fFamily +
                                '"], style[f-origin="3"][f-family="' +
                                a[n].fFamily +
                                '"]'
                            )).length > 0 && (u = !1),
                            u)
                          ) {
                            var p = createTag('style')
                            p.setAttribute('f-forigin', a[n].fOrigin),
                              p.setAttribute('f-origin', a[n].origin),
                              p.setAttribute('f-family', a[n].fFamily),
                              (p.type = 'text/css'),
                              (p.innerText =
                                '@font-face {font-family: ' +
                                a[n].fFamily +
                                "; font-style: normal; src: url('" +
                                a[n].fPath +
                                "');}"),
                              t.appendChild(p)
                          }
                        } else if ('g' === a[n].fOrigin || 1 === a[n].origin) {
                          for (
                            l = document.querySelectorAll(
                              'link[f-forigin="g"], link[f-origin="1"]'
                            ),
                              h = 0;
                            h < l.length;
                            h += 1
                          )
                            -1 !== l[h].href.indexOf(a[n].fPath) && (u = !1)
                          if (u) {
                            var c = createTag('link')
                            c.setAttribute('f-forigin', a[n].fOrigin),
                              c.setAttribute('f-origin', a[n].origin),
                              (c.type = 'text/css'),
                              (c.rel = 'stylesheet'),
                              (c.href = a[n].fPath),
                              document.body.appendChild(c)
                          }
                        } else if ('t' === a[n].fOrigin || 2 === a[n].origin) {
                          for (
                            l = document.querySelectorAll(
                              'script[f-forigin="t"], script[f-origin="2"]'
                            ),
                              h = 0;
                            h < l.length;
                            h += 1
                          )
                            a[n].fPath === l[h].src && (u = !1)
                          if (u) {
                            var d = createTag('link')
                            d.setAttribute('f-forigin', a[n].fOrigin),
                              d.setAttribute('f-origin', a[n].origin),
                              d.setAttribute('rel', 'stylesheet'),
                              d.setAttribute('href', a[n].fPath),
                              t.appendChild(d)
                          }
                        }
                      } else (a[n].loaded = !0), (s -= 1)
                      ;(a[n].helper = r(t, a[n])), (a[n].cache = {}), this.fonts.push(a[n])
                    }
                    0 === s
                      ? (this.isLoaded = !0)
                      : setTimeout(this.checkLoadedFonts.bind(this), 100)
                  } else this.isLoaded = !0
                },
                getCharData: function (t, i, r) {
                  for (var n = 0, a = this.chars.length; n < a; ) {
                    if (
                      this.chars[n].ch === t &&
                      this.chars[n].style === i &&
                      this.chars[n].fFamily === r
                    )
                      return this.chars[n]
                    n += 1
                  }
                  return (
                    (('string' == typeof t && 13 !== t.charCodeAt(0)) || !t) &&
                      console &&
                      console.warn &&
                      !this._warned &&
                      ((this._warned = !0),
                      console.warn('Missing character from exported characters list: ', t, i, r)),
                    e
                  )
                },
                getFontByName: function (e) {
                  for (var t = 0, i = this.fonts.length; t < i; ) {
                    if (this.fonts[t].fName === e) return this.fonts[t]
                    t += 1
                  }
                  return this.fonts[0]
                },
                measureText: function (e, t, i) {
                  var r = this.getFontByName(t),
                    n = e.charCodeAt(0)
                  if (!r.cache[n + 1]) {
                    var a = r.helper
                    if (' ' === e) {
                      a.textContent = '|' + e + '|'
                      var o = a.getComputedTextLength()
                      a.textContent = '||'
                      var s = a.getComputedTextLength()
                      r.cache[n + 1] = (o - s) / 100
                    } else (a.textContent = e), (r.cache[n + 1] = a.getComputedTextLength() / 100)
                  }
                  return r.cache[n + 1] * i
                },
                checkLoadedFonts: function () {
                  var e,
                    t,
                    i,
                    r = this.fonts.length,
                    n = r
                  for (e = 0; e < r; e += 1)
                    this.fonts[e].loaded
                      ? (n -= 1)
                      : 'n' === this.fonts[e].fOrigin || 0 === this.fonts[e].origin
                      ? (this.fonts[e].loaded = !0)
                      : ((t = this.fonts[e].monoCase.node),
                        (i = this.fonts[e].monoCase.w),
                        t.offsetWidth !== i
                          ? ((n -= 1), (this.fonts[e].loaded = !0))
                          : ((t = this.fonts[e].sansCase.node),
                            (i = this.fonts[e].sansCase.w),
                            t.offsetWidth !== i && ((n -= 1), (this.fonts[e].loaded = !0))),
                        this.fonts[e].loaded &&
                          (this.fonts[e].sansCase.parent.parentNode.removeChild(
                            this.fonts[e].sansCase.parent
                          ),
                          this.fonts[e].monoCase.parent.parentNode.removeChild(
                            this.fonts[e].monoCase.parent
                          )))
                  0 !== n && Date.now() - this.initTime < 5e3
                    ? setTimeout(this.checkLoadedFontsBinded, 20)
                    : setTimeout(this.setIsLoadedBinded, 10)
                },
                setIsLoaded: function () {
                  this.isLoaded = !0
                }
              }),
              n
            )
          })(),
          PropertyFactory = (function () {
            var e = initialDefaultFrame,
              t = Math.abs
            function i(e, t) {
              var i,
                n = this.offsetTime
              'multidimensional' === this.propType &&
                (i = createTypedArray('float32', this.pv.length))
              for (
                var a,
                  o,
                  s,
                  l,
                  h,
                  u,
                  p,
                  c,
                  d = t.lastIndex,
                  f = d,
                  m = this.keyframes.length - 1,
                  g = !0;
                g;

              ) {
                if (
                  ((a = this.keyframes[f]),
                  (o = this.keyframes[f + 1]),
                  f === m - 1 && e >= o.t - n)
                ) {
                  a.h && (a = o), (d = 0)
                  break
                }
                if (o.t - n > e) {
                  d = f
                  break
                }
                f < m - 1 ? (f += 1) : ((d = 0), (g = !1))
              }
              var y,
                v,
                _,
                x,
                S,
                b,
                T,
                A,
                w,
                M,
                C = o.t - n,
                P = a.t - n
              if (a.to) {
                a.bezierData || (a.bezierData = bez.buildBezierData(a.s, o.s || a.e, a.to, a.ti))
                var E = a.bezierData
                if (e >= C || e < P) {
                  var I = e >= C ? E.points.length - 1 : 0
                  for (l = E.points[I].point.length, s = 0; s < l; s += 1)
                    i[s] = E.points[I].point[s]
                } else {
                  a.__fnct
                    ? (c = a.__fnct)
                    : ((c = BezierFactory.getBezierEasing(a.o.x, a.o.y, a.i.x, a.i.y, a.n).get),
                      (a.__fnct = c)),
                    (h = c((e - P) / (C - P)))
                  var D,
                    L = E.segmentLength * h,
                    R = t.lastFrame < e && t._lastKeyframeIndex === f ? t._lastAddedLength : 0
                  for (
                    p = t.lastFrame < e && t._lastKeyframeIndex === f ? t._lastPoint : 0,
                      g = !0,
                      u = E.points.length;
                    g;

                  ) {
                    if (
                      ((R += E.points[p].partialLength),
                      0 === L || 0 === h || p === E.points.length - 1)
                    ) {
                      for (l = E.points[p].point.length, s = 0; s < l; s += 1)
                        i[s] = E.points[p].point[s]
                      break
                    }
                    if (L >= R && L < R + E.points[p + 1].partialLength) {
                      for (
                        D = (L - R) / E.points[p + 1].partialLength,
                          l = E.points[p].point.length,
                          s = 0;
                        s < l;
                        s += 1
                      )
                        i[s] =
                          E.points[p].point[s] +
                          (E.points[p + 1].point[s] - E.points[p].point[s]) * D
                      break
                    }
                    p < u - 1 ? (p += 1) : (g = !1)
                  }
                  ;(t._lastPoint = p),
                    (t._lastAddedLength = R - E.points[p].partialLength),
                    (t._lastKeyframeIndex = f)
                }
              } else {
                var O, k, $, N, F
                if (((m = a.s.length), (y = o.s || a.e), this.sh && 1 !== a.h))
                  if (e >= C) (i[0] = y[0]), (i[1] = y[1]), (i[2] = y[2])
                  else if (e <= P) (i[0] = a.s[0]), (i[1] = a.s[1]), (i[2] = a.s[2])
                  else {
                    var B = r(a.s),
                      V = r(y)
                    ;(v = i),
                      (_ = (function (e, t, i) {
                        var r,
                          n,
                          a,
                          o,
                          s,
                          l = [],
                          h = e[0],
                          u = e[1],
                          p = e[2],
                          c = e[3],
                          d = t[0],
                          f = t[1],
                          m = t[2],
                          g = t[3]
                        return (
                          (n = h * d + u * f + p * m + c * g) < 0 &&
                            ((n = -n), (d = -d), (f = -f), (m = -m), (g = -g)),
                          1 - n > 1e-6
                            ? ((r = Math.acos(n)),
                              (a = Math.sin(r)),
                              (o = Math.sin((1 - i) * r) / a),
                              (s = Math.sin(i * r) / a))
                            : ((o = 1 - i), (s = i)),
                          (l[0] = o * h + s * d),
                          (l[1] = o * u + s * f),
                          (l[2] = o * p + s * m),
                          (l[3] = o * c + s * g),
                          l
                        )
                      })(B, V, (e - P) / (C - P))),
                      (x = _[0]),
                      (S = _[1]),
                      (b = _[2]),
                      (T = _[3]),
                      (A = Math.atan2(2 * S * T - 2 * x * b, 1 - 2 * S * S - 2 * b * b)),
                      (w = Math.asin(2 * x * S + 2 * b * T)),
                      (M = Math.atan2(2 * x * T - 2 * S * b, 1 - 2 * x * x - 2 * b * b)),
                      (v[0] = A / degToRads),
                      (v[1] = w / degToRads),
                      (v[2] = M / degToRads)
                  }
                else
                  for (f = 0; f < m; f += 1)
                    1 !== a.h &&
                      (e >= C
                        ? (h = 1)
                        : e < P
                        ? (h = 0)
                        : (a.o.x.constructor === Array
                            ? (a.__fnct || (a.__fnct = []),
                              a.__fnct[f]
                                ? (c = a.__fnct[f])
                                : ((O = void 0 === a.o.x[f] ? a.o.x[0] : a.o.x[f]),
                                  (k = void 0 === a.o.y[f] ? a.o.y[0] : a.o.y[f]),
                                  ($ = void 0 === a.i.x[f] ? a.i.x[0] : a.i.x[f]),
                                  (N = void 0 === a.i.y[f] ? a.i.y[0] : a.i.y[f]),
                                  (c = BezierFactory.getBezierEasing(O, k, $, N).get),
                                  (a.__fnct[f] = c)))
                            : a.__fnct
                            ? (c = a.__fnct)
                            : ((O = a.o.x),
                              (k = a.o.y),
                              ($ = a.i.x),
                              (N = a.i.y),
                              (c = BezierFactory.getBezierEasing(O, k, $, N).get),
                              (a.__fnct = c)),
                          (h = c((e - P) / (C - P))))),
                      (y = o.s || a.e),
                      (F = 1 === a.h ? a.s[f] : a.s[f] + (y[f] - a.s[f]) * h),
                      'multidimensional' === this.propType ? (i[f] = F) : (i = F)
              }
              return (t.lastIndex = d), i
            }
            function r(e) {
              var t = e[0] * degToRads,
                i = e[1] * degToRads,
                r = e[2] * degToRads,
                n = Math.cos(t / 2),
                a = Math.cos(i / 2),
                o = Math.cos(r / 2),
                s = Math.sin(t / 2),
                l = Math.sin(i / 2),
                h = Math.sin(r / 2)
              return [
                s * l * o + n * a * h,
                s * a * o + n * l * h,
                n * l * o - s * a * h,
                n * a * o - s * l * h
              ]
            }
            function n() {
              var t = this.comp.renderedFrame - this.offsetTime,
                i = this.keyframes[0].t - this.offsetTime,
                r = this.keyframes[this.keyframes.length - 1].t - this.offsetTime
              if (
                !(
                  t === this._caching.lastFrame ||
                  (this._caching.lastFrame !== e &&
                    ((this._caching.lastFrame >= r && t >= r) ||
                      (this._caching.lastFrame < i && t < i)))
                )
              ) {
                this._caching.lastFrame >= t &&
                  ((this._caching._lastKeyframeIndex = -1), (this._caching.lastIndex = 0))
                var n = this.interpolateValue(t, this._caching)
                this.pv = n
              }
              return (this._caching.lastFrame = t), this.pv
            }
            function a(e) {
              var i
              if ('unidimensional' === this.propType)
                (i = e * this.mult), t(this.v - i) > 1e-5 && ((this.v = i), (this._mdf = !0))
              else
                for (var r = 0, n = this.v.length; r < n; )
                  (i = e[r] * this.mult),
                    t(this.v[r] - i) > 1e-5 && ((this.v[r] = i), (this._mdf = !0)),
                    (r += 1)
            }
            function o() {
              if (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length)
                if (this.lock) this.setVValue(this.pv)
                else {
                  var e
                  ;(this.lock = !0), (this._mdf = this._isFirstFrame)
                  var t = this.effectsSequence.length,
                    i = this.kf ? this.pv : this.data.k
                  for (e = 0; e < t; e += 1) i = this.effectsSequence[e](i)
                  this.setVValue(i),
                    (this._isFirstFrame = !1),
                    (this.lock = !1),
                    (this.frameId = this.elem.globalData.frameId)
                }
            }
            function s(e) {
              this.effectsSequence.push(e), this.container.addDynamicProperty(this)
            }
            function l(e, t, i, r) {
              ;(this.propType = 'unidimensional'),
                (this.mult = i || 1),
                (this.data = t),
                (this.v = i ? t.k * i : t.k),
                (this.pv = t.k),
                (this._mdf = !1),
                (this.elem = e),
                (this.container = r),
                (this.comp = e.comp),
                (this.k = !1),
                (this.kf = !1),
                (this.vel = 0),
                (this.effectsSequence = []),
                (this._isFirstFrame = !0),
                (this.getValue = o),
                (this.setVValue = a),
                (this.addEffect = s)
            }
            function h(e, t, i, r) {
              var n
              ;(this.propType = 'multidimensional'),
                (this.mult = i || 1),
                (this.data = t),
                (this._mdf = !1),
                (this.elem = e),
                (this.container = r),
                (this.comp = e.comp),
                (this.k = !1),
                (this.kf = !1),
                (this.frameId = -1)
              var l = t.k.length
              for (
                this.v = createTypedArray('float32', l),
                  this.pv = createTypedArray('float32', l),
                  this.vel = createTypedArray('float32', l),
                  n = 0;
                n < l;
                n += 1
              )
                (this.v[n] = t.k[n] * this.mult), (this.pv[n] = t.k[n])
              ;(this._isFirstFrame = !0),
                (this.effectsSequence = []),
                (this.getValue = o),
                (this.setVValue = a),
                (this.addEffect = s)
            }
            function u(t, r, l, h) {
              ;(this.propType = 'unidimensional'),
                (this.keyframes = r.k),
                (this.offsetTime = t.data.st),
                (this.frameId = -1),
                (this._caching = { lastFrame: e, lastIndex: 0, value: 0, _lastKeyframeIndex: -1 }),
                (this.k = !0),
                (this.kf = !0),
                (this.data = r),
                (this.mult = l || 1),
                (this.elem = t),
                (this.container = h),
                (this.comp = t.comp),
                (this.v = e),
                (this.pv = e),
                (this._isFirstFrame = !0),
                (this.getValue = o),
                (this.setVValue = a),
                (this.interpolateValue = i),
                (this.effectsSequence = [n.bind(this)]),
                (this.addEffect = s)
            }
            function p(t, r, l, h) {
              var u
              this.propType = 'multidimensional'
              var p,
                c,
                d,
                f,
                m = r.k.length
              for (u = 0; u < m - 1; u += 1)
                r.k[u].to &&
                  r.k[u].s &&
                  r.k[u + 1] &&
                  r.k[u + 1].s &&
                  ((p = r.k[u].s),
                  (c = r.k[u + 1].s),
                  (d = r.k[u].to),
                  (f = r.k[u].ti),
                  ((2 === p.length &&
                    (p[0] !== c[0] || p[1] !== c[1]) &&
                    bez.pointOnLine2D(p[0], p[1], c[0], c[1], p[0] + d[0], p[1] + d[1]) &&
                    bez.pointOnLine2D(p[0], p[1], c[0], c[1], c[0] + f[0], c[1] + f[1])) ||
                    (3 === p.length &&
                      (p[0] !== c[0] || p[1] !== c[1] || p[2] !== c[2]) &&
                      bez.pointOnLine3D(
                        p[0],
                        p[1],
                        p[2],
                        c[0],
                        c[1],
                        c[2],
                        p[0] + d[0],
                        p[1] + d[1],
                        p[2] + d[2]
                      ) &&
                      bez.pointOnLine3D(
                        p[0],
                        p[1],
                        p[2],
                        c[0],
                        c[1],
                        c[2],
                        c[0] + f[0],
                        c[1] + f[1],
                        c[2] + f[2]
                      ))) &&
                    ((r.k[u].to = null), (r.k[u].ti = null)),
                  p[0] === c[0] &&
                    p[1] === c[1] &&
                    0 === d[0] &&
                    0 === d[1] &&
                    0 === f[0] &&
                    0 === f[1] &&
                    (2 === p.length || (p[2] === c[2] && 0 === d[2] && 0 === f[2])) &&
                    ((r.k[u].to = null), (r.k[u].ti = null)))
              ;(this.effectsSequence = [n.bind(this)]),
                (this.data = r),
                (this.keyframes = r.k),
                (this.offsetTime = t.data.st),
                (this.k = !0),
                (this.kf = !0),
                (this._isFirstFrame = !0),
                (this.mult = l || 1),
                (this.elem = t),
                (this.container = h),
                (this.comp = t.comp),
                (this.getValue = o),
                (this.setVValue = a),
                (this.interpolateValue = i),
                (this.frameId = -1)
              var g = r.k[0].s.length
              for (
                this.v = createTypedArray('float32', g),
                  this.pv = createTypedArray('float32', g),
                  u = 0;
                u < g;
                u += 1
              )
                (this.v[u] = e), (this.pv[u] = e)
              ;(this._caching = {
                lastFrame: e,
                lastIndex: 0,
                value: createTypedArray('float32', g)
              }),
                (this.addEffect = s)
            }
            return {
              getProp: function (e, t, i, r, n) {
                var a
                if (t.k.length)
                  if ('number' == typeof t.k[0]) a = new h(e, t, r, n)
                  else
                    switch (i) {
                      case 0:
                        a = new u(e, t, r, n)
                        break
                      case 1:
                        a = new p(e, t, r, n)
                    }
                else a = new l(e, t, r, n)
                return a.effectsSequence.length && n.addDynamicProperty(a), a
              }
            }
          })(),
          TransformPropertyFactory = (function () {
            var e = [0, 0]
            function t(e, t, i) {
              if (
                ((this.elem = e),
                (this.frameId = -1),
                (this.propType = 'transform'),
                (this.data = t),
                (this.v = new Matrix()),
                (this.pre = new Matrix()),
                (this.appliedTransformations = 0),
                this.initDynamicPropertyContainer(i || e),
                t.p && t.p.s
                  ? ((this.px = PropertyFactory.getProp(e, t.p.x, 0, 0, this)),
                    (this.py = PropertyFactory.getProp(e, t.p.y, 0, 0, this)),
                    t.p.z && (this.pz = PropertyFactory.getProp(e, t.p.z, 0, 0, this)))
                  : (this.p = PropertyFactory.getProp(e, t.p || { k: [0, 0, 0] }, 1, 0, this)),
                t.rx)
              ) {
                if (
                  ((this.rx = PropertyFactory.getProp(e, t.rx, 0, degToRads, this)),
                  (this.ry = PropertyFactory.getProp(e, t.ry, 0, degToRads, this)),
                  (this.rz = PropertyFactory.getProp(e, t.rz, 0, degToRads, this)),
                  t.or.k[0].ti)
                ) {
                  var r,
                    n = t.or.k.length
                  for (r = 0; r < n; r += 1) (t.or.k[r].to = null), (t.or.k[r].ti = null)
                }
                ;(this.or = PropertyFactory.getProp(e, t.or, 1, degToRads, this)), (this.or.sh = !0)
              } else this.r = PropertyFactory.getProp(e, t.r || { k: 0 }, 0, degToRads, this)
              t.sk &&
                ((this.sk = PropertyFactory.getProp(e, t.sk, 0, degToRads, this)),
                (this.sa = PropertyFactory.getProp(e, t.sa, 0, degToRads, this))),
                (this.a = PropertyFactory.getProp(e, t.a || { k: [0, 0, 0] }, 1, 0, this)),
                (this.s = PropertyFactory.getProp(e, t.s || { k: [100, 100, 100] }, 1, 0.01, this)),
                t.o
                  ? (this.o = PropertyFactory.getProp(e, t.o, 0, 0.01, e))
                  : (this.o = { _mdf: !1, v: 1 }),
                (this._isDirty = !0),
                this.dynamicProperties.length || this.getValue(!0)
            }
            return (
              (t.prototype = {
                applyToMatrix: function (e) {
                  var t = this._mdf
                  this.iterateDynamicProperties(),
                    (this._mdf = this._mdf || t),
                    this.a && e.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                    this.s && e.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                    this.sk && e.skewFromAxis(-this.sk.v, this.sa.v),
                    this.r
                      ? e.rotate(-this.r.v)
                      : e
                          .rotateZ(-this.rz.v)
                          .rotateY(this.ry.v)
                          .rotateX(this.rx.v)
                          .rotateZ(-this.or.v[2])
                          .rotateY(this.or.v[1])
                          .rotateX(this.or.v[0]),
                    this.data.p.s
                      ? this.data.p.z
                        ? e.translate(this.px.v, this.py.v, -this.pz.v)
                        : e.translate(this.px.v, this.py.v, 0)
                      : e.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                },
                getValue: function (t) {
                  if (this.elem.globalData.frameId !== this.frameId) {
                    if (
                      (this._isDirty && (this.precalculateMatrix(), (this._isDirty = !1)),
                      this.iterateDynamicProperties(),
                      this._mdf || t)
                    ) {
                      var i
                      if (
                        (this.v.cloneFromProps(this.pre.props),
                        this.appliedTransformations < 1 &&
                          this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                        this.appliedTransformations < 2 &&
                          this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                        this.sk &&
                          this.appliedTransformations < 3 &&
                          this.v.skewFromAxis(-this.sk.v, this.sa.v),
                        this.r && this.appliedTransformations < 4
                          ? this.v.rotate(-this.r.v)
                          : !this.r &&
                            this.appliedTransformations < 4 &&
                            this.v
                              .rotateZ(-this.rz.v)
                              .rotateY(this.ry.v)
                              .rotateX(this.rx.v)
                              .rotateZ(-this.or.v[2])
                              .rotateY(this.or.v[1])
                              .rotateX(this.or.v[0]),
                        this.autoOriented)
                      ) {
                        var r, n
                        if (
                          ((i = this.elem.globalData.frameRate),
                          this.p && this.p.keyframes && this.p.getValueAtTime)
                        )
                          this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t
                            ? ((r = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / i, 0)),
                              (n = this.p.getValueAtTime(this.p.keyframes[0].t / i, 0)))
                            : this.p._caching.lastFrame + this.p.offsetTime >=
                              this.p.keyframes[this.p.keyframes.length - 1].t
                            ? ((r = this.p.getValueAtTime(
                                this.p.keyframes[this.p.keyframes.length - 1].t / i,
                                0
                              )),
                              (n = this.p.getValueAtTime(
                                (this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / i,
                                0
                              )))
                            : ((r = this.p.pv),
                              (n = this.p.getValueAtTime(
                                (this.p._caching.lastFrame + this.p.offsetTime - 0.01) / i,
                                this.p.offsetTime
                              )))
                        else if (
                          this.px &&
                          this.px.keyframes &&
                          this.py.keyframes &&
                          this.px.getValueAtTime &&
                          this.py.getValueAtTime
                        ) {
                          ;(r = []), (n = [])
                          var a = this.px,
                            o = this.py
                          a._caching.lastFrame + a.offsetTime <= a.keyframes[0].t
                            ? ((r[0] = a.getValueAtTime((a.keyframes[0].t + 0.01) / i, 0)),
                              (r[1] = o.getValueAtTime((o.keyframes[0].t + 0.01) / i, 0)),
                              (n[0] = a.getValueAtTime(a.keyframes[0].t / i, 0)),
                              (n[1] = o.getValueAtTime(o.keyframes[0].t / i, 0)))
                            : a._caching.lastFrame + a.offsetTime >=
                              a.keyframes[a.keyframes.length - 1].t
                            ? ((r[0] = a.getValueAtTime(
                                a.keyframes[a.keyframes.length - 1].t / i,
                                0
                              )),
                              (r[1] = o.getValueAtTime(
                                o.keyframes[o.keyframes.length - 1].t / i,
                                0
                              )),
                              (n[0] = a.getValueAtTime(
                                (a.keyframes[a.keyframes.length - 1].t - 0.01) / i,
                                0
                              )),
                              (n[1] = o.getValueAtTime(
                                (o.keyframes[o.keyframes.length - 1].t - 0.01) / i,
                                0
                              )))
                            : ((r = [a.pv, o.pv]),
                              (n[0] = a.getValueAtTime(
                                (a._caching.lastFrame + a.offsetTime - 0.01) / i,
                                a.offsetTime
                              )),
                              (n[1] = o.getValueAtTime(
                                (o._caching.lastFrame + o.offsetTime - 0.01) / i,
                                o.offsetTime
                              )))
                        } else r = n = e
                        this.v.rotate(-Math.atan2(r[1] - n[1], r[0] - n[0]))
                      }
                      this.data.p && this.data.p.s
                        ? this.data.p.z
                          ? this.v.translate(this.px.v, this.py.v, -this.pz.v)
                          : this.v.translate(this.px.v, this.py.v, 0)
                        : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
                    }
                    this.frameId = this.elem.globalData.frameId
                  }
                },
                precalculateMatrix: function () {
                  if (
                    !this.a.k &&
                    (this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                    (this.appliedTransformations = 1),
                    !this.s.effectsSequence.length)
                  ) {
                    if (
                      (this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                      (this.appliedTransformations = 2),
                      this.sk)
                    ) {
                      if (this.sk.effectsSequence.length || this.sa.effectsSequence.length) return
                      this.pre.skewFromAxis(-this.sk.v, this.sa.v),
                        (this.appliedTransformations = 3)
                    }
                    this.r
                      ? this.r.effectsSequence.length ||
                        (this.pre.rotate(-this.r.v), (this.appliedTransformations = 4))
                      : this.rz.effectsSequence.length ||
                        this.ry.effectsSequence.length ||
                        this.rx.effectsSequence.length ||
                        this.or.effectsSequence.length ||
                        (this.pre
                          .rotateZ(-this.rz.v)
                          .rotateY(this.ry.v)
                          .rotateX(this.rx.v)
                          .rotateZ(-this.or.v[2])
                          .rotateY(this.or.v[1])
                          .rotateX(this.or.v[0]),
                        (this.appliedTransformations = 4))
                  }
                },
                autoOrient: function () {}
              }),
              extendPrototype([DynamicPropertyContainer], t),
              (t.prototype.addDynamicProperty = function (e) {
                this._addDynamicProperty(e), this.elem.addDynamicProperty(e), (this._isDirty = !0)
              }),
              (t.prototype._addDynamicProperty =
                DynamicPropertyContainer.prototype.addDynamicProperty),
              {
                getTransformProperty: function (e, i, r) {
                  return new t(e, i, r)
                }
              }
            )
          })()
        function ShapePath() {
          ;(this.c = !1),
            (this._length = 0),
            (this._maxLength = 8),
            (this.v = createSizedArray(this._maxLength)),
            (this.o = createSizedArray(this._maxLength)),
            (this.i = createSizedArray(this._maxLength))
        }
        ;(ShapePath.prototype.setPathData = function (e, t) {
          ;(this.c = e), this.setLength(t)
          for (var i = 0; i < t; )
            (this.v[i] = pointPool.newElement()),
              (this.o[i] = pointPool.newElement()),
              (this.i[i] = pointPool.newElement()),
              (i += 1)
        }),
          (ShapePath.prototype.setLength = function (e) {
            for (; this._maxLength < e; ) this.doubleArrayLength()
            this._length = e
          }),
          (ShapePath.prototype.doubleArrayLength = function () {
            ;(this.v = this.v.concat(createSizedArray(this._maxLength))),
              (this.i = this.i.concat(createSizedArray(this._maxLength))),
              (this.o = this.o.concat(createSizedArray(this._maxLength))),
              (this._maxLength *= 2)
          }),
          (ShapePath.prototype.setXYAt = function (e, t, i, r, n) {
            var a
            switch (
              ((this._length = Math.max(this._length, r + 1)),
              this._length >= this._maxLength && this.doubleArrayLength(),
              i)
            ) {
              case 'v':
                a = this.v
                break
              case 'i':
                a = this.i
                break
              case 'o':
                a = this.o
                break
              default:
                a = []
            }
            ;(!a[r] || (a[r] && !n)) && (a[r] = pointPool.newElement()),
              (a[r][0] = e),
              (a[r][1] = t)
          }),
          (ShapePath.prototype.setTripleAt = function (e, t, i, r, n, a, o, s) {
            this.setXYAt(e, t, 'v', o, s),
              this.setXYAt(i, r, 'o', o, s),
              this.setXYAt(n, a, 'i', o, s)
          }),
          (ShapePath.prototype.reverse = function () {
            var e = new ShapePath()
            e.setPathData(this.c, this._length)
            var t = this.v,
              i = this.o,
              r = this.i,
              n = 0
            this.c &&
              (e.setTripleAt(t[0][0], t[0][1], r[0][0], r[0][1], i[0][0], i[0][1], 0, !1), (n = 1))
            var a,
              o = this._length - 1,
              s = this._length
            for (a = n; a < s; a += 1)
              e.setTripleAt(t[o][0], t[o][1], r[o][0], r[o][1], i[o][0], i[o][1], a, !1), (o -= 1)
            return e
          })
        var ShapePropertyFactory = (function () {
            var e = -999999
            function t(e, t, i) {
              var r,
                n,
                a,
                o,
                s,
                l,
                h,
                u,
                p,
                c = i.lastIndex,
                d = this.keyframes
              if (e < d[0].t - this.offsetTime) (r = d[0].s[0]), (a = !0), (c = 0)
              else if (e >= d[d.length - 1].t - this.offsetTime)
                (r = d[d.length - 1].s ? d[d.length - 1].s[0] : d[d.length - 2].e[0]), (a = !0)
              else {
                for (
                  var f, m, g = c, y = d.length - 1, v = !0;
                  v && ((f = d[g]), !((m = d[g + 1]).t - this.offsetTime > e));

                )
                  g < y - 1 ? (g += 1) : (v = !1)
                if (((c = g), !(a = 1 === f.h))) {
                  if (e >= m.t - this.offsetTime) u = 1
                  else if (e < f.t - this.offsetTime) u = 0
                  else {
                    var _
                    f.__fnct
                      ? (_ = f.__fnct)
                      : ((_ = BezierFactory.getBezierEasing(f.o.x, f.o.y, f.i.x, f.i.y).get),
                        (f.__fnct = _)),
                      (u = _(
                        (e - (f.t - this.offsetTime)) /
                          (m.t - this.offsetTime - (f.t - this.offsetTime))
                      ))
                  }
                  n = m.s ? m.s[0] : f.e[0]
                }
                r = f.s[0]
              }
              for (l = t._length, h = r.i[0].length, i.lastIndex = c, o = 0; o < l; o += 1)
                for (s = 0; s < h; s += 1)
                  (p = a ? r.i[o][s] : r.i[o][s] + (n.i[o][s] - r.i[o][s]) * u),
                    (t.i[o][s] = p),
                    (p = a ? r.o[o][s] : r.o[o][s] + (n.o[o][s] - r.o[o][s]) * u),
                    (t.o[o][s] = p),
                    (p = a ? r.v[o][s] : r.v[o][s] + (n.v[o][s] - r.v[o][s]) * u),
                    (t.v[o][s] = p)
            }
            function i() {
              var t = this.comp.renderedFrame - this.offsetTime,
                i = this.keyframes[0].t - this.offsetTime,
                r = this.keyframes[this.keyframes.length - 1].t - this.offsetTime,
                n = this._caching.lastFrame
              return (
                (n !== e && ((n < i && t < i) || (n > r && t > r))) ||
                  ((this._caching.lastIndex = n < t ? this._caching.lastIndex : 0),
                  this.interpolateShape(t, this.pv, this._caching)),
                (this._caching.lastFrame = t),
                this.pv
              )
            }
            function r() {
              this.paths = this.localShapeCollection
            }
            function n(e) {
              ;(function (e, t) {
                if (e._length !== t._length || e.c !== t.c) return !1
                var i,
                  r = e._length
                for (i = 0; i < r; i += 1)
                  if (
                    e.v[i][0] !== t.v[i][0] ||
                    e.v[i][1] !== t.v[i][1] ||
                    e.o[i][0] !== t.o[i][0] ||
                    e.o[i][1] !== t.o[i][1] ||
                    e.i[i][0] !== t.i[i][0] ||
                    e.i[i][1] !== t.i[i][1]
                  )
                    return !1
                return !0
              })(this.v, e) ||
                ((this.v = shapePool.clone(e)),
                this.localShapeCollection.releaseShapes(),
                this.localShapeCollection.addShape(this.v),
                (this._mdf = !0),
                (this.paths = this.localShapeCollection))
            }
            function a() {
              if (this.elem.globalData.frameId !== this.frameId)
                if (this.effectsSequence.length)
                  if (this.lock) this.setVValue(this.pv)
                  else {
                    var e, t
                    ;(this.lock = !0),
                      (this._mdf = !1),
                      (e = this.kf ? this.pv : this.data.ks ? this.data.ks.k : this.data.pt.k)
                    var i = this.effectsSequence.length
                    for (t = 0; t < i; t += 1) e = this.effectsSequence[t](e)
                    this.setVValue(e),
                      (this.lock = !1),
                      (this.frameId = this.elem.globalData.frameId)
                  }
                else this._mdf = !1
            }
            function o(e, t, i) {
              ;(this.propType = 'shape'),
                (this.comp = e.comp),
                (this.container = e),
                (this.elem = e),
                (this.data = t),
                (this.k = !1),
                (this.kf = !1),
                (this._mdf = !1)
              var n = 3 === i ? t.pt.k : t.ks.k
              ;(this.v = shapePool.clone(n)),
                (this.pv = shapePool.clone(this.v)),
                (this.localShapeCollection = shapeCollectionPool.newShapeCollection()),
                (this.paths = this.localShapeCollection),
                this.paths.addShape(this.v),
                (this.reset = r),
                (this.effectsSequence = [])
            }
            function s(e) {
              this.effectsSequence.push(e), this.container.addDynamicProperty(this)
            }
            function l(t, n, a) {
              ;(this.propType = 'shape'),
                (this.comp = t.comp),
                (this.elem = t),
                (this.container = t),
                (this.offsetTime = t.data.st),
                (this.keyframes = 3 === a ? n.pt.k : n.ks.k),
                (this.k = !0),
                (this.kf = !0)
              var o = this.keyframes[0].s[0].i.length
              ;(this.v = shapePool.newElement()),
                this.v.setPathData(this.keyframes[0].s[0].c, o),
                (this.pv = shapePool.clone(this.v)),
                (this.localShapeCollection = shapeCollectionPool.newShapeCollection()),
                (this.paths = this.localShapeCollection),
                this.paths.addShape(this.v),
                (this.lastFrame = e),
                (this.reset = r),
                (this._caching = { lastFrame: e, lastIndex: 0 }),
                (this.effectsSequence = [i.bind(this)])
            }
            ;(o.prototype.interpolateShape = t),
              (o.prototype.getValue = a),
              (o.prototype.setVValue = n),
              (o.prototype.addEffect = s),
              (l.prototype.getValue = a),
              (l.prototype.interpolateShape = t),
              (l.prototype.setVValue = n),
              (l.prototype.addEffect = s)
            var h = (function () {
                var e = roundCorner
                function t(e, t) {
                  ;(this.v = shapePool.newElement()),
                    this.v.setPathData(!0, 4),
                    (this.localShapeCollection = shapeCollectionPool.newShapeCollection()),
                    (this.paths = this.localShapeCollection),
                    this.localShapeCollection.addShape(this.v),
                    (this.d = t.d),
                    (this.elem = e),
                    (this.comp = e.comp),
                    (this.frameId = -1),
                    this.initDynamicPropertyContainer(e),
                    (this.p = PropertyFactory.getProp(e, t.p, 1, 0, this)),
                    (this.s = PropertyFactory.getProp(e, t.s, 1, 0, this)),
                    this.dynamicProperties.length
                      ? (this.k = !0)
                      : ((this.k = !1), this.convertEllToPath())
                }
                return (
                  (t.prototype = {
                    reset: r,
                    getValue: function () {
                      this.elem.globalData.frameId !== this.frameId &&
                        ((this.frameId = this.elem.globalData.frameId),
                        this.iterateDynamicProperties(),
                        this._mdf && this.convertEllToPath())
                    },
                    convertEllToPath: function () {
                      var t = this.p.v[0],
                        i = this.p.v[1],
                        r = this.s.v[0] / 2,
                        n = this.s.v[1] / 2,
                        a = 3 !== this.d,
                        o = this.v
                      ;(o.v[0][0] = t),
                        (o.v[0][1] = i - n),
                        (o.v[1][0] = a ? t + r : t - r),
                        (o.v[1][1] = i),
                        (o.v[2][0] = t),
                        (o.v[2][1] = i + n),
                        (o.v[3][0] = a ? t - r : t + r),
                        (o.v[3][1] = i),
                        (o.i[0][0] = a ? t - r * e : t + r * e),
                        (o.i[0][1] = i - n),
                        (o.i[1][0] = a ? t + r : t - r),
                        (o.i[1][1] = i - n * e),
                        (o.i[2][0] = a ? t + r * e : t - r * e),
                        (o.i[2][1] = i + n),
                        (o.i[3][0] = a ? t - r : t + r),
                        (o.i[3][1] = i + n * e),
                        (o.o[0][0] = a ? t + r * e : t - r * e),
                        (o.o[0][1] = i - n),
                        (o.o[1][0] = a ? t + r : t - r),
                        (o.o[1][1] = i + n * e),
                        (o.o[2][0] = a ? t - r * e : t + r * e),
                        (o.o[2][1] = i + n),
                        (o.o[3][0] = a ? t - r : t + r),
                        (o.o[3][1] = i - n * e)
                    }
                  }),
                  extendPrototype([DynamicPropertyContainer], t),
                  t
                )
              })(),
              u = (function () {
                function e(e, t) {
                  ;(this.v = shapePool.newElement()),
                    this.v.setPathData(!0, 0),
                    (this.elem = e),
                    (this.comp = e.comp),
                    (this.data = t),
                    (this.frameId = -1),
                    (this.d = t.d),
                    this.initDynamicPropertyContainer(e),
                    1 === t.sy
                      ? ((this.ir = PropertyFactory.getProp(e, t.ir, 0, 0, this)),
                        (this.is = PropertyFactory.getProp(e, t.is, 0, 0.01, this)),
                        (this.convertToPath = this.convertStarToPath))
                      : (this.convertToPath = this.convertPolygonToPath),
                    (this.pt = PropertyFactory.getProp(e, t.pt, 0, 0, this)),
                    (this.p = PropertyFactory.getProp(e, t.p, 1, 0, this)),
                    (this.r = PropertyFactory.getProp(e, t.r, 0, degToRads, this)),
                    (this.or = PropertyFactory.getProp(e, t.or, 0, 0, this)),
                    (this.os = PropertyFactory.getProp(e, t.os, 0, 0.01, this)),
                    (this.localShapeCollection = shapeCollectionPool.newShapeCollection()),
                    this.localShapeCollection.addShape(this.v),
                    (this.paths = this.localShapeCollection),
                    this.dynamicProperties.length
                      ? (this.k = !0)
                      : ((this.k = !1), this.convertToPath())
                }
                return (
                  (e.prototype = {
                    reset: r,
                    getValue: function () {
                      this.elem.globalData.frameId !== this.frameId &&
                        ((this.frameId = this.elem.globalData.frameId),
                        this.iterateDynamicProperties(),
                        this._mdf && this.convertToPath())
                    },
                    convertStarToPath: function () {
                      var e,
                        t,
                        i,
                        r,
                        n = 2 * Math.floor(this.pt.v),
                        a = (2 * Math.PI) / n,
                        o = !0,
                        s = this.or.v,
                        l = this.ir.v,
                        h = this.os.v,
                        u = this.is.v,
                        p = (2 * Math.PI * s) / (2 * n),
                        c = (2 * Math.PI * l) / (2 * n),
                        d = -Math.PI / 2
                      d += this.r.v
                      var f = 3 === this.data.d ? -1 : 1
                      for (this.v._length = 0, e = 0; e < n; e += 1) {
                        ;(i = o ? h : u), (r = o ? p : c)
                        var m = (t = o ? s : l) * Math.cos(d),
                          g = t * Math.sin(d),
                          y = 0 === m && 0 === g ? 0 : g / Math.sqrt(m * m + g * g),
                          v = 0 === m && 0 === g ? 0 : -m / Math.sqrt(m * m + g * g)
                        ;(m += +this.p.v[0]),
                          (g += +this.p.v[1]),
                          this.v.setTripleAt(
                            m,
                            g,
                            m - y * r * i * f,
                            g - v * r * i * f,
                            m + y * r * i * f,
                            g + v * r * i * f,
                            e,
                            !0
                          ),
                          (o = !o),
                          (d += a * f)
                      }
                    },
                    convertPolygonToPath: function () {
                      var e,
                        t = Math.floor(this.pt.v),
                        i = (2 * Math.PI) / t,
                        r = this.or.v,
                        n = this.os.v,
                        a = (2 * Math.PI * r) / (4 * t),
                        o = 0.5 * -Math.PI,
                        s = 3 === this.data.d ? -1 : 1
                      for (o += this.r.v, this.v._length = 0, e = 0; e < t; e += 1) {
                        var l = r * Math.cos(o),
                          h = r * Math.sin(o),
                          u = 0 === l && 0 === h ? 0 : h / Math.sqrt(l * l + h * h),
                          p = 0 === l && 0 === h ? 0 : -l / Math.sqrt(l * l + h * h)
                        ;(l += +this.p.v[0]),
                          (h += +this.p.v[1]),
                          this.v.setTripleAt(
                            l,
                            h,
                            l - u * a * n * s,
                            h - p * a * n * s,
                            l + u * a * n * s,
                            h + p * a * n * s,
                            e,
                            !0
                          ),
                          (o += i * s)
                      }
                      ;(this.paths.length = 0), (this.paths[0] = this.v)
                    }
                  }),
                  extendPrototype([DynamicPropertyContainer], e),
                  e
                )
              })(),
              p = (function () {
                function e(e, t) {
                  ;(this.v = shapePool.newElement()),
                    (this.v.c = !0),
                    (this.localShapeCollection = shapeCollectionPool.newShapeCollection()),
                    this.localShapeCollection.addShape(this.v),
                    (this.paths = this.localShapeCollection),
                    (this.elem = e),
                    (this.comp = e.comp),
                    (this.frameId = -1),
                    (this.d = t.d),
                    this.initDynamicPropertyContainer(e),
                    (this.p = PropertyFactory.getProp(e, t.p, 1, 0, this)),
                    (this.s = PropertyFactory.getProp(e, t.s, 1, 0, this)),
                    (this.r = PropertyFactory.getProp(e, t.r, 0, 0, this)),
                    this.dynamicProperties.length
                      ? (this.k = !0)
                      : ((this.k = !1), this.convertRectToPath())
                }
                return (
                  (e.prototype = {
                    convertRectToPath: function () {
                      var e = this.p.v[0],
                        t = this.p.v[1],
                        i = this.s.v[0] / 2,
                        r = this.s.v[1] / 2,
                        n = bmMin(i, r, this.r.v),
                        a = n * (1 - roundCorner)
                      ;(this.v._length = 0),
                        2 === this.d || 1 === this.d
                          ? (this.v.setTripleAt(
                              e + i,
                              t - r + n,
                              e + i,
                              t - r + n,
                              e + i,
                              t - r + a,
                              0,
                              !0
                            ),
                            this.v.setTripleAt(
                              e + i,
                              t + r - n,
                              e + i,
                              t + r - a,
                              e + i,
                              t + r - n,
                              1,
                              !0
                            ),
                            0 !== n
                              ? (this.v.setTripleAt(
                                  e + i - n,
                                  t + r,
                                  e + i - n,
                                  t + r,
                                  e + i - a,
                                  t + r,
                                  2,
                                  !0
                                ),
                                this.v.setTripleAt(
                                  e - i + n,
                                  t + r,
                                  e - i + a,
                                  t + r,
                                  e - i + n,
                                  t + r,
                                  3,
                                  !0
                                ),
                                this.v.setTripleAt(
                                  e - i,
                                  t + r - n,
                                  e - i,
                                  t + r - n,
                                  e - i,
                                  t + r - a,
                                  4,
                                  !0
                                ),
                                this.v.setTripleAt(
                                  e - i,
                                  t - r + n,
                                  e - i,
                                  t - r + a,
                                  e - i,
                                  t - r + n,
                                  5,
                                  !0
                                ),
                                this.v.setTripleAt(
                                  e - i + n,
                                  t - r,
                                  e - i + n,
                                  t - r,
                                  e - i + a,
                                  t - r,
                                  6,
                                  !0
                                ),
                                this.v.setTripleAt(
                                  e + i - n,
                                  t - r,
                                  e + i - a,
                                  t - r,
                                  e + i - n,
                                  t - r,
                                  7,
                                  !0
                                ))
                              : (this.v.setTripleAt(
                                  e - i,
                                  t + r,
                                  e - i + a,
                                  t + r,
                                  e - i,
                                  t + r,
                                  2
                                ),
                                this.v.setTripleAt(
                                  e - i,
                                  t - r,
                                  e - i,
                                  t - r + a,
                                  e - i,
                                  t - r,
                                  3
                                )))
                          : (this.v.setTripleAt(
                              e + i,
                              t - r + n,
                              e + i,
                              t - r + a,
                              e + i,
                              t - r + n,
                              0,
                              !0
                            ),
                            0 !== n
                              ? (this.v.setTripleAt(
                                  e + i - n,
                                  t - r,
                                  e + i - n,
                                  t - r,
                                  e + i - a,
                                  t - r,
                                  1,
                                  !0
                                ),
                                this.v.setTripleAt(
                                  e - i + n,
                                  t - r,
                                  e - i + a,
                                  t - r,
                                  e - i + n,
                                  t - r,
                                  2,
                                  !0
                                ),
                                this.v.setTripleAt(
                                  e - i,
                                  t - r + n,
                                  e - i,
                                  t - r + n,
                                  e - i,
                                  t - r + a,
                                  3,
                                  !0
                                ),
                                this.v.setTripleAt(
                                  e - i,
                                  t + r - n,
                                  e - i,
                                  t + r - a,
                                  e - i,
                                  t + r - n,
                                  4,
                                  !0
                                ),
                                this.v.setTripleAt(
                                  e - i + n,
                                  t + r,
                                  e - i + n,
                                  t + r,
                                  e - i + a,
                                  t + r,
                                  5,
                                  !0
                                ),
                                this.v.setTripleAt(
                                  e + i - n,
                                  t + r,
                                  e + i - a,
                                  t + r,
                                  e + i - n,
                                  t + r,
                                  6,
                                  !0
                                ),
                                this.v.setTripleAt(
                                  e + i,
                                  t + r - n,
                                  e + i,
                                  t + r - n,
                                  e + i,
                                  t + r - a,
                                  7,
                                  !0
                                ))
                              : (this.v.setTripleAt(
                                  e - i,
                                  t - r,
                                  e - i + a,
                                  t - r,
                                  e - i,
                                  t - r,
                                  1,
                                  !0
                                ),
                                this.v.setTripleAt(
                                  e - i,
                                  t + r,
                                  e - i,
                                  t + r - a,
                                  e - i,
                                  t + r,
                                  2,
                                  !0
                                ),
                                this.v.setTripleAt(
                                  e + i,
                                  t + r,
                                  e + i - a,
                                  t + r,
                                  e + i,
                                  t + r,
                                  3,
                                  !0
                                )))
                    },
                    getValue: function () {
                      this.elem.globalData.frameId !== this.frameId &&
                        ((this.frameId = this.elem.globalData.frameId),
                        this.iterateDynamicProperties(),
                        this._mdf && this.convertRectToPath())
                    },
                    reset: r
                  }),
                  extendPrototype([DynamicPropertyContainer], e),
                  e
                )
              })(),
              c = {
                getShapeProp: function (e, t, i) {
                  var r
                  return (
                    3 === i || 4 === i
                      ? (r = (3 === i ? t.pt : t.ks).k.length ? new l(e, t, i) : new o(e, t, i))
                      : 5 === i
                      ? (r = new p(e, t))
                      : 6 === i
                      ? (r = new h(e, t))
                      : 7 === i && (r = new u(e, t)),
                    r.k && e.addDynamicProperty(r),
                    r
                  )
                },
                getConstructorFunction: function () {
                  return o
                },
                getKeyframedConstructorFunction: function () {
                  return l
                }
              }
            return c
          })(),
          ShapeModifiers =
            ((ob = {}),
            (modifiers = {}),
            (ob.registerModifier = function (e, t) {
              modifiers[e] || (modifiers[e] = t)
            }),
            (ob.getModifier = function (e, t, i) {
              return new modifiers[e](t, i)
            }),
            ob),
          ob,
          modifiers
        function ShapeModifier() {}
        function TrimModifier() {}
        function RoundCornersModifier() {}
        function PuckerAndBloatModifier() {}
        function RepeaterModifier() {}
        function ShapeCollection() {
          ;(this._length = 0),
            (this._maxLength = 4),
            (this.shapes = createSizedArray(this._maxLength))
        }
        function DashProperty(e, t, i, r) {
          var n
          ;(this.elem = e),
            (this.frameId = -1),
            (this.dataProps = createSizedArray(t.length)),
            (this.renderer = i),
            (this.k = !1),
            (this.dashStr = ''),
            (this.dashArray = createTypedArray('float32', t.length ? t.length - 1 : 0)),
            (this.dashoffset = createTypedArray('float32', 1)),
            this.initDynamicPropertyContainer(r)
          var a,
            o = t.length || 0
          for (n = 0; n < o; n += 1)
            (a = PropertyFactory.getProp(e, t[n].v, 0, 0, this)),
              (this.k = a.k || this.k),
              (this.dataProps[n] = { n: t[n].n, p: a })
          this.k || this.getValue(!0), (this._isAnimated = this.k)
        }
        function GradientProperty(e, t, i) {
          ;(this.data = t), (this.c = createTypedArray('uint8c', 4 * t.p))
          var r = t.k.k[0].s ? t.k.k[0].s.length - 4 * t.p : t.k.k.length - 4 * t.p
          ;(this.o = createTypedArray('float32', r)),
            (this._cmdf = !1),
            (this._omdf = !1),
            (this._collapsable = this.checkCollapsable()),
            (this._hasOpacity = r),
            this.initDynamicPropertyContainer(i),
            (this.prop = PropertyFactory.getProp(e, t.k, 1, null, this)),
            (this.k = this.prop.k),
            this.getValue(!0)
        }
        ;(ShapeModifier.prototype.initModifierProperties = function () {}),
          (ShapeModifier.prototype.addShapeToModifier = function () {}),
          (ShapeModifier.prototype.addShape = function (e) {
            if (!this.closed) {
              e.sh.container.addDynamicProperty(e.sh)
              var t = {
                shape: e.sh,
                data: e,
                localShapeCollection: shapeCollectionPool.newShapeCollection()
              }
              this.shapes.push(t), this.addShapeToModifier(t), this._isAnimated && e.setAsAnimated()
            }
          }),
          (ShapeModifier.prototype.init = function (e, t) {
            ;(this.shapes = []),
              (this.elem = e),
              this.initDynamicPropertyContainer(e),
              this.initModifierProperties(e, t),
              (this.frameId = initialDefaultFrame),
              (this.closed = !1),
              (this.k = !1),
              this.dynamicProperties.length ? (this.k = !0) : this.getValue(!0)
          }),
          (ShapeModifier.prototype.processKeys = function () {
            this.elem.globalData.frameId !== this.frameId &&
              ((this.frameId = this.elem.globalData.frameId), this.iterateDynamicProperties())
          }),
          extendPrototype([DynamicPropertyContainer], ShapeModifier),
          extendPrototype([ShapeModifier], TrimModifier),
          (TrimModifier.prototype.initModifierProperties = function (e, t) {
            ;(this.s = PropertyFactory.getProp(e, t.s, 0, 0.01, this)),
              (this.e = PropertyFactory.getProp(e, t.e, 0, 0.01, this)),
              (this.o = PropertyFactory.getProp(e, t.o, 0, 0, this)),
              (this.sValue = 0),
              (this.eValue = 0),
              (this.getValue = this.processKeys),
              (this.m = t.m),
              (this._isAnimated =
                !!this.s.effectsSequence.length ||
                !!this.e.effectsSequence.length ||
                !!this.o.effectsSequence.length)
          }),
          (TrimModifier.prototype.addShapeToModifier = function (e) {
            e.pathsData = []
          }),
          (TrimModifier.prototype.calculateShapeEdges = function (e, t, i, r, n) {
            var a = []
            t <= 1
              ? a.push({ s: e, e: t })
              : e >= 1
              ? a.push({ s: e - 1, e: t - 1 })
              : (a.push({ s: e, e: 1 }), a.push({ s: 0, e: t - 1 }))
            var o,
              s,
              l = [],
              h = a.length
            for (o = 0; o < h; o += 1) {
              var u, p
              ;(s = a[o]).e * n < r ||
                s.s * n > r + i ||
                ((u = s.s * n <= r ? 0 : (s.s * n - r) / i),
                (p = s.e * n >= r + i ? 1 : (s.e * n - r) / i),
                l.push([u, p]))
            }
            return l.length || l.push([0, 0]), l
          }),
          (TrimModifier.prototype.releasePathsData = function (e) {
            var t,
              i = e.length
            for (t = 0; t < i; t += 1) segmentsLengthPool.release(e[t])
            return (e.length = 0), e
          }),
          (TrimModifier.prototype.processShapes = function (e) {
            var t, i, r, n
            if (this._mdf || e) {
              var a = (this.o.v % 360) / 360
              if (
                (a < 0 && (a += 1),
                (t = this.s.v > 1 ? 1 + a : this.s.v < 0 ? 0 + a : this.s.v + a) >
                  (i = this.e.v > 1 ? 1 + a : this.e.v < 0 ? 0 + a : this.e.v + a))
              ) {
                var o = t
                ;(t = i), (i = o)
              }
              ;(t = 1e-4 * Math.round(1e4 * t)),
                (i = 1e-4 * Math.round(1e4 * i)),
                (this.sValue = t),
                (this.eValue = i)
            } else (t = this.sValue), (i = this.eValue)
            var s,
              l,
              h,
              u,
              p,
              c = this.shapes.length,
              d = 0
            if (i === t)
              for (n = 0; n < c; n += 1)
                this.shapes[n].localShapeCollection.releaseShapes(),
                  (this.shapes[n].shape._mdf = !0),
                  (this.shapes[n].shape.paths = this.shapes[n].localShapeCollection),
                  this._mdf && (this.shapes[n].pathsData.length = 0)
            else if ((1 === i && 0 === t) || (0 === i && 1 === t)) {
              if (this._mdf)
                for (n = 0; n < c; n += 1)
                  (this.shapes[n].pathsData.length = 0), (this.shapes[n].shape._mdf = !0)
            } else {
              var f,
                m,
                g = []
              for (n = 0; n < c; n += 1)
                if ((f = this.shapes[n]).shape._mdf || this._mdf || e || 2 === this.m) {
                  if (
                    ((l = (r = f.shape.paths)._length),
                    (p = 0),
                    !f.shape._mdf && f.pathsData.length)
                  )
                    p = f.totalShapeLength
                  else {
                    for (h = this.releasePathsData(f.pathsData), s = 0; s < l; s += 1)
                      (u = bez.getSegmentsLength(r.shapes[s])), h.push(u), (p += u.totalLength)
                    ;(f.totalShapeLength = p), (f.pathsData = h)
                  }
                  ;(d += p), (f.shape._mdf = !0)
                } else f.shape.paths = f.localShapeCollection
              var y,
                v = t,
                _ = i,
                x = 0
              for (n = c - 1; n >= 0; n -= 1)
                if ((f = this.shapes[n]).shape._mdf) {
                  for (
                    (m = f.localShapeCollection).releaseShapes(),
                      2 === this.m && c > 1
                        ? ((y = this.calculateShapeEdges(t, i, f.totalShapeLength, x, d)),
                          (x += f.totalShapeLength))
                        : (y = [[v, _]]),
                      l = y.length,
                      s = 0;
                    s < l;
                    s += 1
                  ) {
                    ;(v = y[s][0]),
                      (_ = y[s][1]),
                      (g.length = 0),
                      _ <= 1
                        ? g.push({ s: f.totalShapeLength * v, e: f.totalShapeLength * _ })
                        : v >= 1
                        ? g.push({
                            s: f.totalShapeLength * (v - 1),
                            e: f.totalShapeLength * (_ - 1)
                          })
                        : (g.push({ s: f.totalShapeLength * v, e: f.totalShapeLength }),
                          g.push({ s: 0, e: f.totalShapeLength * (_ - 1) }))
                    var S = this.addShapes(f, g[0])
                    if (g[0].s !== g[0].e) {
                      if (g.length > 1)
                        if (f.shape.paths.shapes[f.shape.paths._length - 1].c) {
                          var b = S.pop()
                          this.addPaths(S, m), (S = this.addShapes(f, g[1], b))
                        } else this.addPaths(S, m), (S = this.addShapes(f, g[1]))
                      this.addPaths(S, m)
                    }
                  }
                  f.shape.paths = m
                }
            }
          }),
          (TrimModifier.prototype.addPaths = function (e, t) {
            var i,
              r = e.length
            for (i = 0; i < r; i += 1) t.addShape(e[i])
          }),
          (TrimModifier.prototype.addSegment = function (e, t, i, r, n, a, o) {
            n.setXYAt(t[0], t[1], 'o', a),
              n.setXYAt(i[0], i[1], 'i', a + 1),
              o && n.setXYAt(e[0], e[1], 'v', a),
              n.setXYAt(r[0], r[1], 'v', a + 1)
          }),
          (TrimModifier.prototype.addSegmentFromArray = function (e, t, i, r) {
            t.setXYAt(e[1], e[5], 'o', i),
              t.setXYAt(e[2], e[6], 'i', i + 1),
              r && t.setXYAt(e[0], e[4], 'v', i),
              t.setXYAt(e[3], e[7], 'v', i + 1)
          }),
          (TrimModifier.prototype.addShapes = function (e, t, i) {
            var r,
              n,
              a,
              o,
              s,
              l,
              h,
              u,
              p = e.pathsData,
              c = e.shape.paths.shapes,
              d = e.shape.paths._length,
              f = 0,
              m = [],
              g = !0
            for (
              i
                ? ((s = i._length), (u = i._length))
                : ((i = shapePool.newElement()), (s = 0), (u = 0)),
                m.push(i),
                r = 0;
              r < d;
              r += 1
            ) {
              for (
                l = p[r].lengths, i.c = c[r].c, a = c[r].c ? l.length : l.length + 1, n = 1;
                n < a;
                n += 1
              )
                if (f + (o = l[n - 1]).addedLength < t.s) (f += o.addedLength), (i.c = !1)
                else {
                  if (f > t.e) {
                    i.c = !1
                    break
                  }
                  t.s <= f && t.e >= f + o.addedLength
                    ? (this.addSegment(c[r].v[n - 1], c[r].o[n - 1], c[r].i[n], c[r].v[n], i, s, g),
                      (g = !1))
                    : ((h = bez.getNewSegment(
                        c[r].v[n - 1],
                        c[r].v[n],
                        c[r].o[n - 1],
                        c[r].i[n],
                        (t.s - f) / o.addedLength,
                        (t.e - f) / o.addedLength,
                        l[n - 1]
                      )),
                      this.addSegmentFromArray(h, i, s, g),
                      (g = !1),
                      (i.c = !1)),
                    (f += o.addedLength),
                    (s += 1)
                }
              if (c[r].c && l.length) {
                if (((o = l[n - 1]), f <= t.e)) {
                  var y = l[n - 1].addedLength
                  t.s <= f && t.e >= f + y
                    ? (this.addSegment(c[r].v[n - 1], c[r].o[n - 1], c[r].i[0], c[r].v[0], i, s, g),
                      (g = !1))
                    : ((h = bez.getNewSegment(
                        c[r].v[n - 1],
                        c[r].v[0],
                        c[r].o[n - 1],
                        c[r].i[0],
                        (t.s - f) / y,
                        (t.e - f) / y,
                        l[n - 1]
                      )),
                      this.addSegmentFromArray(h, i, s, g),
                      (g = !1),
                      (i.c = !1))
                } else i.c = !1
                ;(f += o.addedLength), (s += 1)
              }
              if (
                (i._length &&
                  (i.setXYAt(i.v[u][0], i.v[u][1], 'i', u),
                  i.setXYAt(i.v[i._length - 1][0], i.v[i._length - 1][1], 'o', i._length - 1)),
                f > t.e)
              )
                break
              r < d - 1 && ((i = shapePool.newElement()), (g = !0), m.push(i), (s = 0))
            }
            return m
          }),
          ShapeModifiers.registerModifier('tm', TrimModifier),
          extendPrototype([ShapeModifier], RoundCornersModifier),
          (RoundCornersModifier.prototype.initModifierProperties = function (e, t) {
            ;(this.getValue = this.processKeys),
              (this.rd = PropertyFactory.getProp(e, t.r, 0, null, this)),
              (this._isAnimated = !!this.rd.effectsSequence.length)
          }),
          (RoundCornersModifier.prototype.processPath = function (e, t) {
            var i,
              r = shapePool.newElement()
            r.c = e.c
            var n,
              a,
              o,
              s,
              l,
              h,
              u,
              p,
              c,
              d,
              f,
              m,
              g = e._length,
              y = 0
            for (i = 0; i < g; i += 1)
              (n = e.v[i]),
                (o = e.o[i]),
                (a = e.i[i]),
                n[0] === o[0] && n[1] === o[1] && n[0] === a[0] && n[1] === a[1]
                  ? (0 !== i && i !== g - 1) || e.c
                    ? ((s = 0 === i ? e.v[g - 1] : e.v[i - 1]),
                      (h = (l = Math.sqrt(Math.pow(n[0] - s[0], 2) + Math.pow(n[1] - s[1], 2)))
                        ? Math.min(l / 2, t) / l
                        : 0),
                      (u = f = n[0] + (s[0] - n[0]) * h),
                      (p = m = n[1] - (n[1] - s[1]) * h),
                      (c = u - (u - n[0]) * roundCorner),
                      (d = p - (p - n[1]) * roundCorner),
                      r.setTripleAt(u, p, c, d, f, m, y),
                      (y += 1),
                      (s = i === g - 1 ? e.v[0] : e.v[i + 1]),
                      (h = (l = Math.sqrt(Math.pow(n[0] - s[0], 2) + Math.pow(n[1] - s[1], 2)))
                        ? Math.min(l / 2, t) / l
                        : 0),
                      (u = c = n[0] + (s[0] - n[0]) * h),
                      (p = d = n[1] + (s[1] - n[1]) * h),
                      (f = u - (u - n[0]) * roundCorner),
                      (m = p - (p - n[1]) * roundCorner),
                      r.setTripleAt(u, p, c, d, f, m, y),
                      (y += 1))
                    : (r.setTripleAt(n[0], n[1], o[0], o[1], a[0], a[1], y), (y += 1))
                  : (r.setTripleAt(
                      e.v[i][0],
                      e.v[i][1],
                      e.o[i][0],
                      e.o[i][1],
                      e.i[i][0],
                      e.i[i][1],
                      y
                    ),
                    (y += 1))
            return r
          }),
          (RoundCornersModifier.prototype.processShapes = function (e) {
            var t,
              i,
              r,
              n,
              a,
              o,
              s = this.shapes.length,
              l = this.rd.v
            if (0 !== l)
              for (i = 0; i < s; i += 1) {
                if (
                  ((o = (a = this.shapes[i]).localShapeCollection), a.shape._mdf || this._mdf || e)
                )
                  for (
                    o.releaseShapes(),
                      a.shape._mdf = !0,
                      t = a.shape.paths.shapes,
                      n = a.shape.paths._length,
                      r = 0;
                    r < n;
                    r += 1
                  )
                    o.addShape(this.processPath(t[r], l))
                a.shape.paths = a.localShapeCollection
              }
            this.dynamicProperties.length || (this._mdf = !1)
          }),
          ShapeModifiers.registerModifier('rd', RoundCornersModifier),
          extendPrototype([ShapeModifier], PuckerAndBloatModifier),
          (PuckerAndBloatModifier.prototype.initModifierProperties = function (e, t) {
            ;(this.getValue = this.processKeys),
              (this.amount = PropertyFactory.getProp(e, t.a, 0, null, this)),
              (this._isAnimated = !!this.amount.effectsSequence.length)
          }),
          (PuckerAndBloatModifier.prototype.processPath = function (e, t) {
            var i = t / 100,
              r = [0, 0],
              n = e._length,
              a = 0
            for (a = 0; a < n; a += 1) (r[0] += e.v[a][0]), (r[1] += e.v[a][1])
            ;(r[0] /= n), (r[1] /= n)
            var o,
              s,
              l,
              h,
              u,
              p,
              c = shapePool.newElement()
            for (c.c = e.c, a = 0; a < n; a += 1)
              (o = e.v[a][0] + (r[0] - e.v[a][0]) * i),
                (s = e.v[a][1] + (r[1] - e.v[a][1]) * i),
                (l = e.o[a][0] + (r[0] - e.o[a][0]) * -i),
                (h = e.o[a][1] + (r[1] - e.o[a][1]) * -i),
                (u = e.i[a][0] + (r[0] - e.i[a][0]) * -i),
                (p = e.i[a][1] + (r[1] - e.i[a][1]) * -i),
                c.setTripleAt(o, s, l, h, u, p, a)
            return c
          }),
          (PuckerAndBloatModifier.prototype.processShapes = function (e) {
            var t,
              i,
              r,
              n,
              a,
              o,
              s = this.shapes.length,
              l = this.amount.v
            if (0 !== l)
              for (i = 0; i < s; i += 1) {
                if (
                  ((o = (a = this.shapes[i]).localShapeCollection), a.shape._mdf || this._mdf || e)
                )
                  for (
                    o.releaseShapes(),
                      a.shape._mdf = !0,
                      t = a.shape.paths.shapes,
                      n = a.shape.paths._length,
                      r = 0;
                    r < n;
                    r += 1
                  )
                    o.addShape(this.processPath(t[r], l))
                a.shape.paths = a.localShapeCollection
              }
            this.dynamicProperties.length || (this._mdf = !1)
          }),
          ShapeModifiers.registerModifier('pb', PuckerAndBloatModifier),
          extendPrototype([ShapeModifier], RepeaterModifier),
          (RepeaterModifier.prototype.initModifierProperties = function (e, t) {
            ;(this.getValue = this.processKeys),
              (this.c = PropertyFactory.getProp(e, t.c, 0, null, this)),
              (this.o = PropertyFactory.getProp(e, t.o, 0, null, this)),
              (this.tr = TransformPropertyFactory.getTransformProperty(e, t.tr, this)),
              (this.so = PropertyFactory.getProp(e, t.tr.so, 0, 0.01, this)),
              (this.eo = PropertyFactory.getProp(e, t.tr.eo, 0, 0.01, this)),
              (this.data = t),
              this.dynamicProperties.length || this.getValue(!0),
              (this._isAnimated = !!this.dynamicProperties.length),
              (this.pMatrix = new Matrix()),
              (this.rMatrix = new Matrix()),
              (this.sMatrix = new Matrix()),
              (this.tMatrix = new Matrix()),
              (this.matrix = new Matrix())
          }),
          (RepeaterModifier.prototype.applyTransforms = function (e, t, i, r, n, a) {
            var o = a ? -1 : 1,
              s = r.s.v[0] + (1 - r.s.v[0]) * (1 - n),
              l = r.s.v[1] + (1 - r.s.v[1]) * (1 - n)
            e.translate(r.p.v[0] * o * n, r.p.v[1] * o * n, r.p.v[2]),
              t.translate(-r.a.v[0], -r.a.v[1], r.a.v[2]),
              t.rotate(-r.r.v * o * n),
              t.translate(r.a.v[0], r.a.v[1], r.a.v[2]),
              i.translate(-r.a.v[0], -r.a.v[1], r.a.v[2]),
              i.scale(a ? 1 / s : s, a ? 1 / l : l),
              i.translate(r.a.v[0], r.a.v[1], r.a.v[2])
          }),
          (RepeaterModifier.prototype.init = function (e, t, i, r) {
            for (
              this.elem = e,
                this.arr = t,
                this.pos = i,
                this.elemsData = r,
                this._currentCopies = 0,
                this._elements = [],
                this._groups = [],
                this.frameId = -1,
                this.initDynamicPropertyContainer(e),
                this.initModifierProperties(e, t[i]);
              i > 0;

            )
              (i -= 1), this._elements.unshift(t[i])
            this.dynamicProperties.length ? (this.k = !0) : this.getValue(!0)
          }),
          (RepeaterModifier.prototype.resetElements = function (e) {
            var t,
              i = e.length
            for (t = 0; t < i; t += 1)
              (e[t]._processed = !1), 'gr' === e[t].ty && this.resetElements(e[t].it)
          }),
          (RepeaterModifier.prototype.cloneElements = function (e) {
            var t = JSON.parse(JSON.stringify(e))
            return this.resetElements(t), t
          }),
          (RepeaterModifier.prototype.changeGroupRender = function (e, t) {
            var i,
              r = e.length
            for (i = 0; i < r; i += 1)
              (e[i]._render = t), 'gr' === e[i].ty && this.changeGroupRender(e[i].it, t)
          }),
          (RepeaterModifier.prototype.processShapes = function (e) {
            var t,
              i,
              r,
              n,
              a,
              o = !1
            if (this._mdf || e) {
              var s,
                l = Math.ceil(this.c.v)
              if (this._groups.length < l) {
                for (; this._groups.length < l; ) {
                  var h = { it: this.cloneElements(this._elements), ty: 'gr' }
                  h.it.push({
                    a: { a: 0, ix: 1, k: [0, 0] },
                    nm: 'Transform',
                    o: { a: 0, ix: 7, k: 100 },
                    p: { a: 0, ix: 2, k: [0, 0] },
                    r: {
                      a: 1,
                      ix: 6,
                      k: [
                        { s: 0, e: 0, t: 0 },
                        { s: 0, e: 0, t: 1 }
                      ]
                    },
                    s: { a: 0, ix: 3, k: [100, 100] },
                    sa: { a: 0, ix: 5, k: 0 },
                    sk: { a: 0, ix: 4, k: 0 },
                    ty: 'tr'
                  }),
                    this.arr.splice(0, 0, h),
                    this._groups.splice(0, 0, h),
                    (this._currentCopies += 1)
                }
                this.elem.reloadShapes(), (o = !0)
              }
              for (a = 0, r = 0; r <= this._groups.length - 1; r += 1) {
                if (
                  ((s = a < l),
                  (this._groups[r]._render = s),
                  this.changeGroupRender(this._groups[r].it, s),
                  !s)
                ) {
                  var u = this.elemsData[r].it,
                    p = u[u.length - 1]
                  0 !== p.transform.op.v
                    ? ((p.transform.op._mdf = !0), (p.transform.op.v = 0))
                    : (p.transform.op._mdf = !1)
                }
                a += 1
              }
              this._currentCopies = l
              var c = this.o.v,
                d = c % 1,
                f = c > 0 ? Math.floor(c) : Math.ceil(c),
                m = this.pMatrix.props,
                g = this.rMatrix.props,
                y = this.sMatrix.props
              this.pMatrix.reset(),
                this.rMatrix.reset(),
                this.sMatrix.reset(),
                this.tMatrix.reset(),
                this.matrix.reset()
              var v,
                _,
                x = 0
              if (c > 0) {
                for (; x < f; )
                  this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1),
                    (x += 1)
                d &&
                  (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, d, !1),
                  (x += d))
              } else if (c < 0) {
                for (; x > f; )
                  this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0),
                    (x -= 1)
                d &&
                  (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -d, !0),
                  (x -= d))
              }
              for (
                r = 1 === this.data.m ? 0 : this._currentCopies - 1,
                  n = 1 === this.data.m ? 1 : -1,
                  a = this._currentCopies;
                a;

              ) {
                if (
                  ((_ = (i = (t = this.elemsData[r].it)[t.length - 1].transform.mProps.v.props)
                    .length),
                  (t[t.length - 1].transform.mProps._mdf = !0),
                  (t[t.length - 1].transform.op._mdf = !0),
                  (t[t.length - 1].transform.op.v =
                    1 === this._currentCopies
                      ? this.so.v
                      : this.so.v + (this.eo.v - this.so.v) * (r / (this._currentCopies - 1))),
                  0 !== x)
                ) {
                  for (
                    ((0 !== r && 1 === n) || (r !== this._currentCopies - 1 && -1 === n)) &&
                      this.applyTransforms(
                        this.pMatrix,
                        this.rMatrix,
                        this.sMatrix,
                        this.tr,
                        1,
                        !1
                      ),
                      this.matrix.transform(
                        g[0],
                        g[1],
                        g[2],
                        g[3],
                        g[4],
                        g[5],
                        g[6],
                        g[7],
                        g[8],
                        g[9],
                        g[10],
                        g[11],
                        g[12],
                        g[13],
                        g[14],
                        g[15]
                      ),
                      this.matrix.transform(
                        y[0],
                        y[1],
                        y[2],
                        y[3],
                        y[4],
                        y[5],
                        y[6],
                        y[7],
                        y[8],
                        y[9],
                        y[10],
                        y[11],
                        y[12],
                        y[13],
                        y[14],
                        y[15]
                      ),
                      this.matrix.transform(
                        m[0],
                        m[1],
                        m[2],
                        m[3],
                        m[4],
                        m[5],
                        m[6],
                        m[7],
                        m[8],
                        m[9],
                        m[10],
                        m[11],
                        m[12],
                        m[13],
                        m[14],
                        m[15]
                      ),
                      v = 0;
                    v < _;
                    v += 1
                  )
                    i[v] = this.matrix.props[v]
                  this.matrix.reset()
                } else for (this.matrix.reset(), v = 0; v < _; v += 1) i[v] = this.matrix.props[v]
                ;(x += 1), (a -= 1), (r += n)
              }
            } else
              for (a = this._currentCopies, r = 0, n = 1; a; )
                (i = (t = this.elemsData[r].it)[t.length - 1].transform.mProps.v.props),
                  (t[t.length - 1].transform.mProps._mdf = !1),
                  (t[t.length - 1].transform.op._mdf = !1),
                  (a -= 1),
                  (r += n)
            return o
          }),
          (RepeaterModifier.prototype.addShape = function () {}),
          ShapeModifiers.registerModifier('rp', RepeaterModifier),
          (ShapeCollection.prototype.addShape = function (e) {
            this._length === this._maxLength &&
              ((this.shapes = this.shapes.concat(createSizedArray(this._maxLength))),
              (this._maxLength *= 2)),
              (this.shapes[this._length] = e),
              (this._length += 1)
          }),
          (ShapeCollection.prototype.releaseShapes = function () {
            var e
            for (e = 0; e < this._length; e += 1) shapePool.release(this.shapes[e])
            this._length = 0
          }),
          (DashProperty.prototype.getValue = function (e) {
            if (
              (this.elem.globalData.frameId !== this.frameId || e) &&
              ((this.frameId = this.elem.globalData.frameId),
              this.iterateDynamicProperties(),
              (this._mdf = this._mdf || e),
              this._mdf)
            ) {
              var t = 0,
                i = this.dataProps.length
              for ('svg' === this.renderer && (this.dashStr = ''), t = 0; t < i; t += 1)
                'o' !== this.dataProps[t].n
                  ? 'svg' === this.renderer
                    ? (this.dashStr += ' ' + this.dataProps[t].p.v)
                    : (this.dashArray[t] = this.dataProps[t].p.v)
                  : (this.dashoffset[0] = this.dataProps[t].p.v)
            }
          }),
          extendPrototype([DynamicPropertyContainer], DashProperty),
          (GradientProperty.prototype.comparePoints = function (e, t) {
            for (var i = 0, r = this.o.length / 2; i < r; ) {
              if (Math.abs(e[4 * i] - e[4 * t + 2 * i]) > 0.01) return !1
              i += 1
            }
            return !0
          }),
          (GradientProperty.prototype.checkCollapsable = function () {
            if (this.o.length / 2 != this.c.length / 4) return !1
            if (this.data.k.k[0].s)
              for (var e = 0, t = this.data.k.k.length; e < t; ) {
                if (!this.comparePoints(this.data.k.k[e].s, this.data.p)) return !1
                e += 1
              }
            else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1
            return !0
          }),
          (GradientProperty.prototype.getValue = function (e) {
            if (
              (this.prop.getValue(),
              (this._mdf = !1),
              (this._cmdf = !1),
              (this._omdf = !1),
              this.prop._mdf || e)
            ) {
              var t,
                i,
                r,
                n = 4 * this.data.p
              for (t = 0; t < n; t += 1)
                (i = t % 4 == 0 ? 100 : 255),
                  (r = Math.round(this.prop.v[t] * i)),
                  this.c[t] !== r && ((this.c[t] = r), (this._cmdf = !e))
              if (this.o.length)
                for (n = this.prop.v.length, t = 4 * this.data.p; t < n; t += 1)
                  (i = t % 2 == 0 ? 100 : 1),
                    (r = t % 2 == 0 ? Math.round(100 * this.prop.v[t]) : this.prop.v[t]),
                    this.o[t - 4 * this.data.p] !== r &&
                      ((this.o[t - 4 * this.data.p] = r), (this._omdf = !e))
              this._mdf = !e
            }
          }),
          extendPrototype([DynamicPropertyContainer], GradientProperty)
        var buildShapeString = function (e, t, i, r) {
            if (0 === t) return ''
            var n,
              a = e.o,
              o = e.i,
              s = e.v,
              l = ' M' + r.applyToPointStringified(s[0][0], s[0][1])
            for (n = 1; n < t; n += 1)
              l +=
                ' C' +
                r.applyToPointStringified(a[n - 1][0], a[n - 1][1]) +
                ' ' +
                r.applyToPointStringified(o[n][0], o[n][1]) +
                ' ' +
                r.applyToPointStringified(s[n][0], s[n][1])
            return (
              i &&
                t &&
                ((l +=
                  ' C' +
                  r.applyToPointStringified(a[n - 1][0], a[n - 1][1]) +
                  ' ' +
                  r.applyToPointStringified(o[0][0], o[0][1]) +
                  ' ' +
                  r.applyToPointStringified(s[0][0], s[0][1])),
                (l += 'z')),
              l
            )
          },
          audioControllerFactory = (function () {
            function e(e) {
              ;(this.audios = []), (this.audioFactory = e), (this._volume = 1), (this._isMuted = !1)
            }
            return (
              (e.prototype = {
                addAudio: function (e) {
                  this.audios.push(e)
                },
                pause: function () {
                  var e,
                    t = this.audios.length
                  for (e = 0; e < t; e += 1) this.audios[e].pause()
                },
                resume: function () {
                  var e,
                    t = this.audios.length
                  for (e = 0; e < t; e += 1) this.audios[e].resume()
                },
                setRate: function (e) {
                  var t,
                    i = this.audios.length
                  for (t = 0; t < i; t += 1) this.audios[t].setRate(e)
                },
                createAudio: function (e) {
                  return this.audioFactory
                    ? this.audioFactory(e)
                    : Howl
                    ? new Howl({ src: [e] })
                    : {
                        isPlaying: !1,
                        play: function () {
                          this.isPlaying = !0
                        },
                        seek: function () {
                          this.isPlaying = !1
                        },
                        playing: function () {},
                        rate: function () {},
                        setVolume: function () {}
                      }
                },
                setAudioFactory: function (e) {
                  this.audioFactory = e
                },
                setVolume: function (e) {
                  ;(this._volume = e), this._updateVolume()
                },
                mute: function () {
                  ;(this._isMuted = !0), this._updateVolume()
                },
                unmute: function () {
                  ;(this._isMuted = !1), this._updateVolume()
                },
                getVolume: function () {
                  return this._volume
                },
                _updateVolume: function () {
                  var e,
                    t = this.audios.length
                  for (e = 0; e < t; e += 1)
                    this.audios[e].volume(this._volume * (this._isMuted ? 0 : 1))
                }
              }),
              function () {
                return new e()
              }
            )
          })(),
          ImagePreloader = (function () {
            var e = (function () {
              var e = createTag('canvas')
              ;(e.width = 1), (e.height = 1)
              var t = e.getContext('2d')
              return (t.fillStyle = 'rgba(0,0,0,0)'), t.fillRect(0, 0, 1, 1), e
            })()
            function t() {
              ;(this.loadedAssets += 1),
                this.loadedAssets === this.totalImages &&
                  this.loadedFootagesCount === this.totalFootages &&
                  this.imagesLoadedCb &&
                  this.imagesLoadedCb(null)
            }
            function i() {
              ;(this.loadedFootagesCount += 1),
                this.loadedAssets === this.totalImages &&
                  this.loadedFootagesCount === this.totalFootages &&
                  this.imagesLoadedCb &&
                  this.imagesLoadedCb(null)
            }
            function r(e, t, i) {
              var r = ''
              if (e.e) r = e.p
              else if (t) {
                var n = e.p
                ;-1 !== n.indexOf('images/') && (n = n.split('/')[1]), (r = t + n)
              } else (r = i), (r += e.u ? e.u : ''), (r += e.p)
              return r
            }
            function n(e) {
              var t = 0,
                i = setInterval(
                  function () {
                    ;(e.getBBox().width || t > 500) && (this._imageLoaded(), clearInterval(i)),
                      (t += 1)
                  }.bind(this),
                  50
                )
            }
            function a(e) {
              var t = { assetData: e },
                i = r(e, this.assetsPath, this.path)
              return (
                assetLoader.load(
                  i,
                  function (e) {
                    ;(t.img = e), this._footageLoaded()
                  }.bind(this),
                  function () {
                    ;(t.img = {}), this._footageLoaded()
                  }.bind(this)
                ),
                t
              )
            }
            function o() {
              ;(this._imageLoaded = t.bind(this)),
                (this._footageLoaded = i.bind(this)),
                (this.testImageLoaded = n.bind(this)),
                (this.createFootageData = a.bind(this)),
                (this.assetsPath = ''),
                (this.path = ''),
                (this.totalImages = 0),
                (this.totalFootages = 0),
                (this.loadedAssets = 0),
                (this.loadedFootagesCount = 0),
                (this.imagesLoadedCb = null),
                (this.images = [])
            }
            return (
              (o.prototype = {
                loadAssets: function (e, t) {
                  var i
                  this.imagesLoadedCb = t
                  var r = e.length
                  for (i = 0; i < r; i += 1)
                    e[i].layers ||
                      (e[i].t
                        ? 3 === e[i].t &&
                          ((this.totalFootages += 1),
                          this.images.push(this.createFootageData(e[i])))
                        : ((this.totalImages += 1), this.images.push(this._createImageData(e[i]))))
                },
                setAssetsPath: function (e) {
                  this.assetsPath = e || ''
                },
                setPath: function (e) {
                  this.path = e || ''
                },
                loadedImages: function () {
                  return this.totalImages === this.loadedAssets
                },
                loadedFootages: function () {
                  return this.totalFootages === this.loadedFootagesCount
                },
                destroy: function () {
                  ;(this.imagesLoadedCb = null), (this.images.length = 0)
                },
                getAsset: function (e) {
                  for (var t = 0, i = this.images.length; t < i; ) {
                    if (this.images[t].assetData === e) return this.images[t].img
                    t += 1
                  }
                  return null
                },
                createImgData: function (t) {
                  var i = r(t, this.assetsPath, this.path),
                    n = createTag('img')
                  ;(n.crossOrigin = 'anonymous'),
                    n.addEventListener('load', this._imageLoaded, !1),
                    n.addEventListener(
                      'error',
                      function () {
                        ;(a.img = e), this._imageLoaded()
                      }.bind(this),
                      !1
                    ),
                    (n.src = i)
                  var a = { img: n, assetData: t }
                  return a
                },
                createImageData: function (t) {
                  var i = r(t, this.assetsPath, this.path),
                    n = createNS('image')
                  isSafari
                    ? this.testImageLoaded(n)
                    : n.addEventListener('load', this._imageLoaded, !1),
                    n.addEventListener(
                      'error',
                      function () {
                        ;(a.img = e), this._imageLoaded()
                      }.bind(this),
                      !1
                    ),
                    n.setAttributeNS('http://www.w3.org/1999/xlink', 'href', i),
                    this._elementHelper.append
                      ? this._elementHelper.append(n)
                      : this._elementHelper.appendChild(n)
                  var a = { img: n, assetData: t }
                  return a
                },
                imageLoaded: t,
                footageLoaded: i,
                setCacheType: function (e, t) {
                  'svg' === e
                    ? ((this._elementHelper = t),
                      (this._createImageData = this.createImageData.bind(this)))
                    : (this._createImageData = this.createImgData.bind(this))
                }
              }),
              o
            )
          })(),
          featureSupport = (function () {
            var e = { maskType: !0 }
            return (
              (/MSIE 10/i.test(navigator.userAgent) ||
                /MSIE 9/i.test(navigator.userAgent) ||
                /rv:11.0/i.test(navigator.userAgent) ||
                /Edge\/\d./i.test(navigator.userAgent)) &&
                (e.maskType = !1),
              e
            )
          })(),
          filtersFactory = (function () {
            var e = {
              createFilter: function (e, t) {
                var i = createNS('filter')
                return (
                  i.setAttribute('id', e),
                  !0 !== t &&
                    (i.setAttribute('filterUnits', 'objectBoundingBox'),
                    i.setAttribute('x', '0%'),
                    i.setAttribute('y', '0%'),
                    i.setAttribute('width', '100%'),
                    i.setAttribute('height', '100%')),
                  i
                )
              },
              createAlphaToLuminanceFilter: function () {
                var e = createNS('feColorMatrix')
                return (
                  e.setAttribute('type', 'matrix'),
                  e.setAttribute('color-interpolation-filters', 'sRGB'),
                  e.setAttribute('values', '0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1'),
                  e
                )
              }
            }
            return e
          })(),
          assetLoader = (function () {
            function e(e) {
              return e.response && 'object' == typeof e.response
                ? e.response
                : e.response && 'string' == typeof e.response
                ? JSON.parse(e.response)
                : e.responseText
                ? JSON.parse(e.responseText)
                : null
            }
            return {
              load: function (t, i, r) {
                var n,
                  a = new XMLHttpRequest()
                try {
                  a.responseType = 'json'
                } catch (o) {}
                ;(a.onreadystatechange = function () {
                  if (4 === a.readyState)
                    if (200 === a.status) (n = e(a)), i(n)
                    else
                      try {
                        ;(n = e(a)), i(n)
                      } catch (o) {
                        r && r(o)
                      }
                }),
                  a.open('GET', t, !0),
                  a.send()
              }
            }
          })()
        function TextAnimatorProperty(e, t, i) {
          ;(this._isFirstFrame = !0),
            (this._hasMaskedPath = !1),
            (this._frameId = -1),
            (this._textData = e),
            (this._renderType = t),
            (this._elem = i),
            (this._animatorsData = createSizedArray(this._textData.a.length)),
            (this._pathData = {}),
            (this._moreOptions = { alignment: {} }),
            (this.renderedLetters = []),
            (this.lettersChangedFlag = !1),
            this.initDynamicPropertyContainer(i)
        }
        function TextAnimatorDataProperty(e, t, i) {
          var r = { propType: !1 },
            n = PropertyFactory.getProp,
            a = t.a
          ;(this.a = {
            r: a.r ? n(e, a.r, 0, degToRads, i) : r,
            rx: a.rx ? n(e, a.rx, 0, degToRads, i) : r,
            ry: a.ry ? n(e, a.ry, 0, degToRads, i) : r,
            sk: a.sk ? n(e, a.sk, 0, degToRads, i) : r,
            sa: a.sa ? n(e, a.sa, 0, degToRads, i) : r,
            s: a.s ? n(e, a.s, 1, 0.01, i) : r,
            a: a.a ? n(e, a.a, 1, 0, i) : r,
            o: a.o ? n(e, a.o, 0, 0.01, i) : r,
            p: a.p ? n(e, a.p, 1, 0, i) : r,
            sw: a.sw ? n(e, a.sw, 0, 0, i) : r,
            sc: a.sc ? n(e, a.sc, 1, 0, i) : r,
            fc: a.fc ? n(e, a.fc, 1, 0, i) : r,
            fh: a.fh ? n(e, a.fh, 0, 0, i) : r,
            fs: a.fs ? n(e, a.fs, 0, 0.01, i) : r,
            fb: a.fb ? n(e, a.fb, 0, 0.01, i) : r,
            t: a.t ? n(e, a.t, 0, 0, i) : r
          }),
            (this.s = TextSelectorProp.getTextSelectorProp(e, t.s, i)),
            (this.s.t = t.s.t)
        }
        function LetterProps(e, t, i, r, n, a) {
          ;(this.o = e),
            (this.sw = t),
            (this.sc = i),
            (this.fc = r),
            (this.m = n),
            (this.p = a),
            (this._mdf = { o: !0, sw: !!t, sc: !!i, fc: !!r, m: !0, p: !0 })
        }
        function TextProperty(e, t) {
          ;(this._frameId = initialDefaultFrame),
            (this.pv = ''),
            (this.v = ''),
            (this.kf = !1),
            (this._isFirstFrame = !0),
            (this._mdf = !1),
            (this.data = t),
            (this.elem = e),
            (this.comp = this.elem.comp),
            (this.keysIndex = 0),
            (this.canResize = !1),
            (this.minimumFontSize = 1),
            (this.effectsSequence = []),
            (this.currentData = {
              ascent: 0,
              boxWidth: this.defaultBoxWidth,
              f: '',
              fStyle: '',
              fWeight: '',
              fc: '',
              j: '',
              justifyOffset: '',
              l: [],
              lh: 0,
              lineWidths: [],
              ls: '',
              of: '',
              s: '',
              sc: '',
              sw: 0,
              t: 0,
              tr: 0,
              sz: 0,
              ps: null,
              fillColorAnim: !1,
              strokeColorAnim: !1,
              strokeWidthAnim: !1,
              yOffset: 0,
              finalSize: 0,
              finalText: [],
              finalLineHeight: 0,
              __complete: !1
            }),
            this.copyData(this.currentData, this.data.d.k[0].s),
            this.searchProperty() || this.completeTextData(this.currentData)
        }
        ;(TextAnimatorProperty.prototype.searchProperties = function () {
          var e,
            t,
            i = this._textData.a.length,
            r = PropertyFactory.getProp
          for (e = 0; e < i; e += 1)
            (t = this._textData.a[e]),
              (this._animatorsData[e] = new TextAnimatorDataProperty(this._elem, t, this))
          this._textData.p && 'm' in this._textData.p
            ? ((this._pathData = {
                f: r(this._elem, this._textData.p.f, 0, 0, this),
                l: r(this._elem, this._textData.p.l, 0, 0, this),
                r: this._textData.p.r,
                m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
              }),
              (this._hasMaskedPath = !0))
            : (this._hasMaskedPath = !1),
            (this._moreOptions.alignment = r(this._elem, this._textData.m.a, 1, 0, this))
        }),
          (TextAnimatorProperty.prototype.getMeasures = function (e, t) {
            if (
              ((this.lettersChangedFlag = t),
              this._mdf ||
                this._isFirstFrame ||
                t ||
                (this._hasMaskedPath && this._pathData.m._mdf))
            ) {
              this._isFirstFrame = !1
              var i,
                r,
                n,
                a,
                o,
                s,
                l,
                h,
                u,
                p,
                c,
                d,
                f,
                m,
                g,
                y,
                v,
                _,
                x,
                S = this._moreOptions.alignment.v,
                b = this._animatorsData,
                T = this._textData,
                A = this.mHelper,
                w = this._renderType,
                M = this.renderedLetters.length,
                C = e.l
              if (this._hasMaskedPath) {
                if (((x = this._pathData.m), !this._pathData.n || this._pathData._mdf)) {
                  var P,
                    E = x.v
                  for (
                    this._pathData.r && (E = E.reverse()),
                      o = { tLength: 0, segments: [] },
                      a = E._length - 1,
                      y = 0,
                      n = 0;
                    n < a;
                    n += 1
                  )
                    (P = bez.buildBezierData(
                      E.v[n],
                      E.v[n + 1],
                      [E.o[n][0] - E.v[n][0], E.o[n][1] - E.v[n][1]],
                      [E.i[n + 1][0] - E.v[n + 1][0], E.i[n + 1][1] - E.v[n + 1][1]]
                    )),
                      (o.tLength += P.segmentLength),
                      o.segments.push(P),
                      (y += P.segmentLength)
                  ;(n = a),
                    x.v.c &&
                      ((P = bez.buildBezierData(
                        E.v[n],
                        E.v[0],
                        [E.o[n][0] - E.v[n][0], E.o[n][1] - E.v[n][1]],
                        [E.i[0][0] - E.v[0][0], E.i[0][1] - E.v[0][1]]
                      )),
                      (o.tLength += P.segmentLength),
                      o.segments.push(P),
                      (y += P.segmentLength)),
                    (this._pathData.pi = o)
                }
                if (
                  ((o = this._pathData.pi),
                  (s = this._pathData.f.v),
                  (c = 0),
                  (p = 1),
                  (h = 0),
                  (u = !0),
                  (m = o.segments),
                  s < 0 && x.v.c)
                )
                  for (
                    o.tLength < Math.abs(s) && (s = -Math.abs(s) % o.tLength),
                      p = (f = m[(c = m.length - 1)].points).length - 1;
                    s < 0;

                  )
                    (s += f[p].partialLength),
                      (p -= 1) < 0 && (p = (f = m[(c -= 1)].points).length - 1)
                ;(d = (f = m[c].points)[p - 1]), (g = (l = f[p]).partialLength)
              }
              ;(a = C.length), (i = 0), (r = 0)
              var I,
                D,
                L,
                R,
                O,
                k = 1.2 * e.finalSize * 0.714,
                $ = !0
              L = b.length
              var N,
                F,
                B,
                V,
                z,
                G,
                H,
                U,
                Y,
                W,
                j,
                Z,
                X = -1,
                q = s,
                K = c,
                J = p,
                Q = -1,
                ee = '',
                te = this.defaultPropsArray
              if (2 === e.j || 1 === e.j) {
                var ie = 0,
                  re = 0,
                  ne = 2 === e.j ? -0.5 : -1,
                  ae = 0,
                  oe = !0
                for (n = 0; n < a; n += 1)
                  if (C[n].n) {
                    for (ie && (ie += re); ae < n; ) (C[ae].animatorJustifyOffset = ie), (ae += 1)
                    ;(ie = 0), (oe = !0)
                  } else {
                    for (D = 0; D < L; D += 1)
                      (I = b[D].a).t.propType &&
                        (oe && 2 === e.j && (re += I.t.v * ne),
                        (O = b[D].s.getMult(C[n].anIndexes[D], T.a[D].s.totalChars)).length
                          ? (ie += I.t.v * O[0] * ne)
                          : (ie += I.t.v * O * ne))
                    oe = !1
                  }
                for (ie && (ie += re); ae < n; ) (C[ae].animatorJustifyOffset = ie), (ae += 1)
              }
              for (n = 0; n < a; n += 1) {
                if ((A.reset(), (V = 1), C[n].n))
                  (i = 0),
                    (r += e.yOffset),
                    (r += $ ? 1 : 0),
                    (s = q),
                    ($ = !1),
                    this._hasMaskedPath &&
                      ((p = J),
                      (d = (f = m[(c = K)].points)[p - 1]),
                      (g = (l = f[p]).partialLength),
                      (h = 0)),
                    (ee = ''),
                    (j = ''),
                    (Y = ''),
                    (Z = ''),
                    (te = this.defaultPropsArray)
                else {
                  if (this._hasMaskedPath) {
                    if (Q !== C[n].line) {
                      switch (e.j) {
                        case 1:
                          s += y - e.lineWidths[C[n].line]
                          break
                        case 2:
                          s += (y - e.lineWidths[C[n].line]) / 2
                      }
                      Q = C[n].line
                    }
                    X !== C[n].ind &&
                      (C[X] && (s += C[X].extra), (s += C[n].an / 2), (X = C[n].ind)),
                      (s += S[0] * C[n].an * 0.005)
                    var se = 0
                    for (D = 0; D < L; D += 1)
                      (I = b[D].a).p.propType &&
                        ((O = b[D].s.getMult(C[n].anIndexes[D], T.a[D].s.totalChars)).length
                          ? (se += I.p.v[0] * O[0])
                          : (se += I.p.v[0] * O)),
                        I.a.propType &&
                          ((O = b[D].s.getMult(C[n].anIndexes[D], T.a[D].s.totalChars)).length
                            ? (se += I.a.v[0] * O[0])
                            : (se += I.a.v[0] * O))
                    for (u = !0; u; )
                      h + g >= s + se || !f
                        ? ((v = (s + se - h) / l.partialLength),
                          (F = d.point[0] + (l.point[0] - d.point[0]) * v),
                          (B = d.point[1] + (l.point[1] - d.point[1]) * v),
                          A.translate(-S[0] * C[n].an * 0.005, -S[1] * k * 0.01),
                          (u = !1))
                        : f &&
                          ((h += l.partialLength),
                          (p += 1) >= f.length &&
                            ((p = 0),
                            m[(c += 1)]
                              ? (f = m[c].points)
                              : x.v.c
                              ? ((p = 0), (f = m[(c = 0)].points))
                              : ((h -= l.partialLength), (f = null))),
                          f && ((d = l), (g = (l = f[p]).partialLength)))
                    ;(N = C[n].an / 2 - C[n].add), A.translate(-N, 0, 0)
                  } else
                    (N = C[n].an / 2 - C[n].add),
                      A.translate(-N, 0, 0),
                      A.translate(-S[0] * C[n].an * 0.005, -S[1] * k * 0.01, 0)
                  for (D = 0; D < L; D += 1)
                    (I = b[D].a).t.propType &&
                      ((O = b[D].s.getMult(C[n].anIndexes[D], T.a[D].s.totalChars)),
                      (0 === i && 0 === e.j) ||
                        (this._hasMaskedPath
                          ? O.length
                            ? (s += I.t.v * O[0])
                            : (s += I.t.v * O)
                          : O.length
                          ? (i += I.t.v * O[0])
                          : (i += I.t.v * O)))
                  for (
                    e.strokeWidthAnim && (G = e.sw || 0),
                      e.strokeColorAnim && (z = e.sc ? [e.sc[0], e.sc[1], e.sc[2]] : [0, 0, 0]),
                      e.fillColorAnim && e.fc && (H = [e.fc[0], e.fc[1], e.fc[2]]),
                      D = 0;
                    D < L;
                    D += 1
                  )
                    (I = b[D].a).a.propType &&
                      ((O = b[D].s.getMult(C[n].anIndexes[D], T.a[D].s.totalChars)).length
                        ? A.translate(-I.a.v[0] * O[0], -I.a.v[1] * O[1], I.a.v[2] * O[2])
                        : A.translate(-I.a.v[0] * O, -I.a.v[1] * O, I.a.v[2] * O))
                  for (D = 0; D < L; D += 1)
                    (I = b[D].a).s.propType &&
                      ((O = b[D].s.getMult(C[n].anIndexes[D], T.a[D].s.totalChars)).length
                        ? A.scale(1 + (I.s.v[0] - 1) * O[0], 1 + (I.s.v[1] - 1) * O[1], 1)
                        : A.scale(1 + (I.s.v[0] - 1) * O, 1 + (I.s.v[1] - 1) * O, 1))
                  for (D = 0; D < L; D += 1) {
                    if (
                      ((I = b[D].a),
                      (O = b[D].s.getMult(C[n].anIndexes[D], T.a[D].s.totalChars)),
                      I.sk.propType &&
                        (O.length
                          ? A.skewFromAxis(-I.sk.v * O[0], I.sa.v * O[1])
                          : A.skewFromAxis(-I.sk.v * O, I.sa.v * O)),
                      I.r.propType && (O.length ? A.rotateZ(-I.r.v * O[2]) : A.rotateZ(-I.r.v * O)),
                      I.ry.propType &&
                        (O.length ? A.rotateY(I.ry.v * O[1]) : A.rotateY(I.ry.v * O)),
                      I.rx.propType &&
                        (O.length ? A.rotateX(I.rx.v * O[0]) : A.rotateX(I.rx.v * O)),
                      I.o.propType &&
                        (O.length ? (V += (I.o.v * O[0] - V) * O[0]) : (V += (I.o.v * O - V) * O)),
                      e.strokeWidthAnim &&
                        I.sw.propType &&
                        (O.length ? (G += I.sw.v * O[0]) : (G += I.sw.v * O)),
                      e.strokeColorAnim && I.sc.propType)
                    )
                      for (U = 0; U < 3; U += 1)
                        O.length
                          ? (z[U] += (I.sc.v[U] - z[U]) * O[0])
                          : (z[U] += (I.sc.v[U] - z[U]) * O)
                    if (e.fillColorAnim && e.fc) {
                      if (I.fc.propType)
                        for (U = 0; U < 3; U += 1)
                          O.length
                            ? (H[U] += (I.fc.v[U] - H[U]) * O[0])
                            : (H[U] += (I.fc.v[U] - H[U]) * O)
                      I.fh.propType &&
                        (H = O.length ? addHueToRGB(H, I.fh.v * O[0]) : addHueToRGB(H, I.fh.v * O)),
                        I.fs.propType &&
                          (H = O.length
                            ? addSaturationToRGB(H, I.fs.v * O[0])
                            : addSaturationToRGB(H, I.fs.v * O)),
                        I.fb.propType &&
                          (H = O.length
                            ? addBrightnessToRGB(H, I.fb.v * O[0])
                            : addBrightnessToRGB(H, I.fb.v * O))
                    }
                  }
                  for (D = 0; D < L; D += 1)
                    (I = b[D].a).p.propType &&
                      ((O = b[D].s.getMult(C[n].anIndexes[D], T.a[D].s.totalChars)),
                      this._hasMaskedPath
                        ? O.length
                          ? A.translate(0, I.p.v[1] * O[0], -I.p.v[2] * O[1])
                          : A.translate(0, I.p.v[1] * O, -I.p.v[2] * O)
                        : O.length
                        ? A.translate(I.p.v[0] * O[0], I.p.v[1] * O[1], -I.p.v[2] * O[2])
                        : A.translate(I.p.v[0] * O, I.p.v[1] * O, -I.p.v[2] * O))
                  if (
                    (e.strokeWidthAnim && (Y = G < 0 ? 0 : G),
                    e.strokeColorAnim &&
                      (W =
                        'rgb(' +
                        Math.round(255 * z[0]) +
                        ',' +
                        Math.round(255 * z[1]) +
                        ',' +
                        Math.round(255 * z[2]) +
                        ')'),
                    e.fillColorAnim &&
                      e.fc &&
                      (j =
                        'rgb(' +
                        Math.round(255 * H[0]) +
                        ',' +
                        Math.round(255 * H[1]) +
                        ',' +
                        Math.round(255 * H[2]) +
                        ')'),
                    this._hasMaskedPath)
                  ) {
                    if ((A.translate(0, -e.ls), A.translate(0, S[1] * k * 0.01 + r, 0), T.p.p)) {
                      _ = (l.point[1] - d.point[1]) / (l.point[0] - d.point[0])
                      var le = (180 * Math.atan(_)) / Math.PI
                      l.point[0] < d.point[0] && (le += 180), A.rotate((-le * Math.PI) / 180)
                    }
                    A.translate(F, B, 0),
                      (s -= S[0] * C[n].an * 0.005),
                      C[n + 1] &&
                        X !== C[n + 1].ind &&
                        ((s += C[n].an / 2), (s += 0.001 * e.tr * e.finalSize))
                  } else {
                    switch (
                      (A.translate(i, r, 0),
                      e.ps && A.translate(e.ps[0], e.ps[1] + e.ascent, 0),
                      e.j)
                    ) {
                      case 1:
                        A.translate(
                          C[n].animatorJustifyOffset +
                            e.justifyOffset +
                            (e.boxWidth - e.lineWidths[C[n].line]),
                          0,
                          0
                        )
                        break
                      case 2:
                        A.translate(
                          C[n].animatorJustifyOffset +
                            e.justifyOffset +
                            (e.boxWidth - e.lineWidths[C[n].line]) / 2,
                          0,
                          0
                        )
                    }
                    A.translate(0, -e.ls),
                      A.translate(N, 0, 0),
                      A.translate(S[0] * C[n].an * 0.005, S[1] * k * 0.01, 0),
                      (i += C[n].l + 0.001 * e.tr * e.finalSize)
                  }
                  'html' === w
                    ? (ee = A.toCSS())
                    : 'svg' === w
                    ? (ee = A.to2dCSS())
                    : (te = [
                        A.props[0],
                        A.props[1],
                        A.props[2],
                        A.props[3],
                        A.props[4],
                        A.props[5],
                        A.props[6],
                        A.props[7],
                        A.props[8],
                        A.props[9],
                        A.props[10],
                        A.props[11],
                        A.props[12],
                        A.props[13],
                        A.props[14],
                        A.props[15]
                      ]),
                    (Z = V)
                }
                M <= n
                  ? ((R = new LetterProps(Z, Y, W, j, ee, te)),
                    this.renderedLetters.push(R),
                    (M += 1),
                    (this.lettersChangedFlag = !0))
                  : ((R = this.renderedLetters[n]),
                    (this.lettersChangedFlag =
                      R.update(Z, Y, W, j, ee, te) || this.lettersChangedFlag))
              }
            }
          }),
          (TextAnimatorProperty.prototype.getValue = function () {
            this._elem.globalData.frameId !== this._frameId &&
              ((this._frameId = this._elem.globalData.frameId), this.iterateDynamicProperties())
          }),
          (TextAnimatorProperty.prototype.mHelper = new Matrix()),
          (TextAnimatorProperty.prototype.defaultPropsArray = []),
          extendPrototype([DynamicPropertyContainer], TextAnimatorProperty),
          (LetterProps.prototype.update = function (e, t, i, r, n, a) {
            ;(this._mdf.o = !1),
              (this._mdf.sw = !1),
              (this._mdf.sc = !1),
              (this._mdf.fc = !1),
              (this._mdf.m = !1),
              (this._mdf.p = !1)
            var o = !1
            return (
              this.o !== e && ((this.o = e), (this._mdf.o = !0), (o = !0)),
              this.sw !== t && ((this.sw = t), (this._mdf.sw = !0), (o = !0)),
              this.sc !== i && ((this.sc = i), (this._mdf.sc = !0), (o = !0)),
              this.fc !== r && ((this.fc = r), (this._mdf.fc = !0), (o = !0)),
              this.m !== n && ((this.m = n), (this._mdf.m = !0), (o = !0)),
              !a.length ||
                (this.p[0] === a[0] &&
                  this.p[1] === a[1] &&
                  this.p[4] === a[4] &&
                  this.p[5] === a[5] &&
                  this.p[12] === a[12] &&
                  this.p[13] === a[13]) ||
                ((this.p = a), (this._mdf.p = !0), (o = !0)),
              o
            )
          }),
          (TextProperty.prototype.defaultBoxWidth = [0, 0]),
          (TextProperty.prototype.copyData = function (e, t) {
            for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i])
            return e
          }),
          (TextProperty.prototype.setCurrentData = function (e) {
            e.__complete || this.completeTextData(e),
              (this.currentData = e),
              (this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth),
              (this._mdf = !0)
          }),
          (TextProperty.prototype.searchProperty = function () {
            return this.searchKeyframes()
          }),
          (TextProperty.prototype.searchKeyframes = function () {
            return (
              (this.kf = this.data.d.k.length > 1),
              this.kf && this.addEffect(this.getKeyframeValue.bind(this)),
              this.kf
            )
          }),
          (TextProperty.prototype.addEffect = function (e) {
            this.effectsSequence.push(e), this.elem.addDynamicProperty(this)
          }),
          (TextProperty.prototype.getValue = function (e) {
            if (
              (this.elem.globalData.frameId !== this.frameId && this.effectsSequence.length) ||
              e
            ) {
              this.currentData.t = this.data.d.k[this.keysIndex].s.t
              var t = this.currentData,
                i = this.keysIndex
              if (this.lock) this.setCurrentData(this.currentData)
              else {
                var r
                ;(this.lock = !0), (this._mdf = !1)
                var n = this.effectsSequence.length,
                  a = e || this.data.d.k[this.keysIndex].s
                for (r = 0; r < n; r += 1)
                  a =
                    i !== this.keysIndex
                      ? this.effectsSequence[r](a, a.t)
                      : this.effectsSequence[r](this.currentData, a.t)
                t !== a && this.setCurrentData(a),
                  (this.v = this.currentData),
                  (this.pv = this.v),
                  (this.lock = !1),
                  (this.frameId = this.elem.globalData.frameId)
              }
            }
          }),
          (TextProperty.prototype.getKeyframeValue = function () {
            for (
              var e = this.data.d.k, t = this.elem.comp.renderedFrame, i = 0, r = e.length;
              i <= r - 1 && !(i === r - 1 || e[i + 1].t > t);

            )
              i += 1
            return this.keysIndex !== i && (this.keysIndex = i), this.data.d.k[this.keysIndex].s
          }),
          (TextProperty.prototype.buildFinalText = function (e) {
            for (
              var t, i = FontManager.getCombinedCharacterCodes(), r = [], n = 0, a = e.length;
              n < a;

            )
              (t = e.charCodeAt(n)),
                -1 !== i.indexOf(t)
                  ? (r[r.length - 1] += e.charAt(n))
                  : t >= 55296 && t <= 56319 && (t = e.charCodeAt(n + 1)) >= 56320 && t <= 57343
                  ? (r.push(e.substr(n, 2)), (n += 1))
                  : r.push(e.charAt(n)),
                (n += 1)
            return r
          }),
          (TextProperty.prototype.completeTextData = function (e) {
            e.__complete = !0
            var t,
              i,
              r,
              n,
              a,
              o,
              s,
              l = this.elem.globalData.fontManager,
              h = this.data,
              u = [],
              p = 0,
              c = h.m.g,
              d = 0,
              f = 0,
              m = 0,
              g = [],
              y = 0,
              v = 0,
              _ = l.getFontByName(e.f),
              x = 0,
              S = getFontProperties(_)
            ;(e.fWeight = S.weight),
              (e.fStyle = S.style),
              (e.finalSize = e.s),
              (e.finalText = this.buildFinalText(e.t)),
              (i = e.finalText.length),
              (e.finalLineHeight = e.lh)
            var b,
              T = (e.tr / 1e3) * e.finalSize
            if (e.sz)
              for (var A, w, M = !0, C = e.sz[0], P = e.sz[1]; M; ) {
                ;(A = 0),
                  (y = 0),
                  (i = (w = this.buildFinalText(e.t)).length),
                  (T = (e.tr / 1e3) * e.finalSize)
                var E = -1
                for (t = 0; t < i; t += 1)
                  (b = w[t].charCodeAt(0)),
                    (r = !1),
                    ' ' === w[t]
                      ? (E = t)
                      : (13 !== b && 3 !== b) ||
                        ((y = 0), (r = !0), (A += e.finalLineHeight || 1.2 * e.finalSize)),
                    l.chars
                      ? ((s = l.getCharData(w[t], _.fStyle, _.fFamily)),
                        (x = r ? 0 : (s.w * e.finalSize) / 100))
                      : (x = l.measureText(w[t], e.f, e.finalSize)),
                    y + x > C && ' ' !== w[t]
                      ? (-1 === E ? (i += 1) : (t = E),
                        (A += e.finalLineHeight || 1.2 * e.finalSize),
                        w.splice(t, E === t ? 1 : 0, '\r'),
                        (E = -1),
                        (y = 0))
                      : ((y += x), (y += T))
                ;(A += (_.ascent * e.finalSize) / 100),
                  this.canResize && e.finalSize > this.minimumFontSize && P < A
                    ? ((e.finalSize -= 1), (e.finalLineHeight = (e.finalSize * e.lh) / e.s))
                    : ((e.finalText = w), (i = e.finalText.length), (M = !1))
              }
            ;(y = -T), (x = 0)
            var I,
              D = 0
            for (t = 0; t < i; t += 1)
              if (
                ((r = !1),
                13 === (b = (I = e.finalText[t]).charCodeAt(0)) || 3 === b
                  ? ((D = 0),
                    g.push(y),
                    (v = y > v ? y : v),
                    (y = -2 * T),
                    (n = ''),
                    (r = !0),
                    (m += 1))
                  : (n = I),
                l.chars
                  ? ((s = l.getCharData(I, _.fStyle, l.getFontByName(e.f).fFamily)),
                    (x = r ? 0 : (s.w * e.finalSize) / 100))
                  : (x = l.measureText(n, e.f, e.finalSize)),
                ' ' === I ? (D += x + T) : ((y += x + T + D), (D = 0)),
                u.push({
                  l: x,
                  an: x,
                  add: d,
                  n: r,
                  anIndexes: [],
                  val: n,
                  line: m,
                  animatorJustifyOffset: 0
                }),
                2 == c)
              ) {
                if (((d += x), '' === n || ' ' === n || t === i - 1)) {
                  for (('' !== n && ' ' !== n) || (d -= x); f <= t; )
                    (u[f].an = d), (u[f].ind = p), (u[f].extra = x), (f += 1)
                  ;(p += 1), (d = 0)
                }
              } else if (3 == c) {
                if (((d += x), '' === n || t === i - 1)) {
                  for ('' === n && (d -= x); f <= t; )
                    (u[f].an = d), (u[f].ind = p), (u[f].extra = x), (f += 1)
                  ;(d = 0), (p += 1)
                }
              } else (u[p].ind = p), (u[p].extra = 0), (p += 1)
            if (((e.l = u), (v = y > v ? y : v), g.push(y), e.sz))
              (e.boxWidth = e.sz[0]), (e.justifyOffset = 0)
            else
              switch (((e.boxWidth = v), e.j)) {
                case 1:
                  e.justifyOffset = -e.boxWidth
                  break
                case 2:
                  e.justifyOffset = -e.boxWidth / 2
                  break
                default:
                  e.justifyOffset = 0
              }
            e.lineWidths = g
            var L,
              R,
              O,
              k,
              $ = h.a
            o = $.length
            var N = []
            for (a = 0; a < o; a += 1) {
              for (
                (L = $[a]).a.sc && (e.strokeColorAnim = !0),
                  L.a.sw && (e.strokeWidthAnim = !0),
                  (L.a.fc || L.a.fh || L.a.fs || L.a.fb) && (e.fillColorAnim = !0),
                  k = 0,
                  O = L.s.b,
                  t = 0;
                t < i;
                t += 1
              )
                ((R = u[t]).anIndexes[a] = k),
                  ((1 == O && '' !== R.val) ||
                    (2 == O && '' !== R.val && ' ' !== R.val) ||
                    (3 == O && (R.n || ' ' == R.val || t == i - 1)) ||
                    (4 == O && (R.n || t == i - 1))) &&
                    (1 === L.s.rn && N.push(k), (k += 1))
              h.a[a].s.totalChars = k
              var F,
                B = -1
              if (1 === L.s.rn)
                for (t = 0; t < i; t += 1)
                  B != (R = u[t]).anIndexes[a] &&
                    ((B = R.anIndexes[a]),
                    (F = N.splice(Math.floor(Math.random() * N.length), 1)[0])),
                    (R.anIndexes[a] = F)
            }
            ;(e.yOffset = e.finalLineHeight || 1.2 * e.finalSize),
              (e.ls = e.ls || 0),
              (e.ascent = (_.ascent * e.finalSize) / 100)
          }),
          (TextProperty.prototype.updateDocumentData = function (e, t) {
            t = void 0 === t ? this.keysIndex : t
            var i = this.copyData({}, this.data.d.k[t].s)
            ;(i = this.copyData(i, e)),
              (this.data.d.k[t].s = i),
              this.recalculate(t),
              this.elem.addDynamicProperty(this)
          }),
          (TextProperty.prototype.recalculate = function (e) {
            var t = this.data.d.k[e].s
            ;(t.__complete = !1), (this.keysIndex = 0), (this._isFirstFrame = !0), this.getValue(t)
          }),
          (TextProperty.prototype.canResizeFont = function (e) {
            ;(this.canResize = e),
              this.recalculate(this.keysIndex),
              this.elem.addDynamicProperty(this)
          }),
          (TextProperty.prototype.setMinimumFontSize = function (e) {
            ;(this.minimumFontSize = Math.floor(e) || 1),
              this.recalculate(this.keysIndex),
              this.elem.addDynamicProperty(this)
          })
        var TextSelectorProp = (function () {
            var e = Math.max,
              t = Math.min,
              i = Math.floor
            function r(e, t) {
              ;(this._currentTextLength = -1),
                (this.k = !1),
                (this.data = t),
                (this.elem = e),
                (this.comp = e.comp),
                (this.finalS = 0),
                (this.finalE = 0),
                this.initDynamicPropertyContainer(e),
                (this.s = PropertyFactory.getProp(e, t.s || { k: 0 }, 0, 0, this)),
                (this.e = 'e' in t ? PropertyFactory.getProp(e, t.e, 0, 0, this) : { v: 100 }),
                (this.o = PropertyFactory.getProp(e, t.o || { k: 0 }, 0, 0, this)),
                (this.xe = PropertyFactory.getProp(e, t.xe || { k: 0 }, 0, 0, this)),
                (this.ne = PropertyFactory.getProp(e, t.ne || { k: 0 }, 0, 0, this)),
                (this.a = PropertyFactory.getProp(e, t.a, 0, 0.01, this)),
                this.dynamicProperties.length || this.getValue()
            }
            return (
              (r.prototype = {
                getMult: function (r) {
                  this._currentTextLength !== this.elem.textProperty.currentData.l.length &&
                    this.getValue()
                  var n = 0,
                    a = 0,
                    o = 1,
                    s = 1
                  this.ne.v > 0 ? (n = this.ne.v / 100) : (a = -this.ne.v / 100),
                    this.xe.v > 0 ? (o = 1 - this.xe.v / 100) : (s = 1 + this.xe.v / 100)
                  var l = BezierFactory.getBezierEasing(n, a, o, s).get,
                    h = 0,
                    u = this.finalS,
                    p = this.finalE,
                    c = this.data.sh
                  if (2 === c)
                    h = l(
                      (h =
                        p === u ? (r >= p ? 1 : 0) : e(0, t(0.5 / (p - u) + (r - u) / (p - u), 1)))
                    )
                  else if (3 === c)
                    h = l(
                      (h =
                        p === u
                          ? r >= p
                            ? 0
                            : 1
                          : 1 - e(0, t(0.5 / (p - u) + (r - u) / (p - u), 1)))
                    )
                  else if (4 === c)
                    p === u
                      ? (h = 0)
                      : (h = e(0, t(0.5 / (p - u) + (r - u) / (p - u), 1))) < 0.5
                      ? (h *= 2)
                      : (h = 1 - 2 * (h - 0.5)),
                      (h = l(h))
                  else if (5 === c) {
                    if (p === u) h = 0
                    else {
                      var d = p - u,
                        f = -d / 2 + (r = t(e(0, r + 0.5 - u), p - u)),
                        m = d / 2
                      h = Math.sqrt(1 - (f * f) / (m * m))
                    }
                    h = l(h)
                  } else
                    6 === c
                      ? (p === u
                          ? (h = 0)
                          : ((r = t(e(0, r + 0.5 - u), p - u)),
                            (h = (1 + Math.cos(Math.PI + (2 * Math.PI * r) / (p - u))) / 2)),
                        (h = l(h)))
                      : (r >= i(u) && (h = e(0, t(r - u < 0 ? t(p, 1) - (u - r) : p - r, 1))),
                        (h = l(h)))
                  return h * this.a.v
                },
                getValue: function (e) {
                  this.iterateDynamicProperties(),
                    (this._mdf = e || this._mdf),
                    (this._currentTextLength = this.elem.textProperty.currentData.l.length || 0),
                    e && 2 === this.data.r && (this.e.v = this._currentTextLength)
                  var t = 2 === this.data.r ? 1 : 100 / this.data.totalChars,
                    i = this.o.v / t,
                    r = this.s.v / t + i,
                    n = this.e.v / t + i
                  if (r > n) {
                    var a = r
                    ;(r = n), (n = a)
                  }
                  ;(this.finalS = r), (this.finalE = n)
                }
              }),
              extendPrototype([DynamicPropertyContainer], r),
              {
                getTextSelectorProp: function (e, t, i) {
                  return new r(e, t, i)
                }
              }
            )
          })(),
          poolFactory = function (e, t, i) {
            var r = 0,
              n = e,
              a = createSizedArray(n)
            return {
              newElement: function () {
                return r ? a[(r -= 1)] : t()
              },
              release: function (e) {
                r === n && ((a = pooling.double(a)), (n *= 2)), i && i(e), (a[r] = e), (r += 1)
              }
            }
          },
          pooling = {
            double: function (e) {
              return e.concat(createSizedArray(e.length))
            }
          },
          pointPool = poolFactory(8, function () {
            return createTypedArray('float32', 2)
          }),
          shapePool =
            ((factory = poolFactory(
              4,
              function () {
                return new ShapePath()
              },
              function (e) {
                var t,
                  i = e._length
                for (t = 0; t < i; t += 1)
                  pointPool.release(e.v[t]),
                    pointPool.release(e.i[t]),
                    pointPool.release(e.o[t]),
                    (e.v[t] = null),
                    (e.i[t] = null),
                    (e.o[t] = null)
                ;(e._length = 0), (e.c = !1)
              }
            )),
            (factory.clone = function (e) {
              var t,
                i = factory.newElement(),
                r = void 0 === e._length ? e.v.length : e._length
              for (i.setLength(r), i.c = e.c, t = 0; t < r; t += 1)
                i.setTripleAt(e.v[t][0], e.v[t][1], e.o[t][0], e.o[t][1], e.i[t][0], e.i[t][1], t)
              return i
            }),
            factory),
          factory,
          shapeCollectionPool = (function () {
            var e = {
                newShapeCollection: function () {
                  return t ? r[(t -= 1)] : new ShapeCollection()
                },
                release: function (e) {
                  var n,
                    a = e._length
                  for (n = 0; n < a; n += 1) shapePool.release(e.shapes[n])
                  ;(e._length = 0),
                    t === i && ((r = pooling.double(r)), (i *= 2)),
                    (r[t] = e),
                    (t += 1)
                }
              },
              t = 0,
              i = 4,
              r = createSizedArray(i)
            return e
          })(),
          segmentsLengthPool = poolFactory(
            8,
            function () {
              return { lengths: [], totalLength: 0 }
            },
            function (e) {
              var t,
                i = e.lengths.length
              for (t = 0; t < i; t += 1) bezierLengthPool.release(e.lengths[t])
              e.lengths.length = 0
            }
          ),
          bezierLengthPool = poolFactory(8, function () {
            return {
              addedLength: 0,
              percents: createTypedArray('float32', defaultCurveSegments),
              lengths: createTypedArray('float32', defaultCurveSegments)
            }
          }),
          markerParser = (function () {
            function e(e) {
              for (var t, i = e.split('\r\n'), r = {}, n = 0, a = 0; a < i.length; a += 1)
                2 === (t = i[a].split(':')).length && ((r[t[0]] = t[1].trim()), (n += 1))
              if (0 === n) throw new Error()
              return r
            }
            return function (t) {
              for (var i = [], r = 0; r < t.length; r += 1) {
                var n = t[r],
                  a = { time: n.tm, duration: n.dr }
                try {
                  a.payload = JSON.parse(t[r].cm)
                } catch (o) {
                  try {
                    a.payload = e(t[r].cm)
                  } catch (s) {
                    a.payload = { name: t[r] }
                  }
                }
                i.push(a)
              }
              return i
            }
          })()
        function BaseRenderer() {}
        function SVGRenderer(e, t) {
          ;(this.animationItem = e),
            (this.layers = null),
            (this.renderedFrame = -1),
            (this.svgElement = createNS('svg'))
          var i = ''
          if (t && t.title) {
            var r = createNS('title'),
              n = createElementID()
            r.setAttribute('id', n),
              (r.textContent = t.title),
              this.svgElement.appendChild(r),
              (i += n)
          }
          if (t && t.description) {
            var a = createNS('desc'),
              o = createElementID()
            a.setAttribute('id', o),
              (a.textContent = t.description),
              this.svgElement.appendChild(a),
              (i += ' ' + o)
          }
          i && this.svgElement.setAttribute('aria-labelledby', i)
          var s = createNS('defs')
          this.svgElement.appendChild(s)
          var l = createNS('g')
          this.svgElement.appendChild(l),
            (this.layerElement = l),
            (this.renderConfig = {
              preserveAspectRatio: (t && t.preserveAspectRatio) || 'xMidYMid meet',
              imagePreserveAspectRatio: (t && t.imagePreserveAspectRatio) || 'xMidYMid slice',
              progressiveLoad: (t && t.progressiveLoad) || !1,
              hideOnTransparent: !(t && !1 === t.hideOnTransparent),
              viewBoxOnly: (t && t.viewBoxOnly) || !1,
              viewBoxSize: (t && t.viewBoxSize) || !1,
              className: (t && t.className) || '',
              id: (t && t.id) || '',
              focusable: t && t.focusable,
              filterSize: {
                width: (t && t.filterSize && t.filterSize.width) || '100%',
                height: (t && t.filterSize && t.filterSize.height) || '100%',
                x: (t && t.filterSize && t.filterSize.x) || '0%',
                y: (t && t.filterSize && t.filterSize.y) || '0%'
              }
            }),
            (this.globalData = {
              _mdf: !1,
              frameNum: -1,
              defs: s,
              renderConfig: this.renderConfig
            }),
            (this.elements = []),
            (this.pendingElements = []),
            (this.destroyed = !1),
            (this.rendererType = 'svg')
        }
        function CanvasRenderer(e, t) {
          ;(this.animationItem = e),
            (this.renderConfig = {
              clearCanvas: !t || void 0 === t.clearCanvas || t.clearCanvas,
              context: (t && t.context) || null,
              progressiveLoad: (t && t.progressiveLoad) || !1,
              preserveAspectRatio: (t && t.preserveAspectRatio) || 'xMidYMid meet',
              imagePreserveAspectRatio: (t && t.imagePreserveAspectRatio) || 'xMidYMid slice',
              className: (t && t.className) || '',
              id: (t && t.id) || ''
            }),
            (this.renderConfig.dpr = (t && t.dpr) || 1),
            this.animationItem.wrapper &&
              (this.renderConfig.dpr = (t && t.dpr) || window.devicePixelRatio || 1),
            (this.renderedFrame = -1),
            (this.globalData = {
              frameNum: -1,
              _mdf: !1,
              renderConfig: this.renderConfig,
              currentGlobalAlpha: -1
            }),
            (this.contextData = new CVContextData()),
            (this.elements = []),
            (this.pendingElements = []),
            (this.transformMat = new Matrix()),
            (this.completeLayers = !1),
            (this.rendererType = 'canvas')
        }
        function HybridRenderer(e, t) {
          ;(this.animationItem = e),
            (this.layers = null),
            (this.renderedFrame = -1),
            (this.renderConfig = {
              className: (t && t.className) || '',
              imagePreserveAspectRatio: (t && t.imagePreserveAspectRatio) || 'xMidYMid slice',
              hideOnTransparent: !(t && !1 === t.hideOnTransparent),
              filterSize: {
                width: (t && t.filterSize && t.filterSize.width) || '400%',
                height: (t && t.filterSize && t.filterSize.height) || '400%',
                x: (t && t.filterSize && t.filterSize.x) || '-100%',
                y: (t && t.filterSize && t.filterSize.y) || '-100%'
              }
            }),
            (this.globalData = { _mdf: !1, frameNum: -1, renderConfig: this.renderConfig }),
            (this.pendingElements = []),
            (this.elements = []),
            (this.threeDElements = []),
            (this.destroyed = !1),
            (this.camera = null),
            (this.supports3d = !0),
            (this.rendererType = 'html')
        }
        function MaskElement(e, t, i) {
          ;(this.data = e),
            (this.element = t),
            (this.globalData = i),
            (this.storedData = []),
            (this.masksProperties = this.data.masksProperties || []),
            (this.maskElement = null)
          var r,
            n,
            a = this.globalData.defs,
            o = this.masksProperties ? this.masksProperties.length : 0
          ;(this.viewData = createSizedArray(o)), (this.solidPath = '')
          var s,
            l,
            h,
            u,
            p,
            c,
            d = this.masksProperties,
            f = 0,
            m = [],
            g = createElementID(),
            y = 'clipPath',
            v = 'clip-path'
          for (r = 0; r < o; r += 1)
            if (
              ((('a' !== d[r].mode && 'n' !== d[r].mode) ||
                d[r].inv ||
                100 !== d[r].o.k ||
                d[r].o.x) &&
                ((y = 'mask'), (v = 'mask')),
              ('s' !== d[r].mode && 'i' !== d[r].mode) || 0 !== f
                ? (h = null)
                : ((h = createNS('rect')).setAttribute('fill', '#ffffff'),
                  h.setAttribute('width', this.element.comp.data.w || 0),
                  h.setAttribute('height', this.element.comp.data.h || 0),
                  m.push(h)),
              (n = createNS('path')),
              'n' === d[r].mode)
            )
              (this.viewData[r] = {
                op: PropertyFactory.getProp(this.element, d[r].o, 0, 0.01, this.element),
                prop: ShapePropertyFactory.getShapeProp(this.element, d[r], 3),
                elem: n,
                lastPath: ''
              }),
                a.appendChild(n)
            else {
              var _
              if (
                ((f += 1),
                n.setAttribute('fill', 's' === d[r].mode ? '#000000' : '#ffffff'),
                n.setAttribute('clip-rule', 'nonzero'),
                0 !== d[r].x.k
                  ? ((y = 'mask'),
                    (v = 'mask'),
                    (c = PropertyFactory.getProp(this.element, d[r].x, 0, null, this.element)),
                    (_ = createElementID()),
                    (u = createNS('filter')).setAttribute('id', _),
                    (p = createNS('feMorphology')).setAttribute('operator', 'erode'),
                    p.setAttribute('in', 'SourceGraphic'),
                    p.setAttribute('radius', '0'),
                    u.appendChild(p),
                    a.appendChild(u),
                    n.setAttribute('stroke', 's' === d[r].mode ? '#000000' : '#ffffff'))
                  : ((p = null), (c = null)),
                (this.storedData[r] = {
                  elem: n,
                  x: c,
                  expan: p,
                  lastPath: '',
                  lastOperator: '',
                  filterId: _,
                  lastRadius: 0
                }),
                'i' === d[r].mode)
              ) {
                l = m.length
                var x = createNS('g')
                for (s = 0; s < l; s += 1) x.appendChild(m[s])
                var S = createNS('mask')
                S.setAttribute('mask-type', 'alpha'),
                  S.setAttribute('id', g + '_' + f),
                  S.appendChild(n),
                  a.appendChild(S),
                  x.setAttribute('mask', 'url(' + locationHref + '#' + g + '_' + f + ')'),
                  (m.length = 0),
                  m.push(x)
              } else m.push(n)
              d[r].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()),
                (this.viewData[r] = {
                  elem: n,
                  lastPath: '',
                  op: PropertyFactory.getProp(this.element, d[r].o, 0, 0.01, this.element),
                  prop: ShapePropertyFactory.getShapeProp(this.element, d[r], 3),
                  invRect: h
                }),
                this.viewData[r].prop.k ||
                  this.drawPath(d[r], this.viewData[r].prop.v, this.viewData[r])
            }
          for (this.maskElement = createNS(y), o = m.length, r = 0; r < o; r += 1)
            this.maskElement.appendChild(m[r])
          f > 0 &&
            (this.maskElement.setAttribute('id', g),
            this.element.maskedElement.setAttribute(v, 'url(' + locationHref + '#' + g + ')'),
            a.appendChild(this.maskElement)),
            this.viewData.length && this.element.addRenderableComponent(this)
        }
        function HierarchyElement() {}
        function FrameElement() {}
        function TransformElement() {}
        function RenderableElement() {}
        function RenderableDOMElement() {}
        function ProcessedElement(e, t) {
          ;(this.elem = e), (this.pos = t)
        }
        function SVGStyleData(e, t) {
          ;(this.data = e),
            (this.type = e.ty),
            (this.d = ''),
            (this.lvl = t),
            (this._mdf = !1),
            (this.closed = !0 === e.hd),
            (this.pElem = createNS('path')),
            (this.msElem = null)
        }
        function SVGShapeData(e, t, i) {
          ;(this.caches = []),
            (this.styles = []),
            (this.transformers = e),
            (this.lStr = ''),
            (this.sh = i),
            (this.lvl = t),
            (this._isAnimated = !!i.k)
          for (var r = 0, n = e.length; r < n; ) {
            if (e[r].mProps.dynamicProperties.length) {
              this._isAnimated = !0
              break
            }
            r += 1
          }
        }
        function SVGTransformData(e, t, i) {
          ;(this.transform = { mProps: e, op: t, container: i }),
            (this.elements = []),
            (this._isAnimated =
              this.transform.mProps.dynamicProperties.length ||
              this.transform.op.effectsSequence.length)
        }
        function SVGStrokeStyleData(e, t, i) {
          this.initDynamicPropertyContainer(e),
            (this.getValue = this.iterateDynamicProperties),
            (this.o = PropertyFactory.getProp(e, t.o, 0, 0.01, this)),
            (this.w = PropertyFactory.getProp(e, t.w, 0, null, this)),
            (this.d = new DashProperty(e, t.d || {}, 'svg', this)),
            (this.c = PropertyFactory.getProp(e, t.c, 1, 255, this)),
            (this.style = i),
            (this._isAnimated = !!this._isAnimated)
        }
        function SVGFillStyleData(e, t, i) {
          this.initDynamicPropertyContainer(e),
            (this.getValue = this.iterateDynamicProperties),
            (this.o = PropertyFactory.getProp(e, t.o, 0, 0.01, this)),
            (this.c = PropertyFactory.getProp(e, t.c, 1, 255, this)),
            (this.style = i)
        }
        function SVGGradientFillStyleData(e, t, i) {
          this.initDynamicPropertyContainer(e),
            (this.getValue = this.iterateDynamicProperties),
            this.initGradientData(e, t, i)
        }
        function SVGGradientStrokeStyleData(e, t, i) {
          this.initDynamicPropertyContainer(e),
            (this.getValue = this.iterateDynamicProperties),
            (this.w = PropertyFactory.getProp(e, t.w, 0, null, this)),
            (this.d = new DashProperty(e, t.d || {}, 'svg', this)),
            this.initGradientData(e, t, i),
            (this._isAnimated = !!this._isAnimated)
        }
        function ShapeGroupData() {
          ;(this.it = []), (this.prevViewData = []), (this.gr = createNS('g'))
        }
        ;(BaseRenderer.prototype.checkLayers = function (e) {
          var t,
            i,
            r = this.layers.length
          for (this.completeLayers = !0, t = r - 1; t >= 0; t -= 1)
            this.elements[t] ||
              ((i = this.layers[t]).ip - i.st <= e - this.layers[t].st &&
                i.op - i.st > e - this.layers[t].st &&
                this.buildItem(t)),
              (this.completeLayers = !!this.elements[t] && this.completeLayers)
          this.checkPendingElements()
        }),
          (BaseRenderer.prototype.createItem = function (e) {
            switch (e.ty) {
              case 2:
                return this.createImage(e)
              case 0:
                return this.createComp(e)
              case 1:
                return this.createSolid(e)
              case 3:
                return this.createNull(e)
              case 4:
                return this.createShape(e)
              case 5:
                return this.createText(e)
              case 6:
                return this.createAudio(e)
              case 13:
                return this.createCamera(e)
              case 15:
                return this.createFootage(e)
              default:
                return this.createNull(e)
            }
          }),
          (BaseRenderer.prototype.createCamera = function () {
            throw new Error("You're using a 3d camera. Try the html renderer.")
          }),
          (BaseRenderer.prototype.createAudio = function (e) {
            return new AudioElement(e, this.globalData, this)
          }),
          (BaseRenderer.prototype.createFootage = function (e) {
            return new FootageElement(e, this.globalData, this)
          }),
          (BaseRenderer.prototype.buildAllItems = function () {
            var e,
              t = this.layers.length
            for (e = 0; e < t; e += 1) this.buildItem(e)
            this.checkPendingElements()
          }),
          (BaseRenderer.prototype.includeLayers = function (e) {
            var t
            this.completeLayers = !1
            var i,
              r = e.length,
              n = this.layers.length
            for (t = 0; t < r; t += 1)
              for (i = 0; i < n; ) {
                if (this.layers[i].id === e[t].id) {
                  this.layers[i] = e[t]
                  break
                }
                i += 1
              }
          }),
          (BaseRenderer.prototype.setProjectInterface = function (e) {
            this.globalData.projectInterface = e
          }),
          (BaseRenderer.prototype.initItems = function () {
            this.globalData.progressiveLoad || this.buildAllItems()
          }),
          (BaseRenderer.prototype.buildElementParenting = function (e, t, i) {
            for (var r = this.elements, n = this.layers, a = 0, o = n.length; a < o; )
              n[a].ind == t &&
                (r[a] && !0 !== r[a]
                  ? (i.push(r[a]),
                    r[a].setAsParent(),
                    void 0 !== n[a].parent
                      ? this.buildElementParenting(e, n[a].parent, i)
                      : e.setHierarchy(i))
                  : (this.buildItem(a), this.addPendingElement(e))),
                (a += 1)
          }),
          (BaseRenderer.prototype.addPendingElement = function (e) {
            this.pendingElements.push(e)
          }),
          (BaseRenderer.prototype.searchExtraCompositions = function (e) {
            var t,
              i = e.length
            for (t = 0; t < i; t += 1)
              if (e[t].xt) {
                var r = this.createComp(e[t])
                r.initExpressions(), this.globalData.projectInterface.registerComposition(r)
              }
          }),
          (BaseRenderer.prototype.setupGlobalData = function (e, t) {
            ;(this.globalData.fontManager = new FontManager()),
              this.globalData.fontManager.addChars(e.chars),
              this.globalData.fontManager.addFonts(e.fonts, t),
              (this.globalData.getAssetData = this.animationItem.getAssetData.bind(
                this.animationItem
              )),
              (this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(
                this.animationItem
              )),
              (this.globalData.imageLoader = this.animationItem.imagePreloader),
              (this.globalData.audioController = this.animationItem.audioController),
              (this.globalData.frameId = 0),
              (this.globalData.frameRate = e.fr),
              (this.globalData.nm = e.nm),
              (this.globalData.compSize = { w: e.w, h: e.h })
          }),
          extendPrototype([BaseRenderer], SVGRenderer),
          (SVGRenderer.prototype.createNull = function (e) {
            return new NullElement(e, this.globalData, this)
          }),
          (SVGRenderer.prototype.createShape = function (e) {
            return new SVGShapeElement(e, this.globalData, this)
          }),
          (SVGRenderer.prototype.createText = function (e) {
            return new SVGTextLottieElement(e, this.globalData, this)
          }),
          (SVGRenderer.prototype.createImage = function (e) {
            return new IImageElement(e, this.globalData, this)
          }),
          (SVGRenderer.prototype.createComp = function (e) {
            return new SVGCompElement(e, this.globalData, this)
          }),
          (SVGRenderer.prototype.createSolid = function (e) {
            return new ISolidElement(e, this.globalData, this)
          }),
          (SVGRenderer.prototype.configAnimation = function (e) {
            this.svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg'),
              this.renderConfig.viewBoxSize
                ? this.svgElement.setAttribute('viewBox', this.renderConfig.viewBoxSize)
                : this.svgElement.setAttribute('viewBox', '0 0 ' + e.w + ' ' + e.h),
              this.renderConfig.viewBoxOnly ||
                (this.svgElement.setAttribute('width', e.w),
                this.svgElement.setAttribute('height', e.h),
                (this.svgElement.style.width = '100%'),
                (this.svgElement.style.height = '100%'),
                (this.svgElement.style.transform = 'translate3d(0,0,0)')),
              this.renderConfig.className &&
                this.svgElement.setAttribute('class', this.renderConfig.className),
              this.renderConfig.id && this.svgElement.setAttribute('id', this.renderConfig.id),
              void 0 !== this.renderConfig.focusable &&
                this.svgElement.setAttribute('focusable', this.renderConfig.focusable),
              this.svgElement.setAttribute(
                'preserveAspectRatio',
                this.renderConfig.preserveAspectRatio
              ),
              this.animationItem.wrapper.appendChild(this.svgElement)
            var t = this.globalData.defs
            this.setupGlobalData(e, t),
              (this.globalData.progressiveLoad = this.renderConfig.progressiveLoad),
              (this.data = e)
            var i = createNS('clipPath'),
              r = createNS('rect')
            r.setAttribute('width', e.w),
              r.setAttribute('height', e.h),
              r.setAttribute('x', 0),
              r.setAttribute('y', 0)
            var n = createElementID()
            i.setAttribute('id', n),
              i.appendChild(r),
              this.layerElement.setAttribute('clip-path', 'url(' + locationHref + '#' + n + ')'),
              t.appendChild(i),
              (this.layers = e.layers),
              (this.elements = createSizedArray(e.layers.length))
          }),
          (SVGRenderer.prototype.destroy = function () {
            var e
            this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ''),
              (this.layerElement = null),
              (this.globalData.defs = null)
            var t = this.layers ? this.layers.length : 0
            for (e = 0; e < t; e += 1) this.elements[e] && this.elements[e].destroy()
            ;(this.elements.length = 0), (this.destroyed = !0), (this.animationItem = null)
          }),
          (SVGRenderer.prototype.updateContainerSize = function () {}),
          (SVGRenderer.prototype.buildItem = function (e) {
            var t = this.elements
            if (!t[e] && 99 !== this.layers[e].ty) {
              t[e] = !0
              var i = this.createItem(this.layers[e])
              ;(t[e] = i),
                expressionsPlugin &&
                  (0 === this.layers[e].ty &&
                    this.globalData.projectInterface.registerComposition(i),
                  i.initExpressions()),
                this.appendElementInPos(i, e),
                this.layers[e].tt &&
                  (this.elements[e - 1] && !0 !== this.elements[e - 1]
                    ? i.setMatte(t[e - 1].layerId)
                    : (this.buildItem(e - 1), this.addPendingElement(i)))
            }
          }),
          (SVGRenderer.prototype.checkPendingElements = function () {
            for (; this.pendingElements.length; ) {
              var e = this.pendingElements.pop()
              if ((e.checkParenting(), e.data.tt))
                for (var t = 0, i = this.elements.length; t < i; ) {
                  if (this.elements[t] === e) {
                    e.setMatte(this.elements[t - 1].layerId)
                    break
                  }
                  t += 1
                }
            }
          }),
          (SVGRenderer.prototype.renderFrame = function (e) {
            if (this.renderedFrame !== e && !this.destroyed) {
              var t
              null === e ? (e = this.renderedFrame) : (this.renderedFrame = e),
                (this.globalData.frameNum = e),
                (this.globalData.frameId += 1),
                (this.globalData.projectInterface.currentFrame = e),
                (this.globalData._mdf = !1)
              var i = this.layers.length
              for (this.completeLayers || this.checkLayers(e), t = i - 1; t >= 0; t -= 1)
                (this.completeLayers || this.elements[t]) &&
                  this.elements[t].prepareFrame(e - this.layers[t].st)
              if (this.globalData._mdf)
                for (t = 0; t < i; t += 1)
                  (this.completeLayers || this.elements[t]) && this.elements[t].renderFrame()
            }
          }),
          (SVGRenderer.prototype.appendElementInPos = function (e, t) {
            var i = e.getBaseElement()
            if (i) {
              for (var r, n = 0; n < t; )
                this.elements[n] &&
                  !0 !== this.elements[n] &&
                  this.elements[n].getBaseElement() &&
                  (r = this.elements[n].getBaseElement()),
                  (n += 1)
              r ? this.layerElement.insertBefore(i, r) : this.layerElement.appendChild(i)
            }
          }),
          (SVGRenderer.prototype.hide = function () {
            this.layerElement.style.display = 'none'
          }),
          (SVGRenderer.prototype.show = function () {
            this.layerElement.style.display = 'block'
          }),
          extendPrototype([BaseRenderer], CanvasRenderer),
          (CanvasRenderer.prototype.createShape = function (e) {
            return new CVShapeElement(e, this.globalData, this)
          }),
          (CanvasRenderer.prototype.createText = function (e) {
            return new CVTextElement(e, this.globalData, this)
          }),
          (CanvasRenderer.prototype.createImage = function (e) {
            return new CVImageElement(e, this.globalData, this)
          }),
          (CanvasRenderer.prototype.createComp = function (e) {
            return new CVCompElement(e, this.globalData, this)
          }),
          (CanvasRenderer.prototype.createSolid = function (e) {
            return new CVSolidElement(e, this.globalData, this)
          }),
          (CanvasRenderer.prototype.createNull = SVGRenderer.prototype.createNull),
          (CanvasRenderer.prototype.ctxTransform = function (e) {
            if (1 !== e[0] || 0 !== e[1] || 0 !== e[4] || 1 !== e[5] || 0 !== e[12] || 0 !== e[13])
              if (this.renderConfig.clearCanvas) {
                this.transformMat.cloneFromProps(e)
                var t = this.contextData.cTr.props
                this.transformMat.transform(
                  t[0],
                  t[1],
                  t[2],
                  t[3],
                  t[4],
                  t[5],
                  t[6],
                  t[7],
                  t[8],
                  t[9],
                  t[10],
                  t[11],
                  t[12],
                  t[13],
                  t[14],
                  t[15]
                ),
                  this.contextData.cTr.cloneFromProps(this.transformMat.props)
                var i = this.contextData.cTr.props
                this.canvasContext.setTransform(i[0], i[1], i[4], i[5], i[12], i[13])
              } else this.canvasContext.transform(e[0], e[1], e[4], e[5], e[12], e[13])
          }),
          (CanvasRenderer.prototype.ctxOpacity = function (e) {
            if (!this.renderConfig.clearCanvas)
              return (
                (this.canvasContext.globalAlpha *= e < 0 ? 0 : e),
                void (this.globalData.currentGlobalAlpha = this.contextData.cO)
              )
            ;(this.contextData.cO *= e < 0 ? 0 : e),
              this.globalData.currentGlobalAlpha !== this.contextData.cO &&
                ((this.canvasContext.globalAlpha = this.contextData.cO),
                (this.globalData.currentGlobalAlpha = this.contextData.cO))
          }),
          (CanvasRenderer.prototype.reset = function () {
            this.renderConfig.clearCanvas ? this.contextData.reset() : this.canvasContext.restore()
          }),
          (CanvasRenderer.prototype.save = function (e) {
            if (this.renderConfig.clearCanvas) {
              e && this.canvasContext.save()
              var t,
                i = this.contextData.cTr.props
              this.contextData._length <= this.contextData.cArrPos && this.contextData.duplicate()
              var r = this.contextData.saved[this.contextData.cArrPos]
              for (t = 0; t < 16; t += 1) r[t] = i[t]
              ;(this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO),
                (this.contextData.cArrPos += 1)
            } else this.canvasContext.save()
          }),
          (CanvasRenderer.prototype.restore = function (e) {
            if (this.renderConfig.clearCanvas) {
              e && (this.canvasContext.restore(), (this.globalData.blendMode = 'source-over')),
                (this.contextData.cArrPos -= 1)
              var t,
                i = this.contextData.saved[this.contextData.cArrPos],
                r = this.contextData.cTr.props
              for (t = 0; t < 16; t += 1) r[t] = i[t]
              this.canvasContext.setTransform(i[0], i[1], i[4], i[5], i[12], i[13]),
                (i = this.contextData.savedOp[this.contextData.cArrPos]),
                (this.contextData.cO = i),
                this.globalData.currentGlobalAlpha !== i &&
                  ((this.canvasContext.globalAlpha = i), (this.globalData.currentGlobalAlpha = i))
            } else this.canvasContext.restore()
          }),
          (CanvasRenderer.prototype.configAnimation = function (e) {
            if (this.animationItem.wrapper) {
              this.animationItem.container = createTag('canvas')
              var t = this.animationItem.container.style
              ;(t.width = '100%'), (t.height = '100%')
              var i = '0px 0px 0px'
              ;(t.transformOrigin = i),
                (t.mozTransformOrigin = i),
                (t.webkitTransformOrigin = i),
                (t['-webkit-transform'] = i),
                this.animationItem.wrapper.appendChild(this.animationItem.container),
                (this.canvasContext = this.animationItem.container.getContext('2d')),
                this.renderConfig.className &&
                  this.animationItem.container.setAttribute('class', this.renderConfig.className),
                this.renderConfig.id &&
                  this.animationItem.container.setAttribute('id', this.renderConfig.id)
            } else this.canvasContext = this.renderConfig.context
            ;(this.data = e),
              (this.layers = e.layers),
              (this.transformCanvas = { w: e.w, h: e.h, sx: 0, sy: 0, tx: 0, ty: 0 }),
              this.setupGlobalData(e, document.body),
              (this.globalData.canvasContext = this.canvasContext),
              (this.globalData.renderer = this),
              (this.globalData.isDashed = !1),
              (this.globalData.progressiveLoad = this.renderConfig.progressiveLoad),
              (this.globalData.transformCanvas = this.transformCanvas),
              (this.elements = createSizedArray(e.layers.length)),
              this.updateContainerSize()
          }),
          (CanvasRenderer.prototype.updateContainerSize = function () {
            var e, t, i, r
            if (
              (this.reset(),
              this.animationItem.wrapper && this.animationItem.container
                ? ((e = this.animationItem.wrapper.offsetWidth),
                  (t = this.animationItem.wrapper.offsetHeight),
                  this.animationItem.container.setAttribute('width', e * this.renderConfig.dpr),
                  this.animationItem.container.setAttribute('height', t * this.renderConfig.dpr))
                : ((e = this.canvasContext.canvas.width * this.renderConfig.dpr),
                  (t = this.canvasContext.canvas.height * this.renderConfig.dpr)),
              -1 !== this.renderConfig.preserveAspectRatio.indexOf('meet') ||
                -1 !== this.renderConfig.preserveAspectRatio.indexOf('slice'))
            ) {
              var n = this.renderConfig.preserveAspectRatio.split(' '),
                a = n[1] || 'meet',
                o = n[0] || 'xMidYMid',
                s = o.substr(0, 4),
                l = o.substr(4)
              ;(i = e / t),
                ((r = this.transformCanvas.w / this.transformCanvas.h) > i && 'meet' === a) ||
                (r < i && 'slice' === a)
                  ? ((this.transformCanvas.sx =
                      e / (this.transformCanvas.w / this.renderConfig.dpr)),
                    (this.transformCanvas.sy =
                      e / (this.transformCanvas.w / this.renderConfig.dpr)))
                  : ((this.transformCanvas.sx =
                      t / (this.transformCanvas.h / this.renderConfig.dpr)),
                    (this.transformCanvas.sy =
                      t / (this.transformCanvas.h / this.renderConfig.dpr))),
                (this.transformCanvas.tx =
                  'xMid' === s && ((r < i && 'meet' === a) || (r > i && 'slice' === a))
                    ? ((e - this.transformCanvas.w * (t / this.transformCanvas.h)) / 2) *
                      this.renderConfig.dpr
                    : 'xMax' === s && ((r < i && 'meet' === a) || (r > i && 'slice' === a))
                    ? (e - this.transformCanvas.w * (t / this.transformCanvas.h)) *
                      this.renderConfig.dpr
                    : 0),
                (this.transformCanvas.ty =
                  'YMid' === l && ((r > i && 'meet' === a) || (r < i && 'slice' === a))
                    ? ((t - this.transformCanvas.h * (e / this.transformCanvas.w)) / 2) *
                      this.renderConfig.dpr
                    : 'YMax' === l && ((r > i && 'meet' === a) || (r < i && 'slice' === a))
                    ? (t - this.transformCanvas.h * (e / this.transformCanvas.w)) *
                      this.renderConfig.dpr
                    : 0)
            } else
              'none' === this.renderConfig.preserveAspectRatio
                ? ((this.transformCanvas.sx = e / (this.transformCanvas.w / this.renderConfig.dpr)),
                  (this.transformCanvas.sy = t / (this.transformCanvas.h / this.renderConfig.dpr)),
                  (this.transformCanvas.tx = 0),
                  (this.transformCanvas.ty = 0))
                : ((this.transformCanvas.sx = this.renderConfig.dpr),
                  (this.transformCanvas.sy = this.renderConfig.dpr),
                  (this.transformCanvas.tx = 0),
                  (this.transformCanvas.ty = 0))
            ;(this.transformCanvas.props = [
              this.transformCanvas.sx,
              0,
              0,
              0,
              0,
              this.transformCanvas.sy,
              0,
              0,
              0,
              0,
              1,
              0,
              this.transformCanvas.tx,
              this.transformCanvas.ty,
              0,
              1
            ]),
              this.ctxTransform(this.transformCanvas.props),
              this.canvasContext.beginPath(),
              this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h),
              this.canvasContext.closePath(),
              this.canvasContext.clip(),
              this.renderFrame(this.renderedFrame, !0)
          }),
          (CanvasRenderer.prototype.destroy = function () {
            var e
            for (
              this.renderConfig.clearCanvas &&
                this.animationItem.wrapper &&
                (this.animationItem.wrapper.innerText = ''),
                e = (this.layers ? this.layers.length : 0) - 1;
              e >= 0;
              e -= 1
            )
              this.elements[e] && this.elements[e].destroy()
            ;(this.elements.length = 0),
              (this.globalData.canvasContext = null),
              (this.animationItem.container = null),
              (this.destroyed = !0)
          }),
          (CanvasRenderer.prototype.renderFrame = function (e, t) {
            if (
              (this.renderedFrame !== e || !0 !== this.renderConfig.clearCanvas || t) &&
              !this.destroyed &&
              -1 !== e
            ) {
              var i
              ;(this.renderedFrame = e),
                (this.globalData.frameNum = e - this.animationItem._isFirstFrame),
                (this.globalData.frameId += 1),
                (this.globalData._mdf = !this.renderConfig.clearCanvas || t),
                (this.globalData.projectInterface.currentFrame = e)
              var r = this.layers.length
              for (this.completeLayers || this.checkLayers(e), i = 0; i < r; i += 1)
                (this.completeLayers || this.elements[i]) &&
                  this.elements[i].prepareFrame(e - this.layers[i].st)
              if (this.globalData._mdf) {
                for (
                  !0 === this.renderConfig.clearCanvas
                    ? this.canvasContext.clearRect(
                        0,
                        0,
                        this.transformCanvas.w,
                        this.transformCanvas.h
                      )
                    : this.save(),
                    i = r - 1;
                  i >= 0;
                  i -= 1
                )
                  (this.completeLayers || this.elements[i]) && this.elements[i].renderFrame()
                !0 !== this.renderConfig.clearCanvas && this.restore()
              }
            }
          }),
          (CanvasRenderer.prototype.buildItem = function (e) {
            var t = this.elements
            if (!t[e] && 99 !== this.layers[e].ty) {
              var i = this.createItem(this.layers[e], this, this.globalData)
              ;(t[e] = i), i.initExpressions()
            }
          }),
          (CanvasRenderer.prototype.checkPendingElements = function () {
            for (; this.pendingElements.length; ) this.pendingElements.pop().checkParenting()
          }),
          (CanvasRenderer.prototype.hide = function () {
            this.animationItem.container.style.display = 'none'
          }),
          (CanvasRenderer.prototype.show = function () {
            this.animationItem.container.style.display = 'block'
          }),
          extendPrototype([BaseRenderer], HybridRenderer),
          (HybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem),
          (HybridRenderer.prototype.checkPendingElements = function () {
            for (; this.pendingElements.length; ) this.pendingElements.pop().checkParenting()
          }),
          (HybridRenderer.prototype.appendElementInPos = function (e, t) {
            var i = e.getBaseElement()
            if (i) {
              var r = this.layers[t]
              if (r.ddd && this.supports3d) this.addTo3dContainer(i, t)
              else if (this.threeDElements) this.addTo3dContainer(i, t)
              else {
                for (var n, a, o = 0; o < t; )
                  this.elements[o] &&
                    !0 !== this.elements[o] &&
                    this.elements[o].getBaseElement &&
                    ((a = this.elements[o]),
                    (n =
                      (this.layers[o].ddd ? this.getThreeDContainerByPos(o) : a.getBaseElement()) ||
                      n)),
                    (o += 1)
                n
                  ? (r.ddd && this.supports3d) || this.layerElement.insertBefore(i, n)
                  : (r.ddd && this.supports3d) || this.layerElement.appendChild(i)
              }
            }
          }),
          (HybridRenderer.prototype.createShape = function (e) {
            return this.supports3d
              ? new HShapeElement(e, this.globalData, this)
              : new SVGShapeElement(e, this.globalData, this)
          }),
          (HybridRenderer.prototype.createText = function (e) {
            return this.supports3d
              ? new HTextElement(e, this.globalData, this)
              : new SVGTextLottieElement(e, this.globalData, this)
          }),
          (HybridRenderer.prototype.createCamera = function (e) {
            return (this.camera = new HCameraElement(e, this.globalData, this)), this.camera
          }),
          (HybridRenderer.prototype.createImage = function (e) {
            return this.supports3d
              ? new HImageElement(e, this.globalData, this)
              : new IImageElement(e, this.globalData, this)
          }),
          (HybridRenderer.prototype.createComp = function (e) {
            return this.supports3d
              ? new HCompElement(e, this.globalData, this)
              : new SVGCompElement(e, this.globalData, this)
          }),
          (HybridRenderer.prototype.createSolid = function (e) {
            return this.supports3d
              ? new HSolidElement(e, this.globalData, this)
              : new ISolidElement(e, this.globalData, this)
          }),
          (HybridRenderer.prototype.createNull = SVGRenderer.prototype.createNull),
          (HybridRenderer.prototype.getThreeDContainerByPos = function (e) {
            for (var t = 0, i = this.threeDElements.length; t < i; ) {
              if (this.threeDElements[t].startPos <= e && this.threeDElements[t].endPos >= e)
                return this.threeDElements[t].perspectiveElem
              t += 1
            }
            return null
          }),
          (HybridRenderer.prototype.createThreeDContainer = function (e, t) {
            var i,
              r,
              n = createTag('div')
            styleDiv(n)
            var a = createTag('div')
            if ((styleDiv(a), '3d' === t)) {
              ;((i = n.style).width = this.globalData.compSize.w + 'px'),
                (i.height = this.globalData.compSize.h + 'px')
              var o = '50% 50%'
              ;(i.webkitTransformOrigin = o), (i.mozTransformOrigin = o), (i.transformOrigin = o)
              var s = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)'
              ;((r = a.style).transform = s), (r.webkitTransform = s)
            }
            n.appendChild(a)
            var l = { container: a, perspectiveElem: n, startPos: e, endPos: e, type: t }
            return this.threeDElements.push(l), l
          }),
          (HybridRenderer.prototype.build3dContainers = function () {
            var e,
              t,
              i = this.layers.length,
              r = ''
            for (e = 0; e < i; e += 1)
              this.layers[e].ddd && 3 !== this.layers[e].ty
                ? ('3d' !== r && ((r = '3d'), (t = this.createThreeDContainer(e, '3d'))),
                  (t.endPos = Math.max(t.endPos, e)))
                : ('2d' !== r && ((r = '2d'), (t = this.createThreeDContainer(e, '2d'))),
                  (t.endPos = Math.max(t.endPos, e)))
            for (e = (i = this.threeDElements.length) - 1; e >= 0; e -= 1)
              this.resizerElem.appendChild(this.threeDElements[e].perspectiveElem)
          }),
          (HybridRenderer.prototype.addTo3dContainer = function (e, t) {
            for (var i = 0, r = this.threeDElements.length; i < r; ) {
              if (t <= this.threeDElements[i].endPos) {
                for (var n, a = this.threeDElements[i].startPos; a < t; )
                  this.elements[a] &&
                    this.elements[a].getBaseElement &&
                    (n = this.elements[a].getBaseElement()),
                    (a += 1)
                n
                  ? this.threeDElements[i].container.insertBefore(e, n)
                  : this.threeDElements[i].container.appendChild(e)
                break
              }
              i += 1
            }
          }),
          (HybridRenderer.prototype.configAnimation = function (e) {
            var t = createTag('div'),
              i = this.animationItem.wrapper,
              r = t.style
            ;(r.width = e.w + 'px'),
              (r.height = e.h + 'px'),
              (this.resizerElem = t),
              styleDiv(t),
              (r.transformStyle = 'flat'),
              (r.mozTransformStyle = 'flat'),
              (r.webkitTransformStyle = 'flat'),
              this.renderConfig.className && t.setAttribute('class', this.renderConfig.className),
              i.appendChild(t),
              (r.overflow = 'hidden')
            var n = createNS('svg')
            n.setAttribute('width', '1'),
              n.setAttribute('height', '1'),
              styleDiv(n),
              this.resizerElem.appendChild(n)
            var a = createNS('defs')
            n.appendChild(a),
              (this.data = e),
              this.setupGlobalData(e, n),
              (this.globalData.defs = a),
              (this.layers = e.layers),
              (this.layerElement = this.resizerElem),
              this.build3dContainers(),
              this.updateContainerSize()
          }),
          (HybridRenderer.prototype.destroy = function () {
            var e
            this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ''),
              (this.animationItem.container = null),
              (this.globalData.defs = null)
            var t = this.layers ? this.layers.length : 0
            for (e = 0; e < t; e += 1) this.elements[e].destroy()
            ;(this.elements.length = 0), (this.destroyed = !0), (this.animationItem = null)
          }),
          (HybridRenderer.prototype.updateContainerSize = function () {
            var e,
              t,
              i,
              r,
              n = this.animationItem.wrapper.offsetWidth,
              a = this.animationItem.wrapper.offsetHeight,
              o = n / a
            this.globalData.compSize.w / this.globalData.compSize.h > o
              ? ((e = n / this.globalData.compSize.w),
                (t = n / this.globalData.compSize.w),
                (i = 0),
                (r = (a - this.globalData.compSize.h * (n / this.globalData.compSize.w)) / 2))
              : ((e = a / this.globalData.compSize.h),
                (t = a / this.globalData.compSize.h),
                (i = (n - this.globalData.compSize.w * (a / this.globalData.compSize.h)) / 2),
                (r = 0))
            var s = this.resizerElem.style
            ;(s.webkitTransform =
              'matrix3d(' + e + ',0,0,0,0,' + t + ',0,0,0,0,1,0,' + i + ',' + r + ',0,1)'),
              (s.transform = s.webkitTransform)
          }),
          (HybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame),
          (HybridRenderer.prototype.hide = function () {
            this.resizerElem.style.display = 'none'
          }),
          (HybridRenderer.prototype.show = function () {
            this.resizerElem.style.display = 'block'
          }),
          (HybridRenderer.prototype.initItems = function () {
            if ((this.buildAllItems(), this.camera)) this.camera.setup()
            else {
              var e,
                t = this.globalData.compSize.w,
                i = this.globalData.compSize.h,
                r = this.threeDElements.length
              for (e = 0; e < r; e += 1) {
                var n = this.threeDElements[e].perspectiveElem.style
                ;(n.webkitPerspective = Math.sqrt(Math.pow(t, 2) + Math.pow(i, 2)) + 'px'),
                  (n.perspective = n.webkitPerspective)
              }
            }
          }),
          (HybridRenderer.prototype.searchExtraCompositions = function (e) {
            var t,
              i = e.length,
              r = createTag('div')
            for (t = 0; t < i; t += 1)
              if (e[t].xt) {
                var n = this.createComp(e[t], r, this.globalData.comp, null)
                n.initExpressions(), this.globalData.projectInterface.registerComposition(n)
              }
          }),
          (MaskElement.prototype.getMaskProperty = function (e) {
            return this.viewData[e].prop
          }),
          (MaskElement.prototype.renderFrame = function (e) {
            var t,
              i = this.element.finalTransform.mat,
              r = this.masksProperties.length
            for (t = 0; t < r; t += 1)
              if (
                ((this.viewData[t].prop._mdf || e) &&
                  this.drawPath(this.masksProperties[t], this.viewData[t].prop.v, this.viewData[t]),
                (this.viewData[t].op._mdf || e) &&
                  this.viewData[t].elem.setAttribute('fill-opacity', this.viewData[t].op.v),
                'n' !== this.masksProperties[t].mode &&
                  (this.viewData[t].invRect &&
                    (this.element.finalTransform.mProp._mdf || e) &&
                    this.viewData[t].invRect.setAttribute(
                      'transform',
                      i.getInverseMatrix().to2dCSS()
                    ),
                  this.storedData[t].x && (this.storedData[t].x._mdf || e)))
              ) {
                var n = this.storedData[t].expan
                this.storedData[t].x.v < 0
                  ? ('erode' !== this.storedData[t].lastOperator &&
                      ((this.storedData[t].lastOperator = 'erode'),
                      this.storedData[t].elem.setAttribute(
                        'filter',
                        'url(' + locationHref + '#' + this.storedData[t].filterId + ')'
                      )),
                    n.setAttribute('radius', -this.storedData[t].x.v))
                  : ('dilate' !== this.storedData[t].lastOperator &&
                      ((this.storedData[t].lastOperator = 'dilate'),
                      this.storedData[t].elem.setAttribute('filter', null)),
                    this.storedData[t].elem.setAttribute(
                      'stroke-width',
                      2 * this.storedData[t].x.v
                    ))
              }
          }),
          (MaskElement.prototype.getMaskelement = function () {
            return this.maskElement
          }),
          (MaskElement.prototype.createLayerSolidPath = function () {
            var e = 'M0,0 '
            return (
              (e += ' h' + this.globalData.compSize.w),
              (e += ' v' + this.globalData.compSize.h),
              (e += ' h-' + this.globalData.compSize.w),
              (e += ' v-' + this.globalData.compSize.h + ' ')
            )
          }),
          (MaskElement.prototype.drawPath = function (e, t, i) {
            var r,
              n,
              a = ' M' + t.v[0][0] + ',' + t.v[0][1]
            for (n = t._length, r = 1; r < n; r += 1)
              a +=
                ' C' +
                t.o[r - 1][0] +
                ',' +
                t.o[r - 1][1] +
                ' ' +
                t.i[r][0] +
                ',' +
                t.i[r][1] +
                ' ' +
                t.v[r][0] +
                ',' +
                t.v[r][1]
            if (
              (t.c &&
                n > 1 &&
                (a +=
                  ' C' +
                  t.o[r - 1][0] +
                  ',' +
                  t.o[r - 1][1] +
                  ' ' +
                  t.i[0][0] +
                  ',' +
                  t.i[0][1] +
                  ' ' +
                  t.v[0][0] +
                  ',' +
                  t.v[0][1]),
              i.lastPath !== a)
            ) {
              var o = ''
              i.elem && (t.c && (o = e.inv ? this.solidPath + a : a), i.elem.setAttribute('d', o)),
                (i.lastPath = a)
            }
          }),
          (MaskElement.prototype.destroy = function () {
            ;(this.element = null),
              (this.globalData = null),
              (this.maskElement = null),
              (this.data = null),
              (this.masksProperties = null)
          }),
          (HierarchyElement.prototype = {
            initHierarchy: function () {
              ;(this.hierarchy = []), (this._isParent = !1), this.checkParenting()
            },
            setHierarchy: function (e) {
              this.hierarchy = e
            },
            setAsParent: function () {
              this._isParent = !0
            },
            checkParenting: function () {
              void 0 !== this.data.parent &&
                this.comp.buildElementParenting(this, this.data.parent, [])
            }
          }),
          (FrameElement.prototype = {
            initFrame: function () {
              ;(this._isFirstFrame = !1), (this.dynamicProperties = []), (this._mdf = !1)
            },
            prepareProperties: function (e, t) {
              var i,
                r = this.dynamicProperties.length
              for (i = 0; i < r; i += 1)
                (t || (this._isParent && 'transform' === this.dynamicProperties[i].propType)) &&
                  (this.dynamicProperties[i].getValue(),
                  this.dynamicProperties[i]._mdf && ((this.globalData._mdf = !0), (this._mdf = !0)))
            },
            addDynamicProperty: function (e) {
              ;-1 === this.dynamicProperties.indexOf(e) && this.dynamicProperties.push(e)
            }
          }),
          (TransformElement.prototype = {
            initTransform: function () {
              ;(this.finalTransform = {
                mProp: this.data.ks
                  ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this)
                  : { o: 0 },
                _matMdf: !1,
                _opMdf: !1,
                mat: new Matrix()
              }),
                this.data.ao && (this.finalTransform.mProp.autoOriented = !0),
                this.data.ty
            },
            renderTransform: function () {
              if (
                ((this.finalTransform._opMdf =
                  this.finalTransform.mProp.o._mdf || this._isFirstFrame),
                (this.finalTransform._matMdf =
                  this.finalTransform.mProp._mdf || this._isFirstFrame),
                this.hierarchy)
              ) {
                var e,
                  t = this.finalTransform.mat,
                  i = 0,
                  r = this.hierarchy.length
                if (!this.finalTransform._matMdf)
                  for (; i < r; ) {
                    if (this.hierarchy[i].finalTransform.mProp._mdf) {
                      this.finalTransform._matMdf = !0
                      break
                    }
                    i += 1
                  }
                if (this.finalTransform._matMdf)
                  for (
                    e = this.finalTransform.mProp.v.props, t.cloneFromProps(e), i = 0;
                    i < r;
                    i += 1
                  )
                    (e = this.hierarchy[i].finalTransform.mProp.v.props),
                      t.transform(
                        e[0],
                        e[1],
                        e[2],
                        e[3],
                        e[4],
                        e[5],
                        e[6],
                        e[7],
                        e[8],
                        e[9],
                        e[10],
                        e[11],
                        e[12],
                        e[13],
                        e[14],
                        e[15]
                      )
              }
            },
            globalToLocal: function (e) {
              var t = []
              t.push(this.finalTransform)
              for (var i, r = !0, n = this.comp; r; )
                n.finalTransform
                  ? (n.data.hasMask && t.splice(0, 0, n.finalTransform), (n = n.comp))
                  : (r = !1)
              var a,
                o = t.length
              for (i = 0; i < o; i += 1)
                (a = t[i].mat.applyToPointArray(0, 0, 0)), (e = [e[0] - a[0], e[1] - a[1], 0])
              return e
            },
            mHelper: new Matrix()
          }),
          (RenderableElement.prototype = {
            initRenderable: function () {
              ;(this.isInRange = !1),
                (this.hidden = !1),
                (this.isTransparent = !1),
                (this.renderableComponents = [])
            },
            addRenderableComponent: function (e) {
              ;-1 === this.renderableComponents.indexOf(e) && this.renderableComponents.push(e)
            },
            removeRenderableComponent: function (e) {
              ;-1 !== this.renderableComponents.indexOf(e) &&
                this.renderableComponents.splice(this.renderableComponents.indexOf(e), 1)
            },
            prepareRenderableFrame: function (e) {
              this.checkLayerLimits(e)
            },
            checkTransparency: function () {
              this.finalTransform.mProp.o.v <= 0
                ? !this.isTransparent &&
                  this.globalData.renderConfig.hideOnTransparent &&
                  ((this.isTransparent = !0), this.hide())
                : this.isTransparent && ((this.isTransparent = !1), this.show())
            },
            checkLayerLimits: function (e) {
              this.data.ip - this.data.st <= e && this.data.op - this.data.st > e
                ? !0 !== this.isInRange &&
                  ((this.globalData._mdf = !0),
                  (this._mdf = !0),
                  (this.isInRange = !0),
                  this.show())
                : !1 !== this.isInRange &&
                  ((this.globalData._mdf = !0), (this.isInRange = !1), this.hide())
            },
            renderRenderable: function () {
              var e,
                t = this.renderableComponents.length
              for (e = 0; e < t; e += 1)
                this.renderableComponents[e].renderFrame(this._isFirstFrame)
            },
            sourceRectAtTime: function () {
              return { top: 0, left: 0, width: 100, height: 100 }
            },
            getLayerSize: function () {
              return 5 === this.data.ty
                ? { w: this.data.textData.width, h: this.data.textData.height }
                : { w: this.data.width, h: this.data.height }
            }
          }),
          extendPrototype(
            [
              RenderableElement,
              createProxyFunction({
                initElement: function (e, t, i) {
                  this.initFrame(),
                    this.initBaseData(e, t, i),
                    this.initTransform(e, t, i),
                    this.initHierarchy(),
                    this.initRenderable(),
                    this.initRendererElement(),
                    this.createContainerElements(),
                    this.createRenderableComponents(),
                    this.createContent(),
                    this.hide()
                },
                hide: function () {
                  this.hidden ||
                    (this.isInRange && !this.isTransparent) ||
                    (((this.baseElement || this.layerElement).style.display = 'none'),
                    (this.hidden = !0))
                },
                show: function () {
                  this.isInRange &&
                    !this.isTransparent &&
                    (this.data.hd ||
                      ((this.baseElement || this.layerElement).style.display = 'block'),
                    (this.hidden = !1),
                    (this._isFirstFrame = !0))
                },
                renderFrame: function () {
                  this.data.hd ||
                    this.hidden ||
                    (this.renderTransform(),
                    this.renderRenderable(),
                    this.renderElement(),
                    this.renderInnerContent(),
                    this._isFirstFrame && (this._isFirstFrame = !1))
                },
                renderInnerContent: function () {},
                prepareFrame: function (e) {
                  ;(this._mdf = !1),
                    this.prepareRenderableFrame(e),
                    this.prepareProperties(e, this.isInRange),
                    this.checkTransparency()
                },
                destroy: function () {
                  ;(this.innerElem = null), this.destroyBaseElement()
                }
              })
            ],
            RenderableDOMElement
          ),
          (SVGStyleData.prototype.reset = function () {
            ;(this.d = ''), (this._mdf = !1)
          }),
          (SVGShapeData.prototype.setAsAnimated = function () {
            this._isAnimated = !0
          }),
          extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData),
          extendPrototype([DynamicPropertyContainer], SVGFillStyleData),
          (SVGGradientFillStyleData.prototype.initGradientData = function (e, t, i) {
            ;(this.o = PropertyFactory.getProp(e, t.o, 0, 0.01, this)),
              (this.s = PropertyFactory.getProp(e, t.s, 1, null, this)),
              (this.e = PropertyFactory.getProp(e, t.e, 1, null, this)),
              (this.h = PropertyFactory.getProp(e, t.h || { k: 0 }, 0, 0.01, this)),
              (this.a = PropertyFactory.getProp(e, t.a || { k: 0 }, 0, degToRads, this)),
              (this.g = new GradientProperty(e, t.g, this)),
              (this.style = i),
              (this.stops = []),
              this.setGradientData(i.pElem, t),
              this.setGradientOpacity(t, i),
              (this._isAnimated = !!this._isAnimated)
          }),
          (SVGGradientFillStyleData.prototype.setGradientData = function (e, t) {
            var i = createElementID(),
              r = createNS(1 === t.t ? 'linearGradient' : 'radialGradient')
            r.setAttribute('id', i),
              r.setAttribute('spreadMethod', 'pad'),
              r.setAttribute('gradientUnits', 'userSpaceOnUse')
            var n,
              a,
              o,
              s = []
            for (o = 4 * t.g.p, a = 0; a < o; a += 4)
              (n = createNS('stop')), r.appendChild(n), s.push(n)
            e.setAttribute(
              'gf' === t.ty ? 'fill' : 'stroke',
              'url(' + locationHref + '#' + i + ')'
            ),
              (this.gf = r),
              (this.cst = s)
          }),
          (SVGGradientFillStyleData.prototype.setGradientOpacity = function (e, t) {
            if (this.g._hasOpacity && !this.g._collapsable) {
              var i,
                r,
                n,
                a = createNS('mask'),
                o = createNS('path')
              a.appendChild(o)
              var s = createElementID(),
                l = createElementID()
              a.setAttribute('id', l)
              var h = createNS(1 === e.t ? 'linearGradient' : 'radialGradient')
              h.setAttribute('id', s),
                h.setAttribute('spreadMethod', 'pad'),
                h.setAttribute('gradientUnits', 'userSpaceOnUse'),
                (n = e.g.k.k[0].s ? e.g.k.k[0].s.length : e.g.k.k.length)
              var u = this.stops
              for (r = 4 * e.g.p; r < n; r += 2)
                (i = createNS('stop')).setAttribute('stop-color', 'rgb(255,255,255)'),
                  h.appendChild(i),
                  u.push(i)
              o.setAttribute(
                'gf' === e.ty ? 'fill' : 'stroke',
                'url(' + locationHref + '#' + s + ')'
              ),
                (this.of = h),
                (this.ms = a),
                (this.ost = u),
                (this.maskId = l),
                (t.msElem = o)
            }
          }),
          extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData),
          extendPrototype(
            [SVGGradientFillStyleData, DynamicPropertyContainer],
            SVGGradientStrokeStyleData
          )
        var SVGElementsRenderer = (function () {
          var e = new Matrix(),
            t = new Matrix()
          function i(e, t, i) {
            ;(i || t.transform.op._mdf) &&
              t.transform.container.setAttribute('opacity', t.transform.op.v),
              (i || t.transform.mProps._mdf) &&
                t.transform.container.setAttribute('transform', t.transform.mProps.v.to2dCSS())
          }
          function r(i, r, n) {
            var a,
              o,
              s,
              l,
              h,
              u,
              p,
              c,
              d,
              f,
              m,
              g = r.styles.length,
              y = r.lvl
            for (u = 0; u < g; u += 1) {
              if (((l = r.sh._mdf || n), r.styles[u].lvl < y)) {
                for (
                  c = t.reset(), f = y - r.styles[u].lvl, m = r.transformers.length - 1;
                  !l && f > 0;

                )
                  (l = r.transformers[m].mProps._mdf || l), (f -= 1), (m -= 1)
                if (l)
                  for (f = y - r.styles[u].lvl, m = r.transformers.length - 1; f > 0; )
                    (d = r.transformers[m].mProps.v.props),
                      c.transform(
                        d[0],
                        d[1],
                        d[2],
                        d[3],
                        d[4],
                        d[5],
                        d[6],
                        d[7],
                        d[8],
                        d[9],
                        d[10],
                        d[11],
                        d[12],
                        d[13],
                        d[14],
                        d[15]
                      ),
                      (f -= 1),
                      (m -= 1)
              } else c = e
              if (((o = (p = r.sh.paths)._length), l)) {
                for (s = '', a = 0; a < o; a += 1)
                  (h = p.shapes[a]) && h._length && (s += buildShapeString(h, h._length, h.c, c))
                r.caches[u] = s
              } else s = r.caches[u]
              ;(r.styles[u].d += !0 === i.hd ? '' : s), (r.styles[u]._mdf = l || r.styles[u]._mdf)
            }
          }
          function n(e, t, i) {
            var r = t.style
            ;(t.c._mdf || i) &&
              r.pElem.setAttribute(
                'fill',
                'rgb(' + bmFloor(t.c.v[0]) + ',' + bmFloor(t.c.v[1]) + ',' + bmFloor(t.c.v[2]) + ')'
              ),
              (t.o._mdf || i) && r.pElem.setAttribute('fill-opacity', t.o.v)
          }
          function a(e, t, i) {
            o(e, t, i), s(0, t, i)
          }
          function o(e, t, i) {
            var r,
              n,
              a,
              o,
              s,
              l = t.gf,
              h = t.g._hasOpacity,
              u = t.s.v,
              p = t.e.v
            if (t.o._mdf || i) {
              var c = 'gf' === e.ty ? 'fill-opacity' : 'stroke-opacity'
              t.style.pElem.setAttribute(c, t.o.v)
            }
            if (t.s._mdf || i) {
              var d = 1 === e.t ? 'x1' : 'cx',
                f = 'x1' === d ? 'y1' : 'cy'
              l.setAttribute(d, u[0]),
                l.setAttribute(f, u[1]),
                h && !t.g._collapsable && (t.of.setAttribute(d, u[0]), t.of.setAttribute(f, u[1]))
            }
            if (t.g._cmdf || i) {
              r = t.cst
              var m = t.g.c
              for (a = r.length, n = 0; n < a; n += 1)
                (o = r[n]).setAttribute('offset', m[4 * n] + '%'),
                  o.setAttribute(
                    'stop-color',
                    'rgb(' + m[4 * n + 1] + ',' + m[4 * n + 2] + ',' + m[4 * n + 3] + ')'
                  )
            }
            if (h && (t.g._omdf || i)) {
              var g = t.g.o
              for (a = (r = t.g._collapsable ? t.cst : t.ost).length, n = 0; n < a; n += 1)
                (o = r[n]),
                  t.g._collapsable || o.setAttribute('offset', g[2 * n] + '%'),
                  o.setAttribute('stop-opacity', g[2 * n + 1])
            }
            if (1 === e.t)
              (t.e._mdf || i) &&
                (l.setAttribute('x2', p[0]),
                l.setAttribute('y2', p[1]),
                h &&
                  !t.g._collapsable &&
                  (t.of.setAttribute('x2', p[0]), t.of.setAttribute('y2', p[1])))
            else if (
              ((t.s._mdf || t.e._mdf || i) &&
                ((s = Math.sqrt(Math.pow(u[0] - p[0], 2) + Math.pow(u[1] - p[1], 2))),
                l.setAttribute('r', s),
                h && !t.g._collapsable && t.of.setAttribute('r', s)),
              t.e._mdf || t.h._mdf || t.a._mdf || i)
            ) {
              s || (s = Math.sqrt(Math.pow(u[0] - p[0], 2) + Math.pow(u[1] - p[1], 2)))
              var y = Math.atan2(p[1] - u[1], p[0] - u[0]),
                v = t.h.v
              v >= 1 ? (v = 0.99) : v <= -1 && (v = -0.99)
              var _ = s * v,
                x = Math.cos(y + t.a.v) * _ + u[0],
                S = Math.sin(y + t.a.v) * _ + u[1]
              l.setAttribute('fx', x),
                l.setAttribute('fy', S),
                h && !t.g._collapsable && (t.of.setAttribute('fx', x), t.of.setAttribute('fy', S))
            }
          }
          function s(e, t, i) {
            var r = t.style,
              n = t.d
            n &&
              (n._mdf || i) &&
              n.dashStr &&
              (r.pElem.setAttribute('stroke-dasharray', n.dashStr),
              r.pElem.setAttribute('stroke-dashoffset', n.dashoffset[0])),
              t.c &&
                (t.c._mdf || i) &&
                r.pElem.setAttribute(
                  'stroke',
                  'rgb(' +
                    bmFloor(t.c.v[0]) +
                    ',' +
                    bmFloor(t.c.v[1]) +
                    ',' +
                    bmFloor(t.c.v[2]) +
                    ')'
                ),
              (t.o._mdf || i) && r.pElem.setAttribute('stroke-opacity', t.o.v),
              (t.w._mdf || i) &&
                (r.pElem.setAttribute('stroke-width', t.w.v),
                r.msElem && r.msElem.setAttribute('stroke-width', t.w.v))
          }
          return {
            createRenderFunction: function (e) {
              switch (e.ty) {
                case 'fl':
                  return n
                case 'gf':
                  return o
                case 'gs':
                  return a
                case 'st':
                  return s
                case 'sh':
                case 'el':
                case 'rc':
                case 'sr':
                  return r
                case 'tr':
                  return i
                default:
                  return null
              }
            }
          }
        })()
        function ShapeTransformManager() {
          ;(this.sequences = {}), (this.sequenceList = []), (this.transform_key_count = 0)
        }
        function CVShapeData(e, t, i, r) {
          ;(this.styledShapes = []), (this.tr = [0, 0, 0, 0, 0, 0])
          var n,
            a = 4
          'rc' === t.ty ? (a = 5) : 'el' === t.ty ? (a = 6) : 'sr' === t.ty && (a = 7),
            (this.sh = ShapePropertyFactory.getShapeProp(e, t, a, e))
          var o,
            s = i.length
          for (n = 0; n < s; n += 1)
            i[n].closed ||
              ((o = { transforms: r.addTransformSequence(i[n].transforms), trNodes: [] }),
              this.styledShapes.push(o),
              i[n].elements.push(o))
        }
        function BaseElement() {}
        function NullElement(e, t, i) {
          this.initFrame(),
            this.initBaseData(e, t, i),
            this.initFrame(),
            this.initTransform(e, t, i),
            this.initHierarchy()
        }
        function SVGBaseElement() {}
        function IShapeElement() {}
        function ITextElement() {}
        function ICompElement() {}
        function IImageElement(e, t, i) {
          ;(this.assetData = t.getAssetData(e.refId)),
            this.initElement(e, t, i),
            (this.sourceRect = {
              top: 0,
              left: 0,
              width: this.assetData.w,
              height: this.assetData.h
            })
        }
        function ISolidElement(e, t, i) {
          this.initElement(e, t, i)
        }
        function AudioElement(e, t, i) {
          this.initFrame(),
            this.initRenderable(),
            (this.assetData = t.getAssetData(e.refId)),
            this.initBaseData(e, t, i),
            (this._isPlaying = !1),
            (this._canPlay = !1)
          var r = this.globalData.getAssetsPath(this.assetData)
          ;(this.audio = this.globalData.audioController.createAudio(r)),
            (this._currentTime = 0),
            this.globalData.audioController.addAudio(this),
            (this.tm = e.tm
              ? PropertyFactory.getProp(this, e.tm, 0, t.frameRate, this)
              : { _placeholder: !0 })
        }
        function FootageElement(e, t, i) {
          this.initFrame(),
            this.initRenderable(),
            (this.assetData = t.getAssetData(e.refId)),
            (this.footageData = t.imageLoader.getAsset(this.assetData)),
            this.initBaseData(e, t, i)
        }
        function SVGCompElement(e, t, i) {
          ;(this.layers = e.layers),
            (this.supports3d = !0),
            (this.completeLayers = !1),
            (this.pendingElements = []),
            (this.elements = this.layers ? createSizedArray(this.layers.length) : []),
            this.initElement(e, t, i),
            (this.tm = e.tm
              ? PropertyFactory.getProp(this, e.tm, 0, t.frameRate, this)
              : { _placeholder: !0 })
        }
        function SVGTextLottieElement(e, t, i) {
          ;(this.textSpans = []), (this.renderType = 'svg'), this.initElement(e, t, i)
        }
        function SVGShapeElement(e, t, i) {
          ;(this.shapes = []),
            (this.shapesData = e.shapes),
            (this.stylesList = []),
            (this.shapeModifiers = []),
            (this.itemsData = []),
            (this.processedElements = []),
            (this.animatedContents = []),
            this.initElement(e, t, i),
            (this.prevViewData = [])
        }
        function SVGTintFilter(e, t) {
          this.filterManager = t
          var i = createNS('feColorMatrix')
          if (
            (i.setAttribute('type', 'matrix'),
            i.setAttribute('color-interpolation-filters', 'linearRGB'),
            i.setAttribute(
              'values',
              '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0'
            ),
            i.setAttribute('result', 'f1'),
            e.appendChild(i),
            (i = createNS('feColorMatrix')).setAttribute('type', 'matrix'),
            i.setAttribute('color-interpolation-filters', 'sRGB'),
            i.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0'),
            i.setAttribute('result', 'f2'),
            e.appendChild(i),
            (this.matrixFilter = i),
            100 !== t.effectElements[2].p.v || t.effectElements[2].p.k)
          ) {
            var r,
              n = createNS('feMerge')
            e.appendChild(n),
              (r = createNS('feMergeNode')).setAttribute('in', 'SourceGraphic'),
              n.appendChild(r),
              (r = createNS('feMergeNode')).setAttribute('in', 'f2'),
              n.appendChild(r)
          }
        }
        function SVGFillFilter(e, t) {
          this.filterManager = t
          var i = createNS('feColorMatrix')
          i.setAttribute('type', 'matrix'),
            i.setAttribute('color-interpolation-filters', 'sRGB'),
            i.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0'),
            e.appendChild(i),
            (this.matrixFilter = i)
        }
        function SVGGaussianBlurEffect(e, t) {
          e.setAttribute('x', '-100%'),
            e.setAttribute('y', '-100%'),
            e.setAttribute('width', '300%'),
            e.setAttribute('height', '300%'),
            (this.filterManager = t)
          var i = createNS('feGaussianBlur')
          e.appendChild(i), (this.feGaussianBlur = i)
        }
        function SVGStrokeEffect(e, t) {
          ;(this.initialized = !1), (this.filterManager = t), (this.elem = e), (this.paths = [])
        }
        function SVGTritoneFilter(e, t) {
          this.filterManager = t
          var i = createNS('feColorMatrix')
          i.setAttribute('type', 'matrix'),
            i.setAttribute('color-interpolation-filters', 'linearRGB'),
            i.setAttribute(
              'values',
              '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0'
            ),
            i.setAttribute('result', 'f1'),
            e.appendChild(i)
          var r = createNS('feComponentTransfer')
          r.setAttribute('color-interpolation-filters', 'sRGB'),
            e.appendChild(r),
            (this.matrixFilter = r)
          var n = createNS('feFuncR')
          n.setAttribute('type', 'table'), r.appendChild(n), (this.feFuncR = n)
          var a = createNS('feFuncG')
          a.setAttribute('type', 'table'), r.appendChild(a), (this.feFuncG = a)
          var o = createNS('feFuncB')
          o.setAttribute('type', 'table'), r.appendChild(o), (this.feFuncB = o)
        }
        function SVGProLevelsFilter(e, t) {
          this.filterManager = t
          var i = this.filterManager.effectElements,
            r = createNS('feComponentTransfer')
          ;(i[10].p.k ||
            0 !== i[10].p.v ||
            i[11].p.k ||
            1 !== i[11].p.v ||
            i[12].p.k ||
            1 !== i[12].p.v ||
            i[13].p.k ||
            0 !== i[13].p.v ||
            i[14].p.k ||
            1 !== i[14].p.v) &&
            (this.feFuncR = this.createFeFunc('feFuncR', r)),
            (i[17].p.k ||
              0 !== i[17].p.v ||
              i[18].p.k ||
              1 !== i[18].p.v ||
              i[19].p.k ||
              1 !== i[19].p.v ||
              i[20].p.k ||
              0 !== i[20].p.v ||
              i[21].p.k ||
              1 !== i[21].p.v) &&
              (this.feFuncG = this.createFeFunc('feFuncG', r)),
            (i[24].p.k ||
              0 !== i[24].p.v ||
              i[25].p.k ||
              1 !== i[25].p.v ||
              i[26].p.k ||
              1 !== i[26].p.v ||
              i[27].p.k ||
              0 !== i[27].p.v ||
              i[28].p.k ||
              1 !== i[28].p.v) &&
              (this.feFuncB = this.createFeFunc('feFuncB', r)),
            (i[31].p.k ||
              0 !== i[31].p.v ||
              i[32].p.k ||
              1 !== i[32].p.v ||
              i[33].p.k ||
              1 !== i[33].p.v ||
              i[34].p.k ||
              0 !== i[34].p.v ||
              i[35].p.k ||
              1 !== i[35].p.v) &&
              (this.feFuncA = this.createFeFunc('feFuncA', r)),
            (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) &&
              (r.setAttribute('color-interpolation-filters', 'sRGB'),
              e.appendChild(r),
              (r = createNS('feComponentTransfer'))),
            (i[3].p.k ||
              0 !== i[3].p.v ||
              i[4].p.k ||
              1 !== i[4].p.v ||
              i[5].p.k ||
              1 !== i[5].p.v ||
              i[6].p.k ||
              0 !== i[6].p.v ||
              i[7].p.k ||
              1 !== i[7].p.v) &&
              (r.setAttribute('color-interpolation-filters', 'sRGB'),
              e.appendChild(r),
              (this.feFuncRComposed = this.createFeFunc('feFuncR', r)),
              (this.feFuncGComposed = this.createFeFunc('feFuncG', r)),
              (this.feFuncBComposed = this.createFeFunc('feFuncB', r)))
        }
        function SVGDropShadowEffect(e, t) {
          var i = t.container.globalData.renderConfig.filterSize
          e.setAttribute('x', i.x),
            e.setAttribute('y', i.y),
            e.setAttribute('width', i.width),
            e.setAttribute('height', i.height),
            (this.filterManager = t)
          var r = createNS('feGaussianBlur')
          r.setAttribute('in', 'SourceAlpha'),
            r.setAttribute('result', 'drop_shadow_1'),
            r.setAttribute('stdDeviation', '0'),
            (this.feGaussianBlur = r),
            e.appendChild(r)
          var n = createNS('feOffset')
          n.setAttribute('dx', '25'),
            n.setAttribute('dy', '0'),
            n.setAttribute('in', 'drop_shadow_1'),
            n.setAttribute('result', 'drop_shadow_2'),
            (this.feOffset = n),
            e.appendChild(n)
          var a = createNS('feFlood')
          a.setAttribute('flood-color', '#00ff00'),
            a.setAttribute('flood-opacity', '1'),
            a.setAttribute('result', 'drop_shadow_3'),
            (this.feFlood = a),
            e.appendChild(a)
          var o = createNS('feComposite')
          o.setAttribute('in', 'drop_shadow_3'),
            o.setAttribute('in2', 'drop_shadow_2'),
            o.setAttribute('operator', 'in'),
            o.setAttribute('result', 'drop_shadow_4'),
            e.appendChild(o)
          var s,
            l = createNS('feMerge')
          e.appendChild(l),
            (s = createNS('feMergeNode')),
            l.appendChild(s),
            (s = createNS('feMergeNode')).setAttribute('in', 'SourceGraphic'),
            (this.feMergeNode = s),
            (this.feMerge = l),
            (this.originalNodeAdded = !1),
            l.appendChild(s)
        }
        ;(ShapeTransformManager.prototype = {
          addTransformSequence: function (e) {
            var t,
              i = e.length,
              r = '_'
            for (t = 0; t < i; t += 1) r += e[t].transform.key + '_'
            var n = this.sequences[r]
            return (
              n ||
                ((n = { transforms: [].concat(e), finalTransform: new Matrix(), _mdf: !1 }),
                (this.sequences[r] = n),
                this.sequenceList.push(n)),
              n
            )
          },
          processSequence: function (e, t) {
            for (var i, r = 0, n = e.transforms.length, a = t; r < n && !t; ) {
              if (e.transforms[r].transform.mProps._mdf) {
                a = !0
                break
              }
              r += 1
            }
            if (a)
              for (e.finalTransform.reset(), r = n - 1; r >= 0; r -= 1)
                (i = e.transforms[r].transform.mProps.v.props),
                  e.finalTransform.transform(
                    i[0],
                    i[1],
                    i[2],
                    i[3],
                    i[4],
                    i[5],
                    i[6],
                    i[7],
                    i[8],
                    i[9],
                    i[10],
                    i[11],
                    i[12],
                    i[13],
                    i[14],
                    i[15]
                  )
            e._mdf = a
          },
          processSequences: function (e) {
            var t,
              i = this.sequenceList.length
            for (t = 0; t < i; t += 1) this.processSequence(this.sequenceList[t], e)
          },
          getNewKey: function () {
            return (this.transform_key_count += 1), '_' + this.transform_key_count
          }
        }),
          (CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated),
          (BaseElement.prototype = {
            checkMasks: function () {
              if (!this.data.hasMask) return !1
              for (var e = 0, t = this.data.masksProperties.length; e < t; ) {
                if (
                  'n' !== this.data.masksProperties[e].mode &&
                  !1 !== this.data.masksProperties[e].cl
                )
                  return !0
                e += 1
              }
              return !1
            },
            initExpressions: function () {
              ;(this.layerInterface = LayerExpressionInterface(this)),
                this.data.hasMask &&
                  this.maskManager &&
                  this.layerInterface.registerMaskInterface(this.maskManager)
              var e = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface)
              this.layerInterface.registerEffectsInterface(e),
                0 === this.data.ty || this.data.xt
                  ? (this.compInterface = CompExpressionInterface(this))
                  : 4 === this.data.ty
                  ? ((this.layerInterface.shapeInterface = ShapeExpressionInterface(
                      this.shapesData,
                      this.itemsData,
                      this.layerInterface
                    )),
                    (this.layerInterface.content = this.layerInterface.shapeInterface))
                  : 5 === this.data.ty &&
                    ((this.layerInterface.textInterface = TextExpressionInterface(this)),
                    (this.layerInterface.text = this.layerInterface.textInterface))
            },
            setBlendMode: function () {
              var e = getBlendMode(this.data.bm)
              ;(this.baseElement || this.layerElement).style['mix-blend-mode'] = e
            },
            initBaseData: function (e, t, i) {
              ;(this.globalData = t),
                (this.comp = i),
                (this.data = e),
                (this.layerId = createElementID()),
                this.data.sr || (this.data.sr = 1),
                (this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties))
            },
            getType: function () {
              return this.type
            },
            sourceRectAtTime: function () {}
          }),
          (NullElement.prototype.prepareFrame = function (e) {
            this.prepareProperties(e, !0)
          }),
          (NullElement.prototype.renderFrame = function () {}),
          (NullElement.prototype.getBaseElement = function () {
            return null
          }),
          (NullElement.prototype.destroy = function () {}),
          (NullElement.prototype.sourceRectAtTime = function () {}),
          (NullElement.prototype.hide = function () {}),
          extendPrototype(
            [BaseElement, TransformElement, HierarchyElement, FrameElement],
            NullElement
          ),
          (SVGBaseElement.prototype = {
            initRendererElement: function () {
              this.layerElement = createNS('g')
            },
            createContainerElements: function () {
              ;(this.matteElement = createNS('g')),
                (this.transformedElement = this.layerElement),
                (this.maskedElement = this.layerElement),
                (this._sizeChanged = !1)
              var e,
                t,
                i,
                r = null
              if (this.data.td) {
                if (3 == this.data.td || 1 == this.data.td) {
                  var n = createNS('mask')
                  n.setAttribute('id', this.layerId),
                    n.setAttribute('mask-type', 3 == this.data.td ? 'luminance' : 'alpha'),
                    n.appendChild(this.layerElement),
                    (r = n),
                    this.globalData.defs.appendChild(n),
                    featureSupport.maskType ||
                      1 != this.data.td ||
                      (n.setAttribute('mask-type', 'luminance'),
                      (e = createElementID()),
                      (t = filtersFactory.createFilter(e)),
                      this.globalData.defs.appendChild(t),
                      t.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                      (i = createNS('g')).appendChild(this.layerElement),
                      (r = i),
                      n.appendChild(i),
                      i.setAttribute('filter', 'url(' + locationHref + '#' + e + ')'))
                } else if (2 == this.data.td) {
                  var a = createNS('mask')
                  a.setAttribute('id', this.layerId), a.setAttribute('mask-type', 'alpha')
                  var o = createNS('g')
                  a.appendChild(o), (e = createElementID()), (t = filtersFactory.createFilter(e))
                  var s = createNS('feComponentTransfer')
                  s.setAttribute('in', 'SourceGraphic'), t.appendChild(s)
                  var l = createNS('feFuncA')
                  l.setAttribute('type', 'table'),
                    l.setAttribute('tableValues', '1.0 0.0'),
                    s.appendChild(l),
                    this.globalData.defs.appendChild(t)
                  var h = createNS('rect')
                  h.setAttribute('width', this.comp.data.w),
                    h.setAttribute('height', this.comp.data.h),
                    h.setAttribute('x', '0'),
                    h.setAttribute('y', '0'),
                    h.setAttribute('fill', '#ffffff'),
                    h.setAttribute('opacity', '0'),
                    o.setAttribute('filter', 'url(' + locationHref + '#' + e + ')'),
                    o.appendChild(h),
                    o.appendChild(this.layerElement),
                    (r = o),
                    featureSupport.maskType ||
                      (a.setAttribute('mask-type', 'luminance'),
                      t.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                      (i = createNS('g')),
                      o.appendChild(h),
                      i.appendChild(this.layerElement),
                      (r = i),
                      o.appendChild(i)),
                    this.globalData.defs.appendChild(a)
                }
              } else
                this.data.tt
                  ? (this.matteElement.appendChild(this.layerElement),
                    (r = this.matteElement),
                    (this.baseElement = this.matteElement))
                  : (this.baseElement = this.layerElement)
              if (
                (this.data.ln && this.layerElement.setAttribute('id', this.data.ln),
                this.data.cl && this.layerElement.setAttribute('class', this.data.cl),
                0 === this.data.ty && !this.data.hd)
              ) {
                var u = createNS('clipPath'),
                  p = createNS('path')
                p.setAttribute(
                  'd',
                  'M0,0 L' +
                    this.data.w +
                    ',0 L' +
                    this.data.w +
                    ',' +
                    this.data.h +
                    ' L0,' +
                    this.data.h +
                    'z'
                )
                var c = createElementID()
                if (
                  (u.setAttribute('id', c),
                  u.appendChild(p),
                  this.globalData.defs.appendChild(u),
                  this.checkMasks())
                ) {
                  var d = createNS('g')
                  d.setAttribute('clip-path', 'url(' + locationHref + '#' + c + ')'),
                    d.appendChild(this.layerElement),
                    (this.transformedElement = d),
                    r
                      ? r.appendChild(this.transformedElement)
                      : (this.baseElement = this.transformedElement)
                } else
                  this.layerElement.setAttribute('clip-path', 'url(' + locationHref + '#' + c + ')')
              }
              0 !== this.data.bm && this.setBlendMode()
            },
            renderElement: function () {
              this.finalTransform._matMdf &&
                this.transformedElement.setAttribute(
                  'transform',
                  this.finalTransform.mat.to2dCSS()
                ),
                this.finalTransform._opMdf &&
                  this.transformedElement.setAttribute('opacity', this.finalTransform.mProp.o.v)
            },
            destroyBaseElement: function () {
              ;(this.layerElement = null), (this.matteElement = null), this.maskManager.destroy()
            },
            getBaseElement: function () {
              return this.data.hd ? null : this.baseElement
            },
            createRenderableComponents: function () {
              ;(this.maskManager = new MaskElement(this.data, this, this.globalData)),
                (this.renderableEffectsManager = new SVGEffects(this))
            },
            setMatte: function (e) {
              this.matteElement &&
                this.matteElement.setAttribute('mask', 'url(' + locationHref + '#' + e + ')')
            }
          }),
          (IShapeElement.prototype = {
            addShapeToModifiers: function (e) {
              var t,
                i = this.shapeModifiers.length
              for (t = 0; t < i; t += 1) this.shapeModifiers[t].addShape(e)
            },
            isShapeInAnimatedModifiers: function (e) {
              for (var t = this.shapeModifiers.length; 0 < t; )
                if (this.shapeModifiers[0].isAnimatedWithShape(e)) return !0
              return !1
            },
            renderModifiers: function () {
              if (this.shapeModifiers.length) {
                var e,
                  t = this.shapes.length
                for (e = 0; e < t; e += 1) this.shapes[e].sh.reset()
                for (
                  e = (t = this.shapeModifiers.length) - 1;
                  e >= 0 && !this.shapeModifiers[e].processShapes(this._isFirstFrame);
                  e -= 1
                );
              }
            },
            lcEnum: { 1: 'butt', 2: 'round', 3: 'square' },
            ljEnum: { 1: 'miter', 2: 'round', 3: 'bevel' },
            searchProcessedElement: function (e) {
              for (var t = this.processedElements, i = 0, r = t.length; i < r; ) {
                if (t[i].elem === e) return t[i].pos
                i += 1
              }
              return 0
            },
            addProcessedElement: function (e, t) {
              for (var i = this.processedElements, r = i.length; r; )
                if (i[(r -= 1)].elem === e) return void (i[r].pos = t)
              i.push(new ProcessedElement(e, t))
            },
            prepareFrame: function (e) {
              this.prepareRenderableFrame(e), this.prepareProperties(e, this.isInRange)
            }
          }),
          (ITextElement.prototype.initElement = function (e, t, i) {
            ;(this.lettersChangedFlag = !0),
              this.initFrame(),
              this.initBaseData(e, t, i),
              (this.textProperty = new TextProperty(this, e.t, this.dynamicProperties)),
              (this.textAnimator = new TextAnimatorProperty(e.t, this.renderType, this)),
              this.initTransform(e, t, i),
              this.initHierarchy(),
              this.initRenderable(),
              this.initRendererElement(),
              this.createContainerElements(),
              this.createRenderableComponents(),
              this.createContent(),
              this.hide(),
              this.textAnimator.searchProperties(this.dynamicProperties)
          }),
          (ITextElement.prototype.prepareFrame = function (e) {
            ;(this._mdf = !1),
              this.prepareRenderableFrame(e),
              this.prepareProperties(e, this.isInRange),
              (this.textProperty._mdf || this.textProperty._isFirstFrame) &&
                (this.buildNewText(),
                (this.textProperty._isFirstFrame = !1),
                (this.textProperty._mdf = !1))
          }),
          (ITextElement.prototype.createPathShape = function (e, t) {
            var i,
              r,
              n = t.length,
              a = ''
            for (i = 0; i < n; i += 1)
              (r = t[i].ks.k), (a += buildShapeString(r, r.i.length, !0, e))
            return a
          }),
          (ITextElement.prototype.updateDocumentData = function (e, t) {
            this.textProperty.updateDocumentData(e, t)
          }),
          (ITextElement.prototype.canResizeFont = function (e) {
            this.textProperty.canResizeFont(e)
          }),
          (ITextElement.prototype.setMinimumFontSize = function (e) {
            this.textProperty.setMinimumFontSize(e)
          }),
          (ITextElement.prototype.applyTextPropertiesToMatrix = function (e, t, i, r, n) {
            switch (
              (e.ps && t.translate(e.ps[0], e.ps[1] + e.ascent, 0), t.translate(0, -e.ls, 0), e.j)
            ) {
              case 1:
                t.translate(e.justifyOffset + (e.boxWidth - e.lineWidths[i]), 0, 0)
                break
              case 2:
                t.translate(e.justifyOffset + (e.boxWidth - e.lineWidths[i]) / 2, 0, 0)
            }
            t.translate(r, n, 0)
          }),
          (ITextElement.prototype.buildColor = function (e) {
            return (
              'rgb(' +
              Math.round(255 * e[0]) +
              ',' +
              Math.round(255 * e[1]) +
              ',' +
              Math.round(255 * e[2]) +
              ')'
            )
          }),
          (ITextElement.prototype.emptyProp = new LetterProps()),
          (ITextElement.prototype.destroy = function () {}),
          extendPrototype(
            [BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement],
            ICompElement
          ),
          (ICompElement.prototype.initElement = function (e, t, i) {
            this.initFrame(),
              this.initBaseData(e, t, i),
              this.initTransform(e, t, i),
              this.initRenderable(),
              this.initHierarchy(),
              this.initRendererElement(),
              this.createContainerElements(),
              this.createRenderableComponents(),
              (!this.data.xt && t.progressiveLoad) || this.buildAllItems(),
              this.hide()
          }),
          (ICompElement.prototype.prepareFrame = function (e) {
            if (
              ((this._mdf = !1),
              this.prepareRenderableFrame(e),
              this.prepareProperties(e, this.isInRange),
              this.isInRange || this.data.xt)
            ) {
              if (this.tm._placeholder) this.renderedFrame = e / this.data.sr
              else {
                var t = this.tm.v
                t === this.data.op && (t = this.data.op - 1), (this.renderedFrame = t)
              }
              var i,
                r = this.elements.length
              for (
                this.completeLayers || this.checkLayers(this.renderedFrame), i = r - 1;
                i >= 0;
                i -= 1
              )
                (this.completeLayers || this.elements[i]) &&
                  (this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st),
                  this.elements[i]._mdf && (this._mdf = !0))
            }
          }),
          (ICompElement.prototype.renderInnerContent = function () {
            var e,
              t = this.layers.length
            for (e = 0; e < t; e += 1)
              (this.completeLayers || this.elements[e]) && this.elements[e].renderFrame()
          }),
          (ICompElement.prototype.setElements = function (e) {
            this.elements = e
          }),
          (ICompElement.prototype.getElements = function () {
            return this.elements
          }),
          (ICompElement.prototype.destroyElements = function () {
            var e,
              t = this.layers.length
            for (e = 0; e < t; e += 1) this.elements[e] && this.elements[e].destroy()
          }),
          (ICompElement.prototype.destroy = function () {
            this.destroyElements(), this.destroyBaseElement()
          }),
          extendPrototype(
            [
              BaseElement,
              TransformElement,
              SVGBaseElement,
              HierarchyElement,
              FrameElement,
              RenderableDOMElement
            ],
            IImageElement
          ),
          (IImageElement.prototype.createContent = function () {
            var e = this.globalData.getAssetsPath(this.assetData)
            ;(this.innerElem = createNS('image')),
              this.innerElem.setAttribute('width', this.assetData.w + 'px'),
              this.innerElem.setAttribute('height', this.assetData.h + 'px'),
              this.innerElem.setAttribute(
                'preserveAspectRatio',
                this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio
              ),
              this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', e),
              this.layerElement.appendChild(this.innerElem)
          }),
          (IImageElement.prototype.sourceRectAtTime = function () {
            return this.sourceRect
          }),
          extendPrototype([IImageElement], ISolidElement),
          (ISolidElement.prototype.createContent = function () {
            var e = createNS('rect')
            e.setAttribute('width', this.data.sw),
              e.setAttribute('height', this.data.sh),
              e.setAttribute('fill', this.data.sc),
              this.layerElement.appendChild(e)
          }),
          (AudioElement.prototype.prepareFrame = function (e) {
            if (
              (this.prepareRenderableFrame(e, !0),
              this.prepareProperties(e, !0),
              this.tm._placeholder)
            )
              this._currentTime = e / this.data.sr
            else {
              var t = this.tm.v
              this._currentTime = t
            }
          }),
          extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement),
          (AudioElement.prototype.renderFrame = function () {
            this.isInRange &&
              this._canPlay &&
              (this._isPlaying
                ? (!this.audio.playing() ||
                    Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) >
                      0.1) &&
                  this.audio.seek(this._currentTime / this.globalData.frameRate)
                : (this.audio.play(),
                  this.audio.seek(this._currentTime / this.globalData.frameRate),
                  (this._isPlaying = !0)))
          }),
          (AudioElement.prototype.show = function () {}),
          (AudioElement.prototype.hide = function () {
            this.audio.pause(), (this._isPlaying = !1)
          }),
          (AudioElement.prototype.pause = function () {
            this.audio.pause(), (this._isPlaying = !1), (this._canPlay = !1)
          }),
          (AudioElement.prototype.resume = function () {
            this._canPlay = !0
          }),
          (AudioElement.prototype.setRate = function (e) {
            this.audio.rate(e)
          }),
          (AudioElement.prototype.volume = function (e) {
            this.audio.volume(e)
          }),
          (AudioElement.prototype.getBaseElement = function () {
            return null
          }),
          (AudioElement.prototype.destroy = function () {}),
          (AudioElement.prototype.sourceRectAtTime = function () {}),
          (AudioElement.prototype.initExpressions = function () {}),
          (FootageElement.prototype.prepareFrame = function () {}),
          extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement),
          (FootageElement.prototype.getBaseElement = function () {
            return null
          }),
          (FootageElement.prototype.renderFrame = function () {}),
          (FootageElement.prototype.destroy = function () {}),
          (FootageElement.prototype.initExpressions = function () {
            this.layerInterface = FootageInterface(this)
          }),
          (FootageElement.prototype.getFootageData = function () {
            return this.footageData
          }),
          extendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement),
          extendPrototype(
            [
              BaseElement,
              TransformElement,
              SVGBaseElement,
              HierarchyElement,
              FrameElement,
              RenderableDOMElement,
              ITextElement
            ],
            SVGTextLottieElement
          ),
          (SVGTextLottieElement.prototype.createContent = function () {
            this.data.singleShape &&
              !this.globalData.fontManager.chars &&
              (this.textContainer = createNS('text'))
          }),
          (SVGTextLottieElement.prototype.buildTextContents = function (e) {
            for (var t = 0, i = e.length, r = [], n = ''; t < i; )
              e[t] === String.fromCharCode(13) || e[t] === String.fromCharCode(3)
                ? (r.push(n), (n = ''))
                : (n += e[t]),
                (t += 1)
            return r.push(n), r
          }),
          (SVGTextLottieElement.prototype.buildNewText = function () {
            var e,
              t,
              i = this.textProperty.currentData
            ;(this.renderedLetters = createSizedArray(i ? i.l.length : 0)),
              i.fc
                ? this.layerElement.setAttribute('fill', this.buildColor(i.fc))
                : this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)'),
              i.sc &&
                (this.layerElement.setAttribute('stroke', this.buildColor(i.sc)),
                this.layerElement.setAttribute('stroke-width', i.sw)),
              this.layerElement.setAttribute('font-size', i.finalSize)
            var r = this.globalData.fontManager.getFontByName(i.f)
            if (r.fClass) this.layerElement.setAttribute('class', r.fClass)
            else {
              this.layerElement.setAttribute('font-family', r.fFamily)
              var n = i.fWeight,
                a = i.fStyle
              this.layerElement.setAttribute('font-style', a),
                this.layerElement.setAttribute('font-weight', n)
            }
            this.layerElement.setAttribute('aria-label', i.t)
            var o,
              s = i.l || [],
              l = !!this.globalData.fontManager.chars
            t = s.length
            var h,
              u = this.mHelper,
              p = '',
              c = this.data.singleShape,
              d = 0,
              f = 0,
              m = !0,
              g = 0.001 * i.tr * i.finalSize
            if (!c || l || i.sz) {
              var y,
                v,
                _ = this.textSpans.length
              for (e = 0; e < t; e += 1)
                (l && c && 0 !== e) ||
                  ((o = _ > e ? this.textSpans[e] : createNS(l ? 'path' : 'text')),
                  _ <= e &&
                    (o.setAttribute('stroke-linecap', 'butt'),
                    o.setAttribute('stroke-linejoin', 'round'),
                    o.setAttribute('stroke-miterlimit', '4'),
                    (this.textSpans[e] = o),
                    this.layerElement.appendChild(o)),
                  (o.style.display = 'inherit')),
                  u.reset(),
                  u.scale(i.finalSize / 100, i.finalSize / 100),
                  c &&
                    (s[e].n && ((d = -g), (f += i.yOffset), (f += m ? 1 : 0), (m = !1)),
                    this.applyTextPropertiesToMatrix(i, u, s[e].line, d, f),
                    (d += s[e].l || 0),
                    (d += g)),
                  l
                    ? ((h = (y =
                        ((v = this.globalData.fontManager.getCharData(
                          i.finalText[e],
                          r.fStyle,
                          this.globalData.fontManager.getFontByName(i.f).fFamily
                        )) &&
                          v.data) ||
                        {}).shapes
                        ? y.shapes[0].it
                        : []),
                      c
                        ? (p += this.createPathShape(u, h))
                        : o.setAttribute('d', this.createPathShape(u, h)))
                    : (c &&
                        o.setAttribute(
                          'transform',
                          'translate(' + u.props[12] + ',' + u.props[13] + ')'
                        ),
                      (o.textContent = s[e].val),
                      o.setAttributeNS(
                        'http://www.w3.org/XML/1998/namespace',
                        'xml:space',
                        'preserve'
                      ))
              c && o && o.setAttribute('d', p)
            } else {
              var x = this.textContainer,
                S = 'start'
              switch (i.j) {
                case 1:
                  S = 'end'
                  break
                case 2:
                  S = 'middle'
                  break
                default:
                  S = 'start'
              }
              x.setAttribute('text-anchor', S), x.setAttribute('letter-spacing', g)
              var b = this.buildTextContents(i.finalText)
              for (t = b.length, f = i.ps ? i.ps[1] + i.ascent : 0, e = 0; e < t; e += 1)
                ((o = this.textSpans[e] || createNS('tspan')).textContent = b[e]),
                  o.setAttribute('x', 0),
                  o.setAttribute('y', f),
                  (o.style.display = 'inherit'),
                  x.appendChild(o),
                  (this.textSpans[e] = o),
                  (f += i.finalLineHeight)
              this.layerElement.appendChild(x)
            }
            for (; e < this.textSpans.length; ) (this.textSpans[e].style.display = 'none'), (e += 1)
            this._sizeChanged = !0
          }),
          (SVGTextLottieElement.prototype.sourceRectAtTime = function () {
            if (
              (this.prepareFrame(this.comp.renderedFrame - this.data.st),
              this.renderInnerContent(),
              this._sizeChanged)
            ) {
              this._sizeChanged = !1
              var e = this.layerElement.getBBox()
              this.bbox = { top: e.y, left: e.x, width: e.width, height: e.height }
            }
            return this.bbox
          }),
          (SVGTextLottieElement.prototype.renderInnerContent = function () {
            if (
              !this.data.singleShape &&
              (this.textAnimator.getMeasures(
                this.textProperty.currentData,
                this.lettersChangedFlag
              ),
              this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)
            ) {
              var e, t
              this._sizeChanged = !0
              var i,
                r,
                n = this.textAnimator.renderedLetters,
                a = this.textProperty.currentData.l
              for (t = a.length, e = 0; e < t; e += 1)
                a[e].n ||
                  ((i = n[e]),
                  (r = this.textSpans[e]),
                  i._mdf.m && r.setAttribute('transform', i.m),
                  i._mdf.o && r.setAttribute('opacity', i.o),
                  i._mdf.sw && r.setAttribute('stroke-width', i.sw),
                  i._mdf.sc && r.setAttribute('stroke', i.sc),
                  i._mdf.fc && r.setAttribute('fill', i.fc))
            }
          }),
          extendPrototype(
            [
              BaseElement,
              TransformElement,
              SVGBaseElement,
              IShapeElement,
              HierarchyElement,
              FrameElement,
              RenderableDOMElement
            ],
            SVGShapeElement
          ),
          (SVGShapeElement.prototype.initSecondaryElement = function () {}),
          (SVGShapeElement.prototype.identityMatrix = new Matrix()),
          (SVGShapeElement.prototype.buildExpressionInterface = function () {}),
          (SVGShapeElement.prototype.createContent = function () {
            this.searchShapes(
              this.shapesData,
              this.itemsData,
              this.prevViewData,
              this.layerElement,
              0,
              [],
              !0
            ),
              this.filterUniqueShapes()
          }),
          (SVGShapeElement.prototype.filterUniqueShapes = function () {
            var e,
              t,
              i,
              r,
              n = this.shapes.length,
              a = this.stylesList.length,
              o = [],
              s = !1
            for (i = 0; i < a; i += 1) {
              for (r = this.stylesList[i], s = !1, o.length = 0, e = 0; e < n; e += 1)
                -1 !== (t = this.shapes[e]).styles.indexOf(r) &&
                  (o.push(t), (s = t._isAnimated || s))
              o.length > 1 && s && this.setShapesAsAnimated(o)
            }
          }),
          (SVGShapeElement.prototype.setShapesAsAnimated = function (e) {
            var t,
              i = e.length
            for (t = 0; t < i; t += 1) e[t].setAsAnimated()
          }),
          (SVGShapeElement.prototype.createStyleElement = function (e, t) {
            var i,
              r = new SVGStyleData(e, t),
              n = r.pElem
            return (
              'st' === e.ty
                ? (i = new SVGStrokeStyleData(this, e, r))
                : 'fl' === e.ty
                ? (i = new SVGFillStyleData(this, e, r))
                : ('gf' !== e.ty && 'gs' !== e.ty) ||
                  ((i = new ('gf' === e.ty ? SVGGradientFillStyleData : SVGGradientStrokeStyleData)(
                    this,
                    e,
                    r
                  )),
                  this.globalData.defs.appendChild(i.gf),
                  i.maskId &&
                    (this.globalData.defs.appendChild(i.ms),
                    this.globalData.defs.appendChild(i.of),
                    n.setAttribute('mask', 'url(' + locationHref + '#' + i.maskId + ')'))),
              ('st' !== e.ty && 'gs' !== e.ty) ||
                (n.setAttribute('stroke-linecap', this.lcEnum[e.lc] || 'round'),
                n.setAttribute('stroke-linejoin', this.ljEnum[e.lj] || 'round'),
                n.setAttribute('fill-opacity', '0'),
                1 === e.lj && n.setAttribute('stroke-miterlimit', e.ml)),
              2 === e.r && n.setAttribute('fill-rule', 'evenodd'),
              e.ln && n.setAttribute('id', e.ln),
              e.cl && n.setAttribute('class', e.cl),
              e.bm && (n.style['mix-blend-mode'] = getBlendMode(e.bm)),
              this.stylesList.push(r),
              this.addToAnimatedContents(e, i),
              i
            )
          }),
          (SVGShapeElement.prototype.createGroupElement = function (e) {
            var t = new ShapeGroupData()
            return (
              e.ln && t.gr.setAttribute('id', e.ln),
              e.cl && t.gr.setAttribute('class', e.cl),
              e.bm && (t.gr.style['mix-blend-mode'] = getBlendMode(e.bm)),
              t
            )
          }),
          (SVGShapeElement.prototype.createTransformElement = function (e, t) {
            var i = TransformPropertyFactory.getTransformProperty(this, e, this),
              r = new SVGTransformData(i, i.o, t)
            return this.addToAnimatedContents(e, r), r
          }),
          (SVGShapeElement.prototype.createShapeElement = function (e, t, i) {
            var r = 4
            'rc' === e.ty ? (r = 5) : 'el' === e.ty ? (r = 6) : 'sr' === e.ty && (r = 7)
            var n = new SVGShapeData(t, i, ShapePropertyFactory.getShapeProp(this, e, r, this))
            return (
              this.shapes.push(n), this.addShapeToModifiers(n), this.addToAnimatedContents(e, n), n
            )
          }),
          (SVGShapeElement.prototype.addToAnimatedContents = function (e, t) {
            for (var i = 0, r = this.animatedContents.length; i < r; ) {
              if (this.animatedContents[i].element === t) return
              i += 1
            }
            this.animatedContents.push({
              fn: SVGElementsRenderer.createRenderFunction(e),
              element: t,
              data: e
            })
          }),
          (SVGShapeElement.prototype.setElementStyles = function (e) {
            var t,
              i = e.styles,
              r = this.stylesList.length
            for (t = 0; t < r; t += 1) this.stylesList[t].closed || i.push(this.stylesList[t])
          }),
          (SVGShapeElement.prototype.reloadShapes = function () {
            var e
            this._isFirstFrame = !0
            var t = this.itemsData.length
            for (e = 0; e < t; e += 1) this.prevViewData[e] = this.itemsData[e]
            for (
              this.searchShapes(
                this.shapesData,
                this.itemsData,
                this.prevViewData,
                this.layerElement,
                0,
                [],
                !0
              ),
                this.filterUniqueShapes(),
                t = this.dynamicProperties.length,
                e = 0;
              e < t;
              e += 1
            )
              this.dynamicProperties[e].getValue()
            this.renderModifiers()
          }),
          (SVGShapeElement.prototype.searchShapes = function (e, t, i, r, n, a, o) {
            var s,
              l,
              h,
              u,
              p,
              c,
              d = [].concat(a),
              f = e.length - 1,
              m = [],
              g = []
            for (s = f; s >= 0; s -= 1) {
              if (
                ((c = this.searchProcessedElement(e[s])) ? (t[s] = i[c - 1]) : (e[s]._render = o),
                'fl' === e[s].ty || 'st' === e[s].ty || 'gf' === e[s].ty || 'gs' === e[s].ty)
              )
                c ? (t[s].style.closed = !1) : (t[s] = this.createStyleElement(e[s], n)),
                  e[s]._render && r.appendChild(t[s].style.pElem),
                  m.push(t[s].style)
              else if ('gr' === e[s].ty) {
                if (c)
                  for (h = t[s].it.length, l = 0; l < h; l += 1) t[s].prevViewData[l] = t[s].it[l]
                else t[s] = this.createGroupElement(e[s])
                this.searchShapes(e[s].it, t[s].it, t[s].prevViewData, t[s].gr, n + 1, d, o),
                  e[s]._render && r.appendChild(t[s].gr)
              } else
                'tr' === e[s].ty
                  ? (c || (t[s] = this.createTransformElement(e[s], r)),
                    (u = t[s].transform),
                    d.push(u))
                  : 'sh' === e[s].ty || 'rc' === e[s].ty || 'el' === e[s].ty || 'sr' === e[s].ty
                  ? (c || (t[s] = this.createShapeElement(e[s], d, n)), this.setElementStyles(t[s]))
                  : 'tm' === e[s].ty || 'rd' === e[s].ty || 'ms' === e[s].ty || 'pb' === e[s].ty
                  ? (c
                      ? ((p = t[s]).closed = !1)
                      : ((p = ShapeModifiers.getModifier(e[s].ty)).init(this, e[s]),
                        (t[s] = p),
                        this.shapeModifiers.push(p)),
                    g.push(p))
                  : 'rp' === e[s].ty &&
                    (c
                      ? ((p = t[s]).closed = !0)
                      : ((p = ShapeModifiers.getModifier(e[s].ty)),
                        (t[s] = p),
                        p.init(this, e, s, t),
                        this.shapeModifiers.push(p),
                        (o = !1)),
                    g.push(p))
              this.addProcessedElement(e[s], s + 1)
            }
            for (f = m.length, s = 0; s < f; s += 1) m[s].closed = !0
            for (f = g.length, s = 0; s < f; s += 1) g[s].closed = !0
          }),
          (SVGShapeElement.prototype.renderInnerContent = function () {
            var e
            this.renderModifiers()
            var t = this.stylesList.length
            for (e = 0; e < t; e += 1) this.stylesList[e].reset()
            for (this.renderShape(), e = 0; e < t; e += 1)
              (this.stylesList[e]._mdf || this._isFirstFrame) &&
                (this.stylesList[e].msElem &&
                  (this.stylesList[e].msElem.setAttribute('d', this.stylesList[e].d),
                  (this.stylesList[e].d = 'M0 0' + this.stylesList[e].d)),
                this.stylesList[e].pElem.setAttribute('d', this.stylesList[e].d || 'M0 0'))
          }),
          (SVGShapeElement.prototype.renderShape = function () {
            var e,
              t,
              i = this.animatedContents.length
            for (e = 0; e < i; e += 1)
              (t = this.animatedContents[e]),
                (this._isFirstFrame || t.element._isAnimated) &&
                  !0 !== t.data &&
                  t.fn(t.data, t.element, this._isFirstFrame)
          }),
          (SVGShapeElement.prototype.destroy = function () {
            this.destroyBaseElement(), (this.shapesData = null), (this.itemsData = null)
          }),
          (SVGTintFilter.prototype.renderFrame = function (e) {
            if (e || this.filterManager._mdf) {
              var t = this.filterManager.effectElements[0].p.v,
                i = this.filterManager.effectElements[1].p.v,
                r = this.filterManager.effectElements[2].p.v / 100
              this.matrixFilter.setAttribute(
                'values',
                i[0] -
                  t[0] +
                  ' 0 0 0 ' +
                  t[0] +
                  ' ' +
                  (i[1] - t[1]) +
                  ' 0 0 0 ' +
                  t[1] +
                  ' ' +
                  (i[2] - t[2]) +
                  ' 0 0 0 ' +
                  t[2] +
                  ' 0 0 0 ' +
                  r +
                  ' 0'
              )
            }
          }),
          (SVGFillFilter.prototype.renderFrame = function (e) {
            if (e || this.filterManager._mdf) {
              var t = this.filterManager.effectElements[2].p.v,
                i = this.filterManager.effectElements[6].p.v
              this.matrixFilter.setAttribute(
                'values',
                '0 0 0 0 ' + t[0] + ' 0 0 0 0 ' + t[1] + ' 0 0 0 0 ' + t[2] + ' 0 0 0 ' + i + ' 0'
              )
            }
          }),
          (SVGGaussianBlurEffect.prototype.renderFrame = function (e) {
            if (e || this.filterManager._mdf) {
              var t = 0.3 * this.filterManager.effectElements[0].p.v,
                i = this.filterManager.effectElements[1].p.v,
                r = 3 == i ? 0 : t,
                n = 2 == i ? 0 : t
              this.feGaussianBlur.setAttribute('stdDeviation', r + ' ' + n)
              var a = 1 == this.filterManager.effectElements[2].p.v ? 'wrap' : 'duplicate'
              this.feGaussianBlur.setAttribute('edgeMode', a)
            }
          }),
          (SVGStrokeEffect.prototype.initialize = function () {
            var e,
              t,
              i,
              r,
              n = this.elem.layerElement.children || this.elem.layerElement.childNodes
            for (
              1 === this.filterManager.effectElements[1].p.v
                ? ((r = this.elem.maskManager.masksProperties.length), (i = 0))
                : (r = 1 + (i = this.filterManager.effectElements[0].p.v - 1)),
                (t = createNS('g')).setAttribute('fill', 'none'),
                t.setAttribute('stroke-linecap', 'round'),
                t.setAttribute('stroke-dashoffset', 1);
              i < r;
              i += 1
            )
              (e = createNS('path')), t.appendChild(e), this.paths.push({ p: e, m: i })
            if (3 === this.filterManager.effectElements[10].p.v) {
              var a = createNS('mask'),
                o = createElementID()
              a.setAttribute('id', o),
                a.setAttribute('mask-type', 'alpha'),
                a.appendChild(t),
                this.elem.globalData.defs.appendChild(a)
              var s = createNS('g')
              for (s.setAttribute('mask', 'url(' + locationHref + '#' + o + ')'); n[0]; )
                s.appendChild(n[0])
              this.elem.layerElement.appendChild(s),
                (this.masker = a),
                t.setAttribute('stroke', '#fff')
            } else if (
              1 === this.filterManager.effectElements[10].p.v ||
              2 === this.filterManager.effectElements[10].p.v
            ) {
              if (2 === this.filterManager.effectElements[10].p.v)
                for (
                  n = this.elem.layerElement.children || this.elem.layerElement.childNodes;
                  n.length;

                )
                  this.elem.layerElement.removeChild(n[0])
              this.elem.layerElement.appendChild(t),
                this.elem.layerElement.removeAttribute('mask'),
                t.setAttribute('stroke', '#fff')
            }
            ;(this.initialized = !0), (this.pathMasker = t)
          }),
          (SVGStrokeEffect.prototype.renderFrame = function (e) {
            var t
            this.initialized || this.initialize()
            var i,
              r,
              n = this.paths.length
            for (t = 0; t < n; t += 1)
              if (
                -1 !== this.paths[t].m &&
                ((i = this.elem.maskManager.viewData[this.paths[t].m]),
                (r = this.paths[t].p),
                (e || this.filterManager._mdf || i.prop._mdf) && r.setAttribute('d', i.lastPath),
                e ||
                  this.filterManager.effectElements[9].p._mdf ||
                  this.filterManager.effectElements[4].p._mdf ||
                  this.filterManager.effectElements[7].p._mdf ||
                  this.filterManager.effectElements[8].p._mdf ||
                  i.prop._mdf)
              ) {
                var a
                if (
                  0 !== this.filterManager.effectElements[7].p.v ||
                  100 !== this.filterManager.effectElements[8].p.v
                ) {
                  var o =
                      0.01 *
                      Math.min(
                        this.filterManager.effectElements[7].p.v,
                        this.filterManager.effectElements[8].p.v
                      ),
                    s =
                      0.01 *
                      Math.max(
                        this.filterManager.effectElements[7].p.v,
                        this.filterManager.effectElements[8].p.v
                      ),
                    l = r.getTotalLength()
                  a = '0 0 0 ' + l * o + ' '
                  var h,
                    u = l * (s - o),
                    p =
                      1 +
                      2 *
                        this.filterManager.effectElements[4].p.v *
                        this.filterManager.effectElements[9].p.v *
                        0.01,
                    c = Math.floor(u / p)
                  for (h = 0; h < c; h += 1)
                    a +=
                      '1 ' +
                      2 *
                        this.filterManager.effectElements[4].p.v *
                        this.filterManager.effectElements[9].p.v *
                        0.01 +
                      ' '
                  a += '0 ' + 10 * l + ' 0 0'
                } else
                  a =
                    '1 ' +
                    2 *
                      this.filterManager.effectElements[4].p.v *
                      this.filterManager.effectElements[9].p.v *
                      0.01
                r.setAttribute('stroke-dasharray', a)
              }
            if (
              ((e || this.filterManager.effectElements[4].p._mdf) &&
                this.pathMasker.setAttribute(
                  'stroke-width',
                  2 * this.filterManager.effectElements[4].p.v
                ),
              (e || this.filterManager.effectElements[6].p._mdf) &&
                this.pathMasker.setAttribute('opacity', this.filterManager.effectElements[6].p.v),
              (1 === this.filterManager.effectElements[10].p.v ||
                2 === this.filterManager.effectElements[10].p.v) &&
                (e || this.filterManager.effectElements[3].p._mdf))
            ) {
              var d = this.filterManager.effectElements[3].p.v
              this.pathMasker.setAttribute(
                'stroke',
                'rgb(' +
                  bmFloor(255 * d[0]) +
                  ',' +
                  bmFloor(255 * d[1]) +
                  ',' +
                  bmFloor(255 * d[2]) +
                  ')'
              )
            }
          }),
          (SVGTritoneFilter.prototype.renderFrame = function (e) {
            if (e || this.filterManager._mdf) {
              var t = this.filterManager.effectElements[0].p.v,
                i = this.filterManager.effectElements[1].p.v,
                r = this.filterManager.effectElements[2].p.v,
                n = r[0] + ' ' + i[0] + ' ' + t[0],
                a = r[1] + ' ' + i[1] + ' ' + t[1],
                o = r[2] + ' ' + i[2] + ' ' + t[2]
              this.feFuncR.setAttribute('tableValues', n),
                this.feFuncG.setAttribute('tableValues', a),
                this.feFuncB.setAttribute('tableValues', o)
            }
          }),
          (SVGProLevelsFilter.prototype.createFeFunc = function (e, t) {
            var i = createNS(e)
            return i.setAttribute('type', 'table'), t.appendChild(i), i
          }),
          (SVGProLevelsFilter.prototype.getTableValue = function (e, t, i, r, n) {
            for (
              var a,
                o,
                s = 0,
                l = Math.min(e, t),
                h = Math.max(e, t),
                u = Array.call(null, { length: 256 }),
                p = 0,
                c = n - r,
                d = t - e;
              s <= 256;

            )
              (o =
                (a = s / 256) <= l
                  ? d < 0
                    ? n
                    : r
                  : a >= h
                  ? d < 0
                    ? r
                    : n
                  : r + c * Math.pow((a - e) / d, 1 / i)),
                (u[p] = o),
                (p += 1),
                (s += 256 / 255)
            return u.join(' ')
          }),
          (SVGProLevelsFilter.prototype.renderFrame = function (e) {
            if (e || this.filterManager._mdf) {
              var t,
                i = this.filterManager.effectElements
              this.feFuncRComposed &&
                (e || i[3].p._mdf || i[4].p._mdf || i[5].p._mdf || i[6].p._mdf || i[7].p._mdf) &&
                ((t = this.getTableValue(i[3].p.v, i[4].p.v, i[5].p.v, i[6].p.v, i[7].p.v)),
                this.feFuncRComposed.setAttribute('tableValues', t),
                this.feFuncGComposed.setAttribute('tableValues', t),
                this.feFuncBComposed.setAttribute('tableValues', t)),
                this.feFuncR &&
                  (e ||
                    i[10].p._mdf ||
                    i[11].p._mdf ||
                    i[12].p._mdf ||
                    i[13].p._mdf ||
                    i[14].p._mdf) &&
                  ((t = this.getTableValue(i[10].p.v, i[11].p.v, i[12].p.v, i[13].p.v, i[14].p.v)),
                  this.feFuncR.setAttribute('tableValues', t)),
                this.feFuncG &&
                  (e ||
                    i[17].p._mdf ||
                    i[18].p._mdf ||
                    i[19].p._mdf ||
                    i[20].p._mdf ||
                    i[21].p._mdf) &&
                  ((t = this.getTableValue(i[17].p.v, i[18].p.v, i[19].p.v, i[20].p.v, i[21].p.v)),
                  this.feFuncG.setAttribute('tableValues', t)),
                this.feFuncB &&
                  (e ||
                    i[24].p._mdf ||
                    i[25].p._mdf ||
                    i[26].p._mdf ||
                    i[27].p._mdf ||
                    i[28].p._mdf) &&
                  ((t = this.getTableValue(i[24].p.v, i[25].p.v, i[26].p.v, i[27].p.v, i[28].p.v)),
                  this.feFuncB.setAttribute('tableValues', t)),
                this.feFuncA &&
                  (e ||
                    i[31].p._mdf ||
                    i[32].p._mdf ||
                    i[33].p._mdf ||
                    i[34].p._mdf ||
                    i[35].p._mdf) &&
                  ((t = this.getTableValue(i[31].p.v, i[32].p.v, i[33].p.v, i[34].p.v, i[35].p.v)),
                  this.feFuncA.setAttribute('tableValues', t))
            }
          }),
          (SVGDropShadowEffect.prototype.renderFrame = function (e) {
            if (e || this.filterManager._mdf) {
              if (
                ((e || this.filterManager.effectElements[4].p._mdf) &&
                  this.feGaussianBlur.setAttribute(
                    'stdDeviation',
                    this.filterManager.effectElements[4].p.v / 4
                  ),
                e || this.filterManager.effectElements[0].p._mdf)
              ) {
                var t = this.filterManager.effectElements[0].p.v
                this.feFlood.setAttribute(
                  'flood-color',
                  rgbToHex(Math.round(255 * t[0]), Math.round(255 * t[1]), Math.round(255 * t[2]))
                )
              }
              if (
                ((e || this.filterManager.effectElements[1].p._mdf) &&
                  this.feFlood.setAttribute(
                    'flood-opacity',
                    this.filterManager.effectElements[1].p.v / 255
                  ),
                e ||
                  this.filterManager.effectElements[2].p._mdf ||
                  this.filterManager.effectElements[3].p._mdf)
              ) {
                var i = this.filterManager.effectElements[3].p.v,
                  r = (this.filterManager.effectElements[2].p.v - 90) * degToRads,
                  n = i * Math.cos(r),
                  a = i * Math.sin(r)
                this.feOffset.setAttribute('dx', n), this.feOffset.setAttribute('dy', a)
              }
            }
          })
        var _svgMatteSymbols = []
        function SVGMatte3Effect(e, t, i) {
          ;(this.initialized = !1),
            (this.filterManager = t),
            (this.filterElem = e),
            (this.elem = i),
            (i.matteElement = createNS('g')),
            i.matteElement.appendChild(i.layerElement),
            i.matteElement.appendChild(i.transformedElement),
            (i.baseElement = i.matteElement)
        }
        function SVGEffects(e) {
          var t,
            i,
            r = e.data.ef ? e.data.ef.length : 0,
            n = createElementID(),
            a = filtersFactory.createFilter(n, !0),
            o = 0
          for (this.filters = [], t = 0; t < r; t += 1)
            (i = null),
              20 === e.data.ef[t].ty
                ? ((o += 1), (i = new SVGTintFilter(a, e.effectsManager.effectElements[t])))
                : 21 === e.data.ef[t].ty
                ? ((o += 1), (i = new SVGFillFilter(a, e.effectsManager.effectElements[t])))
                : 22 === e.data.ef[t].ty
                ? (i = new SVGStrokeEffect(e, e.effectsManager.effectElements[t]))
                : 23 === e.data.ef[t].ty
                ? ((o += 1), (i = new SVGTritoneFilter(a, e.effectsManager.effectElements[t])))
                : 24 === e.data.ef[t].ty
                ? ((o += 1), (i = new SVGProLevelsFilter(a, e.effectsManager.effectElements[t])))
                : 25 === e.data.ef[t].ty
                ? ((o += 1), (i = new SVGDropShadowEffect(a, e.effectsManager.effectElements[t])))
                : 28 === e.data.ef[t].ty
                ? (i = new SVGMatte3Effect(a, e.effectsManager.effectElements[t], e))
                : 29 === e.data.ef[t].ty &&
                  ((o += 1),
                  (i = new SVGGaussianBlurEffect(a, e.effectsManager.effectElements[t]))),
              i && this.filters.push(i)
          o &&
            (e.globalData.defs.appendChild(a),
            e.layerElement.setAttribute('filter', 'url(' + locationHref + '#' + n + ')')),
            this.filters.length && e.addRenderableComponent(this)
        }
        function CVContextData() {
          var e
          for (
            this.saved = [],
              this.cArrPos = 0,
              this.cTr = new Matrix(),
              this.cO = 1,
              this.savedOp = createTypedArray('float32', 15),
              e = 0;
            e < 15;
            e += 1
          )
            this.saved[e] = createTypedArray('float32', 16)
          this._length = 15
        }
        function CVBaseElement() {}
        function CVImageElement(e, t, i) {
          ;(this.assetData = t.getAssetData(e.refId)),
            (this.img = t.imageLoader.getAsset(this.assetData)),
            this.initElement(e, t, i)
        }
        function CVCompElement(e, t, i) {
          ;(this.completeLayers = !1),
            (this.layers = e.layers),
            (this.pendingElements = []),
            (this.elements = createSizedArray(this.layers.length)),
            this.initElement(e, t, i),
            (this.tm = e.tm
              ? PropertyFactory.getProp(this, e.tm, 0, t.frameRate, this)
              : { _placeholder: !0 })
        }
        function CVMaskElement(e, t) {
          var i
          ;(this.data = e),
            (this.element = t),
            (this.masksProperties = this.data.masksProperties || []),
            (this.viewData = createSizedArray(this.masksProperties.length))
          var r = this.masksProperties.length,
            n = !1
          for (i = 0; i < r; i += 1)
            'n' !== this.masksProperties[i].mode && (n = !0),
              (this.viewData[i] = ShapePropertyFactory.getShapeProp(
                this.element,
                this.masksProperties[i],
                3
              ))
          ;(this.hasMasks = n), n && this.element.addRenderableComponent(this)
        }
        function CVShapeElement(e, t, i) {
          ;(this.shapes = []),
            (this.shapesData = e.shapes),
            (this.stylesList = []),
            (this.itemsData = []),
            (this.prevViewData = []),
            (this.shapeModifiers = []),
            (this.processedElements = []),
            (this.transformsManager = new ShapeTransformManager()),
            this.initElement(e, t, i)
        }
        function CVSolidElement(e, t, i) {
          this.initElement(e, t, i)
        }
        function CVTextElement(e, t, i) {
          ;(this.textSpans = []),
            (this.yOffset = 0),
            (this.fillColorAnim = !1),
            (this.strokeColorAnim = !1),
            (this.strokeWidthAnim = !1),
            (this.stroke = !1),
            (this.fill = !1),
            (this.justifyOffset = 0),
            (this.currentRender = null),
            (this.renderType = 'canvas'),
            (this.values = {
              fill: 'rgba(0,0,0,0)',
              stroke: 'rgba(0,0,0,0)',
              sWidth: 0,
              fValue: ''
            }),
            this.initElement(e, t, i)
        }
        function CVEffects() {}
        function HBaseElement() {}
        function HSolidElement(e, t, i) {
          this.initElement(e, t, i)
        }
        function HCompElement(e, t, i) {
          ;(this.layers = e.layers),
            (this.supports3d = !e.hasMask),
            (this.completeLayers = !1),
            (this.pendingElements = []),
            (this.elements = this.layers ? createSizedArray(this.layers.length) : []),
            this.initElement(e, t, i),
            (this.tm = e.tm
              ? PropertyFactory.getProp(this, e.tm, 0, t.frameRate, this)
              : { _placeholder: !0 })
        }
        function HShapeElement(e, t, i) {
          ;(this.shapes = []),
            (this.shapesData = e.shapes),
            (this.stylesList = []),
            (this.shapeModifiers = []),
            (this.itemsData = []),
            (this.processedElements = []),
            (this.animatedContents = []),
            (this.shapesContainer = createNS('g')),
            this.initElement(e, t, i),
            (this.prevViewData = []),
            (this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 })
        }
        function HTextElement(e, t, i) {
          ;(this.textSpans = []),
            (this.textPaths = []),
            (this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 }),
            (this.renderType = 'svg'),
            (this.isMasked = !1),
            this.initElement(e, t, i)
        }
        function HImageElement(e, t, i) {
          ;(this.assetData = t.getAssetData(e.refId)), this.initElement(e, t, i)
        }
        function HCameraElement(e, t, i) {
          this.initFrame(), this.initBaseData(e, t, i), this.initHierarchy()
          var r = PropertyFactory.getProp
          if (
            ((this.pe = r(this, e.pe, 0, 0, this)),
            e.ks.p.s
              ? ((this.px = r(this, e.ks.p.x, 1, 0, this)),
                (this.py = r(this, e.ks.p.y, 1, 0, this)),
                (this.pz = r(this, e.ks.p.z, 1, 0, this)))
              : (this.p = r(this, e.ks.p, 1, 0, this)),
            e.ks.a && (this.a = r(this, e.ks.a, 1, 0, this)),
            e.ks.or.k.length && e.ks.or.k[0].to)
          ) {
            var n,
              a = e.ks.or.k.length
            for (n = 0; n < a; n += 1) (e.ks.or.k[n].to = null), (e.ks.or.k[n].ti = null)
          }
          ;(this.or = r(this, e.ks.or, 1, degToRads, this)),
            (this.or.sh = !0),
            (this.rx = r(this, e.ks.rx, 0, degToRads, this)),
            (this.ry = r(this, e.ks.ry, 0, degToRads, this)),
            (this.rz = r(this, e.ks.rz, 0, degToRads, this)),
            (this.mat = new Matrix()),
            (this._prevMat = new Matrix()),
            (this._isFirstFrame = !0),
            (this.finalTransform = { mProp: this })
        }
        ;(SVGMatte3Effect.prototype.findSymbol = function (e) {
          for (var t = 0, i = _svgMatteSymbols.length; t < i; ) {
            if (_svgMatteSymbols[t] === e) return _svgMatteSymbols[t]
            t += 1
          }
          return null
        }),
          (SVGMatte3Effect.prototype.replaceInParent = function (e, t) {
            var i = e.layerElement.parentNode
            if (i) {
              for (var r, n = i.children, a = 0, o = n.length; a < o && n[a] !== e.layerElement; )
                a += 1
              a <= o - 2 && (r = n[a + 1])
              var s = createNS('use')
              s.setAttribute('href', '#' + t), r ? i.insertBefore(s, r) : i.appendChild(s)
            }
          }),
          (SVGMatte3Effect.prototype.setElementAsMask = function (e, t) {
            if (!this.findSymbol(t)) {
              var i = createElementID(),
                r = createNS('mask')
              r.setAttribute('id', t.layerId),
                r.setAttribute('mask-type', 'alpha'),
                _svgMatteSymbols.push(t)
              var n = e.globalData.defs
              n.appendChild(r)
              var a = createNS('symbol')
              a.setAttribute('id', i),
                this.replaceInParent(t, i),
                a.appendChild(t.layerElement),
                n.appendChild(a)
              var o = createNS('use')
              o.setAttribute('href', '#' + i), r.appendChild(o), (t.data.hd = !1), t.show()
            }
            e.setMatte(t.layerId)
          }),
          (SVGMatte3Effect.prototype.initialize = function () {
            for (
              var e = this.filterManager.effectElements[0].p.v,
                t = this.elem.comp.elements,
                i = 0,
                r = t.length;
              i < r;

            )
              t[i] && t[i].data.ind === e && this.setElementAsMask(this.elem, t[i]), (i += 1)
            this.initialized = !0
          }),
          (SVGMatte3Effect.prototype.renderFrame = function () {
            this.initialized || this.initialize()
          }),
          (SVGEffects.prototype.renderFrame = function (e) {
            var t,
              i = this.filters.length
            for (t = 0; t < i; t += 1) this.filters[t].renderFrame(e)
          }),
          (CVContextData.prototype.duplicate = function () {
            var e = 2 * this._length,
              t = this.savedOp
            ;(this.savedOp = createTypedArray('float32', e)), this.savedOp.set(t)
            var i = 0
            for (i = this._length; i < e; i += 1) this.saved[i] = createTypedArray('float32', 16)
            this._length = e
          }),
          (CVContextData.prototype.reset = function () {
            ;(this.cArrPos = 0), this.cTr.reset(), (this.cO = 1)
          }),
          (CVBaseElement.prototype = {
            createElements: function () {},
            initRendererElement: function () {},
            createContainerElements: function () {
              ;(this.canvasContext = this.globalData.canvasContext),
                (this.renderableEffectsManager = new CVEffects(this))
            },
            createContent: function () {},
            setBlendMode: function () {
              var e = this.globalData
              if (e.blendMode !== this.data.bm) {
                e.blendMode = this.data.bm
                var t = getBlendMode(this.data.bm)
                e.canvasContext.globalCompositeOperation = t
              }
            },
            createRenderableComponents: function () {
              this.maskManager = new CVMaskElement(this.data, this)
            },
            hideElement: function () {
              this.hidden || (this.isInRange && !this.isTransparent) || (this.hidden = !0)
            },
            showElement: function () {
              this.isInRange &&
                !this.isTransparent &&
                ((this.hidden = !1),
                (this._isFirstFrame = !0),
                (this.maskManager._isFirstFrame = !0))
            },
            renderFrame: function () {
              if (!this.hidden && !this.data.hd) {
                this.renderTransform(), this.renderRenderable(), this.setBlendMode()
                var e = 0 === this.data.ty
                this.globalData.renderer.save(e),
                  this.globalData.renderer.ctxTransform(this.finalTransform.mat.props),
                  this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v),
                  this.renderInnerContent(),
                  this.globalData.renderer.restore(e),
                  this.maskManager.hasMasks && this.globalData.renderer.restore(!0),
                  this._isFirstFrame && (this._isFirstFrame = !1)
              }
            },
            destroy: function () {
              ;(this.canvasContext = null),
                (this.data = null),
                (this.globalData = null),
                this.maskManager.destroy()
            },
            mHelper: new Matrix()
          }),
          (CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement),
          (CVBaseElement.prototype.show = CVBaseElement.prototype.showElement),
          extendPrototype(
            [
              BaseElement,
              TransformElement,
              CVBaseElement,
              HierarchyElement,
              FrameElement,
              RenderableElement
            ],
            CVImageElement
          ),
          (CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement),
          (CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame),
          (CVImageElement.prototype.createContent = function () {
            if (
              this.img.width &&
              (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)
            ) {
              var e = createTag('canvas')
              ;(e.width = this.assetData.w), (e.height = this.assetData.h)
              var t,
                i,
                r = e.getContext('2d'),
                n = this.img.width,
                a = this.img.height,
                o = n / a,
                s = this.assetData.w / this.assetData.h,
                l = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio
              ;(o > s && 'xMidYMid slice' === l) || (o < s && 'xMidYMid slice' !== l)
                ? (t = (i = a) * s)
                : (i = (t = n) / s),
                r.drawImage(
                  this.img,
                  (n - t) / 2,
                  (a - i) / 2,
                  t,
                  i,
                  0,
                  0,
                  this.assetData.w,
                  this.assetData.h
                ),
                (this.img = e)
            }
          }),
          (CVImageElement.prototype.renderInnerContent = function () {
            this.canvasContext.drawImage(this.img, 0, 0)
          }),
          (CVImageElement.prototype.destroy = function () {
            this.img = null
          }),
          extendPrototype([CanvasRenderer, ICompElement, CVBaseElement], CVCompElement),
          (CVCompElement.prototype.renderInnerContent = function () {
            var e,
              t = this.canvasContext
            for (
              t.beginPath(),
                t.moveTo(0, 0),
                t.lineTo(this.data.w, 0),
                t.lineTo(this.data.w, this.data.h),
                t.lineTo(0, this.data.h),
                t.lineTo(0, 0),
                t.clip(),
                e = this.layers.length - 1;
              e >= 0;
              e -= 1
            )
              (this.completeLayers || this.elements[e]) && this.elements[e].renderFrame()
          }),
          (CVCompElement.prototype.destroy = function () {
            var e
            for (e = this.layers.length - 1; e >= 0; e -= 1)
              this.elements[e] && this.elements[e].destroy()
            ;(this.layers = null), (this.elements = null)
          }),
          (CVMaskElement.prototype.renderFrame = function () {
            if (this.hasMasks) {
              var e,
                t,
                i,
                r,
                n = this.element.finalTransform.mat,
                a = this.element.canvasContext,
                o = this.masksProperties.length
              for (a.beginPath(), e = 0; e < o; e += 1)
                if ('n' !== this.masksProperties[e].mode) {
                  var s
                  this.masksProperties[e].inv &&
                    (a.moveTo(0, 0),
                    a.lineTo(this.element.globalData.compSize.w, 0),
                    a.lineTo(
                      this.element.globalData.compSize.w,
                      this.element.globalData.compSize.h
                    ),
                    a.lineTo(0, this.element.globalData.compSize.h),
                    a.lineTo(0, 0)),
                    (r = this.viewData[e].v),
                    (t = n.applyToPointArray(r.v[0][0], r.v[0][1], 0)),
                    a.moveTo(t[0], t[1])
                  var l = r._length
                  for (s = 1; s < l; s += 1)
                    (i = n.applyToTriplePoints(r.o[s - 1], r.i[s], r.v[s])),
                      a.bezierCurveTo(i[0], i[1], i[2], i[3], i[4], i[5])
                  ;(i = n.applyToTriplePoints(r.o[s - 1], r.i[0], r.v[0])),
                    a.bezierCurveTo(i[0], i[1], i[2], i[3], i[4], i[5])
                }
              this.element.globalData.renderer.save(!0), a.clip()
            }
          }),
          (CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty),
          (CVMaskElement.prototype.destroy = function () {
            this.element = null
          }),
          extendPrototype(
            [
              BaseElement,
              TransformElement,
              CVBaseElement,
              IShapeElement,
              HierarchyElement,
              FrameElement,
              RenderableElement
            ],
            CVShapeElement
          ),
          (CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement),
          (CVShapeElement.prototype.transformHelper = { opacity: 1, _opMdf: !1 }),
          (CVShapeElement.prototype.dashResetter = []),
          (CVShapeElement.prototype.createContent = function () {
            this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, [])
          }),
          (CVShapeElement.prototype.createStyleElement = function (e, t) {
            var i = {
                data: e,
                type: e.ty,
                preTransforms: this.transformsManager.addTransformSequence(t),
                transforms: [],
                elements: [],
                closed: !0 === e.hd
              },
              r = {}
            if (
              ('fl' === e.ty || 'st' === e.ty
                ? ((r.c = PropertyFactory.getProp(this, e.c, 1, 255, this)),
                  r.c.k ||
                    (i.co =
                      'rgb(' +
                      bmFloor(r.c.v[0]) +
                      ',' +
                      bmFloor(r.c.v[1]) +
                      ',' +
                      bmFloor(r.c.v[2]) +
                      ')'))
                : ('gf' !== e.ty && 'gs' !== e.ty) ||
                  ((r.s = PropertyFactory.getProp(this, e.s, 1, null, this)),
                  (r.e = PropertyFactory.getProp(this, e.e, 1, null, this)),
                  (r.h = PropertyFactory.getProp(this, e.h || { k: 0 }, 0, 0.01, this)),
                  (r.a = PropertyFactory.getProp(this, e.a || { k: 0 }, 0, degToRads, this)),
                  (r.g = new GradientProperty(this, e.g, this))),
              (r.o = PropertyFactory.getProp(this, e.o, 0, 0.01, this)),
              'st' === e.ty || 'gs' === e.ty)
            ) {
              if (
                ((i.lc = this.lcEnum[e.lc] || 'round'),
                (i.lj = this.ljEnum[e.lj] || 'round'),
                1 == e.lj && (i.ml = e.ml),
                (r.w = PropertyFactory.getProp(this, e.w, 0, null, this)),
                r.w.k || (i.wi = r.w.v),
                e.d)
              ) {
                var n = new DashProperty(this, e.d, 'canvas', this)
                ;(r.d = n), r.d.k || ((i.da = r.d.dashArray), (i.do = r.d.dashoffset[0]))
              }
            } else i.r = 2 === e.r ? 'evenodd' : 'nonzero'
            return this.stylesList.push(i), (r.style = i), r
          }),
          (CVShapeElement.prototype.createGroupElement = function () {
            return { it: [], prevViewData: [] }
          }),
          (CVShapeElement.prototype.createTransformElement = function (e) {
            return {
              transform: {
                opacity: 1,
                _opMdf: !1,
                key: this.transformsManager.getNewKey(),
                op: PropertyFactory.getProp(this, e.o, 0, 0.01, this),
                mProps: TransformPropertyFactory.getTransformProperty(this, e, this)
              }
            }
          }),
          (CVShapeElement.prototype.createShapeElement = function (e) {
            var t = new CVShapeData(this, e, this.stylesList, this.transformsManager)
            return this.shapes.push(t), this.addShapeToModifiers(t), t
          }),
          (CVShapeElement.prototype.reloadShapes = function () {
            var e
            this._isFirstFrame = !0
            var t = this.itemsData.length
            for (e = 0; e < t; e += 1) this.prevViewData[e] = this.itemsData[e]
            for (
              this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []),
                t = this.dynamicProperties.length,
                e = 0;
              e < t;
              e += 1
            )
              this.dynamicProperties[e].getValue()
            this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame)
          }),
          (CVShapeElement.prototype.addTransformToStyleList = function (e) {
            var t,
              i = this.stylesList.length
            for (t = 0; t < i; t += 1)
              this.stylesList[t].closed || this.stylesList[t].transforms.push(e)
          }),
          (CVShapeElement.prototype.removeTransformFromStyleList = function () {
            var e,
              t = this.stylesList.length
            for (e = 0; e < t; e += 1)
              this.stylesList[e].closed || this.stylesList[e].transforms.pop()
          }),
          (CVShapeElement.prototype.closeStyles = function (e) {
            var t,
              i = e.length
            for (t = 0; t < i; t += 1) e[t].closed = !0
          }),
          (CVShapeElement.prototype.searchShapes = function (e, t, i, r, n) {
            var a,
              o,
              s,
              l,
              h,
              u,
              p = e.length - 1,
              c = [],
              d = [],
              f = [].concat(n)
            for (a = p; a >= 0; a -= 1) {
              if (
                ((l = this.searchProcessedElement(e[a]))
                  ? (t[a] = i[l - 1])
                  : (e[a]._shouldRender = r),
                'fl' === e[a].ty || 'st' === e[a].ty || 'gf' === e[a].ty || 'gs' === e[a].ty)
              )
                l ? (t[a].style.closed = !1) : (t[a] = this.createStyleElement(e[a], f)),
                  c.push(t[a].style)
              else if ('gr' === e[a].ty) {
                if (l)
                  for (s = t[a].it.length, o = 0; o < s; o += 1) t[a].prevViewData[o] = t[a].it[o]
                else t[a] = this.createGroupElement(e[a])
                this.searchShapes(e[a].it, t[a].it, t[a].prevViewData, r, f)
              } else
                'tr' === e[a].ty
                  ? (l || ((u = this.createTransformElement(e[a])), (t[a] = u)),
                    f.push(t[a]),
                    this.addTransformToStyleList(t[a]))
                  : 'sh' === e[a].ty || 'rc' === e[a].ty || 'el' === e[a].ty || 'sr' === e[a].ty
                  ? l || (t[a] = this.createShapeElement(e[a]))
                  : 'tm' === e[a].ty || 'rd' === e[a].ty || 'pb' === e[a].ty
                  ? (l
                      ? ((h = t[a]).closed = !1)
                      : ((h = ShapeModifiers.getModifier(e[a].ty)).init(this, e[a]),
                        (t[a] = h),
                        this.shapeModifiers.push(h)),
                    d.push(h))
                  : 'rp' === e[a].ty &&
                    (l
                      ? ((h = t[a]).closed = !0)
                      : ((h = ShapeModifiers.getModifier(e[a].ty)),
                        (t[a] = h),
                        h.init(this, e, a, t),
                        this.shapeModifiers.push(h),
                        (r = !1)),
                    d.push(h))
              this.addProcessedElement(e[a], a + 1)
            }
            for (
              this.removeTransformFromStyleList(), this.closeStyles(c), p = d.length, a = 0;
              a < p;
              a += 1
            )
              d[a].closed = !0
          }),
          (CVShapeElement.prototype.renderInnerContent = function () {
            ;(this.transformHelper.opacity = 1),
              (this.transformHelper._opMdf = !1),
              this.renderModifiers(),
              this.transformsManager.processSequences(this._isFirstFrame),
              this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0)
          }),
          (CVShapeElement.prototype.renderShapeTransform = function (e, t) {
            ;(e._opMdf || t.op._mdf || this._isFirstFrame) &&
              ((t.opacity = e.opacity), (t.opacity *= t.op.v), (t._opMdf = !0))
          }),
          (CVShapeElement.prototype.drawLayer = function () {
            var e,
              t,
              i,
              r,
              n,
              a,
              o,
              s,
              l,
              h = this.stylesList.length,
              u = this.globalData.renderer,
              p = this.globalData.canvasContext
            for (e = 0; e < h; e += 1)
              if (
                (('st' !== (s = (l = this.stylesList[e]).type) && 'gs' !== s) || 0 !== l.wi) &&
                l.data._shouldRender &&
                0 !== l.coOp &&
                0 !== this.globalData.currentGlobalAlpha
              ) {
                for (
                  u.save(),
                    a = l.elements,
                    'st' === s || 'gs' === s
                      ? ((p.strokeStyle = 'st' === s ? l.co : l.grd),
                        (p.lineWidth = l.wi),
                        (p.lineCap = l.lc),
                        (p.lineJoin = l.lj),
                        (p.miterLimit = l.ml || 0))
                      : (p.fillStyle = 'fl' === s ? l.co : l.grd),
                    u.ctxOpacity(l.coOp),
                    'st' !== s && 'gs' !== s && p.beginPath(),
                    u.ctxTransform(l.preTransforms.finalTransform.props),
                    i = a.length,
                    t = 0;
                  t < i;
                  t += 1
                ) {
                  for (
                    ('st' !== s && 'gs' !== s) ||
                      (p.beginPath(), l.da && (p.setLineDash(l.da), (p.lineDashOffset = l.do))),
                      n = (o = a[t].trNodes).length,
                      r = 0;
                    r < n;
                    r += 1
                  )
                    'm' === o[r].t
                      ? p.moveTo(o[r].p[0], o[r].p[1])
                      : 'c' === o[r].t
                      ? p.bezierCurveTo(
                          o[r].pts[0],
                          o[r].pts[1],
                          o[r].pts[2],
                          o[r].pts[3],
                          o[r].pts[4],
                          o[r].pts[5]
                        )
                      : p.closePath()
                  ;('st' !== s && 'gs' !== s) ||
                    (p.stroke(), l.da && p.setLineDash(this.dashResetter))
                }
                'st' !== s && 'gs' !== s && p.fill(l.r), u.restore()
              }
          }),
          (CVShapeElement.prototype.renderShape = function (e, t, i, r) {
            var n, a
            for (a = e, n = t.length - 1; n >= 0; n -= 1)
              'tr' === t[n].ty
                ? ((a = i[n].transform), this.renderShapeTransform(e, a))
                : 'sh' === t[n].ty || 'el' === t[n].ty || 'rc' === t[n].ty || 'sr' === t[n].ty
                ? this.renderPath(t[n], i[n])
                : 'fl' === t[n].ty
                ? this.renderFill(t[n], i[n], a)
                : 'st' === t[n].ty
                ? this.renderStroke(t[n], i[n], a)
                : 'gf' === t[n].ty || 'gs' === t[n].ty
                ? this.renderGradientFill(t[n], i[n], a)
                : 'gr' === t[n].ty
                ? this.renderShape(a, t[n].it, i[n].it)
                : t[n].ty
            r && this.drawLayer()
          }),
          (CVShapeElement.prototype.renderStyledShape = function (e, t) {
            if (this._isFirstFrame || t._mdf || e.transforms._mdf) {
              var i,
                r,
                n,
                a = e.trNodes,
                o = t.paths,
                s = o._length
              a.length = 0
              var l = e.transforms.finalTransform
              for (n = 0; n < s; n += 1) {
                var h = o.shapes[n]
                if (h && h.v) {
                  for (r = h._length, i = 1; i < r; i += 1)
                    1 === i && a.push({ t: 'm', p: l.applyToPointArray(h.v[0][0], h.v[0][1], 0) }),
                      a.push({ t: 'c', pts: l.applyToTriplePoints(h.o[i - 1], h.i[i], h.v[i]) })
                  1 === r && a.push({ t: 'm', p: l.applyToPointArray(h.v[0][0], h.v[0][1], 0) }),
                    h.c &&
                      r &&
                      (a.push({ t: 'c', pts: l.applyToTriplePoints(h.o[i - 1], h.i[0], h.v[0]) }),
                      a.push({ t: 'z' }))
                }
              }
              e.trNodes = a
            }
          }),
          (CVShapeElement.prototype.renderPath = function (e, t) {
            if (!0 !== e.hd && e._shouldRender) {
              var i,
                r = t.styledShapes.length
              for (i = 0; i < r; i += 1) this.renderStyledShape(t.styledShapes[i], t.sh)
            }
          }),
          (CVShapeElement.prototype.renderFill = function (e, t, i) {
            var r = t.style
            ;(t.c._mdf || this._isFirstFrame) &&
              (r.co =
                'rgb(' +
                bmFloor(t.c.v[0]) +
                ',' +
                bmFloor(t.c.v[1]) +
                ',' +
                bmFloor(t.c.v[2]) +
                ')'),
              (t.o._mdf || i._opMdf || this._isFirstFrame) && (r.coOp = t.o.v * i.opacity)
          }),
          (CVShapeElement.prototype.renderGradientFill = function (e, t, i) {
            var r,
              n = t.style
            if (
              !n.grd ||
              t.g._mdf ||
              t.s._mdf ||
              t.e._mdf ||
              (1 !== e.t && (t.h._mdf || t.a._mdf))
            ) {
              var a,
                o = this.globalData.canvasContext,
                s = t.s.v,
                l = t.e.v
              if (1 === e.t) r = o.createLinearGradient(s[0], s[1], l[0], l[1])
              else {
                var h = Math.sqrt(Math.pow(s[0] - l[0], 2) + Math.pow(s[1] - l[1], 2)),
                  u = Math.atan2(l[1] - s[1], l[0] - s[0]),
                  p = t.h.v
                p >= 1 ? (p = 0.99) : p <= -1 && (p = -0.99)
                var c = h * p,
                  d = Math.cos(u + t.a.v) * c + s[0],
                  f = Math.sin(u + t.a.v) * c + s[1]
                r = o.createRadialGradient(d, f, 0, s[0], s[1], h)
              }
              var m = e.g.p,
                g = t.g.c,
                y = 1
              for (a = 0; a < m; a += 1)
                t.g._hasOpacity && t.g._collapsable && (y = t.g.o[2 * a + 1]),
                  r.addColorStop(
                    g[4 * a] / 100,
                    'rgba(' + g[4 * a + 1] + ',' + g[4 * a + 2] + ',' + g[4 * a + 3] + ',' + y + ')'
                  )
              n.grd = r
            }
            n.coOp = t.o.v * i.opacity
          }),
          (CVShapeElement.prototype.renderStroke = function (e, t, i) {
            var r = t.style,
              n = t.d
            n && (n._mdf || this._isFirstFrame) && ((r.da = n.dashArray), (r.do = n.dashoffset[0])),
              (t.c._mdf || this._isFirstFrame) &&
                (r.co =
                  'rgb(' +
                  bmFloor(t.c.v[0]) +
                  ',' +
                  bmFloor(t.c.v[1]) +
                  ',' +
                  bmFloor(t.c.v[2]) +
                  ')'),
              (t.o._mdf || i._opMdf || this._isFirstFrame) && (r.coOp = t.o.v * i.opacity),
              (t.w._mdf || this._isFirstFrame) && (r.wi = t.w.v)
          }),
          (CVShapeElement.prototype.destroy = function () {
            ;(this.shapesData = null),
              (this.globalData = null),
              (this.canvasContext = null),
              (this.stylesList.length = 0),
              (this.itemsData.length = 0)
          }),
          extendPrototype(
            [
              BaseElement,
              TransformElement,
              CVBaseElement,
              HierarchyElement,
              FrameElement,
              RenderableElement
            ],
            CVSolidElement
          ),
          (CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement),
          (CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame),
          (CVSolidElement.prototype.renderInnerContent = function () {
            var e = this.canvasContext
            ;(e.fillStyle = this.data.sc), e.fillRect(0, 0, this.data.sw, this.data.sh)
          }),
          extendPrototype(
            [
              BaseElement,
              TransformElement,
              CVBaseElement,
              HierarchyElement,
              FrameElement,
              RenderableElement,
              ITextElement
            ],
            CVTextElement
          ),
          (CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d')),
          (CVTextElement.prototype.buildNewText = function () {
            var e = this.textProperty.currentData
            this.renderedLetters = createSizedArray(e.l ? e.l.length : 0)
            var t = !1
            e.fc
              ? ((t = !0), (this.values.fill = this.buildColor(e.fc)))
              : (this.values.fill = 'rgba(0,0,0,0)'),
              (this.fill = t)
            var i = !1
            e.sc &&
              ((i = !0), (this.values.stroke = this.buildColor(e.sc)), (this.values.sWidth = e.sw))
            var r,
              n,
              a,
              o,
              s,
              l,
              h,
              u,
              p,
              c,
              d,
              f,
              m = this.globalData.fontManager.getFontByName(e.f),
              g = e.l,
              y = this.mHelper
            ;(this.stroke = i),
              (this.values.fValue =
                e.finalSize + 'px ' + this.globalData.fontManager.getFontByName(e.f).fFamily),
              (n = e.finalText.length)
            var v = this.data.singleShape,
              _ = 0.001 * e.tr * e.finalSize,
              x = 0,
              S = 0,
              b = !0,
              T = 0
            for (r = 0; r < n; r += 1) {
              for (
                o =
                  ((a = this.globalData.fontManager.getCharData(
                    e.finalText[r],
                    m.fStyle,
                    this.globalData.fontManager.getFontByName(e.f).fFamily
                  )) &&
                    a.data) ||
                  {},
                  y.reset(),
                  v && g[r].n && ((x = -_), (S += e.yOffset), (S += b ? 1 : 0), (b = !1)),
                  p = (h = o.shapes ? o.shapes[0].it : []).length,
                  y.scale(e.finalSize / 100, e.finalSize / 100),
                  v && this.applyTextPropertiesToMatrix(e, y, g[r].line, x, S),
                  d = createSizedArray(p),
                  u = 0;
                u < p;
                u += 1
              ) {
                for (l = h[u].ks.k.i.length, c = h[u].ks.k, f = [], s = 1; s < l; s += 1)
                  1 === s &&
                    f.push(
                      y.applyToX(c.v[0][0], c.v[0][1], 0),
                      y.applyToY(c.v[0][0], c.v[0][1], 0)
                    ),
                    f.push(
                      y.applyToX(c.o[s - 1][0], c.o[s - 1][1], 0),
                      y.applyToY(c.o[s - 1][0], c.o[s - 1][1], 0),
                      y.applyToX(c.i[s][0], c.i[s][1], 0),
                      y.applyToY(c.i[s][0], c.i[s][1], 0),
                      y.applyToX(c.v[s][0], c.v[s][1], 0),
                      y.applyToY(c.v[s][0], c.v[s][1], 0)
                    )
                f.push(
                  y.applyToX(c.o[s - 1][0], c.o[s - 1][1], 0),
                  y.applyToY(c.o[s - 1][0], c.o[s - 1][1], 0),
                  y.applyToX(c.i[0][0], c.i[0][1], 0),
                  y.applyToY(c.i[0][0], c.i[0][1], 0),
                  y.applyToX(c.v[0][0], c.v[0][1], 0),
                  y.applyToY(c.v[0][0], c.v[0][1], 0)
                ),
                  (d[u] = f)
              }
              v && ((x += g[r].l), (x += _)),
                this.textSpans[T]
                  ? (this.textSpans[T].elem = d)
                  : (this.textSpans[T] = { elem: d }),
                (T += 1)
            }
          }),
          (CVTextElement.prototype.renderInnerContent = function () {
            var e,
              t,
              i,
              r,
              n,
              a,
              o = this.canvasContext
            ;(o.font = this.values.fValue),
              (o.lineCap = 'butt'),
              (o.lineJoin = 'miter'),
              (o.miterLimit = 4),
              this.data.singleShape ||
                this.textAnimator.getMeasures(
                  this.textProperty.currentData,
                  this.lettersChangedFlag
                )
            var s,
              l = this.textAnimator.renderedLetters,
              h = this.textProperty.currentData.l
            t = h.length
            var u,
              p,
              c = null,
              d = null,
              f = null
            for (e = 0; e < t; e += 1)
              if (!h[e].n) {
                if (
                  ((s = l[e]) &&
                    (this.globalData.renderer.save(),
                    this.globalData.renderer.ctxTransform(s.p),
                    this.globalData.renderer.ctxOpacity(s.o)),
                  this.fill)
                ) {
                  for (
                    s && s.fc
                      ? c !== s.fc && ((c = s.fc), (o.fillStyle = s.fc))
                      : c !== this.values.fill &&
                        ((c = this.values.fill), (o.fillStyle = this.values.fill)),
                      r = (u = this.textSpans[e].elem).length,
                      this.globalData.canvasContext.beginPath(),
                      i = 0;
                    i < r;
                    i += 1
                  )
                    for (
                      a = (p = u[i]).length,
                        this.globalData.canvasContext.moveTo(p[0], p[1]),
                        n = 2;
                      n < a;
                      n += 6
                    )
                      this.globalData.canvasContext.bezierCurveTo(
                        p[n],
                        p[n + 1],
                        p[n + 2],
                        p[n + 3],
                        p[n + 4],
                        p[n + 5]
                      )
                  this.globalData.canvasContext.closePath(), this.globalData.canvasContext.fill()
                }
                if (this.stroke) {
                  for (
                    s && s.sw
                      ? f !== s.sw && ((f = s.sw), (o.lineWidth = s.sw))
                      : f !== this.values.sWidth &&
                        ((f = this.values.sWidth), (o.lineWidth = this.values.sWidth)),
                      s && s.sc
                        ? d !== s.sc && ((d = s.sc), (o.strokeStyle = s.sc))
                        : d !== this.values.stroke &&
                          ((d = this.values.stroke), (o.strokeStyle = this.values.stroke)),
                      r = (u = this.textSpans[e].elem).length,
                      this.globalData.canvasContext.beginPath(),
                      i = 0;
                    i < r;
                    i += 1
                  )
                    for (
                      a = (p = u[i]).length,
                        this.globalData.canvasContext.moveTo(p[0], p[1]),
                        n = 2;
                      n < a;
                      n += 6
                    )
                      this.globalData.canvasContext.bezierCurveTo(
                        p[n],
                        p[n + 1],
                        p[n + 2],
                        p[n + 3],
                        p[n + 4],
                        p[n + 5]
                      )
                  this.globalData.canvasContext.closePath(), this.globalData.canvasContext.stroke()
                }
                s && this.globalData.renderer.restore()
              }
          }),
          (CVEffects.prototype.renderFrame = function () {}),
          (HBaseElement.prototype = {
            checkBlendMode: function () {},
            initRendererElement: function () {
              ;(this.baseElement = createTag(this.data.tg || 'div')),
                this.data.hasMask
                  ? ((this.svgElement = createNS('svg')),
                    (this.layerElement = createNS('g')),
                    (this.maskedElement = this.layerElement),
                    this.svgElement.appendChild(this.layerElement),
                    this.baseElement.appendChild(this.svgElement))
                  : (this.layerElement = this.baseElement),
                styleDiv(this.baseElement)
            },
            createContainerElements: function () {
              ;(this.renderableEffectsManager = new CVEffects(this)),
                (this.transformedElement = this.baseElement),
                (this.maskedElement = this.layerElement),
                this.data.ln && this.layerElement.setAttribute('id', this.data.ln),
                this.data.cl && this.layerElement.setAttribute('class', this.data.cl),
                0 !== this.data.bm && this.setBlendMode()
            },
            renderElement: function () {
              var e = this.transformedElement ? this.transformedElement.style : {}
              if (this.finalTransform._matMdf) {
                var t = this.finalTransform.mat.toCSS()
                ;(e.transform = t), (e.webkitTransform = t)
              }
              this.finalTransform._opMdf && (e.opacity = this.finalTransform.mProp.o.v)
            },
            renderFrame: function () {
              this.data.hd ||
                this.hidden ||
                (this.renderTransform(),
                this.renderRenderable(),
                this.renderElement(),
                this.renderInnerContent(),
                this._isFirstFrame && (this._isFirstFrame = !1))
            },
            destroy: function () {
              ;(this.layerElement = null),
                (this.transformedElement = null),
                this.matteElement && (this.matteElement = null),
                this.maskManager && (this.maskManager.destroy(), (this.maskManager = null))
            },
            createRenderableComponents: function () {
              this.maskManager = new MaskElement(this.data, this, this.globalData)
            },
            addEffects: function () {},
            setMatte: function () {}
          }),
          (HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement),
          (HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy),
          (HBaseElement.prototype.buildElementParenting =
            HybridRenderer.prototype.buildElementParenting),
          extendPrototype(
            [
              BaseElement,
              TransformElement,
              HBaseElement,
              HierarchyElement,
              FrameElement,
              RenderableDOMElement
            ],
            HSolidElement
          ),
          (HSolidElement.prototype.createContent = function () {
            var e
            this.data.hasMask
              ? ((e = createNS('rect')).setAttribute('width', this.data.sw),
                e.setAttribute('height', this.data.sh),
                e.setAttribute('fill', this.data.sc),
                this.svgElement.setAttribute('width', this.data.sw),
                this.svgElement.setAttribute('height', this.data.sh))
              : (((e = createTag('div')).style.width = this.data.sw + 'px'),
                (e.style.height = this.data.sh + 'px'),
                (e.style.backgroundColor = this.data.sc)),
              this.layerElement.appendChild(e)
          }),
          extendPrototype([HybridRenderer, ICompElement, HBaseElement], HCompElement),
          (HCompElement.prototype._createBaseContainerElements =
            HCompElement.prototype.createContainerElements),
          (HCompElement.prototype.createContainerElements = function () {
            this._createBaseContainerElements(),
              this.data.hasMask
                ? (this.svgElement.setAttribute('width', this.data.w),
                  this.svgElement.setAttribute('height', this.data.h),
                  (this.transformedElement = this.baseElement))
                : (this.transformedElement = this.layerElement)
          }),
          (HCompElement.prototype.addTo3dContainer = function (e, t) {
            for (var i, r = 0; r < t; )
              this.elements[r] &&
                this.elements[r].getBaseElement &&
                (i = this.elements[r].getBaseElement()),
                (r += 1)
            i ? this.layerElement.insertBefore(e, i) : this.layerElement.appendChild(e)
          }),
          extendPrototype(
            [
              BaseElement,
              TransformElement,
              HSolidElement,
              SVGShapeElement,
              HBaseElement,
              HierarchyElement,
              FrameElement,
              RenderableElement
            ],
            HShapeElement
          ),
          (HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent),
          (HShapeElement.prototype.createContent = function () {
            var e
            if (((this.baseElement.style.fontSize = 0), this.data.hasMask))
              this.layerElement.appendChild(this.shapesContainer), (e = this.svgElement)
            else {
              e = createNS('svg')
              var t = this.comp.data ? this.comp.data : this.globalData.compSize
              e.setAttribute('width', t.w),
                e.setAttribute('height', t.h),
                e.appendChild(this.shapesContainer),
                this.layerElement.appendChild(e)
            }
            this.searchShapes(
              this.shapesData,
              this.itemsData,
              this.prevViewData,
              this.shapesContainer,
              0,
              [],
              !0
            ),
              this.filterUniqueShapes(),
              (this.shapeCont = e)
          }),
          (HShapeElement.prototype.getTransformedPoint = function (e, t) {
            var i,
              r = e.length
            for (i = 0; i < r; i += 1) t = e[i].mProps.v.applyToPointArray(t[0], t[1], 0)
            return t
          }),
          (HShapeElement.prototype.calculateShapeBoundingBox = function (e, t) {
            var i,
              r,
              n,
              a,
              o,
              s = e.sh.v,
              l = e.transformers,
              h = s._length
            if (!(h <= 1)) {
              for (i = 0; i < h - 1; i += 1)
                (r = this.getTransformedPoint(l, s.v[i])),
                  (n = this.getTransformedPoint(l, s.o[i])),
                  (a = this.getTransformedPoint(l, s.i[i + 1])),
                  (o = this.getTransformedPoint(l, s.v[i + 1])),
                  this.checkBounds(r, n, a, o, t)
              s.c &&
                ((r = this.getTransformedPoint(l, s.v[i])),
                (n = this.getTransformedPoint(l, s.o[i])),
                (a = this.getTransformedPoint(l, s.i[0])),
                (o = this.getTransformedPoint(l, s.v[0])),
                this.checkBounds(r, n, a, o, t))
            }
          }),
          (HShapeElement.prototype.checkBounds = function (e, t, i, r, n) {
            this.getBoundsOfCurve(e, t, i, r)
            var a = this.shapeBoundingBox
            ;(n.x = bmMin(a.left, n.x)),
              (n.xMax = bmMax(a.right, n.xMax)),
              (n.y = bmMin(a.top, n.y)),
              (n.yMax = bmMax(a.bottom, n.yMax))
          }),
          (HShapeElement.prototype.shapeBoundingBox = { left: 0, right: 0, top: 0, bottom: 0 }),
          (HShapeElement.prototype.tempBoundingBox = {
            x: 0,
            xMax: 0,
            y: 0,
            yMax: 0,
            width: 0,
            height: 0
          }),
          (HShapeElement.prototype.getBoundsOfCurve = function (e, t, i, r) {
            for (
              var n,
                a,
                o,
                s,
                l,
                h,
                u,
                p = [
                  [e[0], r[0]],
                  [e[1], r[1]]
                ],
                c = 0;
              c < 2;
              ++c
            )
              (a = 6 * e[c] - 12 * t[c] + 6 * i[c]),
                (n = -3 * e[c] + 9 * t[c] - 9 * i[c] + 3 * r[c]),
                (o = 3 * t[c] - 3 * e[c]),
                (a |= 0),
                (o |= 0),
                (0 == (n |= 0) && 0 === a) ||
                  (0 === n
                    ? (s = -o / a) > 0 && s < 1 && p[c].push(this.calculateF(s, e, t, i, r, c))
                    : (l = a * a - 4 * o * n) >= 0 &&
                      ((h = (-a + bmSqrt(l)) / (2 * n)) > 0 &&
                        h < 1 &&
                        p[c].push(this.calculateF(h, e, t, i, r, c)),
                      (u = (-a - bmSqrt(l)) / (2 * n)) > 0 &&
                        u < 1 &&
                        p[c].push(this.calculateF(u, e, t, i, r, c))))
            ;(this.shapeBoundingBox.left = bmMin.apply(null, p[0])),
              (this.shapeBoundingBox.top = bmMin.apply(null, p[1])),
              (this.shapeBoundingBox.right = bmMax.apply(null, p[0])),
              (this.shapeBoundingBox.bottom = bmMax.apply(null, p[1]))
          }),
          (HShapeElement.prototype.calculateF = function (e, t, i, r, n, a) {
            return (
              bmPow(1 - e, 3) * t[a] +
              3 * bmPow(1 - e, 2) * e * i[a] +
              3 * (1 - e) * bmPow(e, 2) * r[a] +
              bmPow(e, 3) * n[a]
            )
          }),
          (HShapeElement.prototype.calculateBoundingBox = function (e, t) {
            var i,
              r = e.length
            for (i = 0; i < r; i += 1)
              e[i] && e[i].sh
                ? this.calculateShapeBoundingBox(e[i], t)
                : e[i] && e[i].it && this.calculateBoundingBox(e[i].it, t)
          }),
          (HShapeElement.prototype.currentBoxContains = function (e) {
            return (
              this.currentBBox.x <= e.x &&
              this.currentBBox.y <= e.y &&
              this.currentBBox.width + this.currentBBox.x >= e.x + e.width &&
              this.currentBBox.height + this.currentBBox.y >= e.y + e.height
            )
          }),
          (HShapeElement.prototype.renderInnerContent = function () {
            if ((this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf))) {
              var e = this.tempBoundingBox,
                t = 999999
              if (
                ((e.x = t),
                (e.xMax = -t),
                (e.y = t),
                (e.yMax = -t),
                this.calculateBoundingBox(this.itemsData, e),
                (e.width = e.xMax < e.x ? 0 : e.xMax - e.x),
                (e.height = e.yMax < e.y ? 0 : e.yMax - e.y),
                this.currentBoxContains(e))
              )
                return
              var i = !1
              if (
                (this.currentBBox.w !== e.width &&
                  ((this.currentBBox.w = e.width),
                  this.shapeCont.setAttribute('width', e.width),
                  (i = !0)),
                this.currentBBox.h !== e.height &&
                  ((this.currentBBox.h = e.height),
                  this.shapeCont.setAttribute('height', e.height),
                  (i = !0)),
                i || this.currentBBox.x !== e.x || this.currentBBox.y !== e.y)
              ) {
                ;(this.currentBBox.w = e.width),
                  (this.currentBBox.h = e.height),
                  (this.currentBBox.x = e.x),
                  (this.currentBBox.y = e.y),
                  this.shapeCont.setAttribute(
                    'viewBox',
                    this.currentBBox.x +
                      ' ' +
                      this.currentBBox.y +
                      ' ' +
                      this.currentBBox.w +
                      ' ' +
                      this.currentBBox.h
                  )
                var r = this.shapeCont.style,
                  n = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)'
                ;(r.transform = n), (r.webkitTransform = n)
              }
            }
          }),
          extendPrototype(
            [
              BaseElement,
              TransformElement,
              HBaseElement,
              HierarchyElement,
              FrameElement,
              RenderableDOMElement,
              ITextElement
            ],
            HTextElement
          ),
          (HTextElement.prototype.createContent = function () {
            if (((this.isMasked = this.checkMasks()), this.isMasked)) {
              ;(this.renderType = 'svg'),
                (this.compW = this.comp.data.w),
                (this.compH = this.comp.data.h),
                this.svgElement.setAttribute('width', this.compW),
                this.svgElement.setAttribute('height', this.compH)
              var e = createNS('g')
              this.maskedElement.appendChild(e), (this.innerElem = e)
            } else (this.renderType = 'html'), (this.innerElem = this.layerElement)
            this.checkParenting()
          }),
          (HTextElement.prototype.buildNewText = function () {
            var e = this.textProperty.currentData
            this.renderedLetters = createSizedArray(e.l ? e.l.length : 0)
            var t = this.innerElem.style,
              i = e.fc ? this.buildColor(e.fc) : 'rgba(0,0,0,0)'
            ;(t.fill = i),
              (t.color = i),
              e.sc && ((t.stroke = this.buildColor(e.sc)), (t.strokeWidth = e.sw + 'px'))
            var r,
              n,
              a = this.globalData.fontManager.getFontByName(e.f)
            if (!this.globalData.fontManager.chars)
              if (
                ((t.fontSize = e.finalSize + 'px'), (t.lineHeight = e.finalSize + 'px'), a.fClass)
              )
                this.innerElem.className = a.fClass
              else {
                t.fontFamily = a.fFamily
                var o = e.fWeight,
                  s = e.fStyle
                ;(t.fontStyle = s), (t.fontWeight = o)
              }
            var l,
              h,
              u,
              p = e.l
            n = p.length
            var c,
              d = this.mHelper,
              f = '',
              m = 0
            for (r = 0; r < n; r += 1) {
              if (
                (this.globalData.fontManager.chars
                  ? (this.textPaths[m]
                      ? (l = this.textPaths[m])
                      : ((l = createNS('path')).setAttribute('stroke-linecap', 'butt'),
                        l.setAttribute('stroke-linejoin', 'round'),
                        l.setAttribute('stroke-miterlimit', '4')),
                    this.isMasked ||
                      (this.textSpans[m]
                        ? (u = (h = this.textSpans[m]).children[0])
                        : (((h = createTag('div')).style.lineHeight = 0),
                          (u = createNS('svg')).appendChild(l),
                          styleDiv(h))))
                  : this.isMasked
                  ? (l = this.textPaths[m] ? this.textPaths[m] : createNS('text'))
                  : this.textSpans[m]
                  ? ((h = this.textSpans[m]), (l = this.textPaths[m]))
                  : (styleDiv((h = createTag('span'))),
                    styleDiv((l = createTag('span'))),
                    h.appendChild(l)),
                this.globalData.fontManager.chars)
              ) {
                var g,
                  y = this.globalData.fontManager.getCharData(
                    e.finalText[r],
                    a.fStyle,
                    this.globalData.fontManager.getFontByName(e.f).fFamily
                  )
                if (
                  ((g = y ? y.data : null),
                  d.reset(),
                  g &&
                    g.shapes &&
                    ((c = g.shapes[0].it),
                    d.scale(e.finalSize / 100, e.finalSize / 100),
                    (f = this.createPathShape(d, c)),
                    l.setAttribute('d', f)),
                  this.isMasked)
                )
                  this.innerElem.appendChild(l)
                else {
                  if ((this.innerElem.appendChild(h), g && g.shapes)) {
                    document.body.appendChild(u)
                    var v = u.getBBox()
                    u.setAttribute('width', v.width + 2),
                      u.setAttribute('height', v.height + 2),
                      u.setAttribute(
                        'viewBox',
                        v.x - 1 + ' ' + (v.y - 1) + ' ' + (v.width + 2) + ' ' + (v.height + 2)
                      )
                    var _ = u.style,
                      x = 'translate(' + (v.x - 1) + 'px,' + (v.y - 1) + 'px)'
                    ;(_.transform = x), (_.webkitTransform = x), (p[r].yOffset = v.y - 1)
                  } else u.setAttribute('width', 1), u.setAttribute('height', 1)
                  h.appendChild(u)
                }
              } else if (
                ((l.textContent = p[r].val),
                l.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve'),
                this.isMasked)
              )
                this.innerElem.appendChild(l)
              else {
                this.innerElem.appendChild(h)
                var S = l.style,
                  b = 'translate3d(0,' + -e.finalSize / 1.2 + 'px,0)'
                ;(S.transform = b), (S.webkitTransform = b)
              }
              this.isMasked ? (this.textSpans[m] = l) : (this.textSpans[m] = h),
                (this.textSpans[m].style.display = 'block'),
                (this.textPaths[m] = l),
                (m += 1)
            }
            for (; m < this.textSpans.length; ) (this.textSpans[m].style.display = 'none'), (m += 1)
          }),
          (HTextElement.prototype.renderInnerContent = function () {
            var e
            if (this.data.singleShape) {
              if (!this._isFirstFrame && !this.lettersChangedFlag) return
              if (this.isMasked && this.finalTransform._matMdf) {
                this.svgElement.setAttribute(
                  'viewBox',
                  -this.finalTransform.mProp.p.v[0] +
                    ' ' +
                    -this.finalTransform.mProp.p.v[1] +
                    ' ' +
                    this.compW +
                    ' ' +
                    this.compH
                ),
                  (e = this.svgElement.style)
                var t =
                  'translate(' +
                  -this.finalTransform.mProp.p.v[0] +
                  'px,' +
                  -this.finalTransform.mProp.p.v[1] +
                  'px)'
                ;(e.transform = t), (e.webkitTransform = t)
              }
            }
            if (
              (this.textAnimator.getMeasures(
                this.textProperty.currentData,
                this.lettersChangedFlag
              ),
              this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)
            ) {
              var i,
                r,
                n,
                a,
                o,
                s = 0,
                l = this.textAnimator.renderedLetters,
                h = this.textProperty.currentData.l
              for (r = h.length, i = 0; i < r; i += 1)
                h[i].n
                  ? (s += 1)
                  : ((a = this.textSpans[i]),
                    (o = this.textPaths[i]),
                    (n = l[s]),
                    (s += 1),
                    n._mdf.m &&
                      (this.isMasked
                        ? a.setAttribute('transform', n.m)
                        : ((a.style.webkitTransform = n.m), (a.style.transform = n.m))),
                    (a.style.opacity = n.o),
                    n.sw && n._mdf.sw && o.setAttribute('stroke-width', n.sw),
                    n.sc && n._mdf.sc && o.setAttribute('stroke', n.sc),
                    n.fc && n._mdf.fc && (o.setAttribute('fill', n.fc), (o.style.color = n.fc)))
              if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
                var u = this.innerElem.getBBox()
                if (
                  (this.currentBBox.w !== u.width &&
                    ((this.currentBBox.w = u.width),
                    this.svgElement.setAttribute('width', u.width)),
                  this.currentBBox.h !== u.height &&
                    ((this.currentBBox.h = u.height),
                    this.svgElement.setAttribute('height', u.height)),
                  this.currentBBox.w !== u.width + 2 ||
                    this.currentBBox.h !== u.height + 2 ||
                    this.currentBBox.x !== u.x - 1 ||
                    this.currentBBox.y !== u.y - 1)
                ) {
                  ;(this.currentBBox.w = u.width + 2),
                    (this.currentBBox.h = u.height + 2),
                    (this.currentBBox.x = u.x - 1),
                    (this.currentBBox.y = u.y - 1),
                    this.svgElement.setAttribute(
                      'viewBox',
                      this.currentBBox.x +
                        ' ' +
                        this.currentBBox.y +
                        ' ' +
                        this.currentBBox.w +
                        ' ' +
                        this.currentBBox.h
                    ),
                    (e = this.svgElement.style)
                  var p = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)'
                  ;(e.transform = p), (e.webkitTransform = p)
                }
              }
            }
          }),
          extendPrototype(
            [
              BaseElement,
              TransformElement,
              HBaseElement,
              HSolidElement,
              HierarchyElement,
              FrameElement,
              RenderableElement
            ],
            HImageElement
          ),
          (HImageElement.prototype.createContent = function () {
            var e = this.globalData.getAssetsPath(this.assetData),
              t = new Image()
            this.data.hasMask
              ? ((this.imageElem = createNS('image')),
                this.imageElem.setAttribute('width', this.assetData.w + 'px'),
                this.imageElem.setAttribute('height', this.assetData.h + 'px'),
                this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', e),
                this.layerElement.appendChild(this.imageElem),
                this.baseElement.setAttribute('width', this.assetData.w),
                this.baseElement.setAttribute('height', this.assetData.h))
              : this.layerElement.appendChild(t),
              (t.crossOrigin = 'anonymous'),
              (t.src = e),
              this.data.ln && this.baseElement.setAttribute('id', this.data.ln)
          }),
          extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement),
          (HCameraElement.prototype.setup = function () {
            var e,
              t,
              i,
              r,
              n = this.comp.threeDElements.length
            for (e = 0; e < n; e += 1)
              if ('3d' === (t = this.comp.threeDElements[e]).type) {
                ;(i = t.perspectiveElem.style), (r = t.container.style)
                var a = this.pe.v + 'px',
                  o = '0px 0px 0px',
                  s = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)'
                ;(i.perspective = a),
                  (i.webkitPerspective = a),
                  (r.transformOrigin = o),
                  (r.mozTransformOrigin = o),
                  (r.webkitTransformOrigin = o),
                  (i.transform = s),
                  (i.webkitTransform = s)
              }
          }),
          (HCameraElement.prototype.createElements = function () {}),
          (HCameraElement.prototype.hide = function () {}),
          (HCameraElement.prototype.renderFrame = function () {
            var e,
              t,
              i = this._isFirstFrame
            if (this.hierarchy)
              for (t = this.hierarchy.length, e = 0; e < t; e += 1)
                i = this.hierarchy[e].finalTransform.mProp._mdf || i
            if (
              i ||
              this.pe._mdf ||
              (this.p && this.p._mdf) ||
              (this.px && (this.px._mdf || this.py._mdf || this.pz._mdf)) ||
              this.rx._mdf ||
              this.ry._mdf ||
              this.rz._mdf ||
              this.or._mdf ||
              (this.a && this.a._mdf)
            ) {
              if ((this.mat.reset(), this.hierarchy))
                for (e = t = this.hierarchy.length - 1; e >= 0; e -= 1) {
                  var r = this.hierarchy[e].finalTransform.mProp
                  this.mat.translate(-r.p.v[0], -r.p.v[1], r.p.v[2]),
                    this.mat.rotateX(-r.or.v[0]).rotateY(-r.or.v[1]).rotateZ(r.or.v[2]),
                    this.mat.rotateX(-r.rx.v).rotateY(-r.ry.v).rotateZ(r.rz.v),
                    this.mat.scale(1 / r.s.v[0], 1 / r.s.v[1], 1 / r.s.v[2]),
                    this.mat.translate(r.a.v[0], r.a.v[1], r.a.v[2])
                }
              if (
                (this.p
                  ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2])
                  : this.mat.translate(-this.px.v, -this.py.v, this.pz.v),
                this.a)
              ) {
                var n
                n = this.p
                  ? [
                      this.p.v[0] - this.a.v[0],
                      this.p.v[1] - this.a.v[1],
                      this.p.v[2] - this.a.v[2]
                    ]
                  : [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]]
                var a = Math.sqrt(Math.pow(n[0], 2) + Math.pow(n[1], 2) + Math.pow(n[2], 2)),
                  o = [n[0] / a, n[1] / a, n[2] / a],
                  s = Math.sqrt(o[2] * o[2] + o[0] * o[0]),
                  l = Math.atan2(o[1], s),
                  h = Math.atan2(o[0], -o[2])
                this.mat.rotateY(h).rotateX(-l)
              }
              this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v),
                this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]),
                this.mat.translate(
                  this.globalData.compSize.w / 2,
                  this.globalData.compSize.h / 2,
                  0
                ),
                this.mat.translate(0, 0, this.pe.v)
              var u = !this._prevMat.equals(this.mat)
              if ((u || this.pe._mdf) && this.comp.threeDElements) {
                var p, c, d
                for (t = this.comp.threeDElements.length, e = 0; e < t; e += 1)
                  if ('3d' === (p = this.comp.threeDElements[e]).type) {
                    if (u) {
                      var f = this.mat.toCSS()
                      ;((d = p.container.style).transform = f), (d.webkitTransform = f)
                    }
                    this.pe._mdf &&
                      (((c = p.perspectiveElem.style).perspective = this.pe.v + 'px'),
                      (c.webkitPerspective = this.pe.v + 'px'))
                  }
                this.mat.clone(this._prevMat)
              }
            }
            this._isFirstFrame = !1
          }),
          (HCameraElement.prototype.prepareFrame = function (e) {
            this.prepareProperties(e, !0)
          }),
          (HCameraElement.prototype.destroy = function () {}),
          (HCameraElement.prototype.getBaseElement = function () {
            return null
          })
        var animationManager = (function () {
            var e = {},
              t = [],
              i = 0,
              r = 0,
              n = 0,
              a = !0,
              o = !1
            function s(e) {
              for (var i = 0, n = e.target; i < r; )
                t[i].animation === n && (t.splice(i, 1), (i -= 1), (r -= 1), n.isPaused || u()),
                  (i += 1)
            }
            function l(e, i) {
              if (!e) return null
              for (var n = 0; n < r; ) {
                if (t[n].elem === e && null !== t[n].elem) return t[n].animation
                n += 1
              }
              var a = new AnimationItem()
              return p(a, e), a.setData(e, i), a
            }
            function h() {
              ;(n += 1), f()
            }
            function u() {
              n -= 1
            }
            function p(e, i) {
              e.addEventListener('destroy', s),
                e.addEventListener('_active', h),
                e.addEventListener('_idle', u),
                t.push({ elem: i, animation: e }),
                (r += 1)
            }
            function c(e) {
              var s,
                l = e - i
              for (s = 0; s < r; s += 1) t[s].animation.advanceTime(l)
              ;(i = e), n && !o ? window.requestAnimationFrame(c) : (a = !0)
            }
            function d(e) {
              ;(i = e), window.requestAnimationFrame(c)
            }
            function f() {
              !o && n && a && (window.requestAnimationFrame(d), (a = !1))
            }
            return (
              (e.registerAnimation = l),
              (e.loadAnimation = function (e) {
                var t = new AnimationItem()
                return p(t, null), t.setParams(e), t
              }),
              (e.setSpeed = function (e, i) {
                var n
                for (n = 0; n < r; n += 1) t[n].animation.setSpeed(e, i)
              }),
              (e.setDirection = function (e, i) {
                var n
                for (n = 0; n < r; n += 1) t[n].animation.setDirection(e, i)
              }),
              (e.play = function (e) {
                var i
                for (i = 0; i < r; i += 1) t[i].animation.play(e)
              }),
              (e.pause = function (e) {
                var i
                for (i = 0; i < r; i += 1) t[i].animation.pause(e)
              }),
              (e.stop = function (e) {
                var i
                for (i = 0; i < r; i += 1) t[i].animation.stop(e)
              }),
              (e.togglePause = function (e) {
                var i
                for (i = 0; i < r; i += 1) t[i].animation.togglePause(e)
              }),
              (e.searchAnimations = function (e, t, i) {
                var r,
                  n = [].concat(
                    [].slice.call(document.getElementsByClassName('lottie')),
                    [].slice.call(document.getElementsByClassName('bodymovin'))
                  ),
                  a = n.length
                for (r = 0; r < a; r += 1) i && n[r].setAttribute('data-bm-type', i), l(n[r], e)
                if (t && 0 === a) {
                  i || (i = 'svg')
                  var o = document.getElementsByTagName('body')[0]
                  o.innerText = ''
                  var s = createTag('div')
                  ;(s.style.width = '100%'),
                    (s.style.height = '100%'),
                    s.setAttribute('data-bm-type', i),
                    o.appendChild(s),
                    l(s, e)
                }
              }),
              (e.resize = function () {
                var e
                for (e = 0; e < r; e += 1) t[e].animation.resize()
              }),
              (e.goToAndStop = function (e, i, n) {
                var a
                for (a = 0; a < r; a += 1) t[a].animation.goToAndStop(e, i, n)
              }),
              (e.destroy = function (e) {
                var i
                for (i = r - 1; i >= 0; i -= 1) t[i].animation.destroy(e)
              }),
              (e.freeze = function () {
                o = !0
              }),
              (e.unfreeze = function () {
                ;(o = !1), f()
              }),
              (e.setVolume = function (e, i) {
                var n
                for (n = 0; n < r; n += 1) t[n].animation.setVolume(e, i)
              }),
              (e.mute = function (e) {
                var i
                for (i = 0; i < r; i += 1) t[i].animation.mute(e)
              }),
              (e.unmute = function (e) {
                var i
                for (i = 0; i < r; i += 1) t[i].animation.unmute(e)
              }),
              (e.getRegisteredAnimations = function () {
                var e,
                  i = t.length,
                  r = []
                for (e = 0; e < i; e += 1) r.push(t[e].animation)
                return r
              }),
              e
            )
          })(),
          AnimationItem = function () {
            ;(this._cbs = []),
              (this.name = ''),
              (this.path = ''),
              (this.isLoaded = !1),
              (this.currentFrame = 0),
              (this.currentRawFrame = 0),
              (this.firstFrame = 0),
              (this.totalFrames = 0),
              (this.frameRate = 0),
              (this.frameMult = 0),
              (this.playSpeed = 1),
              (this.playDirection = 1),
              (this.playCount = 0),
              (this.animationData = {}),
              (this.assets = []),
              (this.isPaused = !0),
              (this.autoplay = !1),
              (this.loop = !0),
              (this.renderer = null),
              (this.animationID = createElementID()),
              (this.assetsPath = ''),
              (this.timeCompleted = 0),
              (this.segmentPos = 0),
              (this.isSubframeEnabled = subframeEnabled),
              (this.segments = []),
              (this._idle = !0),
              (this._completedLoop = !1),
              (this.projectInterface = ProjectInterface()),
              (this.imagePreloader = new ImagePreloader()),
              (this.audioController = audioControllerFactory()),
              (this.markers = [])
          }
        extendPrototype([BaseEvent], AnimationItem),
          (AnimationItem.prototype.setParams = function (e) {
            ;(e.wrapper || e.container) && (this.wrapper = e.wrapper || e.container)
            var t = 'svg'
            switch ((e.animType ? (t = e.animType) : e.renderer && (t = e.renderer), t)) {
              case 'canvas':
                this.renderer = new CanvasRenderer(this, e.rendererSettings)
                break
              case 'svg':
                this.renderer = new SVGRenderer(this, e.rendererSettings)
                break
              default:
                this.renderer = new HybridRenderer(this, e.rendererSettings)
            }
            this.imagePreloader.setCacheType(t, this.renderer.globalData.defs),
              this.renderer.setProjectInterface(this.projectInterface),
              (this.animType = t),
              '' === e.loop || null === e.loop || void 0 === e.loop || !0 === e.loop
                ? (this.loop = !0)
                : !1 === e.loop
                ? (this.loop = !1)
                : (this.loop = parseInt(e.loop, 10)),
              (this.autoplay = !('autoplay' in e) || e.autoplay),
              (this.name = e.name ? e.name : ''),
              (this.autoloadSegments =
                !Object.prototype.hasOwnProperty.call(e, 'autoloadSegments') || e.autoloadSegments),
              (this.assetsPath = e.assetsPath),
              (this.initialSegment = e.initialSegment),
              e.audioFactory && this.audioController.setAudioFactory(e.audioFactory),
              e.animationData
                ? this.configAnimation(e.animationData)
                : e.path &&
                  (-1 !== e.path.lastIndexOf('\\')
                    ? (this.path = e.path.substr(0, e.path.lastIndexOf('\\') + 1))
                    : (this.path = e.path.substr(0, e.path.lastIndexOf('/') + 1)),
                  (this.fileName = e.path.substr(e.path.lastIndexOf('/') + 1)),
                  (this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf('.json'))),
                  assetLoader.load(
                    e.path,
                    this.configAnimation.bind(this),
                    function () {
                      this.trigger('data_failed')
                    }.bind(this)
                  ))
          }),
          (AnimationItem.prototype.setData = function (e, t) {
            t && 'object' != typeof t && (t = JSON.parse(t))
            var i = { wrapper: e, animationData: t },
              r = e.attributes
            ;(i.path = r.getNamedItem('data-animation-path')
              ? r.getNamedItem('data-animation-path').value
              : r.getNamedItem('data-bm-path')
              ? r.getNamedItem('data-bm-path').value
              : r.getNamedItem('bm-path')
              ? r.getNamedItem('bm-path').value
              : ''),
              (i.animType = r.getNamedItem('data-anim-type')
                ? r.getNamedItem('data-anim-type').value
                : r.getNamedItem('data-bm-type')
                ? r.getNamedItem('data-bm-type').value
                : r.getNamedItem('bm-type')
                ? r.getNamedItem('bm-type').value
                : r.getNamedItem('data-bm-renderer')
                ? r.getNamedItem('data-bm-renderer').value
                : r.getNamedItem('bm-renderer')
                ? r.getNamedItem('bm-renderer').value
                : 'canvas')
            var n = r.getNamedItem('data-anim-loop')
              ? r.getNamedItem('data-anim-loop').value
              : r.getNamedItem('data-bm-loop')
              ? r.getNamedItem('data-bm-loop').value
              : r.getNamedItem('bm-loop')
              ? r.getNamedItem('bm-loop').value
              : ''
            'false' === n
              ? (i.loop = !1)
              : 'true' === n
              ? (i.loop = !0)
              : '' !== n && (i.loop = parseInt(n, 10))
            var a = r.getNamedItem('data-anim-autoplay')
              ? r.getNamedItem('data-anim-autoplay').value
              : r.getNamedItem('data-bm-autoplay')
              ? r.getNamedItem('data-bm-autoplay').value
              : !r.getNamedItem('bm-autoplay') || r.getNamedItem('bm-autoplay').value
            ;(i.autoplay = 'false' !== a),
              (i.name = r.getNamedItem('data-name')
                ? r.getNamedItem('data-name').value
                : r.getNamedItem('data-bm-name')
                ? r.getNamedItem('data-bm-name').value
                : r.getNamedItem('bm-name')
                ? r.getNamedItem('bm-name').value
                : ''),
              'false' ===
                (r.getNamedItem('data-anim-prerender')
                  ? r.getNamedItem('data-anim-prerender').value
                  : r.getNamedItem('data-bm-prerender')
                  ? r.getNamedItem('data-bm-prerender').value
                  : r.getNamedItem('bm-prerender')
                  ? r.getNamedItem('bm-prerender').value
                  : '') && (i.prerender = !1),
              this.setParams(i)
          }),
          (AnimationItem.prototype.includeLayers = function (e) {
            e.op > this.animationData.op &&
              ((this.animationData.op = e.op),
              (this.totalFrames = Math.floor(e.op - this.animationData.ip)))
            var t,
              i,
              r = this.animationData.layers,
              n = r.length,
              a = e.layers,
              o = a.length
            for (i = 0; i < o; i += 1)
              for (t = 0; t < n; ) {
                if (r[t].id === a[i].id) {
                  r[t] = a[i]
                  break
                }
                t += 1
              }
            if (
              ((e.chars || e.fonts) &&
                (this.renderer.globalData.fontManager.addChars(e.chars),
                this.renderer.globalData.fontManager.addFonts(
                  e.fonts,
                  this.renderer.globalData.defs
                )),
              e.assets)
            )
              for (n = e.assets.length, t = 0; t < n; t += 1)
                this.animationData.assets.push(e.assets[t])
            ;(this.animationData.__complete = !1),
              dataManager.completeData(this.animationData, this.renderer.globalData.fontManager),
              this.renderer.includeLayers(e.layers),
              expressionsPlugin && expressionsPlugin.initExpressions(this),
              this.loadNextSegment()
          }),
          (AnimationItem.prototype.loadNextSegment = function () {
            var e = this.animationData.segments
            if (!e || 0 === e.length || !this.autoloadSegments)
              return this.trigger('data_ready'), void (this.timeCompleted = this.totalFrames)
            var t = e.shift()
            this.timeCompleted = t.time * this.frameRate
            var i = this.path + this.fileName + '_' + this.segmentPos + '.json'
            ;(this.segmentPos += 1),
              assetLoader.load(
                i,
                this.includeLayers.bind(this),
                function () {
                  this.trigger('data_failed')
                }.bind(this)
              )
          }),
          (AnimationItem.prototype.loadSegments = function () {
            this.animationData.segments || (this.timeCompleted = this.totalFrames),
              this.loadNextSegment()
          }),
          (AnimationItem.prototype.imagesLoaded = function () {
            this.trigger('loaded_images'), this.checkLoaded()
          }),
          (AnimationItem.prototype.preloadImages = function () {
            this.imagePreloader.setAssetsPath(this.assetsPath),
              this.imagePreloader.setPath(this.path),
              this.imagePreloader.loadAssets(
                this.animationData.assets,
                this.imagesLoaded.bind(this)
              )
          }),
          (AnimationItem.prototype.configAnimation = function (e) {
            if (this.renderer)
              try {
                ;(this.animationData = e),
                  this.initialSegment
                    ? ((this.totalFrames = Math.floor(
                        this.initialSegment[1] - this.initialSegment[0]
                      )),
                      (this.firstFrame = Math.round(this.initialSegment[0])))
                    : ((this.totalFrames = Math.floor(
                        this.animationData.op - this.animationData.ip
                      )),
                      (this.firstFrame = Math.round(this.animationData.ip))),
                  this.renderer.configAnimation(e),
                  e.assets || (e.assets = []),
                  (this.assets = this.animationData.assets),
                  (this.frameRate = this.animationData.fr),
                  (this.frameMult = this.animationData.fr / 1e3),
                  this.renderer.searchExtraCompositions(e.assets),
                  (this.markers = markerParser(e.markers || [])),
                  this.trigger('config_ready'),
                  this.preloadImages(),
                  this.loadSegments(),
                  this.updaFrameModifier(),
                  this.waitForFontsLoaded(),
                  this.isPaused && this.audioController.pause()
              } catch (t) {
                this.triggerConfigError(t)
              }
          }),
          (AnimationItem.prototype.waitForFontsLoaded = function () {
            this.renderer &&
              (this.renderer.globalData.fontManager.isLoaded
                ? this.checkLoaded()
                : setTimeout(this.waitForFontsLoaded.bind(this), 20))
          }),
          (AnimationItem.prototype.checkLoaded = function () {
            !this.isLoaded &&
              this.renderer.globalData.fontManager.isLoaded &&
              (this.imagePreloader.loadedImages() || 'canvas' !== this.renderer.rendererType) &&
              this.imagePreloader.loadedFootages() &&
              ((this.isLoaded = !0),
              dataManager.completeData(this.animationData, this.renderer.globalData.fontManager),
              expressionsPlugin && expressionsPlugin.initExpressions(this),
              this.renderer.initItems(),
              setTimeout(
                function () {
                  this.trigger('DOMLoaded')
                }.bind(this),
                0
              ),
              this.gotoFrame(),
              this.autoplay && this.play())
          }),
          (AnimationItem.prototype.resize = function () {
            this.renderer.updateContainerSize()
          }),
          (AnimationItem.prototype.setSubframe = function (e) {
            this.isSubframeEnabled = !!e
          }),
          (AnimationItem.prototype.gotoFrame = function () {
            ;(this.currentFrame = this.isSubframeEnabled
              ? this.currentRawFrame
              : ~~this.currentRawFrame),
              this.timeCompleted !== this.totalFrames &&
                this.currentFrame > this.timeCompleted &&
                (this.currentFrame = this.timeCompleted),
              this.trigger('enterFrame'),
              this.renderFrame()
          }),
          (AnimationItem.prototype.renderFrame = function () {
            if (!1 !== this.isLoaded && this.renderer)
              try {
                this.renderer.renderFrame(this.currentFrame + this.firstFrame)
              } catch (e) {
                this.triggerRenderFrameError(e)
              }
          }),
          (AnimationItem.prototype.play = function (e) {
            ;(e && this.name !== e) ||
              (!0 === this.isPaused &&
                ((this.isPaused = !1),
                this.audioController.resume(),
                this._idle && ((this._idle = !1), this.trigger('_active'))))
          }),
          (AnimationItem.prototype.pause = function (e) {
            ;(e && this.name !== e) ||
              (!1 === this.isPaused &&
                ((this.isPaused = !0),
                (this._idle = !0),
                this.trigger('_idle'),
                this.audioController.pause()))
          }),
          (AnimationItem.prototype.togglePause = function (e) {
            ;(e && this.name !== e) || (!0 === this.isPaused ? this.play() : this.pause())
          }),
          (AnimationItem.prototype.stop = function (e) {
            ;(e && this.name !== e) ||
              (this.pause(),
              (this.playCount = 0),
              (this._completedLoop = !1),
              this.setCurrentRawFrameValue(0))
          }),
          (AnimationItem.prototype.getMarkerData = function (e) {
            for (var t, i = 0; i < this.markers.length; i += 1)
              if ((t = this.markers[i]).payload && t.payload.name === e) return t
            return null
          }),
          (AnimationItem.prototype.goToAndStop = function (e, t, i) {
            if (!i || this.name === i) {
              var r = Number(e)
              if (isNaN(r)) {
                var n = this.getMarkerData(e)
                n && this.goToAndStop(n.time, !0)
              } else
                t
                  ? this.setCurrentRawFrameValue(e)
                  : this.setCurrentRawFrameValue(e * this.frameModifier)
              this.pause()
            }
          }),
          (AnimationItem.prototype.goToAndPlay = function (e, t, i) {
            if (!i || this.name === i) {
              var r = Number(e)
              if (isNaN(r)) {
                var n = this.getMarkerData(e)
                n &&
                  (n.duration
                    ? this.playSegments([n.time, n.time + n.duration], !0)
                    : this.goToAndStop(n.time, !0))
              } else this.goToAndStop(r, t, i)
              this.play()
            }
          }),
          (AnimationItem.prototype.advanceTime = function (e) {
            if (!0 !== this.isPaused && !1 !== this.isLoaded) {
              var t = this.currentRawFrame + e * this.frameModifier,
                i = !1
              t >= this.totalFrames - 1 && this.frameModifier > 0
                ? this.loop && this.playCount !== this.loop
                  ? t >= this.totalFrames
                    ? ((this.playCount += 1),
                      this.checkSegments(t % this.totalFrames) ||
                        (this.setCurrentRawFrameValue(t % this.totalFrames),
                        (this._completedLoop = !0),
                        this.trigger('loopComplete')))
                    : this.setCurrentRawFrameValue(t)
                  : this.checkSegments(t > this.totalFrames ? t % this.totalFrames : 0) ||
                    ((i = !0), (t = this.totalFrames - 1))
                : t < 0
                ? this.checkSegments(t % this.totalFrames) ||
                  (!this.loop || (this.playCount-- <= 0 && !0 !== this.loop)
                    ? ((i = !0), (t = 0))
                    : (this.setCurrentRawFrameValue(this.totalFrames + (t % this.totalFrames)),
                      this._completedLoop
                        ? this.trigger('loopComplete')
                        : (this._completedLoop = !0)))
                : this.setCurrentRawFrameValue(t),
                i && (this.setCurrentRawFrameValue(t), this.pause(), this.trigger('complete'))
            }
          }),
          (AnimationItem.prototype.adjustSegment = function (e, t) {
            ;(this.playCount = 0),
              e[1] < e[0]
                ? (this.frameModifier > 0 &&
                    (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)),
                  (this.totalFrames = e[0] - e[1]),
                  (this.timeCompleted = this.totalFrames),
                  (this.firstFrame = e[1]),
                  this.setCurrentRawFrameValue(this.totalFrames - 0.001 - t))
                : e[1] > e[0] &&
                  (this.frameModifier < 0 &&
                    (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)),
                  (this.totalFrames = e[1] - e[0]),
                  (this.timeCompleted = this.totalFrames),
                  (this.firstFrame = e[0]),
                  this.setCurrentRawFrameValue(0.001 + t)),
              this.trigger('segmentStart')
          }),
          (AnimationItem.prototype.setSegment = function (e, t) {
            var i = -1
            this.isPaused &&
              (this.currentRawFrame + this.firstFrame < e
                ? (i = e)
                : this.currentRawFrame + this.firstFrame > t && (i = t - e)),
              (this.firstFrame = e),
              (this.totalFrames = t - e),
              (this.timeCompleted = this.totalFrames),
              -1 !== i && this.goToAndStop(i, !0)
          }),
          (AnimationItem.prototype.playSegments = function (e, t) {
            if ((t && (this.segments.length = 0), 'object' == typeof e[0])) {
              var i,
                r = e.length
              for (i = 0; i < r; i += 1) this.segments.push(e[i])
            } else this.segments.push(e)
            this.segments.length && t && this.adjustSegment(this.segments.shift(), 0),
              this.isPaused && this.play()
          }),
          (AnimationItem.prototype.resetSegments = function (e) {
            ;(this.segments.length = 0),
              this.segments.push([this.animationData.ip, this.animationData.op]),
              e && this.checkSegments(0)
          }),
          (AnimationItem.prototype.checkSegments = function (e) {
            return !!this.segments.length && (this.adjustSegment(this.segments.shift(), e), !0)
          }),
          (AnimationItem.prototype.destroy = function (e) {
            ;(e && this.name !== e) ||
              !this.renderer ||
              (this.renderer.destroy(),
              this.imagePreloader.destroy(),
              this.trigger('destroy'),
              (this._cbs = null),
              (this.onEnterFrame = null),
              (this.onLoopComplete = null),
              (this.onComplete = null),
              (this.onSegmentStart = null),
              (this.onDestroy = null),
              (this.renderer = null),
              (this.renderer = null),
              (this.imagePreloader = null),
              (this.projectInterface = null))
          }),
          (AnimationItem.prototype.setCurrentRawFrameValue = function (e) {
            ;(this.currentRawFrame = e), this.gotoFrame()
          }),
          (AnimationItem.prototype.setSpeed = function (e) {
            ;(this.playSpeed = e), this.updaFrameModifier()
          }),
          (AnimationItem.prototype.setDirection = function (e) {
            ;(this.playDirection = e < 0 ? -1 : 1), this.updaFrameModifier()
          }),
          (AnimationItem.prototype.setVolume = function (e, t) {
            ;(t && this.name !== t) || this.audioController.setVolume(e)
          }),
          (AnimationItem.prototype.getVolume = function () {
            return this.audioController.getVolume()
          }),
          (AnimationItem.prototype.mute = function (e) {
            ;(e && this.name !== e) || this.audioController.mute()
          }),
          (AnimationItem.prototype.unmute = function (e) {
            ;(e && this.name !== e) || this.audioController.unmute()
          }),
          (AnimationItem.prototype.updaFrameModifier = function () {
            ;(this.frameModifier = this.frameMult * this.playSpeed * this.playDirection),
              this.audioController.setRate(this.playSpeed * this.playDirection)
          }),
          (AnimationItem.prototype.getPath = function () {
            return this.path
          }),
          (AnimationItem.prototype.getAssetsPath = function (e) {
            var t = ''
            if (e.e) t = e.p
            else if (this.assetsPath) {
              var i = e.p
              ;-1 !== i.indexOf('images/') && (i = i.split('/')[1]), (t = this.assetsPath + i)
            } else (t = this.path), (t += e.u ? e.u : ''), (t += e.p)
            return t
          }),
          (AnimationItem.prototype.getAssetData = function (e) {
            for (var t = 0, i = this.assets.length; t < i; ) {
              if (e === this.assets[t].id) return this.assets[t]
              t += 1
            }
            return null
          }),
          (AnimationItem.prototype.hide = function () {
            this.renderer.hide()
          }),
          (AnimationItem.prototype.show = function () {
            this.renderer.show()
          }),
          (AnimationItem.prototype.getDuration = function (e) {
            return e ? this.totalFrames : this.totalFrames / this.frameRate
          }),
          (AnimationItem.prototype.trigger = function (e) {
            if (this._cbs && this._cbs[e])
              switch (e) {
                case 'enterFrame':
                  this.triggerEvent(
                    e,
                    new BMEnterFrameEvent(
                      e,
                      this.currentFrame,
                      this.totalFrames,
                      this.frameModifier
                    )
                  )
                  break
                case 'loopComplete':
                  this.triggerEvent(
                    e,
                    new BMCompleteLoopEvent(e, this.loop, this.playCount, this.frameMult)
                  )
                  break
                case 'complete':
                  this.triggerEvent(e, new BMCompleteEvent(e, this.frameMult))
                  break
                case 'segmentStart':
                  this.triggerEvent(
                    e,
                    new BMSegmentStartEvent(e, this.firstFrame, this.totalFrames)
                  )
                  break
                case 'destroy':
                  this.triggerEvent(e, new BMDestroyEvent(e, this))
                  break
                default:
                  this.triggerEvent(e)
              }
            'enterFrame' === e &&
              this.onEnterFrame &&
              this.onEnterFrame.call(
                this,
                new BMEnterFrameEvent(e, this.currentFrame, this.totalFrames, this.frameMult)
              ),
              'loopComplete' === e &&
                this.onLoopComplete &&
                this.onLoopComplete.call(
                  this,
                  new BMCompleteLoopEvent(e, this.loop, this.playCount, this.frameMult)
                ),
              'complete' === e &&
                this.onComplete &&
                this.onComplete.call(this, new BMCompleteEvent(e, this.frameMult)),
              'segmentStart' === e &&
                this.onSegmentStart &&
                this.onSegmentStart.call(
                  this,
                  new BMSegmentStartEvent(e, this.firstFrame, this.totalFrames)
                ),
              'destroy' === e &&
                this.onDestroy &&
                this.onDestroy.call(this, new BMDestroyEvent(e, this))
          }),
          (AnimationItem.prototype.triggerRenderFrameError = function (e) {
            var t = new BMRenderFrameErrorEvent(e, this.currentFrame)
            this.triggerEvent('error', t), this.onError && this.onError.call(this, t)
          }),
          (AnimationItem.prototype.triggerConfigError = function (e) {
            var t = new BMConfigErrorEvent(e, this.currentFrame)
            this.triggerEvent('error', t), this.onError && this.onError.call(this, t)
          })
        var Expressions = (function () {
          var e = {
            initExpressions: function (e) {
              var t = 0,
                i = []
              ;(e.renderer.compInterface = CompExpressionInterface(e.renderer)),
                e.renderer.globalData.projectInterface.registerComposition(e.renderer),
                (e.renderer.globalData.pushExpression = function () {
                  t += 1
                }),
                (e.renderer.globalData.popExpression = function () {
                  0 == (t -= 1) &&
                    (function () {
                      var e,
                        t = i.length
                      for (e = 0; e < t; e += 1) i[e].release()
                      i.length = 0
                    })()
                }),
                (e.renderer.globalData.registerExpressionProperty = function (e) {
                  ;-1 === i.indexOf(e) && i.push(e)
                })
            }
          }
          return e
        })()
        expressionsPlugin = Expressions
        var ExpressionManager = (function () {
            var ob = {},
              Math = BMMath
            function initiateExpression(elem, data, property) {
              var val = data.x,
                needsVelocity = /velocity(?![\w\d])/.test(val),
                _needsRandom = -1 !== val.indexOf('random'),
                elemType = elem.data.ty,
                transform,
                content,
                effect,
                thisProperty = property,
                thisLayer,
                velocityAtTime,
                scoped_bm_rt
              ;(thisProperty.valueAtTime = thisProperty.getValueAtTime),
                Object.defineProperty(thisProperty, 'value', {
                  get: function () {
                    return thisProperty.v
                  }
                }),
                (elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate),
                (elem.comp.displayStartTime = 0),
                elem.data.ip,
                elem.comp.globalData.frameRate,
                elem.data.op,
                elem.comp.globalData.frameRate,
                elem.data.sw && elem.data.sw,
                elem.data.sh && elem.data.sh,
                elem.data.nm
              var expression_function = eval(
                  '[function _expression_function(){' + val + ';scoped_bm_rt=$bm_rt}]'
                )[0],
                time,
                value
              function seedRandom(e) {
                BMMath.seedrandom(randSeed + e)
              }
              property.kf && data.k.length,
                !this.data || this.data.hd,
                function (e, t) {
                  var i,
                    r,
                    n = this.pv.length ? this.pv.length : 1,
                    a = createTypedArray('float32', n),
                    o = Math.floor(5 * time)
                  for (i = 0, r = 0; i < o; ) {
                    for (r = 0; r < n; r += 1) a[r] += -t + 2 * t * BMMath.random()
                    i += 1
                  }
                  var s = 5 * time,
                    l = s - Math.floor(s),
                    h = createTypedArray('float32', n)
                  if (n > 1) {
                    for (r = 0; r < n; r += 1)
                      h[r] = this.pv[r] + a[r] + (-t + 2 * t * BMMath.random()) * l
                    return h
                  }
                  return this.pv + a[0] + (-t + 2 * t * BMMath.random()) * l
                }.bind(this),
                thisProperty.loopIn && thisProperty.loopIn.bind(thisProperty),
                thisProperty.loopOut && thisProperty.loopOut.bind(thisProperty),
                thisProperty.smooth && thisProperty.smooth.bind(thisProperty),
                this.getValueAtTime && this.getValueAtTime.bind(this),
                this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this)),
                elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface),
                elem.data.ind
              var hasParent = !(!elem.hierarchy || !elem.hierarchy.length),
                parent,
                randSeed = Math.floor(1e6 * Math.random())
              function executeExpression(e) {
                return (
                  (value = e),
                  _needsRandom && seedRandom(randSeed),
                  this.frameExpressionId === elem.globalData.frameId &&
                  'textSelector' !== this.propType
                    ? value
                    : ('textSelector' === this.propType &&
                        (this.textIndex, this.textTotal, this.selectorValue),
                      thisLayer ||
                        (elem.layerInterface.text,
                        (thisLayer = elem.layerInterface),
                        elem.comp.compInterface,
                        thisLayer.toWorld.bind(thisLayer),
                        thisLayer.fromWorld.bind(thisLayer),
                        thisLayer.fromComp.bind(thisLayer),
                        thisLayer.toComp.bind(thisLayer),
                        thisLayer.mask && thisLayer.mask.bind(thisLayer)),
                      transform ||
                        ((transform = elem.layerInterface('ADBE Transform Group')) &&
                          transform.anchorPoint),
                      4 !== elemType || content || (content = thisLayer('ADBE Root Vectors Group')),
                      effect || (effect = thisLayer(4)),
                      (hasParent = !(!elem.hierarchy || !elem.hierarchy.length)) &&
                        !parent &&
                        (parent = elem.hierarchy[0].layerInterface),
                      (time = this.comp.renderedFrame / this.comp.globalData.frameRate),
                      needsVelocity && velocityAtTime(time),
                      expression_function(),
                      (this.frameExpressionId = elem.globalData.frameId),
                      scoped_bm_rt.propType,
                      scoped_bm_rt)
                )
              }
              return elem.globalData, executeExpression
            }
            return (
              BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, 'easeIn').get,
              BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, 'easeOut').get,
              BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, 'easeInOut').get,
              (ob.initiateExpression = initiateExpression),
              ob
            )
          })(),
          expressionHelpers = {
            searchExpressions: function (e, t, i) {
              t.x &&
                ((i.k = !0),
                (i.x = !0),
                (i.initiateExpression = ExpressionManager.initiateExpression),
                i.effectsSequence.push(i.initiateExpression(e, t, i).bind(i)))
            },
            getSpeedAtTime: function (e) {
              var t = this.getValueAtTime(e),
                i = this.getValueAtTime(e + -0.01),
                r = 0
              if (t.length) {
                var n
                for (n = 0; n < t.length; n += 1) r += Math.pow(i[n] - t[n], 2)
                r = 100 * Math.sqrt(r)
              } else r = 0
              return r
            },
            getVelocityAtTime: function (e) {
              if (void 0 !== this.vel) return this.vel
              var t,
                i,
                r = -0.001,
                n = this.getValueAtTime(e),
                a = this.getValueAtTime(e + r)
              if (n.length)
                for (t = createTypedArray('float32', n.length), i = 0; i < n.length; i += 1)
                  t[i] = (a[i] - n[i]) / r
              else t = (a - n) / r
              return t
            },
            getValueAtTime: function (e) {
              return (
                (e *= this.elem.globalData.frameRate),
                (e -= this.offsetTime) !== this._cachingAtTime.lastFrame &&
                  ((this._cachingAtTime.lastIndex =
                    this._cachingAtTime.lastFrame < e ? this._cachingAtTime.lastIndex : 0),
                  (this._cachingAtTime.value = this.interpolateValue(e, this._cachingAtTime)),
                  (this._cachingAtTime.lastFrame = e)),
                this._cachingAtTime.value
              )
            },
            getStaticValueAtTime: function () {
              return this.pv
            },
            setGroupProperty: function (e) {
              this.propertyGroup = e
            }
          }
        !(function () {
          function e(e, t, i) {
            if (!this.k || !this.keyframes) return this.pv
            e = e ? e.toLowerCase() : ''
            var r,
              n,
              a,
              o,
              s,
              l = this.comp.renderedFrame,
              h = this.keyframes,
              u = h[h.length - 1].t
            if (l <= u) return this.pv
            if (
              (i
                ? (n =
                    u -
                    (r = t
                      ? Math.abs(u - this.elem.comp.globalData.frameRate * t)
                      : Math.max(0, u - this.elem.data.ip)))
                : ((!t || t > h.length - 1) && (t = h.length - 1),
                  (r = u - (n = h[h.length - 1 - t].t))),
              'pingpong' === e)
            ) {
              if (Math.floor((l - n) / r) % 2 != 0)
                return this.getValueAtTime(
                  (r - ((l - n) % r) + n) / this.comp.globalData.frameRate,
                  0
                )
            } else {
              if ('offset' === e) {
                var p = this.getValueAtTime(n / this.comp.globalData.frameRate, 0),
                  c = this.getValueAtTime(u / this.comp.globalData.frameRate, 0),
                  d = this.getValueAtTime((((l - n) % r) + n) / this.comp.globalData.frameRate, 0),
                  f = Math.floor((l - n) / r)
                if (this.pv.length) {
                  for (o = (s = new Array(p.length)).length, a = 0; a < o; a += 1)
                    s[a] = (c[a] - p[a]) * f + d[a]
                  return s
                }
                return (c - p) * f + d
              }
              if ('continue' === e) {
                var m = this.getValueAtTime(u / this.comp.globalData.frameRate, 0),
                  g = this.getValueAtTime((u - 0.001) / this.comp.globalData.frameRate, 0)
                if (this.pv.length) {
                  for (o = (s = new Array(m.length)).length, a = 0; a < o; a += 1)
                    s[a] =
                      m[a] + ((m[a] - g[a]) * ((l - u) / this.comp.globalData.frameRate)) / 5e-4
                  return s
                }
                return m + ((l - u) / 0.001) * (m - g)
              }
            }
            return this.getValueAtTime((((l - n) % r) + n) / this.comp.globalData.frameRate, 0)
          }
          function t(e, t, i) {
            if (!this.k) return this.pv
            e = e ? e.toLowerCase() : ''
            var r,
              n,
              a,
              o,
              s,
              l = this.comp.renderedFrame,
              h = this.keyframes,
              u = h[0].t
            if (l >= u) return this.pv
            if (
              (i
                ? (n =
                    u +
                    (r = t
                      ? Math.abs(this.elem.comp.globalData.frameRate * t)
                      : Math.max(0, this.elem.data.op - u)))
                : ((!t || t > h.length - 1) && (t = h.length - 1), (r = (n = h[t].t) - u)),
              'pingpong' === e)
            ) {
              if (Math.floor((u - l) / r) % 2 == 0)
                return this.getValueAtTime((((u - l) % r) + u) / this.comp.globalData.frameRate, 0)
            } else {
              if ('offset' === e) {
                var p = this.getValueAtTime(u / this.comp.globalData.frameRate, 0),
                  c = this.getValueAtTime(n / this.comp.globalData.frameRate, 0),
                  d = this.getValueAtTime(
                    (r - ((u - l) % r) + u) / this.comp.globalData.frameRate,
                    0
                  ),
                  f = Math.floor((u - l) / r) + 1
                if (this.pv.length) {
                  for (o = (s = new Array(p.length)).length, a = 0; a < o; a += 1)
                    s[a] = d[a] - (c[a] - p[a]) * f
                  return s
                }
                return d - (c - p) * f
              }
              if ('continue' === e) {
                var m = this.getValueAtTime(u / this.comp.globalData.frameRate, 0),
                  g = this.getValueAtTime((u + 0.001) / this.comp.globalData.frameRate, 0)
                if (this.pv.length) {
                  for (o = (s = new Array(m.length)).length, a = 0; a < o; a += 1)
                    s[a] = m[a] + ((m[a] - g[a]) * (u - l)) / 0.001
                  return s
                }
                return m + ((m - g) * (u - l)) / 0.001
              }
            }
            return this.getValueAtTime(
              (r - (((u - l) % r) + u)) / this.comp.globalData.frameRate,
              0
            )
          }
          function i(e, t) {
            if (!this.k) return this.pv
            if (((e = 0.5 * (e || 0.4)), (t = Math.floor(t || 5)) <= 1)) return this.pv
            var i,
              r,
              n = this.comp.renderedFrame / this.comp.globalData.frameRate,
              a = n - e,
              o = t > 1 ? (n + e - a) / (t - 1) : 1,
              s = 0,
              l = 0
            for (i = this.pv.length ? createTypedArray('float32', this.pv.length) : 0; s < t; ) {
              if (((r = this.getValueAtTime(a + s * o)), this.pv.length))
                for (l = 0; l < this.pv.length; l += 1) i[l] += r[l]
              else i += r
              s += 1
            }
            if (this.pv.length) for (l = 0; l < this.pv.length; l += 1) i[l] /= t
            else i /= t
            return i
          }
          function r(e) {
            this._transformCachingAtTime || (this._transformCachingAtTime = { v: new Matrix() })
            var t = this._transformCachingAtTime.v
            if ((t.cloneFromProps(this.pre.props), this.appliedTransformations < 1)) {
              var i = this.a.getValueAtTime(e)
              t.translate(-i[0] * this.a.mult, -i[1] * this.a.mult, i[2] * this.a.mult)
            }
            if (this.appliedTransformations < 2) {
              var r = this.s.getValueAtTime(e)
              t.scale(r[0] * this.s.mult, r[1] * this.s.mult, r[2] * this.s.mult)
            }
            if (this.sk && this.appliedTransformations < 3) {
              var n = this.sk.getValueAtTime(e),
                a = this.sa.getValueAtTime(e)
              t.skewFromAxis(-n * this.sk.mult, a * this.sa.mult)
            }
            if (this.r && this.appliedTransformations < 4) {
              var o = this.r.getValueAtTime(e)
              t.rotate(-o * this.r.mult)
            } else if (!this.r && this.appliedTransformations < 4) {
              var s = this.rz.getValueAtTime(e),
                l = this.ry.getValueAtTime(e),
                h = this.rx.getValueAtTime(e),
                u = this.or.getValueAtTime(e)
              t.rotateZ(-s * this.rz.mult)
                .rotateY(l * this.ry.mult)
                .rotateX(h * this.rx.mult)
                .rotateZ(-u[2] * this.or.mult)
                .rotateY(u[1] * this.or.mult)
                .rotateX(u[0] * this.or.mult)
            }
            if (this.data.p && this.data.p.s) {
              var p = this.px.getValueAtTime(e),
                c = this.py.getValueAtTime(e)
              if (this.data.p.z) {
                var d = this.pz.getValueAtTime(e)
                t.translate(p * this.px.mult, c * this.py.mult, -d * this.pz.mult)
              } else t.translate(p * this.px.mult, c * this.py.mult, 0)
            } else {
              var f = this.p.getValueAtTime(e)
              t.translate(f[0] * this.p.mult, f[1] * this.p.mult, -f[2] * this.p.mult)
            }
            return t
          }
          function n() {
            return this.v.clone(new Matrix())
          }
          var a = TransformPropertyFactory.getTransformProperty
          TransformPropertyFactory.getTransformProperty = function (e, t, i) {
            var o = a(e, t, i)
            return (
              o.dynamicProperties.length
                ? (o.getValueAtTime = r.bind(o))
                : (o.getValueAtTime = n.bind(o)),
              (o.setGroupProperty = expressionHelpers.setGroupProperty),
              o
            )
          }
          var o = PropertyFactory.getProp
          PropertyFactory.getProp = function (r, n, a, s, l) {
            var h = o(r, n, a, s, l)
            h.kf
              ? (h.getValueAtTime = expressionHelpers.getValueAtTime.bind(h))
              : (h.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(h)),
              (h.setGroupProperty = expressionHelpers.setGroupProperty),
              (h.loopOut = e),
              (h.loopIn = t),
              (h.smooth = i),
              (h.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(h)),
              (h.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(h)),
              (h.numKeys = 1 === n.a ? n.k.length : 0),
              (h.propertyIndex = n.ix)
            var u = 0
            return (
              0 !== a &&
                (u = createTypedArray('float32', 1 === n.a ? n.k[0].s.length : n.k.length)),
              (h._cachingAtTime = { lastFrame: initialDefaultFrame, lastIndex: 0, value: u }),
              expressionHelpers.searchExpressions(r, n, h),
              h.k && l.addDynamicProperty(h),
              h
            )
          }
          var s = ShapePropertyFactory.getConstructorFunction(),
            l = ShapePropertyFactory.getKeyframedConstructorFunction()
          function h() {}
          ;(h.prototype = {
            vertices: function (e, t) {
              this.k && this.getValue()
              var i,
                r = this.v
              void 0 !== t && (r = this.getValueAtTime(t, 0))
              var n = r._length,
                a = r[e],
                o = r.v,
                s = createSizedArray(n)
              for (i = 0; i < n; i += 1)
                s[i] =
                  'i' === e || 'o' === e
                    ? [a[i][0] - o[i][0], a[i][1] - o[i][1]]
                    : [a[i][0], a[i][1]]
              return s
            },
            points: function (e) {
              return this.vertices('v', e)
            },
            inTangents: function (e) {
              return this.vertices('i', e)
            },
            outTangents: function (e) {
              return this.vertices('o', e)
            },
            isClosed: function () {
              return this.v.c
            },
            pointOnPath: function (e, t) {
              var i = this.v
              void 0 !== t && (i = this.getValueAtTime(t, 0)),
                this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(i))
              for (
                var r,
                  n = this._segmentsLength,
                  a = n.lengths,
                  o = n.totalLength * e,
                  s = 0,
                  l = a.length,
                  h = 0;
                s < l;

              ) {
                if (h + a[s].addedLength > o) {
                  var u = s,
                    p = i.c && s === l - 1 ? 0 : s + 1,
                    c = (o - h) / a[s].addedLength
                  r = bez.getPointInSegment(i.v[u], i.v[p], i.o[u], i.i[p], c, a[s])
                  break
                }
                ;(h += a[s].addedLength), (s += 1)
              }
              return (
                r ||
                  (r = i.c
                    ? [i.v[0][0], i.v[0][1]]
                    : [i.v[i._length - 1][0], i.v[i._length - 1][1]]),
                r
              )
            },
            vectorOnPath: function (e, t, i) {
              1 == e ? (e = this.v.c) : 0 == e && (e = 0.999)
              var r = this.pointOnPath(e, t),
                n = this.pointOnPath(e + 0.001, t),
                a = n[0] - r[0],
                o = n[1] - r[1],
                s = Math.sqrt(Math.pow(a, 2) + Math.pow(o, 2))
              return 0 === s ? [0, 0] : 'tangent' === i ? [a / s, o / s] : [-o / s, a / s]
            },
            tangentOnPath: function (e, t) {
              return this.vectorOnPath(e, t, 'tangent')
            },
            normalOnPath: function (e, t) {
              return this.vectorOnPath(e, t, 'normal')
            },
            setGroupProperty: expressionHelpers.setGroupProperty,
            getValueAtTime: expressionHelpers.getStaticValueAtTime
          }),
            extendPrototype([h], s),
            extendPrototype([h], l),
            (l.prototype.getValueAtTime = function (e) {
              return (
                this._cachingAtTime ||
                  (this._cachingAtTime = {
                    shapeValue: shapePool.clone(this.pv),
                    lastIndex: 0,
                    lastTime: initialDefaultFrame
                  }),
                (e *= this.elem.globalData.frameRate),
                (e -= this.offsetTime) !== this._cachingAtTime.lastTime &&
                  ((this._cachingAtTime.lastIndex =
                    this._cachingAtTime.lastTime < e ? this._caching.lastIndex : 0),
                  (this._cachingAtTime.lastTime = e),
                  this.interpolateShape(e, this._cachingAtTime.shapeValue, this._cachingAtTime)),
                this._cachingAtTime.shapeValue
              )
            }),
            (l.prototype.initiateExpression = ExpressionManager.initiateExpression)
          var u = ShapePropertyFactory.getShapeProp
          ShapePropertyFactory.getShapeProp = function (e, t, i, r, n) {
            var a = u(e, t, i, r, n)
            return (
              (a.propertyIndex = t.ix),
              (a.lock = !1),
              3 === i
                ? expressionHelpers.searchExpressions(e, t.pt, a)
                : 4 === i && expressionHelpers.searchExpressions(e, t.ks, a),
              a.k && e.addDynamicProperty(a),
              a
            )
          }
        })(),
          (TextProperty.prototype.getExpressionValue = function (e, t) {
            var i = this.calculateExpression(t)
            if (e.t !== i) {
              var r = {}
              return this.copyData(r, e), (r.t = i.toString()), (r.__complete = !1), r
            }
            return e
          }),
          (TextProperty.prototype.searchProperty = function () {
            var e = this.searchKeyframes(),
              t = this.searchExpressions()
            return (this.kf = e || t), this.kf
          }),
          (TextProperty.prototype.searchExpressions = function () {
            return this.data.d.x
              ? ((this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(
                  this.elem,
                  this.data.d,
                  this
                )),
                this.addEffect(this.getExpressionValue.bind(this)),
                !0)
              : null
          })
        var ShapePathInterface = function (e, t, i) {
            var r = t.sh
            function n(e) {
              return 'Shape' === e ||
                'shape' === e ||
                'Path' === e ||
                'path' === e ||
                'ADBE Vector Shape' === e ||
                2 === e
                ? n.path
                : null
            }
            var a = propertyGroupFactory(n, i)
            return (
              r.setGroupProperty(PropertyInterface('Path', a)),
              Object.defineProperties(n, {
                path: {
                  get: function () {
                    return r.k && r.getValue(), r
                  }
                },
                shape: {
                  get: function () {
                    return r.k && r.getValue(), r
                  }
                },
                _name: { value: e.nm },
                ix: { value: e.ix },
                propertyIndex: { value: e.ix },
                mn: { value: e.mn },
                propertyGroup: { value: i }
              }),
              n
            )
          },
          propertyGroupFactory = function (e, t) {
            return function (i) {
              return (i = void 0 === i ? 1 : i) <= 0 ? e : t(i - 1)
            }
          },
          PropertyInterface = function (e, t) {
            var i = { _name: e }
            return function (e) {
              return (e = void 0 === e ? 1 : e) <= 0 ? i : t(e - 1)
            }
          },
          ShapeExpressionInterface = (function () {
            function e(e, a, p) {
              var c,
                d = [],
                f = e ? e.length : 0
              for (c = 0; c < f; c += 1)
                'gr' === e[c].ty
                  ? d.push(t(e[c], a[c], p))
                  : 'fl' === e[c].ty
                  ? d.push(i(e[c], a[c], p))
                  : 'st' === e[c].ty
                  ? d.push(r(e[c], a[c], p))
                  : 'tm' === e[c].ty
                  ? d.push(n(e[c], a[c], p))
                  : 'tr' === e[c].ty ||
                    ('el' === e[c].ty
                      ? d.push(o(e[c], a[c], p))
                      : 'sr' === e[c].ty
                      ? d.push(s(e[c], a[c], p))
                      : 'sh' === e[c].ty
                      ? d.push(ShapePathInterface(e[c], a[c], p))
                      : 'rc' === e[c].ty
                      ? d.push(l(e[c], a[c], p))
                      : 'rd' === e[c].ty
                      ? d.push(h(e[c], a[c], p))
                      : 'rp' === e[c].ty && d.push(u(e[c], a[c], p)))
              return d
            }
            function t(t, i, r) {
              var n = function (e) {
                switch (e) {
                  case 'ADBE Vectors Group':
                  case 'Contents':
                  case 2:
                    return n.content
                  default:
                    return n.transform
                }
              }
              n.propertyGroup = propertyGroupFactory(n, r)
              var o = (function (t, i, r) {
                  var n,
                    o = function (e) {
                      for (var t = 0, i = n.length; t < i; ) {
                        if (
                          n[t]._name === e ||
                          n[t].mn === e ||
                          n[t].propertyIndex === e ||
                          n[t].ix === e ||
                          n[t].ind === e
                        )
                          return n[t]
                        t += 1
                      }
                      return 'number' == typeof e ? n[e - 1] : null
                    }
                  ;(o.propertyGroup = propertyGroupFactory(o, r)),
                    (n = e(t.it, i.it, o.propertyGroup)),
                    (o.numProperties = n.length)
                  var s = a(t.it[t.it.length - 1], i.it[i.it.length - 1], o.propertyGroup)
                  return (o.transform = s), (o.propertyIndex = t.cix), (o._name = t.nm), o
                })(t, i, n.propertyGroup),
                s = a(t.it[t.it.length - 1], i.it[i.it.length - 1], n.propertyGroup)
              return (
                (n.content = o),
                (n.transform = s),
                Object.defineProperty(n, '_name', {
                  get: function () {
                    return t.nm
                  }
                }),
                (n.numProperties = t.np),
                (n.propertyIndex = t.ix),
                (n.nm = t.nm),
                (n.mn = t.mn),
                n
              )
            }
            function i(e, t, i) {
              function r(e) {
                return 'Color' === e || 'color' === e
                  ? r.color
                  : 'Opacity' === e || 'opacity' === e
                  ? r.opacity
                  : null
              }
              return (
                Object.defineProperties(r, {
                  color: { get: ExpressionPropertyInterface(t.c) },
                  opacity: { get: ExpressionPropertyInterface(t.o) },
                  _name: { value: e.nm },
                  mn: { value: e.mn }
                }),
                t.c.setGroupProperty(PropertyInterface('Color', i)),
                t.o.setGroupProperty(PropertyInterface('Opacity', i)),
                r
              )
            }
            function r(e, t, i) {
              var r,
                n,
                a = propertyGroupFactory(h, i),
                o = propertyGroupFactory(l, a),
                s = e.d ? e.d.length : 0,
                l = {}
              for (r = 0; r < s; r += 1)
                (n = r),
                  Object.defineProperty(l, e.d[n].nm, {
                    get: ExpressionPropertyInterface(t.d.dataProps[n].p)
                  }),
                  t.d.dataProps[r].p.setGroupProperty(o)
              function h(e) {
                return 'Color' === e || 'color' === e
                  ? h.color
                  : 'Opacity' === e || 'opacity' === e
                  ? h.opacity
                  : 'Stroke Width' === e || 'stroke width' === e
                  ? h.strokeWidth
                  : null
              }
              return (
                Object.defineProperties(h, {
                  color: { get: ExpressionPropertyInterface(t.c) },
                  opacity: { get: ExpressionPropertyInterface(t.o) },
                  strokeWidth: { get: ExpressionPropertyInterface(t.w) },
                  dash: {
                    get: function () {
                      return l
                    }
                  },
                  _name: { value: e.nm },
                  mn: { value: e.mn }
                }),
                t.c.setGroupProperty(PropertyInterface('Color', a)),
                t.o.setGroupProperty(PropertyInterface('Opacity', a)),
                t.w.setGroupProperty(PropertyInterface('Stroke Width', a)),
                h
              )
            }
            function n(e, t, i) {
              function r(t) {
                return t === e.e.ix || 'End' === t || 'end' === t
                  ? r.end
                  : t === e.s.ix
                  ? r.start
                  : t === e.o.ix
                  ? r.offset
                  : null
              }
              var n = propertyGroupFactory(r, i)
              return (
                (r.propertyIndex = e.ix),
                t.s.setGroupProperty(PropertyInterface('Start', n)),
                t.e.setGroupProperty(PropertyInterface('End', n)),
                t.o.setGroupProperty(PropertyInterface('Offset', n)),
                (r.propertyIndex = e.ix),
                (r.propertyGroup = i),
                Object.defineProperties(r, {
                  start: { get: ExpressionPropertyInterface(t.s) },
                  end: { get: ExpressionPropertyInterface(t.e) },
                  offset: { get: ExpressionPropertyInterface(t.o) },
                  _name: { value: e.nm }
                }),
                (r.mn = e.mn),
                r
              )
            }
            function a(e, t, i) {
              function r(t) {
                return e.a.ix === t || 'Anchor Point' === t
                  ? r.anchorPoint
                  : e.o.ix === t || 'Opacity' === t
                  ? r.opacity
                  : e.p.ix === t || 'Position' === t
                  ? r.position
                  : e.r.ix === t || 'Rotation' === t || 'ADBE Vector Rotation' === t
                  ? r.rotation
                  : e.s.ix === t || 'Scale' === t
                  ? r.scale
                  : (e.sk && e.sk.ix === t) || 'Skew' === t
                  ? r.skew
                  : (e.sa && e.sa.ix === t) || 'Skew Axis' === t
                  ? r.skewAxis
                  : null
              }
              var n = propertyGroupFactory(r, i)
              return (
                t.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity', n)),
                t.transform.mProps.p.setGroupProperty(PropertyInterface('Position', n)),
                t.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point', n)),
                t.transform.mProps.s.setGroupProperty(PropertyInterface('Scale', n)),
                t.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation', n)),
                t.transform.mProps.sk &&
                  (t.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew', n)),
                  t.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle', n))),
                t.transform.op.setGroupProperty(PropertyInterface('Opacity', n)),
                Object.defineProperties(r, {
                  opacity: { get: ExpressionPropertyInterface(t.transform.mProps.o) },
                  position: { get: ExpressionPropertyInterface(t.transform.mProps.p) },
                  anchorPoint: { get: ExpressionPropertyInterface(t.transform.mProps.a) },
                  scale: { get: ExpressionPropertyInterface(t.transform.mProps.s) },
                  rotation: { get: ExpressionPropertyInterface(t.transform.mProps.r) },
                  skew: { get: ExpressionPropertyInterface(t.transform.mProps.sk) },
                  skewAxis: { get: ExpressionPropertyInterface(t.transform.mProps.sa) },
                  _name: { value: e.nm }
                }),
                (r.ty = 'tr'),
                (r.mn = e.mn),
                (r.propertyGroup = i),
                r
              )
            }
            function o(e, t, i) {
              function r(t) {
                return e.p.ix === t ? r.position : e.s.ix === t ? r.size : null
              }
              var n = propertyGroupFactory(r, i)
              r.propertyIndex = e.ix
              var a = 'tm' === t.sh.ty ? t.sh.prop : t.sh
              return (
                a.s.setGroupProperty(PropertyInterface('Size', n)),
                a.p.setGroupProperty(PropertyInterface('Position', n)),
                Object.defineProperties(r, {
                  size: { get: ExpressionPropertyInterface(a.s) },
                  position: { get: ExpressionPropertyInterface(a.p) },
                  _name: { value: e.nm }
                }),
                (r.mn = e.mn),
                r
              )
            }
            function s(e, t, i) {
              function r(t) {
                return e.p.ix === t
                  ? r.position
                  : e.r.ix === t
                  ? r.rotation
                  : e.pt.ix === t
                  ? r.points
                  : e.or.ix === t || 'ADBE Vector Star Outer Radius' === t
                  ? r.outerRadius
                  : e.os.ix === t
                  ? r.outerRoundness
                  : !e.ir || (e.ir.ix !== t && 'ADBE Vector Star Inner Radius' !== t)
                  ? e.is && e.is.ix === t
                    ? r.innerRoundness
                    : null
                  : r.innerRadius
              }
              var n = propertyGroupFactory(r, i),
                a = 'tm' === t.sh.ty ? t.sh.prop : t.sh
              return (
                (r.propertyIndex = e.ix),
                a.or.setGroupProperty(PropertyInterface('Outer Radius', n)),
                a.os.setGroupProperty(PropertyInterface('Outer Roundness', n)),
                a.pt.setGroupProperty(PropertyInterface('Points', n)),
                a.p.setGroupProperty(PropertyInterface('Position', n)),
                a.r.setGroupProperty(PropertyInterface('Rotation', n)),
                e.ir &&
                  (a.ir.setGroupProperty(PropertyInterface('Inner Radius', n)),
                  a.is.setGroupProperty(PropertyInterface('Inner Roundness', n))),
                Object.defineProperties(r, {
                  position: { get: ExpressionPropertyInterface(a.p) },
                  rotation: { get: ExpressionPropertyInterface(a.r) },
                  points: { get: ExpressionPropertyInterface(a.pt) },
                  outerRadius: { get: ExpressionPropertyInterface(a.or) },
                  outerRoundness: { get: ExpressionPropertyInterface(a.os) },
                  innerRadius: { get: ExpressionPropertyInterface(a.ir) },
                  innerRoundness: { get: ExpressionPropertyInterface(a.is) },
                  _name: { value: e.nm }
                }),
                (r.mn = e.mn),
                r
              )
            }
            function l(e, t, i) {
              function r(t) {
                return e.p.ix === t
                  ? r.position
                  : e.r.ix === t
                  ? r.roundness
                  : e.s.ix === t || 'Size' === t || 'ADBE Vector Rect Size' === t
                  ? r.size
                  : null
              }
              var n = propertyGroupFactory(r, i),
                a = 'tm' === t.sh.ty ? t.sh.prop : t.sh
              return (
                (r.propertyIndex = e.ix),
                a.p.setGroupProperty(PropertyInterface('Position', n)),
                a.s.setGroupProperty(PropertyInterface('Size', n)),
                a.r.setGroupProperty(PropertyInterface('Rotation', n)),
                Object.defineProperties(r, {
                  position: { get: ExpressionPropertyInterface(a.p) },
                  roundness: { get: ExpressionPropertyInterface(a.r) },
                  size: { get: ExpressionPropertyInterface(a.s) },
                  _name: { value: e.nm }
                }),
                (r.mn = e.mn),
                r
              )
            }
            function h(e, t, i) {
              function r(t) {
                return e.r.ix === t || 'Round Corners 1' === t ? r.radius : null
              }
              var n = propertyGroupFactory(r, i),
                a = t
              return (
                (r.propertyIndex = e.ix),
                a.rd.setGroupProperty(PropertyInterface('Radius', n)),
                Object.defineProperties(r, {
                  radius: { get: ExpressionPropertyInterface(a.rd) },
                  _name: { value: e.nm }
                }),
                (r.mn = e.mn),
                r
              )
            }
            function u(e, t, i) {
              function r(t) {
                return e.c.ix === t || 'Copies' === t
                  ? r.copies
                  : e.o.ix === t || 'Offset' === t
                  ? r.offset
                  : null
              }
              var n = propertyGroupFactory(r, i),
                a = t
              return (
                (r.propertyIndex = e.ix),
                a.c.setGroupProperty(PropertyInterface('Copies', n)),
                a.o.setGroupProperty(PropertyInterface('Offset', n)),
                Object.defineProperties(r, {
                  copies: { get: ExpressionPropertyInterface(a.c) },
                  offset: { get: ExpressionPropertyInterface(a.o) },
                  _name: { value: e.nm }
                }),
                (r.mn = e.mn),
                r
              )
            }
            return function (t, i, r) {
              var n
              function a(e) {
                if ('number' == typeof e) return 0 === (e = void 0 === e ? 1 : e) ? r : n[e - 1]
                for (var t = 0, i = n.length; t < i; ) {
                  if (n[t]._name === e) return n[t]
                  t += 1
                }
                return null
              }
              return (
                (a.propertyGroup = propertyGroupFactory(a, function () {
                  return r
                })),
                (n = e(t, i, a.propertyGroup)),
                (a.numProperties = n.length),
                (a._name = 'Contents'),
                a
              )
            }
          })(),
          TextExpressionInterface = function (e) {
            var t, i
            function r(e) {
              switch (e) {
                case 'ADBE Text Document':
                  return r.sourceText
                default:
                  return null
              }
            }
            return (
              Object.defineProperty(r, 'sourceText', {
                get: function () {
                  e.textProperty.getValue()
                  var r = e.textProperty.currentData.t
                  return (
                    r !== t &&
                      ((e.textProperty.currentData.t = t),
                      ((i = new String(r)).value = r || new String(r))),
                    i
                  )
                }
              }),
              r
            )
          },
          LayerExpressionInterface = (function () {
            function e(e) {
              var t = new Matrix()
              return (
                void 0 !== e
                  ? this._elem.finalTransform.mProp.getValueAtTime(e).clone(t)
                  : this._elem.finalTransform.mProp.applyToMatrix(t),
                t
              )
            }
            function t(e, t) {
              var i = this.getMatrix(t)
              return (i.props[12] = 0), (i.props[13] = 0), (i.props[14] = 0), this.applyPoint(i, e)
            }
            function i(e, t) {
              var i = this.getMatrix(t)
              return this.applyPoint(i, e)
            }
            function r(e, t) {
              var i = this.getMatrix(t)
              return (i.props[12] = 0), (i.props[13] = 0), (i.props[14] = 0), this.invertPoint(i, e)
            }
            function n(e, t) {
              var i = this.getMatrix(t)
              return this.invertPoint(i, e)
            }
            function a(e, t) {
              if (this._elem.hierarchy && this._elem.hierarchy.length) {
                var i,
                  r = this._elem.hierarchy.length
                for (i = 0; i < r; i += 1)
                  this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(e)
              }
              return e.applyToPointArray(t[0], t[1], t[2] || 0)
            }
            function o(e, t) {
              if (this._elem.hierarchy && this._elem.hierarchy.length) {
                var i,
                  r = this._elem.hierarchy.length
                for (i = 0; i < r; i += 1)
                  this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(e)
              }
              return e.inversePoint(t)
            }
            function s(e) {
              var t = new Matrix()
              if (
                (t.reset(),
                this._elem.finalTransform.mProp.applyToMatrix(t),
                this._elem.hierarchy && this._elem.hierarchy.length)
              ) {
                var i,
                  r = this._elem.hierarchy.length
                for (i = 0; i < r; i += 1)
                  this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(t)
                return t.inversePoint(e)
              }
              return t.inversePoint(e)
            }
            function l() {
              return [1, 1, 1, 1]
            }
            return function (h) {
              var u
              function p(e) {
                switch (e) {
                  case 'ADBE Root Vectors Group':
                  case 'Contents':
                  case 2:
                    return p.shapeInterface
                  case 1:
                  case 6:
                  case 'Transform':
                  case 'transform':
                  case 'ADBE Transform Group':
                    return u
                  case 4:
                  case 'ADBE Effect Parade':
                  case 'effects':
                  case 'Effects':
                    return p.effect
                  case 'ADBE Text Properties':
                    return p.textInterface
                  default:
                    return null
                }
              }
              ;(p.getMatrix = e),
                (p.invertPoint = o),
                (p.applyPoint = a),
                (p.toWorld = i),
                (p.toWorldVec = t),
                (p.fromWorld = n),
                (p.fromWorldVec = r),
                (p.toComp = i),
                (p.fromComp = s),
                (p.sampleImage = l),
                (p.sourceRectAtTime = h.sourceRectAtTime.bind(h)),
                (p._elem = h)
              var c = getDescriptor(
                (u = TransformExpressionInterface(h.finalTransform.mProp)),
                'anchorPoint'
              )
              return (
                Object.defineProperties(p, {
                  hasParent: {
                    get: function () {
                      return h.hierarchy.length
                    }
                  },
                  parent: {
                    get: function () {
                      return h.hierarchy[0].layerInterface
                    }
                  },
                  rotation: getDescriptor(u, 'rotation'),
                  scale: getDescriptor(u, 'scale'),
                  position: getDescriptor(u, 'position'),
                  opacity: getDescriptor(u, 'opacity'),
                  anchorPoint: c,
                  anchor_point: c,
                  transform: {
                    get: function () {
                      return u
                    }
                  },
                  active: {
                    get: function () {
                      return h.isInRange
                    }
                  }
                }),
                (p.startTime = h.data.st),
                (p.index = h.data.ind),
                (p.source = h.data.refId),
                (p.height = 0 === h.data.ty ? h.data.h : 100),
                (p.width = 0 === h.data.ty ? h.data.w : 100),
                (p.inPoint = h.data.ip / h.comp.globalData.frameRate),
                (p.outPoint = h.data.op / h.comp.globalData.frameRate),
                (p._name = h.data.nm),
                (p.registerMaskInterface = function (e) {
                  p.mask = new MaskManagerInterface(e, h)
                }),
                (p.registerEffectsInterface = function (e) {
                  p.effect = e
                }),
                p
              )
            }
          })(),
          FootageInterface =
            ((dataInterfaceFactory = function (e) {
              function t(e) {
                return 'Outline' === e ? t.outlineInterface() : null
              }
              return (
                (t._name = 'Outline'),
                (t.outlineInterface = (function (e) {
                  var t = '',
                    i = e.getFootageData()
                  function r(e) {
                    if (i[e]) return (t = e), 'object' == typeof (i = i[e]) ? r : i
                    var n = e.indexOf(t)
                    if (-1 !== n) {
                      var a = parseInt(e.substr(n + t.length), 10)
                      return 'object' == typeof (i = i[a]) ? r : i
                    }
                    return ''
                  }
                  return function () {
                    return (t = ''), (i = e.getFootageData()), r
                  }
                })(e)),
                t
              )
            }),
            function (e) {
              function t(e) {
                return 'Data' === e ? t.dataInterface : null
              }
              return (t._name = 'Data'), (t.dataInterface = dataInterfaceFactory(e)), t
            }),
          dataInterfaceFactory,
          CompExpressionInterface = function (e) {
            function t(t) {
              for (var i = 0, r = e.layers.length; i < r; ) {
                if (e.layers[i].nm === t || e.layers[i].ind === t)
                  return e.elements[i].layerInterface
                i += 1
              }
              return null
            }
            return (
              Object.defineProperty(t, '_name', { value: e.data.nm }),
              (t.layer = t),
              (t.pixelAspect = 1),
              (t.height = e.data.h || e.globalData.compSize.h),
              (t.width = e.data.w || e.globalData.compSize.w),
              (t.pixelAspect = 1),
              (t.frameDuration = 1 / e.globalData.frameRate),
              (t.displayStartTime = 0),
              (t.numLayers = e.layers.length),
              t
            )
          },
          TransformExpressionInterface = function (e) {
            function t(e) {
              switch (e) {
                case 'scale':
                case 'Scale':
                case 'ADBE Scale':
                case 6:
                  return t.scale
                case 'rotation':
                case 'Rotation':
                case 'ADBE Rotation':
                case 'ADBE Rotate Z':
                case 10:
                  return t.rotation
                case 'ADBE Rotate X':
                  return t.xRotation
                case 'ADBE Rotate Y':
                  return t.yRotation
                case 'position':
                case 'Position':
                case 'ADBE Position':
                case 2:
                  return t.position
                case 'ADBE Position_0':
                  return t.xPosition
                case 'ADBE Position_1':
                  return t.yPosition
                case 'ADBE Position_2':
                  return t.zPosition
                case 'anchorPoint':
                case 'AnchorPoint':
                case 'Anchor Point':
                case 'ADBE AnchorPoint':
                case 1:
                  return t.anchorPoint
                case 'opacity':
                case 'Opacity':
                case 11:
                  return t.opacity
                default:
                  return null
              }
            }
            var i, r, n, a
            return (
              Object.defineProperty(t, 'rotation', {
                get: ExpressionPropertyInterface(e.r || e.rz)
              }),
              Object.defineProperty(t, 'zRotation', {
                get: ExpressionPropertyInterface(e.rz || e.r)
              }),
              Object.defineProperty(t, 'xRotation', { get: ExpressionPropertyInterface(e.rx) }),
              Object.defineProperty(t, 'yRotation', { get: ExpressionPropertyInterface(e.ry) }),
              Object.defineProperty(t, 'scale', { get: ExpressionPropertyInterface(e.s) }),
              e.p
                ? (a = ExpressionPropertyInterface(e.p))
                : ((i = ExpressionPropertyInterface(e.px)),
                  (r = ExpressionPropertyInterface(e.py)),
                  e.pz && (n = ExpressionPropertyInterface(e.pz))),
              Object.defineProperty(t, 'position', {
                get: function () {
                  return e.p ? a() : [i(), r(), n ? n() : 0]
                }
              }),
              Object.defineProperty(t, 'xPosition', { get: ExpressionPropertyInterface(e.px) }),
              Object.defineProperty(t, 'yPosition', { get: ExpressionPropertyInterface(e.py) }),
              Object.defineProperty(t, 'zPosition', { get: ExpressionPropertyInterface(e.pz) }),
              Object.defineProperty(t, 'anchorPoint', { get: ExpressionPropertyInterface(e.a) }),
              Object.defineProperty(t, 'opacity', { get: ExpressionPropertyInterface(e.o) }),
              Object.defineProperty(t, 'skew', { get: ExpressionPropertyInterface(e.sk) }),
              Object.defineProperty(t, 'skewAxis', { get: ExpressionPropertyInterface(e.sa) }),
              Object.defineProperty(t, 'orientation', { get: ExpressionPropertyInterface(e.or) }),
              t
            )
          },
          ProjectInterface = (function () {
            function e(e) {
              this.compositions.push(e)
            }
            return function () {
              function t(e) {
                for (var t = 0, i = this.compositions.length; t < i; ) {
                  if (this.compositions[t].data && this.compositions[t].data.nm === e)
                    return (
                      this.compositions[t].prepareFrame &&
                        this.compositions[t].data.xt &&
                        this.compositions[t].prepareFrame(this.currentFrame),
                      this.compositions[t].compInterface
                    )
                  t += 1
                }
                return null
              }
              return (t.compositions = []), (t.currentFrame = 0), (t.registerComposition = e), t
            }
          })(),
          EffectsExpressionInterface = (function () {
            function e(i, r, n, a) {
              function o(e) {
                for (var t = i.ef, r = 0, n = t.length; r < n; ) {
                  if (e === t[r].nm || e === t[r].mn || e === t[r].ix)
                    return 5 === t[r].ty ? h[r] : h[r]()
                  r += 1
                }
                throw new Error()
              }
              var s,
                l = propertyGroupFactory(o, n),
                h = [],
                u = i.ef.length
              for (s = 0; s < u; s += 1)
                5 === i.ef[s].ty
                  ? h.push(e(i.ef[s], r.effectElements[s], r.effectElements[s].propertyGroup, a))
                  : h.push(t(r.effectElements[s], i.ef[s].ty, a, l))
              return (
                'ADBE Color Control' === i.mn &&
                  Object.defineProperty(o, 'color', {
                    get: function () {
                      return h[0]()
                    }
                  }),
                Object.defineProperties(o, {
                  numProperties: {
                    get: function () {
                      return i.np
                    }
                  },
                  _name: { value: i.nm },
                  propertyGroup: { value: l }
                }),
                (o.enabled = 0 !== i.en),
                (o.active = o.enabled),
                o
              )
            }
            function t(e, t, i, r) {
              var n = ExpressionPropertyInterface(e.p)
              return (
                e.p.setGroupProperty && e.p.setGroupProperty(PropertyInterface('', r)),
                function () {
                  return 10 === t ? i.comp.compInterface(e.p.v) : n()
                }
              )
            }
            return {
              createEffectsInterface: function (t, i) {
                if (t.effectsManager) {
                  var r,
                    n = [],
                    a = t.data.ef,
                    o = t.effectsManager.effectElements.length
                  for (r = 0; r < o; r += 1)
                    n.push(e(a[r], t.effectsManager.effectElements[r], i, t))
                  var s = t.data.ef || [],
                    l = function (e) {
                      for (r = 0, o = s.length; r < o; ) {
                        if (e === s[r].nm || e === s[r].mn || e === s[r].ix) return n[r]
                        r += 1
                      }
                      return null
                    }
                  return (
                    Object.defineProperty(l, 'numProperties', {
                      get: function () {
                        return s.length
                      }
                    }),
                    l
                  )
                }
                return null
              }
            }
          })(),
          MaskManagerInterface = (function () {
            function e(e, t) {
              ;(this._mask = e), (this._data = t)
            }
            return (
              Object.defineProperty(e.prototype, 'maskPath', {
                get: function () {
                  return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop
                }
              }),
              Object.defineProperty(e.prototype, 'maskOpacity', {
                get: function () {
                  return this._mask.op.k && this._mask.op.getValue(), 100 * this._mask.op.v
                }
              }),
              function (t) {
                var i,
                  r = createSizedArray(t.viewData.length),
                  n = t.viewData.length
                for (i = 0; i < n; i += 1) r[i] = new e(t.viewData[i], t.masksProperties[i])
                return function (e) {
                  for (i = 0; i < n; ) {
                    if (t.masksProperties[i].nm === e) return r[i]
                    i += 1
                  }
                  return null
                }
              }
            )
          })(),
          ExpressionPropertyInterface = (function () {
            var e = { pv: 0, v: 0, mult: 1 },
              t = { pv: [0, 0, 0], v: [0, 0, 0], mult: 1 }
            function i(e, t, i) {
              Object.defineProperty(e, 'velocity', {
                get: function () {
                  return t.getVelocityAtTime(t.comp.currentFrame)
                }
              }),
                (e.numKeys = t.keyframes ? t.keyframes.length : 0),
                (e.key = function (r) {
                  if (!e.numKeys) return 0
                  var n = ''
                  n =
                    's' in t.keyframes[r - 1]
                      ? t.keyframes[r - 1].s
                      : 'e' in t.keyframes[r - 2]
                      ? t.keyframes[r - 2].e
                      : t.keyframes[r - 2].s
                  var a = 'unidimensional' === i ? new Number(n) : Object.assign({}, n)
                  return (
                    (a.time = t.keyframes[r - 1].t / t.elem.comp.globalData.frameRate),
                    (a.value = 'unidimensional' === i ? n[0] : n),
                    a
                  )
                }),
                (e.valueAtTime = t.getValueAtTime),
                (e.speedAtTime = t.getSpeedAtTime),
                (e.velocityAtTime = t.getVelocityAtTime),
                (e.propertyGroup = t.propertyGroup)
            }
            function r() {
              return e
            }
            return function (n) {
              return n
                ? 'unidimensional' === n.propType
                  ? (function (t) {
                      ;(t && 'pv' in t) || (t = e)
                      var r = 1 / t.mult,
                        n = t.pv * r,
                        a = new Number(n)
                      return (
                        (a.value = n),
                        i(a, t, 'unidimensional'),
                        function () {
                          return (
                            t.k && t.getValue(),
                            (n = t.v * r),
                            a.value !== n &&
                              (((a = new Number(n)).value = n), i(a, t, 'unidimensional')),
                            a
                          )
                        }
                      )
                    })(n)
                  : (function (e) {
                      ;(e && 'pv' in e) || (e = t)
                      var r = 1 / e.mult,
                        n = (e.data && e.data.l) || e.pv.length,
                        a = createTypedArray('float32', n),
                        o = createTypedArray('float32', n)
                      return (
                        (a.value = o),
                        i(a, e, 'multidimensional'),
                        function () {
                          e.k && e.getValue()
                          for (var t = 0; t < n; t += 1) (o[t] = e.v[t] * r), (a[t] = o[t])
                          return a
                        }
                      )
                    })(n)
                : r
            }
          })(),
          propertyGetTextProp
        function SliderEffect(e, t, i) {
          this.p = PropertyFactory.getProp(t, e.v, 0, 0, i)
        }
        function AngleEffect(e, t, i) {
          this.p = PropertyFactory.getProp(t, e.v, 0, 0, i)
        }
        function ColorEffect(e, t, i) {
          this.p = PropertyFactory.getProp(t, e.v, 1, 0, i)
        }
        function PointEffect(e, t, i) {
          this.p = PropertyFactory.getProp(t, e.v, 1, 0, i)
        }
        function LayerIndexEffect(e, t, i) {
          this.p = PropertyFactory.getProp(t, e.v, 0, 0, i)
        }
        function MaskIndexEffect(e, t, i) {
          this.p = PropertyFactory.getProp(t, e.v, 0, 0, i)
        }
        function CheckboxEffect(e, t, i) {
          this.p = PropertyFactory.getProp(t, e.v, 0, 0, i)
        }
        function NoValueEffect() {
          this.p = {}
        }
        function EffectsManager(e, t) {
          var i,
            r = e.ef || []
          this.effectElements = []
          var n,
            a = r.length
          for (i = 0; i < a; i += 1) (n = new GroupEffect(r[i], t)), this.effectElements.push(n)
        }
        function GroupEffect(e, t) {
          this.init(e, t)
        }
        ;(propertyGetTextProp = TextSelectorProp.getTextSelectorProp),
          (TextSelectorProp.getTextSelectorProp = function (e, t, i) {
            return 1 === t.t
              ? new TextExpressionSelectorPropFactory(e, t, i)
              : propertyGetTextProp(e, t, i)
          }),
          extendPrototype([DynamicPropertyContainer], GroupEffect),
          (GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties),
          (GroupEffect.prototype.init = function (e, t) {
            var i
            ;(this.data = e), (this.effectElements = []), this.initDynamicPropertyContainer(t)
            var r,
              n = this.data.ef.length,
              a = this.data.ef
            for (i = 0; i < n; i += 1) {
              switch (((r = null), a[i].ty)) {
                case 0:
                  r = new SliderEffect(a[i], t, this)
                  break
                case 1:
                  r = new AngleEffect(a[i], t, this)
                  break
                case 2:
                  r = new ColorEffect(a[i], t, this)
                  break
                case 3:
                  r = new PointEffect(a[i], t, this)
                  break
                case 4:
                case 7:
                  r = new CheckboxEffect(a[i], t, this)
                  break
                case 10:
                  r = new LayerIndexEffect(a[i], t, this)
                  break
                case 11:
                  r = new MaskIndexEffect(a[i], t, this)
                  break
                case 5:
                  r = new EffectsManager(a[i], t, this)
                  break
                default:
                  r = new NoValueEffect(a[i], t, this)
              }
              r && this.effectElements.push(r)
            }
          })
        var lottie = {},
          queryString
        function setLocationHref(e) {
          locationHref = e
        }
        function searchAnimations() {
          animationManager.searchAnimations()
        }
        function setSubframeRendering(e) {
          subframeEnabled = e
        }
        function loadAnimation(e) {
          return animationManager.loadAnimation(e)
        }
        function setQuality(e) {
          if ('string' == typeof e)
            switch (e) {
              case 'high':
                defaultCurveSegments = 200
                break
              default:
              case 'medium':
                defaultCurveSegments = 50
                break
              case 'low':
                defaultCurveSegments = 10
            }
          else !isNaN(e) && e > 1 && (defaultCurveSegments = e)
        }
        function inBrowser() {
          return 'undefined' != typeof navigator
        }
        function installPlugin(e, t) {
          'expressions' === e && (expressionsPlugin = t)
        }
        function getFactory(e) {
          switch (e) {
            case 'propertyFactory':
              return PropertyFactory
            case 'shapePropertyFactory':
              return ShapePropertyFactory
            case 'matrix':
              return Matrix
            default:
              return null
          }
        }
        function checkReady() {
          'complete' === document.readyState &&
            (clearInterval(readyStateCheckInterval), searchAnimations())
        }
        function getQueryVariable(e) {
          for (var t = queryString.split('&'), i = 0; i < t.length; i += 1) {
            var r = t[i].split('=')
            if (decodeURIComponent(r[0]) == e) return decodeURIComponent(r[1])
          }
          return null
        }
        ;(lottie.play = animationManager.play),
          (lottie.pause = animationManager.pause),
          (lottie.setLocationHref = setLocationHref),
          (lottie.togglePause = animationManager.togglePause),
          (lottie.setSpeed = animationManager.setSpeed),
          (lottie.setDirection = animationManager.setDirection),
          (lottie.stop = animationManager.stop),
          (lottie.searchAnimations = searchAnimations),
          (lottie.registerAnimation = animationManager.registerAnimation),
          (lottie.loadAnimation = loadAnimation),
          (lottie.setSubframeRendering = setSubframeRendering),
          (lottie.resize = animationManager.resize),
          (lottie.goToAndStop = animationManager.goToAndStop),
          (lottie.destroy = animationManager.destroy),
          (lottie.setQuality = setQuality),
          (lottie.inBrowser = inBrowser),
          (lottie.installPlugin = installPlugin),
          (lottie.freeze = animationManager.freeze),
          (lottie.unfreeze = animationManager.unfreeze),
          (lottie.setVolume = animationManager.setVolume),
          (lottie.mute = animationManager.mute),
          (lottie.unmute = animationManager.unmute),
          (lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations),
          (lottie.__getFactory = getFactory),
          (lottie.version = '5.7.8')
        var scripts = document.getElementsByTagName('script'),
          index = scripts.length - 1,
          myScript = scripts[index] || { src: '' }
        ;(queryString = myScript.src.replace(/^[^\?]+\??/, '')), getQueryVariable('renderer')
        var readyStateCheckInterval = setInterval(checkReady, 100)
        return lottie
      }),
      module.exports
        ? (module.exports = factory(root))
        : ((root.lottie = factory(root)), (root.bodymovin = root.lottie)))
  }),
  _sfc_main$1 = defineComponent({
    props: { path: String, autoplay: Boolean },
    setup(e, t) {
      let i = ref(null),
        r = ref({}),
        n = (e) => {
          console.log(e),
            (r.value = lottie.loadAnimation({
              container: i.value,
              renderer: 'svg',
              loop: !1 !== e.loop,
              autoplay: e.autoplay || !1,
              animationData: e.animationData,
              path: e.path,
              rendererSettings: e.rendererSettings
            }))
        }
      return (
        onMounted(() => {
          e.path && n({ path: e.path, autoplay: e.autoplay })
        }),
        { aniElement: i, aniObj: r, createLottie: n }
      )
    }
  }),
  Lottie_vue_vue_type_style_index_0_lang = '.c-lottie-ele {\n  overflow: hidden;\n}\n'
const _hoisted_1$1 = { class: 'c-lottie-ele', ref: 'aniElement' }
function _sfc_render$1(e, t, i, r, n, a) {
  return openBlock(), createBlock('div', _hoisted_1$1, null, 512)
}
_sfc_main$1.render = _sfc_render$1
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function (e, t) {
  return (extendStatics =
    Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array &&
      function (e, t) {
        e.__proto__ = t
      }) ||
    function (e, t) {
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i])
    })(e, t)
}
function __extends(e, t) {
  function i() {
    this.constructor = e
  }
  extendStatics(e, t),
    (e.prototype = null === t ? Object.create(t) : ((i.prototype = t.prototype), new i()))
}
var __assign = function () {
  return (__assign =
    Object.assign ||
    function (e) {
      for (var t, i = 1, r = arguments.length; i < r; i++)
        for (var n in (t = arguments[i]))
          Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
      return e
    }).apply(this, arguments)
}
function __spreadArrays() {
  for (var e = 0, t = 0, i = arguments.length; t < i; t++) e += arguments[t].length
  var r = Array(e),
    n = 0
  for (t = 0; t < i; t++)
    for (var a = arguments[t], o = 0, s = a.length; o < s; o++, n++) r[n] = a[o]
  return r
}
var Browser = function () {
    ;(this.firefox = !1), (this.ie = !1), (this.edge = !1), (this.newEdge = !1), (this.weChat = !1)
  },
  Env = function () {
    ;(this.browser = new Browser()),
      (this.node = !1),
      (this.wxa = !1),
      (this.worker = !1),
      (this.canvasSupported = !1),
      (this.svgSupported = !1),
      (this.touchEventsSupported = !1),
      (this.pointerEventsSupported = !1),
      (this.domSupported = !1),
      (this.transformSupported = !1),
      (this.transform3dSupported = !1)
  },
  env = new Env()
function detect(e, t) {
  var i = t.browser,
    r = e.match(/Firefox\/([\d.]+)/),
    n = e.match(/MSIE\s([\d.]+)/) || e.match(/Trident\/.+?rv:(([\d.]+))/),
    a = e.match(/Edge?\/([\d.]+)/),
    o = /micromessenger/i.test(e)
  r && ((i.firefox = !0), (i.version = r[1])),
    n && ((i.ie = !0), (i.version = n[1])),
    a && ((i.edge = !0), (i.version = a[1]), (i.newEdge = +a[1].split('.')[0] > 18)),
    o && (i.weChat = !0),
    (t.canvasSupported = !!document.createElement('canvas').getContext),
    (t.svgSupported = 'undefined' != typeof SVGRect),
    (t.touchEventsSupported = 'ontouchstart' in window && !i.ie && !i.edge),
    (t.pointerEventsSupported =
      'onpointerdown' in window && (i.edge || (i.ie && +i.version >= 11))),
    (t.domSupported = 'undefined' != typeof document)
  var s = document.documentElement.style
  ;(t.transform3dSupported =
    ((i.ie && 'transition' in s) ||
      i.edge ||
      ('WebKitCSSMatrix' in window && 'm11' in new WebKitCSSMatrix()) ||
      'MozPerspective' in s) &&
    !('OTransition' in s)),
    (t.transformSupported = t.transform3dSupported || (i.ie && +i.version >= 9))
}
'object' == typeof wx && 'function' == typeof wx.getSystemInfoSync
  ? ((env.wxa = !0), (env.canvasSupported = !0), (env.touchEventsSupported = !0))
  : 'undefined' == typeof document && 'undefined' != typeof self
  ? ((env.worker = !0), (env.canvasSupported = !0))
  : 'undefined' == typeof navigator
  ? ((env.node = !0), (env.canvasSupported = !0), (env.svgSupported = !0))
  : detect(navigator.userAgent, env)
var BUILTIN_OBJECT = {
    '[object Function]': !0,
    '[object RegExp]': !0,
    '[object Date]': !0,
    '[object Error]': !0,
    '[object CanvasGradient]': !0,
    '[object CanvasPattern]': !0,
    '[object Image]': !0,
    '[object Canvas]': !0
  },
  TYPED_ARRAY = {
    '[object Int8Array]': !0,
    '[object Uint8Array]': !0,
    '[object Uint8ClampedArray]': !0,
    '[object Int16Array]': !0,
    '[object Uint16Array]': !0,
    '[object Int32Array]': !0,
    '[object Uint32Array]': !0,
    '[object Float32Array]': !0,
    '[object Float64Array]': !0
  },
  objToString = Object.prototype.toString,
  arrayProto = Array.prototype,
  nativeForEach = arrayProto.forEach,
  nativeFilter = arrayProto.filter,
  nativeSlice = arrayProto.slice,
  nativeMap = arrayProto.map,
  ctorFunction = function () {}.constructor,
  protoFunction = ctorFunction ? ctorFunction.prototype : null,
  methods$1 = {},
  idStart = 2311
function guid() {
  return idStart++
}
function logError() {
  for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t]
  'undefined' != typeof console && console.error.apply(console, e)
}
function clone$3(e) {
  if (null == e || 'object' != typeof e) return e
  var t = e,
    i = objToString.call(e)
  if ('[object Array]' === i) {
    if (!isPrimitive(e)) {
      t = []
      for (var r = 0, n = e.length; r < n; r++) t[r] = clone$3(e[r])
    }
  } else if (TYPED_ARRAY[i]) {
    if (!isPrimitive(e)) {
      var a = e.constructor
      if (a.from) t = a.from(e)
      else {
        t = new a(e.length)
        for (r = 0, n = e.length; r < n; r++) t[r] = clone$3(e[r])
      }
    }
  } else if (!BUILTIN_OBJECT[i] && !isPrimitive(e) && !isDom(e))
    for (var o in ((t = {}), e)) e.hasOwnProperty(o) && (t[o] = clone$3(e[o]))
  return t
}
function merge(e, t, i) {
  if (!isObject$7(t) || !isObject$7(e)) return i ? clone$3(t) : e
  for (var r in t)
    if (t.hasOwnProperty(r)) {
      var n = e[r],
        a = t[r]
      !isObject$7(a) ||
      !isObject$7(n) ||
      isArray$1(a) ||
      isArray$1(n) ||
      isDom(a) ||
      isDom(n) ||
      isBuiltInObject(a) ||
      isBuiltInObject(n) ||
      isPrimitive(a) ||
      isPrimitive(n)
        ? (!i && r in e) || (e[r] = clone$3(t[r]))
        : merge(n, a, i)
    }
  return e
}
function mergeAll(e, t) {
  for (var i = e[0], r = 1, n = e.length; r < n; r++) i = merge(i, e[r], t)
  return i
}
function extend$3(e, t) {
  if (Object.assign) Object.assign(e, t)
  else for (var i in t) t.hasOwnProperty(i) && (e[i] = t[i])
  return e
}
function defaults$1(e, t, i) {
  for (var r = keys(t), n = 0; n < r.length; n++) {
    var a = r[n]
    ;(i ? null != t[a] : null == e[a]) && (e[a] = t[a])
  }
  return e
}
var createCanvas = function () {
  return methods$1.createCanvas()
}
function indexOf$1(e, t) {
  if (e) {
    if (e.indexOf) return e.indexOf(t)
    for (var i = 0, r = e.length; i < r; i++) if (e[i] === t) return i
  }
  return -1
}
function inherits(e, t) {
  var i = e.prototype
  function r() {}
  for (var n in ((r.prototype = t.prototype), (e.prototype = new r()), i))
    i.hasOwnProperty(n) && (e.prototype[n] = i[n])
  ;(e.prototype.constructor = e), (e.superClass = t)
}
function mixin(e, t, i) {
  if (
    ((e = 'prototype' in e ? e.prototype : e),
    (t = 'prototype' in t ? t.prototype : t),
    Object.getOwnPropertyNames)
  )
    for (var r = Object.getOwnPropertyNames(t), n = 0; n < r.length; n++) {
      var a = r[n]
      'constructor' !== a && (i ? null != t[a] : null == e[a]) && (e[a] = t[a])
    }
  else defaults$1(e, t, i)
}
function isArrayLike(e) {
  return !!e && 'string' != typeof e && 'number' == typeof e.length
}
function each$i(e, t, i) {
  if (e && t)
    if (e.forEach && e.forEach === nativeForEach) e.forEach(t, i)
    else if (e.length === +e.length) for (var r = 0, n = e.length; r < n; r++) t.call(i, e[r], r, e)
    else for (var a in e) e.hasOwnProperty(a) && t.call(i, e[a], a, e)
}
function map$1(e, t, i) {
  if (!e) return []
  if (!t) return slice(e)
  if (e.map && e.map === nativeMap) return e.map(t, i)
  for (var r = [], n = 0, a = e.length; n < a; n++) r.push(t.call(i, e[n], n, e))
  return r
}
function reduce(e, t, i, r) {
  if (e && t) {
    for (var n = 0, a = e.length; n < a; n++) i = t.call(r, i, e[n], n, e)
    return i
  }
}
function filter$1(e, t, i) {
  if (!e) return []
  if (!t) return slice(e)
  if (e.filter && e.filter === nativeFilter) return e.filter(t, i)
  for (var r = [], n = 0, a = e.length; n < a; n++) t.call(i, e[n], n, e) && r.push(e[n])
  return r
}
function find$1(e, t, i) {
  if (e && t) for (var r = 0, n = e.length; r < n; r++) if (t.call(i, e[r], r, e)) return e[r]
}
function keys(e) {
  if (!e) return []
  if (Object.keys) return Object.keys(e)
  var t = []
  for (var i in e) e.hasOwnProperty(i) && t.push(i)
  return t
}
function bindPolyfill(e, t) {
  for (var i = [], r = 2; r < arguments.length; r++) i[r - 2] = arguments[r]
  return function () {
    return e.apply(t, i.concat(nativeSlice.call(arguments)))
  }
}
methods$1.createCanvas = function () {
  return document.createElement('canvas')
}
var bind$2 =
  protoFunction && isFunction$1(protoFunction.bind)
    ? protoFunction.call.bind(protoFunction.bind)
    : bindPolyfill
function curry$1(e) {
  for (var t = [], i = 1; i < arguments.length; i++) t[i - 1] = arguments[i]
  return function () {
    return e.apply(this, t.concat(nativeSlice.call(arguments)))
  }
}
function isArray$1(e) {
  return Array.isArray ? Array.isArray(e) : '[object Array]' === objToString.call(e)
}
function isFunction$1(e) {
  return 'function' == typeof e
}
function isString(e) {
  return 'string' == typeof e
}
function isStringSafe(e) {
  return '[object String]' === objToString.call(e)
}
function isNumber(e) {
  return 'number' == typeof e
}
function isObject$7(e) {
  var t = typeof e
  return 'function' === t || (!!e && 'object' === t)
}
function isBuiltInObject(e) {
  return !!BUILTIN_OBJECT[objToString.call(e)]
}
function isTypedArray(e) {
  return !!TYPED_ARRAY[objToString.call(e)]
}
function isDom(e) {
  return 'object' == typeof e && 'number' == typeof e.nodeType && 'object' == typeof e.ownerDocument
}
function isGradientObject(e) {
  return null != e.colorStops
}
function isImagePatternObject(e) {
  return null != e.image
}
function isRegExp(e) {
  return '[object RegExp]' === objToString.call(e)
}
function eqNaN(e) {
  return e != e
}
function retrieve() {
  for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t]
  for (var i = 0, r = e.length; i < r; i++) if (null != e[i]) return e[i]
}
function retrieve2(e, t) {
  return null != e ? e : t
}
function retrieve3(e, t, i) {
  return null != e ? e : null != t ? t : i
}
function slice(e) {
  for (var t = [], i = 1; i < arguments.length; i++) t[i - 1] = arguments[i]
  return nativeSlice.apply(e, t)
}
function normalizeCssArray$1(e) {
  if ('number' == typeof e) return [e, e, e, e]
  var t = e.length
  return 2 === t ? [e[0], e[1], e[0], e[1]] : 3 === t ? [e[0], e[1], e[2], e[1]] : e
}
function assert$1(e, t) {
  if (!e) throw new Error(t)
}
function trim$1(e) {
  return null == e
    ? null
    : 'function' == typeof e.trim
    ? e.trim()
    : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
}
var primitiveKey = '__ec_primitive__'
function setAsPrimitive(e) {
  e[primitiveKey] = !0
}
function isPrimitive(e) {
  return e[primitiveKey]
}
var HashMap = (function () {
  function e(t) {
    this.data = {}
    var i = isArray$1(t)
    this.data = {}
    var r = this
    function n(e, t) {
      i ? r.set(e, t) : r.set(t, e)
    }
    t instanceof e ? t.each(n) : t && each$i(t, n)
  }
  return (
    (e.prototype.get = function (e) {
      return this.data.hasOwnProperty(e) ? this.data[e] : null
    }),
    (e.prototype.set = function (e, t) {
      return (this.data[e] = t)
    }),
    (e.prototype.each = function (e, t) {
      for (var i in this.data) this.data.hasOwnProperty(i) && e.call(t, this.data[i], i)
    }),
    (e.prototype.keys = function () {
      return keys(this.data)
    }),
    (e.prototype.removeKey = function (e) {
      delete this.data[e]
    }),
    e
  )
})()
function createHashMap(e) {
  return new HashMap(e)
}
function concatArray(e, t) {
  for (var i = new e.constructor(e.length + t.length), r = 0; r < e.length; r++) i[r] = e[r]
  var n = e.length
  for (r = 0; r < t.length; r++) i[r + n] = t[r]
  return i
}
function createObject(e, t) {
  var i
  if (Object.create) i = Object.create(e)
  else {
    var r = function () {}
    ;(r.prototype = e), (i = new r())
  }
  return t && extend$3(i, t), i
}
function hasOwn(e, t) {
  return e.hasOwnProperty(t)
}
function noop$1() {}
function create$2(e, t) {
  return null == e && (e = 0), null == t && (t = 0), [e, t]
}
function copy$1(e, t) {
  return (e[0] = t[0]), (e[1] = t[1]), e
}
function clone$2(e) {
  return [e[0], e[1]]
}
function set$1(e, t, i) {
  return (e[0] = t), (e[1] = i), e
}
function add(e, t, i) {
  return (e[0] = t[0] + i[0]), (e[1] = t[1] + i[1]), e
}
function scaleAndAdd$1(e, t, i, r) {
  return (e[0] = t[0] + i[0] * r), (e[1] = t[1] + i[1] * r), e
}
function sub(e, t, i) {
  return (e[0] = t[0] - i[0]), (e[1] = t[1] - i[1]), e
}
function len(e) {
  return Math.sqrt(lenSquare(e))
}
function lenSquare(e) {
  return e[0] * e[0] + e[1] * e[1]
}
function scale$2(e, t, i) {
  return (e[0] = t[0] * i), (e[1] = t[1] * i), e
}
function normalize$3(e, t) {
  var i = len(t)
  return 0 === i ? ((e[0] = 0), (e[1] = 0)) : ((e[0] = t[0] / i), (e[1] = t[1] / i)), e
}
function distance(e, t) {
  return Math.sqrt((e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1]))
}
var dist$1 = distance
function distanceSquare(e, t) {
  return (e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1])
}
var distSquare = distanceSquare
function lerp(e, t, i, r) {
  return (e[0] = t[0] + r * (i[0] - t[0])), (e[1] = t[1] + r * (i[1] - t[1])), e
}
function applyTransform$1(e, t, i) {
  var r = t[0],
    n = t[1]
  return (e[0] = i[0] * r + i[2] * n + i[4]), (e[1] = i[1] * r + i[3] * n + i[5]), e
}
function min$1(e, t, i) {
  return (e[0] = Math.min(t[0], i[0])), (e[1] = Math.min(t[1], i[1])), e
}
function max$1(e, t, i) {
  return (e[0] = Math.max(t[0], i[0])), (e[1] = Math.max(t[1], i[1])), e
}
var Param = function (e, t) {
    ;(this.target = e), (this.topTarget = t && t.topTarget)
  },
  Draggable = (function () {
    function e(e) {
      ;(this.handler = e),
        e.on('mousedown', this._dragStart, this),
        e.on('mousemove', this._drag, this),
        e.on('mouseup', this._dragEnd, this)
    }
    return (
      (e.prototype._dragStart = function (e) {
        for (var t = e.target; t && !t.draggable; ) t = t.parent
        t &&
          ((this._draggingTarget = t),
          (t.dragging = !0),
          (this._x = e.offsetX),
          (this._y = e.offsetY),
          this.handler.dispatchToElement(new Param(t, e), 'dragstart', e.event))
      }),
      (e.prototype._drag = function (e) {
        var t = this._draggingTarget
        if (t) {
          var i = e.offsetX,
            r = e.offsetY,
            n = i - this._x,
            a = r - this._y
          ;(this._x = i),
            (this._y = r),
            t.drift(n, a, e),
            this.handler.dispatchToElement(new Param(t, e), 'drag', e.event)
          var o = this.handler.findHover(i, r, t).target,
            s = this._dropTarget
          ;(this._dropTarget = o),
            t !== o &&
              (s &&
                o !== s &&
                this.handler.dispatchToElement(new Param(s, e), 'dragleave', e.event),
              o && o !== s && this.handler.dispatchToElement(new Param(o, e), 'dragenter', e.event))
        }
      }),
      (e.prototype._dragEnd = function (e) {
        var t = this._draggingTarget
        t && (t.dragging = !1),
          this.handler.dispatchToElement(new Param(t, e), 'dragend', e.event),
          this._dropTarget &&
            this.handler.dispatchToElement(new Param(this._dropTarget, e), 'drop', e.event),
          (this._draggingTarget = null),
          (this._dropTarget = null)
      }),
      e
    )
  })(),
  Eventful = (function () {
    function e(e) {
      e && (this._$eventProcessor = e)
    }
    return (
      (e.prototype.on = function (e, t, i, r) {
        this._$handlers || (this._$handlers = {})
        var n = this._$handlers
        if (('function' == typeof t && ((r = i), (i = t), (t = null)), !i || !e)) return this
        var a = this._$eventProcessor
        null != t && a && a.normalizeQuery && (t = a.normalizeQuery(t)), n[e] || (n[e] = [])
        for (var o = 0; o < n[e].length; o++) if (n[e][o].h === i) return this
        var s = { h: i, query: t, ctx: r || this, callAtLast: i.zrEventfulCallAtLast },
          l = n[e].length - 1,
          h = n[e][l]
        return h && h.callAtLast ? n[e].splice(l, 0, s) : n[e].push(s), this
      }),
      (e.prototype.isSilent = function (e) {
        var t = this._$handlers
        return !t || !t[e] || !t[e].length
      }),
      (e.prototype.off = function (e, t) {
        var i = this._$handlers
        if (!i) return this
        if (!e) return (this._$handlers = {}), this
        if (t) {
          if (i[e]) {
            for (var r = [], n = 0, a = i[e].length; n < a; n++) i[e][n].h !== t && r.push(i[e][n])
            i[e] = r
          }
          i[e] && 0 === i[e].length && delete i[e]
        } else delete i[e]
        return this
      }),
      (e.prototype.trigger = function (e) {
        for (var t = [], i = 1; i < arguments.length; i++) t[i - 1] = arguments[i]
        if (!this._$handlers) return this
        var r = this._$handlers[e],
          n = this._$eventProcessor
        if (r)
          for (var a = t.length, o = r.length, s = 0; s < o; s++) {
            var l = r[s]
            if (!n || !n.filter || null == l.query || n.filter(e, l.query))
              switch (a) {
                case 0:
                  l.h.call(l.ctx)
                  break
                case 1:
                  l.h.call(l.ctx, t[0])
                  break
                case 2:
                  l.h.call(l.ctx, t[0], t[1])
                  break
                default:
                  l.h.apply(l.ctx, t)
              }
          }
        return n && n.afterTrigger && n.afterTrigger(e), this
      }),
      (e.prototype.triggerWithContext = function (e) {
        if (!this._$handlers) return this
        var t = this._$handlers[e],
          i = this._$eventProcessor
        if (t)
          for (var r = arguments, n = r.length, a = r[n - 1], o = t.length, s = 0; s < o; s++) {
            var l = t[s]
            if (!i || !i.filter || null == l.query || i.filter(e, l.query))
              switch (n) {
                case 0:
                  l.h.call(a)
                  break
                case 1:
                  l.h.call(a, r[0])
                  break
                case 2:
                  l.h.call(a, r[0], r[1])
                  break
                default:
                  l.h.apply(a, r.slice(1, n - 1))
              }
          }
        return i && i.afterTrigger && i.afterTrigger(e), this
      }),
      e
    )
  })(),
  LN2 = Math.log(2)
function determinant(e, t, i, r, n, a) {
  var o = r + '-' + n,
    s = e.length
  if (a.hasOwnProperty(o)) return a[o]
  if (1 === t) {
    var l = Math.round(Math.log(((1 << s) - 1) & ~n) / LN2)
    return e[i][l]
  }
  for (var h = r | (1 << i), u = i + 1; r & (1 << u); ) u++
  for (var p = 0, c = 0, d = 0; c < s; c++) {
    var f = 1 << c
    f & n || ((p += (d % 2 ? -1 : 1) * e[i][c] * determinant(e, t - 1, u, h, n | f, a)), d++)
  }
  return (a[o] = p), p
}
function buildTransformer(e, t) {
  var i = [
      [e[0], e[1], 1, 0, 0, 0, -t[0] * e[0], -t[0] * e[1]],
      [0, 0, 0, e[0], e[1], 1, -t[1] * e[0], -t[1] * e[1]],
      [e[2], e[3], 1, 0, 0, 0, -t[2] * e[2], -t[2] * e[3]],
      [0, 0, 0, e[2], e[3], 1, -t[3] * e[2], -t[3] * e[3]],
      [e[4], e[5], 1, 0, 0, 0, -t[4] * e[4], -t[4] * e[5]],
      [0, 0, 0, e[4], e[5], 1, -t[5] * e[4], -t[5] * e[5]],
      [e[6], e[7], 1, 0, 0, 0, -t[6] * e[6], -t[6] * e[7]],
      [0, 0, 0, e[6], e[7], 1, -t[7] * e[6], -t[7] * e[7]]
    ],
    r = {},
    n = determinant(i, 8, 0, 0, 0, r)
  if (0 !== n) {
    for (var a = [], o = 0; o < 8; o++)
      for (var s = 0; s < 8; s++)
        null == a[s] && (a[s] = 0),
          (a[s] +=
            ((((o + s) % 2 ? -1 : 1) * determinant(i, 7, 0 === o ? 1 : 0, 1 << o, 1 << s, r)) / n) *
            t[o])
    return function (e, t, i) {
      var r = t * a[6] + i * a[7] + 1
      ;(e[0] = (t * a[0] + i * a[1] + a[2]) / r), (e[1] = (t * a[3] + i * a[4] + a[5]) / r)
    }
  }
}
var EVENT_SAVED_PROP = '___zrEVENTSAVED',
  _calcOut$1 = []
function transformLocalCoord(e, t, i, r, n) {
  return (
    transformCoordWithViewport(_calcOut$1, t, r, n, !0) &&
    transformCoordWithViewport(e, i, _calcOut$1[0], _calcOut$1[1])
  )
}
function transformCoordWithViewport(e, t, i, r, n) {
  if (t.getBoundingClientRect && env.domSupported && !isCanvasEl(t)) {
    var a = t[EVENT_SAVED_PROP] || (t[EVENT_SAVED_PROP] = {}),
      o = preparePointerTransformer(prepareCoordMarkers(t, a), a, n)
    if (o) return o(e, i, r), !0
  }
  return !1
}
function prepareCoordMarkers(e, t) {
  var i = t.markers
  if (i) return i
  i = t.markers = []
  for (var r = ['left', 'right'], n = ['top', 'bottom'], a = 0; a < 4; a++) {
    var o = document.createElement('div'),
      s = a % 2,
      l = (a >> 1) % 2
    ;(o.style.cssText = [
      'position: absolute',
      'visibility: hidden',
      'padding: 0',
      'margin: 0',
      'border-width: 0',
      'user-select: none',
      'width:0',
      'height:0',
      r[s] + ':0',
      n[l] + ':0',
      r[1 - s] + ':auto',
      n[1 - l] + ':auto',
      ''
    ].join('!important;')),
      e.appendChild(o),
      i.push(o)
  }
  return i
}
function preparePointerTransformer(e, t, i) {
  for (
    var r = i ? 'invTrans' : 'trans', n = t[r], a = t.srcCoords, o = [], s = [], l = !0, h = 0;
    h < 4;
    h++
  ) {
    var u = e[h].getBoundingClientRect(),
      p = 2 * h,
      c = u.left,
      d = u.top
    o.push(c, d),
      (l = l && a && c === a[p] && d === a[p + 1]),
      s.push(e[h].offsetLeft, e[h].offsetTop)
  }
  return l && n
    ? n
    : ((t.srcCoords = o), (t[r] = i ? buildTransformer(s, o) : buildTransformer(o, s)))
}
function isCanvasEl(e) {
  return 'CANVAS' === e.nodeName.toUpperCase()
}
var isDomLevel2 = 'undefined' != typeof window && !!window.addEventListener,
  MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
  _calcOut = []
function clientToLocal(e, t, i, r) {
  return (
    (i = i || {}),
    r || !env.canvasSupported
      ? calculateZrXY(e, t, i)
      : env.browser.firefox && null != t.layerX && t.layerX !== t.offsetX
      ? ((i.zrX = t.layerX), (i.zrY = t.layerY))
      : null != t.offsetX
      ? ((i.zrX = t.offsetX), (i.zrY = t.offsetY))
      : calculateZrXY(e, t, i),
    i
  )
}
function calculateZrXY(e, t, i) {
  if (env.domSupported && e.getBoundingClientRect) {
    var r = t.clientX,
      n = t.clientY
    if (isCanvasEl(e)) {
      var a = e.getBoundingClientRect()
      return (i.zrX = r - a.left), void (i.zrY = n - a.top)
    }
    if (transformCoordWithViewport(_calcOut, e, r, n))
      return (i.zrX = _calcOut[0]), void (i.zrY = _calcOut[1])
  }
  i.zrX = i.zrY = 0
}
function getNativeEvent(e) {
  return e || window.event
}
function normalizeEvent(e, t, i) {
  if (null != (t = getNativeEvent(t)).zrX) return t
  var r = t.type
  if (r && r.indexOf('touch') >= 0) {
    var n = 'touchend' !== r ? t.targetTouches[0] : t.changedTouches[0]
    n && clientToLocal(e, n, t, i)
  } else {
    clientToLocal(e, t, t, i)
    var a = getWheelDeltaMayPolyfill(t)
    t.zrDelta = a ? a / 120 : -(t.detail || 0) / 3
  }
  var o = t.button
  return (
    null == t.which &&
      void 0 !== o &&
      MOUSE_EVENT_REG.test(t.type) &&
      (t.which = 1 & o ? 1 : 2 & o ? 3 : 4 & o ? 2 : 0),
    t
  )
}
function getWheelDeltaMayPolyfill(e) {
  var t = e.wheelDelta
  if (t) return t
  var i = e.deltaX,
    r = e.deltaY
  return null == i || null == r
    ? t
    : 3 * (0 !== r ? Math.abs(r) : Math.abs(i)) * (r > 0 ? -1 : r < 0 ? 1 : i > 0 ? -1 : 1)
}
function addEventListener(e, t, i, r) {
  isDomLevel2 ? e.addEventListener(t, i, r) : e.attachEvent('on' + t, i)
}
function removeEventListener(e, t, i, r) {
  isDomLevel2 ? e.removeEventListener(t, i, r) : e.detachEvent('on' + t, i)
}
var stop = isDomLevel2
  ? function (e) {
      e.preventDefault(), e.stopPropagation(), (e.cancelBubble = !0)
    }
  : function (e) {
      ;(e.returnValue = !1), (e.cancelBubble = !0)
    }
function isMiddleOrRightButtonOnMouseUpDown(e) {
  return 2 === e.which || 3 === e.which
}
var GestureMgr = (function () {
  function e() {
    this._track = []
  }
  return (
    (e.prototype.recognize = function (e, t, i) {
      return this._doTrack(e, t, i), this._recognize(e)
    }),
    (e.prototype.clear = function () {
      return (this._track.length = 0), this
    }),
    (e.prototype._doTrack = function (e, t, i) {
      var r = e.touches
      if (r) {
        for (
          var n = { points: [], touches: [], target: t, event: e }, a = 0, o = r.length;
          a < o;
          a++
        ) {
          var s = r[a],
            l = clientToLocal(i, s, {})
          n.points.push([l.zrX, l.zrY]), n.touches.push(s)
        }
        this._track.push(n)
      }
    }),
    (e.prototype._recognize = function (e) {
      for (var t in recognizers)
        if (recognizers.hasOwnProperty(t)) {
          var i = recognizers[t](this._track, e)
          if (i) return i
        }
    }),
    e
  )
})()
function dist(e) {
  var t = e[1][0] - e[0][0],
    i = e[1][1] - e[0][1]
  return Math.sqrt(t * t + i * i)
}
function center$1(e) {
  return [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2]
}
var recognizers = {
    pinch: function (e, t) {
      var i = e.length
      if (i) {
        var r = (e[i - 1] || {}).points,
          n = (e[i - 2] || {}).points || r
        if (n && n.length > 1 && r && r.length > 1) {
          var a = dist(r) / dist(n)
          !isFinite(a) && (a = 1), (t.pinchScale = a)
          var o = center$1(r)
          return (
            (t.pinchX = o[0]), (t.pinchY = o[1]), { type: 'pinch', target: e[0].target, event: t }
          )
        }
      }
    }
  },
  SILENT = 'silent'
function makeEventPacket(e, t, i) {
  return {
    type: e,
    event: i,
    target: t.target,
    topTarget: t.topTarget,
    cancelBubble: !1,
    offsetX: i.zrX,
    offsetY: i.zrY,
    gestureEvent: i.gestureEvent,
    pinchX: i.pinchX,
    pinchY: i.pinchY,
    pinchScale: i.pinchScale,
    wheelDelta: i.zrDelta,
    zrByTouch: i.zrByTouch,
    which: i.which,
    stop: stopEvent
  }
}
function stopEvent() {
  stop(this.event)
}
var EmptyProxy = (function (e) {
    function t() {
      var t = (null !== e && e.apply(this, arguments)) || this
      return (t.handler = null), t
    }
    return (
      __extends(t, e),
      (t.prototype.dispose = function () {}),
      (t.prototype.setCursor = function () {}),
      t
    )
  })(Eventful),
  HoveredResult = function (e, t) {
    ;(this.x = e), (this.y = t)
  },
  handlerNames = [
    'click',
    'dblclick',
    'mousewheel',
    'mouseout',
    'mouseup',
    'mousedown',
    'mousemove',
    'contextmenu'
  ],
  Handler = (function (e) {
    function t(t, i, r, n) {
      var a = e.call(this) || this
      return (
        (a._hovered = new HoveredResult(0, 0)),
        (a.storage = t),
        (a.painter = i),
        (a.painterRoot = n),
        (r = r || new EmptyProxy()),
        (a.proxy = null),
        a.setHandlerProxy(r),
        (a._draggingMgr = new Draggable(a)),
        a
      )
    }
    return (
      __extends(t, e),
      (t.prototype.setHandlerProxy = function (e) {
        this.proxy && this.proxy.dispose(),
          e &&
            (each$i(
              handlerNames,
              function (t) {
                e.on && e.on(t, this[t], this)
              },
              this
            ),
            (e.handler = this)),
          (this.proxy = e)
      }),
      (t.prototype.mousemove = function (e) {
        var t = e.zrX,
          i = e.zrY,
          r = isOutsideBoundary(this, t, i),
          n = this._hovered,
          a = n.target
        a && !a.__zr && (a = (n = this.findHover(n.x, n.y)).target)
        var o = (this._hovered = r ? new HoveredResult(t, i) : this.findHover(t, i)),
          s = o.target,
          l = this.proxy
        l.setCursor && l.setCursor(s ? s.cursor : 'default'),
          a && s !== a && this.dispatchToElement(n, 'mouseout', e),
          this.dispatchToElement(o, 'mousemove', e),
          s && s !== a && this.dispatchToElement(o, 'mouseover', e)
      }),
      (t.prototype.mouseout = function (e) {
        var t = e.zrEventControl
        'only_globalout' !== t && this.dispatchToElement(this._hovered, 'mouseout', e),
          'no_globalout' !== t && this.trigger('globalout', { type: 'globalout', event: e })
      }),
      (t.prototype.resize = function () {
        this._hovered = new HoveredResult(0, 0)
      }),
      (t.prototype.dispatch = function (e, t) {
        var i = this[e]
        i && i.call(this, t)
      }),
      (t.prototype.dispose = function () {
        this.proxy.dispose(), (this.storage = null), (this.proxy = null), (this.painter = null)
      }),
      (t.prototype.setCursorStyle = function (e) {
        var t = this.proxy
        t.setCursor && t.setCursor(e)
      }),
      (t.prototype.dispatchToElement = function (e, t, i) {
        var r = (e = e || {}).target
        if (!r || !r.silent) {
          for (
            var n = 'on' + t, a = makeEventPacket(t, e, i);
            r &&
            (r[n] && (a.cancelBubble = !!r[n].call(r, a)),
            r.trigger(t, a),
            (r = r.__hostTarget ? r.__hostTarget : r.parent),
            !a.cancelBubble);

          );
          a.cancelBubble ||
            (this.trigger(t, a),
            this.painter &&
              this.painter.eachOtherLayer &&
              this.painter.eachOtherLayer(function (e) {
                'function' == typeof e[n] && e[n].call(e, a), e.trigger && e.trigger(t, a)
              }))
        }
      }),
      (t.prototype.findHover = function (e, t, i) {
        for (
          var r = this.storage.getDisplayList(), n = new HoveredResult(e, t), a = r.length - 1;
          a >= 0;
          a--
        ) {
          var o = void 0
          if (
            r[a] !== i &&
            !r[a].ignore &&
            (o = isHover(r[a], e, t)) &&
            (!n.topTarget && (n.topTarget = r[a]), o !== SILENT)
          ) {
            n.target = r[a]
            break
          }
        }
        return n
      }),
      (t.prototype.processGesture = function (e, t) {
        this._gestureMgr || (this._gestureMgr = new GestureMgr())
        var i = this._gestureMgr
        'start' === t && i.clear()
        var r = i.recognize(e, this.findHover(e.zrX, e.zrY, null).target, this.proxy.dom)
        if (('end' === t && i.clear(), r)) {
          var n = r.type
          e.gestureEvent = n
          var a = new HoveredResult()
          ;(a.target = r.target), this.dispatchToElement(a, n, r.event)
        }
      }),
      t
    )
  })(Eventful)
function isHover(e, t, i) {
  if (e[e.rectHover ? 'rectContain' : 'contain'](t, i)) {
    for (var r = e, n = void 0, a = !1; r; ) {
      if ((r.ignoreClip && (a = !0), !a)) {
        var o = r.getClipPath()
        if (o && !o.contain(t, i)) return !1
        r.silent && (n = !0)
      }
      var s = r.__hostTarget
      r = s || r.parent
    }
    return !n || SILENT
  }
  return !1
}
function isOutsideBoundary(e, t, i) {
  var r = e.painter
  return t < 0 || t > r.getWidth() || i < 0 || i > r.getHeight()
}
each$i(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (e) {
  Handler.prototype[e] = function (t) {
    var i,
      r,
      n = t.zrX,
      a = t.zrY,
      o = isOutsideBoundary(this, n, a)
    if ((('mouseup' === e && o) || (r = (i = this.findHover(n, a)).target), 'mousedown' === e))
      (this._downEl = r), (this._downPoint = [t.zrX, t.zrY]), (this._upEl = r)
    else if ('mouseup' === e) this._upEl = r
    else if ('click' === e) {
      if (
        this._downEl !== this._upEl ||
        !this._downPoint ||
        dist$1(this._downPoint, [t.zrX, t.zrY]) > 4
      )
        return
      this._downPoint = null
    }
    this.dispatchToElement(i, e, t)
  }
})
var DEFAULT_MIN_MERGE = 32,
  DEFAULT_MIN_GALLOPING = 7
function minRunLength(e) {
  for (var t = 0; e >= DEFAULT_MIN_MERGE; ) (t |= 1 & e), (e >>= 1)
  return e + t
}
function makeAscendingRun(e, t, i, r) {
  var n = t + 1
  if (n === i) return 1
  if (r(e[n++], e[t]) < 0) {
    for (; n < i && r(e[n], e[n - 1]) < 0; ) n++
    reverseRun(e, t, n)
  } else for (; n < i && r(e[n], e[n - 1]) >= 0; ) n++
  return n - t
}
function reverseRun(e, t, i) {
  for (i--; t < i; ) {
    var r = e[t]
    ;(e[t++] = e[i]), (e[i--] = r)
  }
}
function binaryInsertionSort(e, t, i, r, n) {
  for (r === t && r++; r < i; r++) {
    for (var a, o = e[r], s = t, l = r; s < l; )
      n(o, e[(a = (s + l) >>> 1)]) < 0 ? (l = a) : (s = a + 1)
    var h = r - s
    switch (h) {
      case 3:
        e[s + 3] = e[s + 2]
      case 2:
        e[s + 2] = e[s + 1]
      case 1:
        e[s + 1] = e[s]
        break
      default:
        for (; h > 0; ) (e[s + h] = e[s + h - 1]), h--
    }
    e[s] = o
  }
}
function gallopLeft(e, t, i, r, n, a) {
  var o = 0,
    s = 0,
    l = 1
  if (a(e, t[i + n]) > 0) {
    for (s = r - n; l < s && a(e, t[i + n + l]) > 0; ) (o = l), (l = 1 + (l << 1)) <= 0 && (l = s)
    l > s && (l = s), (o += n), (l += n)
  } else {
    for (s = n + 1; l < s && a(e, t[i + n - l]) <= 0; ) (o = l), (l = 1 + (l << 1)) <= 0 && (l = s)
    l > s && (l = s)
    var h = o
    ;(o = n - l), (l = n - h)
  }
  for (o++; o < l; ) {
    var u = o + ((l - o) >>> 1)
    a(e, t[i + u]) > 0 ? (o = u + 1) : (l = u)
  }
  return l
}
function gallopRight(e, t, i, r, n, a) {
  var o = 0,
    s = 0,
    l = 1
  if (a(e, t[i + n]) < 0) {
    for (s = n + 1; l < s && a(e, t[i + n - l]) < 0; ) (o = l), (l = 1 + (l << 1)) <= 0 && (l = s)
    l > s && (l = s)
    var h = o
    ;(o = n - l), (l = n - h)
  } else {
    for (s = r - n; l < s && a(e, t[i + n + l]) >= 0; ) (o = l), (l = 1 + (l << 1)) <= 0 && (l = s)
    l > s && (l = s), (o += n), (l += n)
  }
  for (o++; o < l; ) {
    var u = o + ((l - o) >>> 1)
    a(e, t[i + u]) < 0 ? (l = u) : (o = u + 1)
  }
  return l
}
function TimSort(e, t) {
  var i,
    r,
    n = DEFAULT_MIN_GALLOPING,
    a = 0
  e.length
  var o = []
  function s(s) {
    var l = i[s],
      h = r[s],
      u = i[s + 1],
      p = r[s + 1]
    ;(r[s] = h + p), s === a - 3 && ((i[s + 1] = i[s + 2]), (r[s + 1] = r[s + 2])), a--
    var c = gallopRight(e[u], e, l, h, 0, t)
    ;(l += c),
      0 !== (h -= c) &&
        0 !== (p = gallopLeft(e[l + h - 1], e, u, p, p - 1, t)) &&
        (h <= p
          ? (function (i, r, a, s) {
              var l = 0
              for (l = 0; l < r; l++) o[l] = e[i + l]
              var h = 0,
                u = a,
                p = i
              if (((e[p++] = e[u++]), 0 == --s)) {
                for (l = 0; l < r; l++) e[p + l] = o[h + l]
                return
              }
              if (1 === r) {
                for (l = 0; l < s; l++) e[p + l] = e[u + l]
                return void (e[p + s] = o[h])
              }
              var c,
                d,
                f,
                m = n
              for (;;) {
                ;(c = 0), (d = 0), (f = !1)
                do {
                  if (t(e[u], o[h]) < 0) {
                    if (((e[p++] = e[u++]), d++, (c = 0), 0 == --s)) {
                      f = !0
                      break
                    }
                  } else if (((e[p++] = o[h++]), c++, (d = 0), 1 == --r)) {
                    f = !0
                    break
                  }
                } while ((c | d) < m)
                if (f) break
                do {
                  if (0 !== (c = gallopRight(e[u], o, h, r, 0, t))) {
                    for (l = 0; l < c; l++) e[p + l] = o[h + l]
                    if (((p += c), (h += c), (r -= c) <= 1)) {
                      f = !0
                      break
                    }
                  }
                  if (((e[p++] = e[u++]), 0 == --s)) {
                    f = !0
                    break
                  }
                  if (0 !== (d = gallopLeft(o[h], e, u, s, 0, t))) {
                    for (l = 0; l < d; l++) e[p + l] = e[u + l]
                    if (((p += d), (u += d), 0 === (s -= d))) {
                      f = !0
                      break
                    }
                  }
                  if (((e[p++] = o[h++]), 1 == --r)) {
                    f = !0
                    break
                  }
                  m--
                } while (c >= DEFAULT_MIN_GALLOPING || d >= DEFAULT_MIN_GALLOPING)
                if (f) break
                m < 0 && (m = 0), (m += 2)
              }
              if (((n = m) < 1 && (n = 1), 1 === r)) {
                for (l = 0; l < s; l++) e[p + l] = e[u + l]
                e[p + s] = o[h]
              } else {
                if (0 === r) throw new Error()
                for (l = 0; l < r; l++) e[p + l] = o[h + l]
              }
            })(l, h, u, p)
          : (function (i, r, a, s) {
              var l = 0
              for (l = 0; l < s; l++) o[l] = e[a + l]
              var h = i + r - 1,
                u = s - 1,
                p = a + s - 1,
                c = 0,
                d = 0
              if (((e[p--] = e[h--]), 0 == --r)) {
                for (c = p - (s - 1), l = 0; l < s; l++) e[c + l] = o[l]
                return
              }
              if (1 === s) {
                for (d = (p -= r) + 1, c = (h -= r) + 1, l = r - 1; l >= 0; l--) e[d + l] = e[c + l]
                return void (e[p] = o[u])
              }
              var f = n
              for (;;) {
                var m = 0,
                  g = 0,
                  y = !1
                do {
                  if (t(o[u], e[h]) < 0) {
                    if (((e[p--] = e[h--]), m++, (g = 0), 0 == --r)) {
                      y = !0
                      break
                    }
                  } else if (((e[p--] = o[u--]), g++, (m = 0), 1 == --s)) {
                    y = !0
                    break
                  }
                } while ((m | g) < f)
                if (y) break
                do {
                  if (0 !== (m = r - gallopRight(o[u], e, i, r, r - 1, t))) {
                    for (r -= m, d = (p -= m) + 1, c = (h -= m) + 1, l = m - 1; l >= 0; l--)
                      e[d + l] = e[c + l]
                    if (0 === r) {
                      y = !0
                      break
                    }
                  }
                  if (((e[p--] = o[u--]), 1 == --s)) {
                    y = !0
                    break
                  }
                  if (0 !== (g = s - gallopLeft(e[h], o, 0, s, s - 1, t))) {
                    for (s -= g, d = (p -= g) + 1, c = (u -= g) + 1, l = 0; l < g; l++)
                      e[d + l] = o[c + l]
                    if (s <= 1) {
                      y = !0
                      break
                    }
                  }
                  if (((e[p--] = e[h--]), 0 == --r)) {
                    y = !0
                    break
                  }
                  f--
                } while (m >= DEFAULT_MIN_GALLOPING || g >= DEFAULT_MIN_GALLOPING)
                if (y) break
                f < 0 && (f = 0), (f += 2)
              }
              ;(n = f) < 1 && (n = 1)
              if (1 === s) {
                for (d = (p -= r) + 1, c = (h -= r) + 1, l = r - 1; l >= 0; l--) e[d + l] = e[c + l]
                e[p] = o[u]
              } else {
                if (0 === s) throw new Error()
                for (c = p - (s - 1), l = 0; l < s; l++) e[c + l] = o[l]
              }
            })(l, h, u, p))
  }
  return (
    (i = []),
    (r = []),
    {
      mergeRuns: function () {
        for (; a > 1; ) {
          var e = a - 2
          if ((e >= 1 && r[e - 1] <= r[e] + r[e + 1]) || (e >= 2 && r[e - 2] <= r[e] + r[e - 1]))
            r[e - 1] < r[e + 1] && e--
          else if (r[e] > r[e + 1]) break
          s(e)
        }
      },
      forceMergeRuns: function () {
        for (; a > 1; ) {
          var e = a - 2
          e > 0 && r[e - 1] < r[e + 1] && e--, s(e)
        }
      },
      pushRun: function (e, t) {
        ;(i[a] = e), (r[a] = t), (a += 1)
      }
    }
  )
}
function sort$2(e, t, i, r) {
  i || (i = 0), r || (r = e.length)
  var n = r - i
  if (!(n < 2)) {
    var a = 0
    if (n < DEFAULT_MIN_MERGE)
      binaryInsertionSort(e, i, r, i + (a = makeAscendingRun(e, i, r, t)), t)
    else {
      var o = TimSort(e, t),
        s = minRunLength(n)
      do {
        if ((a = makeAscendingRun(e, i, r, t)) < s) {
          var l = n
          l > s && (l = s), binaryInsertionSort(e, i, i + l, i + a, t), (a = l)
        }
        o.pushRun(i, a), o.mergeRuns(), (n -= a), (i += a)
      } while (0 !== n)
      o.forceMergeRuns()
    }
  }
}
var REDARAW_BIT = 1,
  STYLE_CHANGED_BIT = 2,
  SHAPE_CHANGED_BIT = 4,
  invalidZErrorLogged = !1
function logInvalidZError() {
  invalidZErrorLogged ||
    ((invalidZErrorLogged = !0),
    console.warn('z / z2 / zlevel of displayable is invalid, which may cause unexpected errors'))
}
function shapeCompareFunc(e, t) {
  return e.zlevel === t.zlevel ? (e.z === t.z ? e.z2 - t.z2 : e.z - t.z) : e.zlevel - t.zlevel
}
var Storage = (function () {
    function e() {
      ;(this._roots = []),
        (this._displayList = []),
        (this._displayListLen = 0),
        (this.displayableSortFunc = shapeCompareFunc)
    }
    return (
      (e.prototype.traverse = function (e, t) {
        for (var i = 0; i < this._roots.length; i++) this._roots[i].traverse(e, t)
      }),
      (e.prototype.getDisplayList = function (e, t) {
        t = t || !1
        var i = this._displayList
        return (!e && i.length) || this.updateDisplayList(t), i
      }),
      (e.prototype.updateDisplayList = function (e) {
        this._displayListLen = 0
        for (var t = this._roots, i = this._displayList, r = 0, n = t.length; r < n; r++)
          this._updateAndAddDisplayable(t[r], null, e)
        ;(i.length = this._displayListLen), env.canvasSupported && sort$2(i, shapeCompareFunc)
      }),
      (e.prototype._updateAndAddDisplayable = function (e, t, i) {
        if (!e.ignore || i) {
          e.beforeUpdate(), e.update(), e.afterUpdate()
          var r = e.getClipPath()
          if (e.ignoreClip) t = null
          else if (r) {
            t = t ? t.slice() : []
            for (var n = r, a = e; n; )
              (n.parent = a), n.updateTransform(), t.push(n), (a = n), (n = n.getClipPath())
          }
          if (e.childrenRef) {
            for (var o = e.childrenRef(), s = 0; s < o.length; s++) {
              var l = o[s]
              e.__dirty && (l.__dirty |= REDARAW_BIT), this._updateAndAddDisplayable(l, t, i)
            }
            e.__dirty = 0
          } else {
            var h = e
            t && t.length
              ? (h.__clipPaths = t)
              : h.__clipPaths && h.__clipPaths.length > 0 && (h.__clipPaths = []),
              isNaN(h.z) && (logInvalidZError(), (h.z = 0)),
              isNaN(h.z2) && (logInvalidZError(), (h.z2 = 0)),
              isNaN(h.zlevel) && (logInvalidZError(), (h.zlevel = 0)),
              (this._displayList[this._displayListLen++] = h)
          }
          var u = e.getDecalElement && e.getDecalElement()
          u && this._updateAndAddDisplayable(u, t, i)
          var p = e.getTextGuideLine()
          p && this._updateAndAddDisplayable(p, t, i)
          var c = e.getTextContent()
          c && this._updateAndAddDisplayable(c, t, i)
        }
      }),
      (e.prototype.addRoot = function (e) {
        ;(e.__zr && e.__zr.storage === this) || this._roots.push(e)
      }),
      (e.prototype.delRoot = function (e) {
        if (e instanceof Array) for (var t = 0, i = e.length; t < i; t++) this.delRoot(e[t])
        else {
          var r = indexOf$1(this._roots, e)
          r >= 0 && this._roots.splice(r, 1)
        }
      }),
      (e.prototype.delAllRoots = function () {
        ;(this._roots = []), (this._displayList = []), (this._displayListLen = 0)
      }),
      (e.prototype.getRoots = function () {
        return this._roots
      }),
      (e.prototype.dispose = function () {
        ;(this._displayList = null), (this._roots = null)
      }),
      e
    )
  })(),
  requestAnimationFrame
requestAnimationFrame =
  ('undefined' != typeof window &&
    ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window)) ||
      (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window)) ||
      window.mozRequestAnimationFrame ||
      window.webkitRequestAnimationFrame)) ||
  function (e) {
    return setTimeout(e, 16)
  }
var requestAnimationFrame$1 = requestAnimationFrame,
  easing = {
    linear: function (e) {
      return e
    },
    quadraticIn: function (e) {
      return e * e
    },
    quadraticOut: function (e) {
      return e * (2 - e)
    },
    quadraticInOut: function (e) {
      return (e *= 2) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1)
    },
    cubicIn: function (e) {
      return e * e * e
    },
    cubicOut: function (e) {
      return --e * e * e + 1
    },
    cubicInOut: function (e) {
      return (e *= 2) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2)
    },
    quarticIn: function (e) {
      return e * e * e * e
    },
    quarticOut: function (e) {
      return 1 - --e * e * e * e
    },
    quarticInOut: function (e) {
      return (e *= 2) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2)
    },
    quinticIn: function (e) {
      return e * e * e * e * e
    },
    quinticOut: function (e) {
      return --e * e * e * e * e + 1
    },
    quinticInOut: function (e) {
      return (e *= 2) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2)
    },
    sinusoidalIn: function (e) {
      return 1 - Math.cos((e * Math.PI) / 2)
    },
    sinusoidalOut: function (e) {
      return Math.sin((e * Math.PI) / 2)
    },
    sinusoidalInOut: function (e) {
      return 0.5 * (1 - Math.cos(Math.PI * e))
    },
    exponentialIn: function (e) {
      return 0 === e ? 0 : Math.pow(1024, e - 1)
    },
    exponentialOut: function (e) {
      return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
    },
    exponentialInOut: function (e) {
      return 0 === e
        ? 0
        : 1 === e
        ? 1
        : (e *= 2) < 1
        ? 0.5 * Math.pow(1024, e - 1)
        : 0.5 * (2 - Math.pow(2, -10 * (e - 1)))
    },
    circularIn: function (e) {
      return 1 - Math.sqrt(1 - e * e)
    },
    circularOut: function (e) {
      return Math.sqrt(1 - --e * e)
    },
    circularInOut: function (e) {
      return (e *= 2) < 1
        ? -0.5 * (Math.sqrt(1 - e * e) - 1)
        : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
    },
    elasticIn: function (e) {
      var t,
        i = 0.1
      return 0 === e
        ? 0
        : 1 === e
        ? 1
        : (!i || i < 1 ? ((i = 1), (t = 0.1)) : (t = (0.4 * Math.asin(1 / i)) / (2 * Math.PI)),
          -i * Math.pow(2, 10 * (e -= 1)) * Math.sin(((e - t) * (2 * Math.PI)) / 0.4))
    },
    elasticOut: function (e) {
      var t,
        i = 0.1
      return 0 === e
        ? 0
        : 1 === e
        ? 1
        : (!i || i < 1 ? ((i = 1), (t = 0.1)) : (t = (0.4 * Math.asin(1 / i)) / (2 * Math.PI)),
          i * Math.pow(2, -10 * e) * Math.sin(((e - t) * (2 * Math.PI)) / 0.4) + 1)
    },
    elasticInOut: function (e) {
      var t,
        i = 0.1,
        r = 0.4
      return 0 === e
        ? 0
        : 1 === e
        ? 1
        : (!i || i < 1 ? ((i = 1), (t = 0.1)) : (t = (r * Math.asin(1 / i)) / (2 * Math.PI)),
          (e *= 2) < 1
            ? i * Math.pow(2, 10 * (e -= 1)) * Math.sin(((e - t) * (2 * Math.PI)) / r) * -0.5
            : i * Math.pow(2, -10 * (e -= 1)) * Math.sin(((e - t) * (2 * Math.PI)) / r) * 0.5 + 1)
    },
    backIn: function (e) {
      var t = 1.70158
      return e * e * ((t + 1) * e - t)
    },
    backOut: function (e) {
      var t = 1.70158
      return --e * e * ((t + 1) * e + t) + 1
    },
    backInOut: function (e) {
      var t = 2.5949095
      return (e *= 2) < 1
        ? e * e * ((t + 1) * e - t) * 0.5
        : 0.5 * ((e -= 2) * e * ((t + 1) * e + t) + 2)
    },
    bounceIn: function (e) {
      return 1 - easing.bounceOut(1 - e)
    },
    bounceOut: function (e) {
      return e < 1 / 2.75
        ? 7.5625 * e * e
        : e < 2 / 2.75
        ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75
        : e < 2.5 / 2.75
        ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375
        : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375
    },
    bounceInOut: function (e) {
      return e < 0.5 ? 0.5 * easing.bounceIn(2 * e) : 0.5 * easing.bounceOut(2 * e - 1) + 0.5
    }
  },
  Clip = (function () {
    function e(e) {
      ;(this._initialized = !1),
        (this._startTime = 0),
        (this._pausedTime = 0),
        (this._paused = !1),
        (this._life = e.life || 1e3),
        (this._delay = e.delay || 0),
        (this.loop = null != e.loop && e.loop),
        (this.gap = e.gap || 0),
        (this.easing = e.easing || 'linear'),
        (this.onframe = e.onframe),
        (this.ondestroy = e.ondestroy),
        (this.onrestart = e.onrestart)
    }
    return (
      (e.prototype.step = function (e, t) {
        if (
          (this._initialized || ((this._startTime = e + this._delay), (this._initialized = !0)),
          !this._paused)
        ) {
          var i = (e - this._startTime - this._pausedTime) / this._life
          i < 0 && (i = 0), (i = Math.min(i, 1))
          var r = this.easing,
            n = 'string' == typeof r ? easing[r] : r,
            a = 'function' == typeof n ? n(i) : i
          if ((this.onframe && this.onframe(a), 1 === i)) {
            if (!this.loop) return !0
            this._restart(e), this.onrestart && this.onrestart()
          }
          return !1
        }
        this._pausedTime += t
      }),
      (e.prototype._restart = function (e) {
        var t = (e - this._startTime - this._pausedTime) % this._life
        ;(this._startTime = e - t + this.gap), (this._pausedTime = 0)
      }),
      (e.prototype.pause = function () {
        this._paused = !0
      }),
      (e.prototype.resume = function () {
        this._paused = !1
      }),
      e
    )
  })(),
  Entry = function (e) {
    this.value = e
  },
  LinkedList = (function () {
    function e() {
      this._len = 0
    }
    return (
      (e.prototype.insert = function (e) {
        var t = new Entry(e)
        return this.insertEntry(t), t
      }),
      (e.prototype.insertEntry = function (e) {
        this.head
          ? ((this.tail.next = e), (e.prev = this.tail), (e.next = null), (this.tail = e))
          : (this.head = this.tail = e),
          this._len++
      }),
      (e.prototype.remove = function (e) {
        var t = e.prev,
          i = e.next
        t ? (t.next = i) : (this.head = i),
          i ? (i.prev = t) : (this.tail = t),
          (e.next = e.prev = null),
          this._len--
      }),
      (e.prototype.len = function () {
        return this._len
      }),
      (e.prototype.clear = function () {
        ;(this.head = this.tail = null), (this._len = 0)
      }),
      e
    )
  })(),
  LRU = (function () {
    function e(e) {
      ;(this._list = new LinkedList()), (this._maxSize = 10), (this._map = {}), (this._maxSize = e)
    }
    return (
      (e.prototype.put = function (e, t) {
        var i = this._list,
          r = this._map,
          n = null
        if (null == r[e]) {
          var a = i.len(),
            o = this._lastRemovedEntry
          if (a >= this._maxSize && a > 0) {
            var s = i.head
            i.remove(s), delete r[s.key], (n = s.value), (this._lastRemovedEntry = s)
          }
          o ? (o.value = t) : (o = new Entry(t)), (o.key = e), i.insertEntry(o), (r[e] = o)
        }
        return n
      }),
      (e.prototype.get = function (e) {
        var t = this._map[e],
          i = this._list
        if (null != t) return t !== i.tail && (i.remove(t), i.insertEntry(t)), t.value
      }),
      (e.prototype.clear = function () {
        this._list.clear(), (this._map = {})
      }),
      (e.prototype.len = function () {
        return this._list.len()
      }),
      e
    )
  })(),
  kCSSColorTable = {
    transparent: [0, 0, 0, 0],
    aliceblue: [240, 248, 255, 1],
    antiquewhite: [250, 235, 215, 1],
    aqua: [0, 255, 255, 1],
    aquamarine: [127, 255, 212, 1],
    azure: [240, 255, 255, 1],
    beige: [245, 245, 220, 1],
    bisque: [255, 228, 196, 1],
    black: [0, 0, 0, 1],
    blanchedalmond: [255, 235, 205, 1],
    blue: [0, 0, 255, 1],
    blueviolet: [138, 43, 226, 1],
    brown: [165, 42, 42, 1],
    burlywood: [222, 184, 135, 1],
    cadetblue: [95, 158, 160, 1],
    chartreuse: [127, 255, 0, 1],
    chocolate: [210, 105, 30, 1],
    coral: [255, 127, 80, 1],
    cornflowerblue: [100, 149, 237, 1],
    cornsilk: [255, 248, 220, 1],
    crimson: [220, 20, 60, 1],
    cyan: [0, 255, 255, 1],
    darkblue: [0, 0, 139, 1],
    darkcyan: [0, 139, 139, 1],
    darkgoldenrod: [184, 134, 11, 1],
    darkgray: [169, 169, 169, 1],
    darkgreen: [0, 100, 0, 1],
    darkgrey: [169, 169, 169, 1],
    darkkhaki: [189, 183, 107, 1],
    darkmagenta: [139, 0, 139, 1],
    darkolivegreen: [85, 107, 47, 1],
    darkorange: [255, 140, 0, 1],
    darkorchid: [153, 50, 204, 1],
    darkred: [139, 0, 0, 1],
    darksalmon: [233, 150, 122, 1],
    darkseagreen: [143, 188, 143, 1],
    darkslateblue: [72, 61, 139, 1],
    darkslategray: [47, 79, 79, 1],
    darkslategrey: [47, 79, 79, 1],
    darkturquoise: [0, 206, 209, 1],
    darkviolet: [148, 0, 211, 1],
    deeppink: [255, 20, 147, 1],
    deepskyblue: [0, 191, 255, 1],
    dimgray: [105, 105, 105, 1],
    dimgrey: [105, 105, 105, 1],
    dodgerblue: [30, 144, 255, 1],
    firebrick: [178, 34, 34, 1],
    floralwhite: [255, 250, 240, 1],
    forestgreen: [34, 139, 34, 1],
    fuchsia: [255, 0, 255, 1],
    gainsboro: [220, 220, 220, 1],
    ghostwhite: [248, 248, 255, 1],
    gold: [255, 215, 0, 1],
    goldenrod: [218, 165, 32, 1],
    gray: [128, 128, 128, 1],
    green: [0, 128, 0, 1],
    greenyellow: [173, 255, 47, 1],
    grey: [128, 128, 128, 1],
    honeydew: [240, 255, 240, 1],
    hotpink: [255, 105, 180, 1],
    indianred: [205, 92, 92, 1],
    indigo: [75, 0, 130, 1],
    ivory: [255, 255, 240, 1],
    khaki: [240, 230, 140, 1],
    lavender: [230, 230, 250, 1],
    lavenderblush: [255, 240, 245, 1],
    lawngreen: [124, 252, 0, 1],
    lemonchiffon: [255, 250, 205, 1],
    lightblue: [173, 216, 230, 1],
    lightcoral: [240, 128, 128, 1],
    lightcyan: [224, 255, 255, 1],
    lightgoldenrodyellow: [250, 250, 210, 1],
    lightgray: [211, 211, 211, 1],
    lightgreen: [144, 238, 144, 1],
    lightgrey: [211, 211, 211, 1],
    lightpink: [255, 182, 193, 1],
    lightsalmon: [255, 160, 122, 1],
    lightseagreen: [32, 178, 170, 1],
    lightskyblue: [135, 206, 250, 1],
    lightslategray: [119, 136, 153, 1],
    lightslategrey: [119, 136, 153, 1],
    lightsteelblue: [176, 196, 222, 1],
    lightyellow: [255, 255, 224, 1],
    lime: [0, 255, 0, 1],
    limegreen: [50, 205, 50, 1],
    linen: [250, 240, 230, 1],
    magenta: [255, 0, 255, 1],
    maroon: [128, 0, 0, 1],
    mediumaquamarine: [102, 205, 170, 1],
    mediumblue: [0, 0, 205, 1],
    mediumorchid: [186, 85, 211, 1],
    mediumpurple: [147, 112, 219, 1],
    mediumseagreen: [60, 179, 113, 1],
    mediumslateblue: [123, 104, 238, 1],
    mediumspringgreen: [0, 250, 154, 1],
    mediumturquoise: [72, 209, 204, 1],
    mediumvioletred: [199, 21, 133, 1],
    midnightblue: [25, 25, 112, 1],
    mintcream: [245, 255, 250, 1],
    mistyrose: [255, 228, 225, 1],
    moccasin: [255, 228, 181, 1],
    navajowhite: [255, 222, 173, 1],
    navy: [0, 0, 128, 1],
    oldlace: [253, 245, 230, 1],
    olive: [128, 128, 0, 1],
    olivedrab: [107, 142, 35, 1],
    orange: [255, 165, 0, 1],
    orangered: [255, 69, 0, 1],
    orchid: [218, 112, 214, 1],
    palegoldenrod: [238, 232, 170, 1],
    palegreen: [152, 251, 152, 1],
    paleturquoise: [175, 238, 238, 1],
    palevioletred: [219, 112, 147, 1],
    papayawhip: [255, 239, 213, 1],
    peachpuff: [255, 218, 185, 1],
    peru: [205, 133, 63, 1],
    pink: [255, 192, 203, 1],
    plum: [221, 160, 221, 1],
    powderblue: [176, 224, 230, 1],
    purple: [128, 0, 128, 1],
    red: [255, 0, 0, 1],
    rosybrown: [188, 143, 143, 1],
    royalblue: [65, 105, 225, 1],
    saddlebrown: [139, 69, 19, 1],
    salmon: [250, 128, 114, 1],
    sandybrown: [244, 164, 96, 1],
    seagreen: [46, 139, 87, 1],
    seashell: [255, 245, 238, 1],
    sienna: [160, 82, 45, 1],
    silver: [192, 192, 192, 1],
    skyblue: [135, 206, 235, 1],
    slateblue: [106, 90, 205, 1],
    slategray: [112, 128, 144, 1],
    slategrey: [112, 128, 144, 1],
    snow: [255, 250, 250, 1],
    springgreen: [0, 255, 127, 1],
    steelblue: [70, 130, 180, 1],
    tan: [210, 180, 140, 1],
    teal: [0, 128, 128, 1],
    thistle: [216, 191, 216, 1],
    tomato: [255, 99, 71, 1],
    turquoise: [64, 224, 208, 1],
    violet: [238, 130, 238, 1],
    wheat: [245, 222, 179, 1],
    white: [255, 255, 255, 1],
    whitesmoke: [245, 245, 245, 1],
    yellow: [255, 255, 0, 1],
    yellowgreen: [154, 205, 50, 1]
  }
function clampCssByte(e) {
  return (e = Math.round(e)) < 0 ? 0 : e > 255 ? 255 : e
}
function clampCssAngle(e) {
  return (e = Math.round(e)) < 0 ? 0 : e > 360 ? 360 : e
}
function clampCssFloat(e) {
  return e < 0 ? 0 : e > 1 ? 1 : e
}
function parseCssInt(e) {
  var t = e
  return t.length && '%' === t.charAt(t.length - 1)
    ? clampCssByte((parseFloat(t) / 100) * 255)
    : clampCssByte(parseInt(t, 10))
}
function parseCssFloat(e) {
  var t = e
  return t.length && '%' === t.charAt(t.length - 1)
    ? clampCssFloat(parseFloat(t) / 100)
    : clampCssFloat(parseFloat(t))
}
function cssHueToRgb(e, t, i) {
  return (
    i < 0 ? (i += 1) : i > 1 && (i -= 1),
    6 * i < 1 ? e + (t - e) * i * 6 : 2 * i < 1 ? t : 3 * i < 2 ? e + (t - e) * (2 / 3 - i) * 6 : e
  )
}
function lerpNumber(e, t, i) {
  return e + (t - e) * i
}
function setRgba(e, t, i, r, n) {
  return (e[0] = t), (e[1] = i), (e[2] = r), (e[3] = n), e
}
function copyRgba(e, t) {
  return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[3]), e
}
var colorCache = new LRU(20),
  lastRemovedArr = null
function putToCache(e, t) {
  lastRemovedArr && copyRgba(lastRemovedArr, t),
    (lastRemovedArr = colorCache.put(e, lastRemovedArr || t.slice()))
}
function parse(e, t) {
  if (e) {
    t = t || []
    var i = colorCache.get(e)
    if (i) return copyRgba(t, i)
    var r = (e += '').replace(/ /g, '').toLowerCase()
    if (r in kCSSColorTable) return copyRgba(t, kCSSColorTable[r]), putToCache(e, t), t
    var n,
      a = r.length
    if ('#' === r.charAt(0))
      return 4 === a || 5 === a
        ? (n = parseInt(r.slice(1, 4), 16)) >= 0 && n <= 4095
          ? (setRgba(
              t,
              ((3840 & n) >> 4) | ((3840 & n) >> 8),
              (240 & n) | ((240 & n) >> 4),
              (15 & n) | ((15 & n) << 4),
              5 === a ? parseInt(r.slice(4), 16) / 15 : 1
            ),
            putToCache(e, t),
            t)
          : void setRgba(t, 0, 0, 0, 1)
        : 7 === a || 9 === a
        ? (n = parseInt(r.slice(1, 7), 16)) >= 0 && n <= 16777215
          ? (setRgba(
              t,
              (16711680 & n) >> 16,
              (65280 & n) >> 8,
              255 & n,
              9 === a ? parseInt(r.slice(7), 16) / 255 : 1
            ),
            putToCache(e, t),
            t)
          : void setRgba(t, 0, 0, 0, 1)
        : void 0
    var o = r.indexOf('('),
      s = r.indexOf(')')
    if (-1 !== o && s + 1 === a) {
      var l = r.substr(0, o),
        h = r.substr(o + 1, s - (o + 1)).split(','),
        u = 1
      switch (l) {
        case 'rgba':
          if (4 !== h.length)
            return 3 === h.length ? setRgba(t, +h[0], +h[1], +h[2], 1) : setRgba(t, 0, 0, 0, 1)
          u = parseCssFloat(h.pop())
        case 'rgb':
          return 3 !== h.length
            ? void setRgba(t, 0, 0, 0, 1)
            : (setRgba(t, parseCssInt(h[0]), parseCssInt(h[1]), parseCssInt(h[2]), u),
              putToCache(e, t),
              t)
        case 'hsla':
          return 4 !== h.length
            ? void setRgba(t, 0, 0, 0, 1)
            : ((h[3] = parseCssFloat(h[3])), hsla2rgba(h, t), putToCache(e, t), t)
        case 'hsl':
          return 3 !== h.length
            ? void setRgba(t, 0, 0, 0, 1)
            : (hsla2rgba(h, t), putToCache(e, t), t)
        default:
          return
      }
    }
    setRgba(t, 0, 0, 0, 1)
  }
}
function hsla2rgba(e, t) {
  var i = (((parseFloat(e[0]) % 360) + 360) % 360) / 360,
    r = parseCssFloat(e[1]),
    n = parseCssFloat(e[2]),
    a = n <= 0.5 ? n * (r + 1) : n + r - n * r,
    o = 2 * n - a
  return (
    setRgba(
      (t = t || []),
      clampCssByte(255 * cssHueToRgb(o, a, i + 1 / 3)),
      clampCssByte(255 * cssHueToRgb(o, a, i)),
      clampCssByte(255 * cssHueToRgb(o, a, i - 1 / 3)),
      1
    ),
    4 === e.length && (t[3] = e[3]),
    t
  )
}
function rgba2hsla(e) {
  if (e) {
    var t,
      i,
      r = e[0] / 255,
      n = e[1] / 255,
      a = e[2] / 255,
      o = Math.min(r, n, a),
      s = Math.max(r, n, a),
      l = s - o,
      h = (s + o) / 2
    if (0 === l) (t = 0), (i = 0)
    else {
      i = h < 0.5 ? l / (s + o) : l / (2 - s - o)
      var u = ((s - r) / 6 + l / 2) / l,
        p = ((s - n) / 6 + l / 2) / l,
        c = ((s - a) / 6 + l / 2) / l
      r === s ? (t = c - p) : n === s ? (t = 1 / 3 + u - c) : a === s && (t = 2 / 3 + p - u),
        t < 0 && (t += 1),
        t > 1 && (t -= 1)
    }
    var d = [360 * t, i, h]
    return null != e[3] && d.push(e[3]), d
  }
}
function lift(e, t) {
  var i = parse(e)
  if (i) {
    for (var r = 0; r < 3; r++)
      (i[r] = t < 0 ? (i[r] * (1 - t)) | 0 : ((255 - i[r]) * t + i[r]) | 0),
        i[r] > 255 ? (i[r] = 255) : i[r] < 0 && (i[r] = 0)
    return stringify(i, 4 === i.length ? 'rgba' : 'rgb')
  }
}
function toHex(e) {
  var t = parse(e)
  if (t) return ((1 << 24) + (t[0] << 16) + (t[1] << 8) + +t[2]).toString(16).slice(1)
}
function fastLerp(e, t, i) {
  if (t && t.length && e >= 0 && e <= 1) {
    i = i || []
    var r = e * (t.length - 1),
      n = Math.floor(r),
      a = Math.ceil(r),
      o = t[n],
      s = t[a],
      l = r - n
    return (
      (i[0] = clampCssByte(lerpNumber(o[0], s[0], l))),
      (i[1] = clampCssByte(lerpNumber(o[1], s[1], l))),
      (i[2] = clampCssByte(lerpNumber(o[2], s[2], l))),
      (i[3] = clampCssFloat(lerpNumber(o[3], s[3], l))),
      i
    )
  }
}
function modifyHSL(e, t, i, r) {
  var n = parse(e)
  if (e)
    return (
      (n = rgba2hsla(n)),
      null != t && (n[0] = clampCssAngle(t)),
      null != i && (n[1] = parseCssFloat(i)),
      null != r && (n[2] = parseCssFloat(r)),
      stringify(hsla2rgba(n), 'rgba')
    )
}
function modifyAlpha(e, t) {
  var i = parse(e)
  if (i && null != t) return (i[3] = clampCssFloat(t)), stringify(i, 'rgba')
}
function stringify(e, t) {
  if (e && e.length) {
    var i = e[0] + ',' + e[1] + ',' + e[2]
    return ('rgba' !== t && 'hsva' !== t && 'hsla' !== t) || (i += ',' + e[3]), t + '(' + i + ')'
  }
}
function lum(e, t) {
  var i = parse(e)
  return i ? ((0.299 * i[0] + 0.587 * i[1] + 0.114 * i[2]) * i[3]) / 255 + (1 - i[3]) * t : 0
}
var arraySlice = Array.prototype.slice
function interpolateNumber(e, t, i) {
  return (t - e) * i + e
}
function step(e, t, i) {
  return i > 0.5 ? t : e
}
function interpolate1DArray(e, t, i, r) {
  for (var n = t.length, a = 0; a < n; a++) e[a] = interpolateNumber(t[a], i[a], r)
}
function interpolate2DArray(e, t, i, r) {
  for (var n = t.length, a = n && t[0].length, o = 0; o < n; o++) {
    e[o] || (e[o] = [])
    for (var s = 0; s < a; s++) e[o][s] = interpolateNumber(t[o][s], i[o][s], r)
  }
}
function add1DArray(e, t, i, r) {
  for (var n = t.length, a = 0; a < n; a++) e[a] = t[a] + i[a] * r
  return e
}
function add2DArray(e, t, i, r) {
  for (var n = t.length, a = n && t[0].length, o = 0; o < n; o++) {
    e[o] || (e[o] = [])
    for (var s = 0; s < a; s++) e[o][s] = t[o][s] + i[o][s] * r
  }
  return e
}
function fillArray(e, t, i) {
  var r = e,
    n = t
  if (r.push && n.push) {
    var a = r.length,
      o = n.length
    if (a !== o)
      if (a > o) r.length = o
      else for (var s = a; s < o; s++) r.push(1 === i ? n[s] : arraySlice.call(n[s]))
    var l = r[0] && r[0].length
    for (s = 0; s < r.length; s++)
      if (1 === i) isNaN(r[s]) && (r[s] = n[s])
      else for (var h = 0; h < l; h++) isNaN(r[s][h]) && (r[s][h] = n[s][h])
  }
}
function is1DArraySame(e, t) {
  var i = e.length
  if (i !== t.length) return !1
  for (var r = 0; r < i; r++) if (e[r] !== t[r]) return !1
  return !0
}
function catmullRomInterpolate(e, t, i, r, n, a, o) {
  var s = 0.5 * (i - e),
    l = 0.5 * (r - t)
  return (2 * (t - i) + s + l) * o + (-3 * (t - i) - 2 * s - l) * a + s * n + t
}
function catmullRomInterpolate1DArray(e, t, i, r, n, a, o, s) {
  for (var l = t.length, h = 0; h < l; h++)
    e[h] = catmullRomInterpolate(t[h], i[h], r[h], n[h], a, o, s)
}
function catmullRomInterpolate2DArray(e, t, i, r, n, a, o, s) {
  for (var l = t.length, h = t[0].length, u = 0; u < l; u++) {
    e[u] || (e[1] = [])
    for (var p = 0; p < h; p++)
      e[u][p] = catmullRomInterpolate(t[u][p], i[u][p], r[u][p], n[u][p], a, o, s)
  }
}
function cloneValue(e) {
  if (isArrayLike(e)) {
    var t = e.length
    if (isArrayLike(e[0])) {
      for (var i = [], r = 0; r < t; r++) i.push(arraySlice.call(e[r]))
      return i
    }
    return arraySlice.call(e)
  }
  return e
}
function rgba2String(e) {
  return (
    (e[0] = Math.floor(e[0])),
    (e[1] = Math.floor(e[1])),
    (e[2] = Math.floor(e[2])),
    'rgba(' + e.join(',') + ')'
  )
}
function guessArrayDim(e) {
  return isArrayLike(e && e[0]) ? 2 : 1
}
var tmpRgba = [0, 0, 0, 0],
  Track = (function () {
    function e(e) {
      ;(this.keyframes = []),
        (this.maxTime = 0),
        (this.arrDim = 0),
        (this.interpolable = !0),
        (this._needsSort = !1),
        (this._isAllValueEqual = !0),
        (this._lastFrame = 0),
        (this._lastFramePercent = 0),
        (this.propName = e)
    }
    return (
      (e.prototype.isFinished = function () {
        return this._finished
      }),
      (e.prototype.setFinished = function () {
        ;(this._finished = !0), this._additiveTrack && this._additiveTrack.setFinished()
      }),
      (e.prototype.needsAnimate = function () {
        return !this._isAllValueEqual && this.keyframes.length >= 2 && this.interpolable
      }),
      (e.prototype.getAdditiveTrack = function () {
        return this._additiveTrack
      }),
      (e.prototype.addKeyframe = function (e, t) {
        e >= this.maxTime ? (this.maxTime = e) : (this._needsSort = !0)
        var i = this.keyframes,
          r = i.length
        if (this.interpolable)
          if (isArrayLike(t)) {
            var n = guessArrayDim(t)
            if (r > 0 && this.arrDim !== n) return void (this.interpolable = !1)
            if ((1 === n && 'number' != typeof t[0]) || (2 === n && 'number' != typeof t[0][0]))
              return void (this.interpolable = !1)
            if (r > 0) {
              var a = i[r - 1]
              this._isAllValueEqual &&
                ((1 === n && is1DArraySame(t, a.value)) || (this._isAllValueEqual = !1))
            }
            this.arrDim = n
          } else {
            if (this.arrDim > 0) return void (this.interpolable = !1)
            if ('string' == typeof t) {
              var o = parse(t)
              o ? ((t = o), (this.isValueColor = !0)) : (this.interpolable = !1)
            } else if ('number' != typeof t || isNaN(t)) return void (this.interpolable = !1)
            if (this._isAllValueEqual && r > 0) {
              a = i[r - 1]
              ;((this.isValueColor && !is1DArraySame(a.value, t)) || a.value !== t) &&
                (this._isAllValueEqual = !1)
            }
          }
        var s = { time: e, value: t, percent: 0 }
        return this.keyframes.push(s), s
      }),
      (e.prototype.prepare = function (e) {
        var t = this.keyframes
        this._needsSort &&
          t.sort(function (e, t) {
            return e.time - t.time
          })
        for (var i = this.arrDim, r = t.length, n = t[r - 1], a = 0; a < r; a++)
          (t[a].percent = t[a].time / this.maxTime),
            i > 0 && a !== r - 1 && fillArray(t[a].value, n.value, i)
        if (
          e &&
          this.needsAnimate() &&
          e.needsAnimate() &&
          i === e.arrDim &&
          this.isValueColor === e.isValueColor &&
          !e._finished
        ) {
          this._additiveTrack = e
          var o = t[0].value
          for (a = 0; a < r; a++)
            0 === i
              ? this.isValueColor
                ? (t[a].additiveValue = add1DArray([], t[a].value, o, -1))
                : (t[a].additiveValue = t[a].value - o)
              : 1 === i
              ? (t[a].additiveValue = add1DArray([], t[a].value, o, -1))
              : 2 === i && (t[a].additiveValue = add2DArray([], t[a].value, o, -1))
        }
      }),
      (e.prototype.step = function (e, t) {
        if (!this._finished) {
          this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null)
          var i,
            r = null != this._additiveTrack,
            n = r ? 'additiveValue' : 'value',
            a = this.keyframes,
            o = this.keyframes.length,
            s = this.propName,
            l = this.arrDim,
            h = this.isValueColor
          if (t < 0) i = 0
          else if (t < this._lastFramePercent) {
            for (i = Math.min(this._lastFrame + 1, o - 1); i >= 0 && !(a[i].percent <= t); i--);
            i = Math.min(i, o - 2)
          } else {
            for (i = this._lastFrame; i < o && !(a[i].percent > t); i++);
            i = Math.min(i - 1, o - 2)
          }
          var u = a[i + 1],
            p = a[i]
          if (p && u) {
            ;(this._lastFrame = i), (this._lastFramePercent = t)
            var c = u.percent - p.percent
            if (0 !== c) {
              var d = (t - p.percent) / c,
                f = r ? this._additiveValue : h ? tmpRgba : e[s]
              if (((l > 0 || h) && !f && (f = this._additiveValue = []), this.useSpline)) {
                var m = a[i][n],
                  g = a[0 === i ? i : i - 1][n],
                  y = a[i > o - 2 ? o - 1 : i + 1][n],
                  v = a[i > o - 3 ? o - 1 : i + 2][n]
                if (l > 0)
                  1 === l
                    ? catmullRomInterpolate1DArray(f, g, m, y, v, d, d * d, d * d * d)
                    : catmullRomInterpolate2DArray(f, g, m, y, v, d, d * d, d * d * d)
                else if (h)
                  catmullRomInterpolate1DArray(f, g, m, y, v, d, d * d, d * d * d),
                    r || (e[s] = rgba2String(f))
                else {
                  var _ = void 0
                  ;(_ = this.interpolable
                    ? catmullRomInterpolate(g, m, y, v, d, d * d, d * d * d)
                    : y),
                    r ? (this._additiveValue = _) : (e[s] = _)
                }
              } else if (l > 0)
                1 === l
                  ? interpolate1DArray(f, p[n], u[n], d)
                  : interpolate2DArray(f, p[n], u[n], d)
              else if (h) interpolate1DArray(f, p[n], u[n], d), r || (e[s] = rgba2String(f))
              else {
                _ = void 0
                ;(_ = this.interpolable ? interpolateNumber(p[n], u[n], d) : step(p[n], u[n], d)),
                  r ? (this._additiveValue = _) : (e[s] = _)
              }
              r && this._addToTarget(e)
            }
          }
        }
      }),
      (e.prototype._addToTarget = function (e) {
        var t = this.arrDim,
          i = this.propName,
          r = this._additiveValue
        0 === t
          ? this.isValueColor
            ? (parse(e[i], tmpRgba),
              add1DArray(tmpRgba, tmpRgba, r, 1),
              (e[i] = rgba2String(tmpRgba)))
            : (e[i] = e[i] + r)
          : 1 === t
          ? add1DArray(e[i], e[i], r, 1)
          : 2 === t && add2DArray(e[i], e[i], r, 1)
      }),
      e
    )
  })(),
  Animator = (function () {
    function e(e, t, i) {
      ;(this._tracks = {}),
        (this._trackKeys = []),
        (this._delay = 0),
        (this._maxTime = 0),
        (this._paused = !1),
        (this._started = 0),
        (this._clip = null),
        (this._target = e),
        (this._loop = t),
        t && i
          ? logError("Can' use additive animation on looped animation.")
          : (this._additiveAnimators = i)
    }
    return (
      (e.prototype.getTarget = function () {
        return this._target
      }),
      (e.prototype.changeTarget = function (e) {
        this._target = e
      }),
      (e.prototype.when = function (e, t) {
        return this.whenWithKeys(e, t, keys(t))
      }),
      (e.prototype.whenWithKeys = function (e, t, i) {
        for (var r = this._tracks, n = 0; n < i.length; n++) {
          var a = i[n],
            o = r[a]
          if (!o) {
            o = r[a] = new Track(a)
            var s = void 0,
              l = this._getAdditiveTrack(a)
            if (l) {
              var h = l.keyframes[l.keyframes.length - 1]
              ;(s = h && h.value), l.isValueColor && s && (s = rgba2String(s))
            } else s = this._target[a]
            if (null == s) continue
            0 !== e && o.addKeyframe(0, cloneValue(s)), this._trackKeys.push(a)
          }
          o.addKeyframe(e, cloneValue(t[a]))
        }
        return (this._maxTime = Math.max(this._maxTime, e)), this
      }),
      (e.prototype.pause = function () {
        this._clip.pause(), (this._paused = !0)
      }),
      (e.prototype.resume = function () {
        this._clip.resume(), (this._paused = !1)
      }),
      (e.prototype.isPaused = function () {
        return !!this._paused
      }),
      (e.prototype._doneCallback = function () {
        this._setTracksFinished(), (this._clip = null)
        var e = this._doneList
        if (e) for (var t = e.length, i = 0; i < t; i++) e[i].call(this)
      }),
      (e.prototype._abortedCallback = function () {
        this._setTracksFinished()
        var e = this.animation,
          t = this._abortedList
        if ((e && e.removeClip(this._clip), (this._clip = null), t))
          for (var i = 0; i < t.length; i++) t[i].call(this)
      }),
      (e.prototype._setTracksFinished = function () {
        for (var e = this._tracks, t = this._trackKeys, i = 0; i < t.length; i++)
          e[t[i]].setFinished()
      }),
      (e.prototype._getAdditiveTrack = function (e) {
        var t,
          i = this._additiveAnimators
        if (i)
          for (var r = 0; r < i.length; r++) {
            var n = i[r].getTrack(e)
            n && (t = n)
          }
        return t
      }),
      (e.prototype.start = function (e, t) {
        if (!(this._started > 0)) {
          this._started = 1
          for (var i = this, r = [], n = 0; n < this._trackKeys.length; n++) {
            var a = this._trackKeys[n],
              o = this._tracks[a],
              s = this._getAdditiveTrack(a),
              l = o.keyframes
            if ((o.prepare(s), o.needsAnimate())) r.push(o)
            else if (!o.interpolable) {
              var h = l[l.length - 1]
              h && (i._target[o.propName] = h.value)
            }
          }
          if (r.length || t) {
            var u = new Clip({
              life: this._maxTime,
              loop: this._loop,
              delay: this._delay,
              onframe: function (e) {
                i._started = 2
                var t = i._additiveAnimators
                if (t) {
                  for (var n = !1, a = 0; a < t.length; a++)
                    if (t[a]._clip) {
                      n = !0
                      break
                    }
                  n || (i._additiveAnimators = null)
                }
                for (a = 0; a < r.length; a++) r[a].step(i._target, e)
                var o = i._onframeList
                if (o) for (a = 0; a < o.length; a++) o[a](i._target, e)
              },
              ondestroy: function () {
                i._doneCallback()
              }
            })
            ;(this._clip = u),
              this.animation && this.animation.addClip(u),
              e && 'spline' !== e && (u.easing = e)
          } else this._doneCallback()
          return this
        }
      }),
      (e.prototype.stop = function (e) {
        if (this._clip) {
          var t = this._clip
          e && t.onframe(1), this._abortedCallback()
        }
      }),
      (e.prototype.delay = function (e) {
        return (this._delay = e), this
      }),
      (e.prototype.during = function (e) {
        return e && (this._onframeList || (this._onframeList = []), this._onframeList.push(e)), this
      }),
      (e.prototype.done = function (e) {
        return e && (this._doneList || (this._doneList = []), this._doneList.push(e)), this
      }),
      (e.prototype.aborted = function (e) {
        return e && (this._abortedList || (this._abortedList = []), this._abortedList.push(e)), this
      }),
      (e.prototype.getClip = function () {
        return this._clip
      }),
      (e.prototype.getTrack = function (e) {
        return this._tracks[e]
      }),
      (e.prototype.stopTracks = function (e, t) {
        if (!e.length || !this._clip) return !0
        for (var i = this._tracks, r = this._trackKeys, n = 0; n < e.length; n++) {
          var a = i[e[n]]
          a &&
            (t ? a.step(this._target, 1) : 1 === this._started && a.step(this._target, 0),
            a.setFinished())
        }
        var o = !0
        for (n = 0; n < r.length; n++)
          if (!i[r[n]].isFinished()) {
            o = !1
            break
          }
        return o && this._abortedCallback(), o
      }),
      (e.prototype.saveFinalToTarget = function (e, t) {
        if (e) {
          t = t || this._trackKeys
          for (var i = 0; i < t.length; i++) {
            var r = t[i],
              n = this._tracks[r]
            if (n && !n.isFinished()) {
              var a = n.keyframes,
                o = a[a.length - 1]
              if (o) {
                var s = cloneValue(o.value)
                n.isValueColor && (s = rgba2String(s)), (e[r] = s)
              }
            }
          }
        }
      }),
      (e.prototype.__changeFinalValue = function (e, t) {
        t = t || keys(e)
        for (var i = 0; i < t.length; i++) {
          var r = t[i],
            n = this._tracks[r]
          if (n) {
            var a = n.keyframes
            if (a.length > 1) {
              var o = a.pop()
              n.addKeyframe(o.time, e[r]), n.prepare(n.getAdditiveTrack())
            }
          }
        }
      }),
      e
    )
  })(),
  Animation = (function (e) {
    function t(t) {
      var i = e.call(this) || this
      return (
        (i._running = !1),
        (i._time = 0),
        (i._pausedTime = 0),
        (i._pauseStart = 0),
        (i._paused = !1),
        (t = t || {}),
        (i.stage = t.stage || {}),
        (i.onframe = t.onframe || function () {}),
        i
      )
    }
    return (
      __extends(t, e),
      (t.prototype.addClip = function (e) {
        e.animation && this.removeClip(e),
          this._clipsHead
            ? ((this._clipsTail.next = e),
              (e.prev = this._clipsTail),
              (e.next = null),
              (this._clipsTail = e))
            : (this._clipsHead = this._clipsTail = e),
          (e.animation = this)
      }),
      (t.prototype.addAnimator = function (e) {
        e.animation = this
        var t = e.getClip()
        t && this.addClip(t)
      }),
      (t.prototype.removeClip = function (e) {
        if (e.animation) {
          var t = e.prev,
            i = e.next
          t ? (t.next = i) : (this._clipsHead = i),
            i ? (i.prev = t) : (this._clipsTail = t),
            (e.next = e.prev = e.animation = null)
        }
      }),
      (t.prototype.removeAnimator = function (e) {
        var t = e.getClip()
        t && this.removeClip(t), (e.animation = null)
      }),
      (t.prototype.update = function (e) {
        for (
          var t = new Date().getTime() - this._pausedTime, i = t - this._time, r = this._clipsHead;
          r;

        ) {
          var n = r.next
          r.step(t, i) ? (r.ondestroy && r.ondestroy(), this.removeClip(r), (r = n)) : (r = n)
        }
        ;(this._time = t),
          e || (this.onframe(i), this.trigger('frame', i), this.stage.update && this.stage.update())
      }),
      (t.prototype._startLoop = function () {
        var e = this
        ;(this._running = !0),
          requestAnimationFrame$1(function t() {
            e._running && (requestAnimationFrame$1(t), !e._paused && e.update())
          })
      }),
      (t.prototype.start = function () {
        this._running ||
          ((this._time = new Date().getTime()), (this._pausedTime = 0), this._startLoop())
      }),
      (t.prototype.stop = function () {
        this._running = !1
      }),
      (t.prototype.pause = function () {
        this._paused || ((this._pauseStart = new Date().getTime()), (this._paused = !0))
      }),
      (t.prototype.resume = function () {
        this._paused &&
          ((this._pausedTime += new Date().getTime() - this._pauseStart), (this._paused = !1))
      }),
      (t.prototype.clear = function () {
        for (var e = this._clipsHead; e; ) {
          var t = e.next
          ;(e.prev = e.next = e.animation = null), (e = t)
        }
        this._clipsHead = this._clipsTail = null
      }),
      (t.prototype.isFinished = function () {
        return null == this._clipsHead
      }),
      (t.prototype.animate = function (e, t) {
        ;(t = t || {}), this.start()
        var i = new Animator(e, t.loop)
        return this.addAnimator(i), i
      }),
      t
    )
  })(Eventful),
  TOUCH_CLICK_DELAY = 300,
  globalEventSupported = env.domSupported,
  localNativeListenerNames =
    ((mouseHandlerNames = [
      'click',
      'dblclick',
      'mousewheel',
      'wheel',
      'mouseout',
      'mouseup',
      'mousedown',
      'mousemove',
      'contextmenu'
    ]),
    (pointerEventNameMap = { pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1 }),
    {
      mouse: mouseHandlerNames,
      touch: ['touchstart', 'touchend', 'touchmove'],
      pointer: map$1(mouseHandlerNames, function (e) {
        var t = e.replace('mouse', 'pointer')
        return pointerEventNameMap.hasOwnProperty(t) ? t : e
      })
    }),
  mouseHandlerNames,
  pointerEventNameMap,
  globalNativeListenerNames = {
    mouse: ['mousemove', 'mouseup'],
    pointer: ['pointermove', 'pointerup']
  },
  wheelEventSupported = !1
function isPointerFromTouch(e) {
  var t = e.pointerType
  return 'pen' === t || 'touch' === t
}
function setTouchTimer(e) {
  ;(e.touching = !0),
    null != e.touchTimer && (clearTimeout(e.touchTimer), (e.touchTimer = null)),
    (e.touchTimer = setTimeout(function () {
      ;(e.touching = !1), (e.touchTimer = null)
    }, 700))
}
function markTouch(e) {
  e && (e.zrByTouch = !0)
}
function normalizeGlobalEvent(e, t) {
  return normalizeEvent(e.dom, new FakeGlobalEvent(e, t), !0)
}
function isLocalEl(e, t) {
  for (
    var i = t, r = !1;
    i && 9 !== i.nodeType && !(r = i.domBelongToZr || (i !== t && i === e.painterRoot));

  )
    i = i.parentNode
  return r
}
var FakeGlobalEvent = function (e, t) {
    ;(this.stopPropagation = noop$1),
      (this.stopImmediatePropagation = noop$1),
      (this.preventDefault = noop$1),
      (this.type = t.type),
      (this.target = this.currentTarget = e.dom),
      (this.pointerType = t.pointerType),
      (this.clientX = t.clientX),
      (this.clientY = t.clientY)
  },
  localDOMHandlers = {
    mousedown: function (e) {
      ;(e = normalizeEvent(this.dom, e)),
        (this.__mayPointerCapture = [e.zrX, e.zrY]),
        this.trigger('mousedown', e)
    },
    mousemove: function (e) {
      e = normalizeEvent(this.dom, e)
      var t = this.__mayPointerCapture
      !t || (e.zrX === t[0] && e.zrY === t[1]) || this.__togglePointerCapture(!0),
        this.trigger('mousemove', e)
    },
    mouseup: function (e) {
      ;(e = normalizeEvent(this.dom, e)),
        this.__togglePointerCapture(!1),
        this.trigger('mouseup', e)
    },
    mouseout: function (e) {
      isLocalEl(this, (e = normalizeEvent(this.dom, e)).toElement || e.relatedTarget) ||
        (this.__pointerCapturing && (e.zrEventControl = 'no_globalout'),
        this.trigger('mouseout', e))
    },
    wheel: function (e) {
      ;(wheelEventSupported = !0), (e = normalizeEvent(this.dom, e)), this.trigger('mousewheel', e)
    },
    mousewheel: function (e) {
      wheelEventSupported || ((e = normalizeEvent(this.dom, e)), this.trigger('mousewheel', e))
    },
    touchstart: function (e) {
      markTouch((e = normalizeEvent(this.dom, e))),
        (this.__lastTouchMoment = new Date()),
        this.handler.processGesture(e, 'start'),
        localDOMHandlers.mousemove.call(this, e),
        localDOMHandlers.mousedown.call(this, e)
    },
    touchmove: function (e) {
      markTouch((e = normalizeEvent(this.dom, e))),
        this.handler.processGesture(e, 'change'),
        localDOMHandlers.mousemove.call(this, e)
    },
    touchend: function (e) {
      markTouch((e = normalizeEvent(this.dom, e))),
        this.handler.processGesture(e, 'end'),
        localDOMHandlers.mouseup.call(this, e),
        +new Date() - +this.__lastTouchMoment < TOUCH_CLICK_DELAY &&
          localDOMHandlers.click.call(this, e)
    },
    pointerdown: function (e) {
      localDOMHandlers.mousedown.call(this, e)
    },
    pointermove: function (e) {
      isPointerFromTouch(e) || localDOMHandlers.mousemove.call(this, e)
    },
    pointerup: function (e) {
      localDOMHandlers.mouseup.call(this, e)
    },
    pointerout: function (e) {
      isPointerFromTouch(e) || localDOMHandlers.mouseout.call(this, e)
    }
  }
each$i(['click', 'dblclick', 'contextmenu'], function (e) {
  localDOMHandlers[e] = function (t) {
    ;(t = normalizeEvent(this.dom, t)), this.trigger(e, t)
  }
})
var globalDOMHandlers = {
  pointermove: function (e) {
    isPointerFromTouch(e) || globalDOMHandlers.mousemove.call(this, e)
  },
  pointerup: function (e) {
    globalDOMHandlers.mouseup.call(this, e)
  },
  mousemove: function (e) {
    this.trigger('mousemove', e)
  },
  mouseup: function (e) {
    var t = this.__pointerCapturing
    this.__togglePointerCapture(!1),
      this.trigger('mouseup', e),
      t && ((e.zrEventControl = 'only_globalout'), this.trigger('mouseout', e))
  }
}
function mountLocalDOMEventListeners(e, t) {
  var i = t.domHandlers
  env.pointerEventsSupported
    ? each$i(localNativeListenerNames.pointer, function (r) {
        mountSingleDOMEventListener(t, r, function (t) {
          i[r].call(e, t)
        })
      })
    : (env.touchEventsSupported &&
        each$i(localNativeListenerNames.touch, function (r) {
          mountSingleDOMEventListener(t, r, function (n) {
            i[r].call(e, n), setTouchTimer(t)
          })
        }),
      each$i(localNativeListenerNames.mouse, function (r) {
        mountSingleDOMEventListener(t, r, function (n) {
          ;(n = getNativeEvent(n)), t.touching || i[r].call(e, n)
        })
      }))
}
function mountGlobalDOMEventListeners(e, t) {
  function i(i) {
    mountSingleDOMEventListener(
      t,
      i,
      function (r) {
        ;(r = getNativeEvent(r)),
          isLocalEl(e, r.target) || ((r = normalizeGlobalEvent(e, r)), t.domHandlers[i].call(e, r))
      },
      { capture: !0 }
    )
  }
  env.pointerEventsSupported
    ? each$i(globalNativeListenerNames.pointer, i)
    : env.touchEventsSupported || each$i(globalNativeListenerNames.mouse, i)
}
function mountSingleDOMEventListener(e, t, i, r) {
  ;(e.mounted[t] = i), (e.listenerOpts[t] = r), addEventListener(e.domTarget, t, i, r)
}
function unmountDOMEventListeners(e) {
  var t = e.mounted
  for (var i in t)
    t.hasOwnProperty(i) && removeEventListener(e.domTarget, i, t[i], e.listenerOpts[i])
  e.mounted = {}
}
var DOMHandlerScope = function (e, t) {
    ;(this.mounted = {}),
      (this.listenerOpts = {}),
      (this.touching = !1),
      (this.domTarget = e),
      (this.domHandlers = t)
  },
  HandlerDomProxy = (function (e) {
    function t(t, i) {
      var r = e.call(this) || this
      return (
        (r.__pointerCapturing = !1),
        (r.dom = t),
        (r.painterRoot = i),
        (r._localHandlerScope = new DOMHandlerScope(t, localDOMHandlers)),
        globalEventSupported &&
          (r._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers)),
        mountLocalDOMEventListeners(r, r._localHandlerScope),
        r
      )
    }
    return (
      __extends(t, e),
      (t.prototype.dispose = function () {
        unmountDOMEventListeners(this._localHandlerScope),
          globalEventSupported && unmountDOMEventListeners(this._globalHandlerScope)
      }),
      (t.prototype.setCursor = function (e) {
        this.dom.style && (this.dom.style.cursor = e || 'default')
      }),
      (t.prototype.__togglePointerCapture = function (e) {
        if (
          ((this.__mayPointerCapture = null), globalEventSupported && +this.__pointerCapturing ^ +e)
        ) {
          this.__pointerCapturing = e
          var t = this._globalHandlerScope
          e ? mountGlobalDOMEventListeners(this, t) : unmountDOMEventListeners(t)
        }
      }),
      t
    )
  })(Eventful),
  dpr = 1
'undefined' != typeof window &&
  (dpr = Math.max(
    window.devicePixelRatio ||
      (window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI) ||
      1,
    1
  ))
var devicePixelRatio = dpr,
  DARK_MODE_THRESHOLD = 0.4,
  DARK_LABEL_COLOR = '#333',
  LIGHT_LABEL_COLOR = '#ccc',
  LIGHTER_LABEL_COLOR = '#eee'
function create$1() {
  return [1, 0, 0, 1, 0, 0]
}
function identity(e) {
  return (e[0] = 1), (e[1] = 0), (e[2] = 0), (e[3] = 1), (e[4] = 0), (e[5] = 0), e
}
function copy(e, t) {
  return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[3]), (e[4] = t[4]), (e[5] = t[5]), e
}
function mul(e, t, i) {
  var r = t[0] * i[0] + t[2] * i[1],
    n = t[1] * i[0] + t[3] * i[1],
    a = t[0] * i[2] + t[2] * i[3],
    o = t[1] * i[2] + t[3] * i[3],
    s = t[0] * i[4] + t[2] * i[5] + t[4],
    l = t[1] * i[4] + t[3] * i[5] + t[5]
  return (e[0] = r), (e[1] = n), (e[2] = a), (e[3] = o), (e[4] = s), (e[5] = l), e
}
function translate$1(e, t, i) {
  return (
    (e[0] = t[0]),
    (e[1] = t[1]),
    (e[2] = t[2]),
    (e[3] = t[3]),
    (e[4] = t[4] + i[0]),
    (e[5] = t[5] + i[1]),
    e
  )
}
function rotate(e, t, i) {
  var r = t[0],
    n = t[2],
    a = t[4],
    o = t[1],
    s = t[3],
    l = t[5],
    h = Math.sin(i),
    u = Math.cos(i)
  return (
    (e[0] = r * u + o * h),
    (e[1] = -r * h + o * u),
    (e[2] = n * u + s * h),
    (e[3] = -n * h + u * s),
    (e[4] = u * a + h * l),
    (e[5] = u * l - h * a),
    e
  )
}
function scale$1(e, t, i) {
  var r = i[0],
    n = i[1]
  return (
    (e[0] = t[0] * r),
    (e[1] = t[1] * n),
    (e[2] = t[2] * r),
    (e[3] = t[3] * n),
    (e[4] = t[4] * r),
    (e[5] = t[5] * n),
    e
  )
}
function invert(e, t) {
  var i = t[0],
    r = t[2],
    n = t[4],
    a = t[1],
    o = t[3],
    s = t[5],
    l = i * o - a * r
  return l
    ? ((l = 1 / l),
      (e[0] = o * l),
      (e[1] = -a * l),
      (e[2] = -r * l),
      (e[3] = i * l),
      (e[4] = (r * s - o * n) * l),
      (e[5] = (a * n - i * s) * l),
      e)
    : null
}
function clone$1(e) {
  var t = create$1()
  return copy(t, e), t
}
var mIdentity = identity,
  EPSILON$4 = 5e-5
function isNotAroundZero$1(e) {
  return e > EPSILON$4 || e < -EPSILON$4
}
var scaleTmp = [],
  tmpTransform = [],
  originTransform = create$1(),
  abs = Math.abs,
  Transformable = (function () {
    function e() {}
    var t
    return (
      (e.prototype.setPosition = function (e) {
        ;(this.x = e[0]), (this.y = e[1])
      }),
      (e.prototype.setScale = function (e) {
        ;(this.scaleX = e[0]), (this.scaleY = e[1])
      }),
      (e.prototype.setSkew = function (e) {
        ;(this.skewX = e[0]), (this.skewY = e[1])
      }),
      (e.prototype.setOrigin = function (e) {
        ;(this.originX = e[0]), (this.originY = e[1])
      }),
      (e.prototype.needLocalTransform = function () {
        return (
          isNotAroundZero$1(this.rotation) ||
          isNotAroundZero$1(this.x) ||
          isNotAroundZero$1(this.y) ||
          isNotAroundZero$1(this.scaleX - 1) ||
          isNotAroundZero$1(this.scaleY - 1)
        )
      }),
      (e.prototype.updateTransform = function () {
        var e = this.parent,
          t = e && e.transform,
          i = this.needLocalTransform(),
          r = this.transform
        i || t
          ? ((r = r || create$1()),
            i ? this.getLocalTransform(r) : mIdentity(r),
            t && (i ? mul(r, e.transform, r) : copy(r, e.transform)),
            (this.transform = r),
            this._resolveGlobalScaleRatio(r))
          : r && mIdentity(r)
      }),
      (e.prototype._resolveGlobalScaleRatio = function (e) {
        var t = this.globalScaleRatio
        if (null != t && 1 !== t) {
          this.getGlobalScale(scaleTmp)
          var i = scaleTmp[0] < 0 ? -1 : 1,
            r = scaleTmp[1] < 0 ? -1 : 1,
            n = ((scaleTmp[0] - i) * t + i) / scaleTmp[0] || 0,
            a = ((scaleTmp[1] - r) * t + r) / scaleTmp[1] || 0
          ;(e[0] *= n), (e[1] *= n), (e[2] *= a), (e[3] *= a)
        }
        ;(this.invTransform = this.invTransform || create$1()), invert(this.invTransform, e)
      }),
      (e.prototype.getLocalTransform = function (t) {
        return e.getLocalTransform(this, t)
      }),
      (e.prototype.getComputedTransform = function () {
        for (var e = this, t = []; e; ) t.push(e), (e = e.parent)
        for (; (e = t.pop()); ) e.updateTransform()
        return this.transform
      }),
      (e.prototype.setLocalTransform = function (e) {
        if (e) {
          var t = e[0] * e[0] + e[1] * e[1],
            i = e[2] * e[2] + e[3] * e[3],
            r = Math.atan2(e[1], e[0]),
            n = Math.PI / 2 + r - Math.atan2(e[3], e[2])
          ;(i = Math.sqrt(i) * Math.cos(n)),
            (t = Math.sqrt(t)),
            (this.skewX = n),
            (this.skewY = 0),
            (this.rotation = -r),
            (this.x = +e[4]),
            (this.y = +e[5]),
            (this.scaleX = t),
            (this.scaleY = i),
            (this.originX = 0),
            (this.originY = 0)
        }
      }),
      (e.prototype.decomposeTransform = function () {
        if (this.transform) {
          var e = this.parent,
            t = this.transform
          e && e.transform && (mul(tmpTransform, e.invTransform, t), (t = tmpTransform))
          var i = this.originX,
            r = this.originY
          ;(i || r) &&
            ((originTransform[4] = i),
            (originTransform[5] = r),
            mul(tmpTransform, t, originTransform),
            (tmpTransform[4] -= i),
            (tmpTransform[5] -= r),
            (t = tmpTransform)),
            this.setLocalTransform(t)
        }
      }),
      (e.prototype.getGlobalScale = function (e) {
        var t = this.transform
        return (
          (e = e || []),
          t
            ? ((e[0] = Math.sqrt(t[0] * t[0] + t[1] * t[1])),
              (e[1] = Math.sqrt(t[2] * t[2] + t[3] * t[3])),
              t[0] < 0 && (e[0] = -e[0]),
              t[3] < 0 && (e[1] = -e[1]),
              e)
            : ((e[0] = 1), (e[1] = 1), e)
        )
      }),
      (e.prototype.transformCoordToLocal = function (e, t) {
        var i = [e, t],
          r = this.invTransform
        return r && applyTransform$1(i, i, r), i
      }),
      (e.prototype.transformCoordToGlobal = function (e, t) {
        var i = [e, t],
          r = this.transform
        return r && applyTransform$1(i, i, r), i
      }),
      (e.prototype.getLineScale = function () {
        var e = this.transform
        return e && abs(e[0] - 1) > 1e-10 && abs(e[3] - 1) > 1e-10
          ? Math.sqrt(abs(e[0] * e[3] - e[2] * e[1]))
          : 1
      }),
      (e.getLocalTransform = function (e, t) {
        t = t || []
        var i = e.originX || 0,
          r = e.originY || 0,
          n = e.scaleX,
          a = e.scaleY,
          o = e.rotation || 0,
          s = e.x,
          l = e.y,
          h = e.skewX ? Math.tan(e.skewX) : 0,
          u = e.skewY ? Math.tan(-e.skewY) : 0
        return (
          i || r ? ((t[4] = -i * n - h * r * a), (t[5] = -r * a - u * i * n)) : (t[4] = t[5] = 0),
          (t[0] = n),
          (t[3] = a),
          (t[1] = u * n),
          (t[2] = h * a),
          o && rotate(t, t, o),
          (t[4] += i + s),
          (t[5] += r + l),
          t
        )
      }),
      (e.initDefaultProps =
        (((t = e.prototype).x = 0),
        (t.y = 0),
        (t.scaleX = 1),
        (t.scaleY = 1),
        (t.originX = 0),
        (t.originY = 0),
        (t.skewX = 0),
        (t.skewY = 0),
        (t.rotation = 0),
        void (t.globalScaleRatio = 1))),
      e
    )
  })(),
  Point = (function () {
    function e(e, t) {
      ;(this.x = e || 0), (this.y = t || 0)
    }
    return (
      (e.prototype.copy = function (e) {
        return (this.x = e.x), (this.y = e.y), this
      }),
      (e.prototype.clone = function () {
        return new e(this.x, this.y)
      }),
      (e.prototype.set = function (e, t) {
        return (this.x = e), (this.y = t), this
      }),
      (e.prototype.equal = function (e) {
        return e.x === this.x && e.y === this.y
      }),
      (e.prototype.add = function (e) {
        return (this.x += e.x), (this.y += e.y), this
      }),
      (e.prototype.scale = function (e) {
        ;(this.x *= e), (this.y *= e)
      }),
      (e.prototype.scaleAndAdd = function (e, t) {
        ;(this.x += e.x * t), (this.y += e.y * t)
      }),
      (e.prototype.sub = function (e) {
        return (this.x -= e.x), (this.y -= e.y), this
      }),
      (e.prototype.dot = function (e) {
        return this.x * e.x + this.y * e.y
      }),
      (e.prototype.len = function () {
        return Math.sqrt(this.x * this.x + this.y * this.y)
      }),
      (e.prototype.lenSquare = function () {
        return this.x * this.x + this.y * this.y
      }),
      (e.prototype.normalize = function () {
        var e = this.len()
        return (this.x /= e), (this.y /= e), this
      }),
      (e.prototype.distance = function (e) {
        var t = this.x - e.x,
          i = this.y - e.y
        return Math.sqrt(t * t + i * i)
      }),
      (e.prototype.distanceSquare = function (e) {
        var t = this.x - e.x,
          i = this.y - e.y
        return t * t + i * i
      }),
      (e.prototype.negate = function () {
        return (this.x = -this.x), (this.y = -this.y), this
      }),
      (e.prototype.transform = function (e) {
        if (e) {
          var t = this.x,
            i = this.y
          return (this.x = e[0] * t + e[2] * i + e[4]), (this.y = e[1] * t + e[3] * i + e[5]), this
        }
      }),
      (e.prototype.toArray = function (e) {
        return (e[0] = this.x), (e[1] = this.y), e
      }),
      (e.prototype.fromArray = function (e) {
        ;(this.x = e[0]), (this.y = e[1])
      }),
      (e.set = function (e, t, i) {
        ;(e.x = t), (e.y = i)
      }),
      (e.copy = function (e, t) {
        ;(e.x = t.x), (e.y = t.y)
      }),
      (e.len = function (e) {
        return Math.sqrt(e.x * e.x + e.y * e.y)
      }),
      (e.lenSquare = function (e) {
        return e.x * e.x + e.y * e.y
      }),
      (e.dot = function (e, t) {
        return e.x * t.x + e.y * t.y
      }),
      (e.add = function (e, t, i) {
        ;(e.x = t.x + i.x), (e.y = t.y + i.y)
      }),
      (e.sub = function (e, t, i) {
        ;(e.x = t.x - i.x), (e.y = t.y - i.y)
      }),
      (e.scale = function (e, t, i) {
        ;(e.x = t.x * i), (e.y = t.y * i)
      }),
      (e.scaleAndAdd = function (e, t, i, r) {
        ;(e.x = t.x + i.x * r), (e.y = t.y + i.y * r)
      }),
      (e.lerp = function (e, t, i, r) {
        var n = 1 - r
        ;(e.x = n * t.x + r * i.x), (e.y = n * t.y + r * i.y)
      }),
      e
    )
  })(),
  mathMin$a = Math.min,
  mathMax$a = Math.max,
  lt = new Point(),
  rb = new Point(),
  lb = new Point(),
  rt = new Point(),
  minTv$1 = new Point(),
  maxTv$1 = new Point(),
  BoundingRect = (function () {
    function e(e, t, i, r) {
      i < 0 && ((e += i), (i = -i)),
        r < 0 && ((t += r), (r = -r)),
        (this.x = e),
        (this.y = t),
        (this.width = i),
        (this.height = r)
    }
    return (
      (e.prototype.union = function (e) {
        var t = mathMin$a(e.x, this.x),
          i = mathMin$a(e.y, this.y)
        isFinite(this.x) && isFinite(this.width)
          ? (this.width = mathMax$a(e.x + e.width, this.x + this.width) - t)
          : (this.width = e.width),
          isFinite(this.y) && isFinite(this.height)
            ? (this.height = mathMax$a(e.y + e.height, this.y + this.height) - i)
            : (this.height = e.height),
          (this.x = t),
          (this.y = i)
      }),
      (e.prototype.applyTransform = function (t) {
        e.applyTransform(this, this, t)
      }),
      (e.prototype.calculateTransform = function (e) {
        var t = this,
          i = e.width / t.width,
          r = e.height / t.height,
          n = create$1()
        return (
          translate$1(n, n, [-t.x, -t.y]), scale$1(n, n, [i, r]), translate$1(n, n, [e.x, e.y]), n
        )
      }),
      (e.prototype.intersect = function (t, i) {
        if (!t) return !1
        t instanceof e || (t = e.create(t))
        var r = this,
          n = r.x,
          a = r.x + r.width,
          o = r.y,
          s = r.y + r.height,
          l = t.x,
          h = t.x + t.width,
          u = t.y,
          p = t.y + t.height,
          c = !(a < l || h < n || s < u || p < o)
        if (i) {
          var d = 1 / 0,
            f = 0,
            m = Math.abs(a - l),
            g = Math.abs(h - n),
            y = Math.abs(s - u),
            v = Math.abs(p - o),
            _ = Math.min(m, g),
            x = Math.min(y, v)
          a < l || h < n
            ? _ > f && ((f = _), m < g ? Point.set(maxTv$1, -m, 0) : Point.set(maxTv$1, g, 0))
            : _ < d && ((d = _), m < g ? Point.set(minTv$1, m, 0) : Point.set(minTv$1, -g, 0)),
            s < u || p < o
              ? x > f && ((f = x), y < v ? Point.set(maxTv$1, 0, -y) : Point.set(maxTv$1, 0, v))
              : _ < d && ((d = _), y < v ? Point.set(minTv$1, 0, y) : Point.set(minTv$1, 0, -v))
        }
        return i && Point.copy(i, c ? minTv$1 : maxTv$1), c
      }),
      (e.prototype.contain = function (e, t) {
        var i = this
        return e >= i.x && e <= i.x + i.width && t >= i.y && t <= i.y + i.height
      }),
      (e.prototype.clone = function () {
        return new e(this.x, this.y, this.width, this.height)
      }),
      (e.prototype.copy = function (t) {
        e.copy(this, t)
      }),
      (e.prototype.plain = function () {
        return { x: this.x, y: this.y, width: this.width, height: this.height }
      }),
      (e.prototype.isFinite = function () {
        return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height)
      }),
      (e.prototype.isZero = function () {
        return 0 === this.width || 0 === this.height
      }),
      (e.create = function (t) {
        return new e(t.x, t.y, t.width, t.height)
      }),
      (e.copy = function (e, t) {
        ;(e.x = t.x), (e.y = t.y), (e.width = t.width), (e.height = t.height)
      }),
      (e.applyTransform = function (t, i, r) {
        if (r) {
          if (r[1] < 1e-5 && r[1] > -1e-5 && r[2] < 1e-5 && r[2] > -1e-5) {
            var n = r[0],
              a = r[3],
              o = r[4],
              s = r[5]
            return (
              (t.x = i.x * n + o),
              (t.y = i.y * a + s),
              (t.width = i.width * n),
              (t.height = i.height * a),
              t.width < 0 && ((t.x += t.width), (t.width = -t.width)),
              void (t.height < 0 && ((t.y += t.height), (t.height = -t.height)))
            )
          }
          ;(lt.x = lb.x = i.x),
            (lt.y = rt.y = i.y),
            (rb.x = rt.x = i.x + i.width),
            (rb.y = lb.y = i.y + i.height),
            lt.transform(r),
            rt.transform(r),
            rb.transform(r),
            lb.transform(r),
            (t.x = mathMin$a(lt.x, rb.x, lb.x, rt.x)),
            (t.y = mathMin$a(lt.y, rb.y, lb.y, rt.y))
          var l = mathMax$a(lt.x, rb.x, lb.x, rt.x),
            h = mathMax$a(lt.y, rb.y, lb.y, rt.y)
          ;(t.width = l - t.x), (t.height = h - t.y)
        } else t !== i && e.copy(t, i)
      }),
      e
    )
  })(),
  textWidthCache = {},
  DEFAULT_FONT = '12px sans-serif',
  _ctx,
  _cachedFont
function defaultMeasureText(e, t) {
  return (
    _ctx || (_ctx = createCanvas().getContext('2d')),
    _cachedFont !== t && (_cachedFont = _ctx.font = t || DEFAULT_FONT),
    _ctx.measureText(e)
  )
}
var methods = { measureText: defaultMeasureText }
function getWidth(e, t) {
  var i = textWidthCache[(t = t || DEFAULT_FONT)]
  i || (i = textWidthCache[t] = new LRU(500))
  var r = i.get(e)
  return null == r && ((r = methods.measureText(e, t).width), i.put(e, r)), r
}
function innerGetBoundingRect(e, t, i, r) {
  var n = getWidth(e, t),
    a = getLineHeight(t),
    o = adjustTextX(0, n, i),
    s = adjustTextY$1(0, a, r)
  return new BoundingRect(o, s, n, a)
}
function getBoundingRect(e, t, i, r) {
  var n = ((e || '') + '').split('\n')
  if (1 === n.length) return innerGetBoundingRect(n[0], t, i, r)
  for (var a = new BoundingRect(0, 0, 0, 0), o = 0; o < n.length; o++) {
    var s = innerGetBoundingRect(n[o], t, i, r)
    0 === o ? a.copy(s) : a.union(s)
  }
  return a
}
function adjustTextX(e, t, i) {
  return 'right' === i ? (e -= t) : 'center' === i && (e -= t / 2), e
}
function adjustTextY$1(e, t, i) {
  return 'middle' === i ? (e -= t / 2) : 'bottom' === i && (e -= t), e
}
function getLineHeight(e) {
  return getWidth('', e)
}
function parsePercent$2(e, t) {
  return 'string' == typeof e
    ? e.lastIndexOf('%') >= 0
      ? (parseFloat(e) / 100) * t
      : parseFloat(e)
    : e
}
function calculateTextPosition(e, t, i) {
  var r = t.position || 'inside',
    n = null != t.distance ? t.distance : 5,
    a = i.height,
    o = i.width,
    s = a / 2,
    l = i.x,
    h = i.y,
    u = 'left',
    p = 'top'
  if (r instanceof Array)
    (l += parsePercent$2(r[0], i.width)),
      (h += parsePercent$2(r[1], i.height)),
      (u = null),
      (p = null)
  else
    switch (r) {
      case 'left':
        ;(l -= n), (h += s), (u = 'right'), (p = 'middle')
        break
      case 'right':
        ;(l += n + o), (h += s), (p = 'middle')
        break
      case 'top':
        ;(l += o / 2), (h -= n), (u = 'center'), (p = 'bottom')
        break
      case 'bottom':
        ;(l += o / 2), (h += a + n), (u = 'center')
        break
      case 'inside':
        ;(l += o / 2), (h += s), (u = 'center'), (p = 'middle')
        break
      case 'insideLeft':
        ;(l += n), (h += s), (p = 'middle')
        break
      case 'insideRight':
        ;(l += o - n), (h += s), (u = 'right'), (p = 'middle')
        break
      case 'insideTop':
        ;(l += o / 2), (h += n), (u = 'center')
        break
      case 'insideBottom':
        ;(l += o / 2), (h += a - n), (u = 'center'), (p = 'bottom')
        break
      case 'insideTopLeft':
        ;(l += n), (h += n)
        break
      case 'insideTopRight':
        ;(l += o - n), (h += n), (u = 'right')
        break
      case 'insideBottomLeft':
        ;(l += n), (h += a - n), (p = 'bottom')
        break
      case 'insideBottomRight':
        ;(l += o - n), (h += a - n), (u = 'right'), (p = 'bottom')
    }
  return ((e = e || {}).x = l), (e.y = h), (e.align = u), (e.verticalAlign = p), e
}
var PRESERVED_NORMAL_STATE = '__zr_normal__',
  PRIMARY_STATES_KEYS$1 = [
    'x',
    'y',
    'scaleX',
    'scaleY',
    'originX',
    'originY',
    'rotation',
    'ignore'
  ],
  DEFAULT_ANIMATABLE_MAP = {
    x: !0,
    y: !0,
    scaleX: !0,
    scaleY: !0,
    originX: !0,
    originY: !0,
    rotation: !0,
    ignore: !1
  },
  tmpTextPosCalcRes = {},
  tmpBoundingRect = new BoundingRect(0, 0, 0, 0),
  Element = (function () {
    function e(e) {
      ;(this.id = guid()),
        (this.animators = []),
        (this.currentStates = []),
        (this.states = {}),
        this._init(e)
    }
    return (
      (e.prototype._init = function (e) {
        this.attr(e)
      }),
      (e.prototype.drift = function (e, t, i) {
        switch (this.draggable) {
          case 'horizontal':
            t = 0
            break
          case 'vertical':
            e = 0
        }
        var r = this.transform
        r || (r = this.transform = [1, 0, 0, 1, 0, 0]),
          (r[4] += e),
          (r[5] += t),
          this.decomposeTransform(),
          this.markRedraw()
      }),
      (e.prototype.beforeUpdate = function () {}),
      (e.prototype.afterUpdate = function () {}),
      (e.prototype.update = function () {
        this.updateTransform(), this.__dirty && this.updateInnerText()
      }),
      (e.prototype.updateInnerText = function (e) {
        var t = this._textContent
        if (t && (!t.ignore || e)) {
          this.textConfig || (this.textConfig = {})
          var i = this.textConfig,
            r = i.local,
            n = t.attachedTransform,
            a = void 0,
            o = void 0,
            s = !1
          n.parent = r ? this : null
          var l = !1
          if (
            ((n.x = t.x),
            (n.y = t.y),
            (n.originX = t.originX),
            (n.originY = t.originY),
            (n.rotation = t.rotation),
            (n.scaleX = t.scaleX),
            (n.scaleY = t.scaleY),
            null != i.position)
          ) {
            var h = tmpBoundingRect
            i.layoutRect ? h.copy(i.layoutRect) : h.copy(this.getBoundingRect()),
              r || h.applyTransform(this.transform),
              this.calculateTextPosition
                ? this.calculateTextPosition(tmpTextPosCalcRes, i, h)
                : calculateTextPosition(tmpTextPosCalcRes, i, h),
              (n.x = tmpTextPosCalcRes.x),
              (n.y = tmpTextPosCalcRes.y),
              (a = tmpTextPosCalcRes.align),
              (o = tmpTextPosCalcRes.verticalAlign)
            var u = i.origin
            if (u && null != i.rotation) {
              var p = void 0,
                c = void 0
              'center' === u
                ? ((p = 0.5 * h.width), (c = 0.5 * h.height))
                : ((p = parsePercent$2(u[0], h.width)), (c = parsePercent$2(u[1], h.height))),
                (l = !0),
                (n.originX = -n.x + p + (r ? 0 : h.x)),
                (n.originY = -n.y + c + (r ? 0 : h.y))
            }
          }
          null != i.rotation && (n.rotation = i.rotation)
          var d = i.offset
          d && ((n.x += d[0]), (n.y += d[1]), l || ((n.originX = -d[0]), (n.originY = -d[1])))
          var f =
              null == i.inside
                ? 'string' == typeof i.position && i.position.indexOf('inside') >= 0
                : i.inside,
            m = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}),
            g = void 0,
            y = void 0,
            v = void 0
          f && this.canBeInsideText()
            ? ((g = i.insideFill),
              (y = i.insideStroke),
              (null != g && 'auto' !== g) || (g = this.getInsideTextFill()),
              (null != y && 'auto' !== y) || ((y = this.getInsideTextStroke(g)), (v = !0)))
            : ((g = i.outsideFill),
              (y = i.outsideStroke),
              (null != g && 'auto' !== g) || (g = this.getOutsideFill()),
              (null != y && 'auto' !== y) || ((y = this.getOutsideStroke(g)), (v = !0))),
            ((g = g || '#000') === m.fill &&
              y === m.stroke &&
              v === m.autoStroke &&
              a === m.align &&
              o === m.verticalAlign) ||
              ((s = !0),
              (m.fill = g),
              (m.stroke = y),
              (m.autoStroke = v),
              (m.align = a),
              (m.verticalAlign = o),
              t.setDefaultTextStyle(m)),
            (t.__dirty |= REDARAW_BIT),
            s && t.dirtyStyle(!0)
        }
      }),
      (e.prototype.canBeInsideText = function () {
        return !0
      }),
      (e.prototype.getInsideTextFill = function () {
        return '#fff'
      }),
      (e.prototype.getInsideTextStroke = function (e) {
        return '#000'
      }),
      (e.prototype.getOutsideFill = function () {
        return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR
      }),
      (e.prototype.getOutsideStroke = function (e) {
        var t = this.__zr && this.__zr.getBackgroundColor(),
          i = 'string' == typeof t && parse(t)
        i || (i = [255, 255, 255, 1])
        for (var r = i[3], n = this.__zr.isDarkMode(), a = 0; a < 3; a++)
          i[a] = i[a] * r + (n ? 0 : 255) * (1 - r)
        return (i[3] = 1), stringify(i, 'rgba')
      }),
      (e.prototype.traverse = function (e, t) {}),
      (e.prototype.attrKV = function (e, t) {
        'textConfig' === e
          ? this.setTextConfig(t)
          : 'textContent' === e
          ? this.setTextContent(t)
          : 'clipPath' === e
          ? this.setClipPath(t)
          : 'extra' === e
          ? ((this.extra = this.extra || {}), extend$3(this.extra, t))
          : (this[e] = t)
      }),
      (e.prototype.hide = function () {
        ;(this.ignore = !0), this.markRedraw()
      }),
      (e.prototype.show = function () {
        ;(this.ignore = !1), this.markRedraw()
      }),
      (e.prototype.attr = function (e, t) {
        if ('string' == typeof e) this.attrKV(e, t)
        else if (isObject$7(e))
          for (var i = keys(e), r = 0; r < i.length; r++) {
            var n = i[r]
            this.attrKV(n, e[n])
          }
        return this.markRedraw(), this
      }),
      (e.prototype.saveCurrentToNormalState = function (e) {
        this._innerSaveToNormal(e)
        for (var t = this._normalState, i = 0; i < this.animators.length; i++) {
          var r = this.animators[i],
            n = r.__fromStateTransition
          if (!n || n === PRESERVED_NORMAL_STATE) {
            var a = r.targetName,
              o = a ? t[a] : t
            r.saveFinalToTarget(o)
          }
        }
      }),
      (e.prototype._innerSaveToNormal = function (e) {
        var t = this._normalState
        t || (t = this._normalState = {}),
          e.textConfig && !t.textConfig && (t.textConfig = this.textConfig),
          this._savePrimaryToNormal(e, t, PRIMARY_STATES_KEYS$1)
      }),
      (e.prototype._savePrimaryToNormal = function (e, t, i) {
        for (var r = 0; r < i.length; r++) {
          var n = i[r]
          null == e[n] || n in t || (t[n] = this[n])
        }
      }),
      (e.prototype.hasState = function () {
        return this.currentStates.length > 0
      }),
      (e.prototype.getState = function (e) {
        return this.states[e]
      }),
      (e.prototype.ensureState = function (e) {
        var t = this.states
        return t[e] || (t[e] = {}), t[e]
      }),
      (e.prototype.clearStates = function (e) {
        this.useState(PRESERVED_NORMAL_STATE, !1, e)
      }),
      (e.prototype.useState = function (e, t, i, r) {
        var n = e === PRESERVED_NORMAL_STATE
        if (this.hasState() || !n) {
          var a = this.currentStates,
            o = this.stateTransition
          if (!(indexOf$1(a, e) >= 0) || (!t && 1 !== a.length)) {
            var s
            if (
              (this.stateProxy && !n && (s = this.stateProxy(e)),
              s || (s = this.states && this.states[e]),
              s || n)
            ) {
              n || this.saveCurrentToNormalState(s)
              var l = !!((s && s.hoverLayer) || r)
              l && this._toggleHoverLayerFlag(!0),
                this._applyStateObj(
                  e,
                  s,
                  this._normalState,
                  t,
                  !i && !this.__inHover && o && o.duration > 0,
                  o
                )
              var h = this._textContent,
                u = this._textGuide
              return (
                h && h.useState(e, t, i, l),
                u && u.useState(e, t, i, l),
                n
                  ? ((this.currentStates = []), (this._normalState = {}))
                  : t
                  ? this.currentStates.push(e)
                  : (this.currentStates = [e]),
                this._updateAnimationTargets(),
                this.markRedraw(),
                !l &&
                  this.__inHover &&
                  (this._toggleHoverLayerFlag(!1), (this.__dirty &= ~REDARAW_BIT)),
                s
              )
            }
            logError('State ' + e + ' not exists.')
          }
        }
      }),
      (e.prototype.useStates = function (e, t, i) {
        if (e.length) {
          var r = [],
            n = this.currentStates,
            a = e.length,
            o = a === n.length
          if (o)
            for (var s = 0; s < a; s++)
              if (e[s] !== n[s]) {
                o = !1
                break
              }
          if (o) return
          for (s = 0; s < a; s++) {
            var l = e[s],
              h = void 0
            this.stateProxy && (h = this.stateProxy(l, e)),
              h || (h = this.states[l]),
              h && r.push(h)
          }
          var u = r[a - 1],
            p = !!((u && u.hoverLayer) || i)
          p && this._toggleHoverLayerFlag(!0)
          var c = this._mergeStates(r),
            d = this.stateTransition
          this.saveCurrentToNormalState(c),
            this._applyStateObj(
              e.join(','),
              c,
              this._normalState,
              !1,
              !t && !this.__inHover && d && d.duration > 0,
              d
            )
          var f = this._textContent,
            m = this._textGuide
          f && f.useStates(e, t, p),
            m && m.useStates(e, t, p),
            this._updateAnimationTargets(),
            (this.currentStates = e.slice()),
            this.markRedraw(),
            !p && this.__inHover && (this._toggleHoverLayerFlag(!1), (this.__dirty &= ~REDARAW_BIT))
        } else this.clearStates()
      }),
      (e.prototype._updateAnimationTargets = function () {
        for (var e = 0; e < this.animators.length; e++) {
          var t = this.animators[e]
          t.targetName && t.changeTarget(this[t.targetName])
        }
      }),
      (e.prototype.removeState = function (e) {
        var t = indexOf$1(this.currentStates, e)
        if (t >= 0) {
          var i = this.currentStates.slice()
          i.splice(t, 1), this.useStates(i)
        }
      }),
      (e.prototype.replaceState = function (e, t, i) {
        var r = this.currentStates.slice(),
          n = indexOf$1(r, e),
          a = indexOf$1(r, t) >= 0
        n >= 0 ? (a ? r.splice(n, 1) : (r[n] = t)) : i && !a && r.push(t), this.useStates(r)
      }),
      (e.prototype.toggleState = function (e, t) {
        t ? this.useState(e, !0) : this.removeState(e)
      }),
      (e.prototype._mergeStates = function (e) {
        for (var t, i = {}, r = 0; r < e.length; r++) {
          var n = e[r]
          extend$3(i, n), n.textConfig && extend$3((t = t || {}), n.textConfig)
        }
        return t && (i.textConfig = t), i
      }),
      (e.prototype._applyStateObj = function (e, t, i, r, n, a) {
        var o = !(t && r)
        t && t.textConfig
          ? ((this.textConfig = extend$3({}, r ? this.textConfig : i.textConfig)),
            extend$3(this.textConfig, t.textConfig))
          : o && i.textConfig && (this.textConfig = i.textConfig)
        for (var s = {}, l = !1, h = 0; h < PRIMARY_STATES_KEYS$1.length; h++) {
          var u = PRIMARY_STATES_KEYS$1[h],
            p = n && DEFAULT_ANIMATABLE_MAP[u]
          t && null != t[u]
            ? p
              ? ((l = !0), (s[u] = t[u]))
              : (this[u] = t[u])
            : o && null != i[u] && (p ? ((l = !0), (s[u] = i[u])) : (this[u] = i[u]))
        }
        if (!n)
          for (h = 0; h < this.animators.length; h++) {
            var c = this.animators[h],
              d = c.targetName
            c.__changeFinalValue(d ? (t || i)[d] : t || i)
          }
        l && this._transitionState(e, s, a)
      }),
      (e.prototype._attachComponent = function (e) {
        if (e.__zr && !e.__hostTarget) throw new Error('Text element has been added to zrender.')
        if (e === this) throw new Error('Recursive component attachment.')
        var t = this.__zr
        t && e.addSelfToZr(t), (e.__zr = t), (e.__hostTarget = this)
      }),
      (e.prototype._detachComponent = function (e) {
        e.__zr && e.removeSelfFromZr(e.__zr), (e.__zr = null), (e.__hostTarget = null)
      }),
      (e.prototype.getClipPath = function () {
        return this._clipPath
      }),
      (e.prototype.setClipPath = function (e) {
        this._clipPath && this._clipPath !== e && this.removeClipPath(),
          this._attachComponent(e),
          (this._clipPath = e),
          this.markRedraw()
      }),
      (e.prototype.removeClipPath = function () {
        var e = this._clipPath
        e && (this._detachComponent(e), (this._clipPath = null), this.markRedraw())
      }),
      (e.prototype.getTextContent = function () {
        return this._textContent
      }),
      (e.prototype.setTextContent = function (e) {
        var t = this._textContent
        if (t !== e) {
          if ((t && t !== e && this.removeTextContent(), e.__zr && !e.__hostTarget))
            throw new Error('Text element has been added to zrender.')
          ;(e.attachedTransform = new Transformable()),
            this._attachComponent(e),
            (this._textContent = e),
            this.markRedraw()
        }
      }),
      (e.prototype.setTextConfig = function (e) {
        this.textConfig || (this.textConfig = {}), extend$3(this.textConfig, e), this.markRedraw()
      }),
      (e.prototype.removeTextConfig = function () {
        ;(this.textConfig = null), this.markRedraw()
      }),
      (e.prototype.removeTextContent = function () {
        var e = this._textContent
        e &&
          ((e.attachedTransform = null),
          this._detachComponent(e),
          (this._textContent = null),
          (this._innerTextDefaultStyle = null),
          this.markRedraw())
      }),
      (e.prototype.getTextGuideLine = function () {
        return this._textGuide
      }),
      (e.prototype.setTextGuideLine = function (e) {
        this._textGuide && this._textGuide !== e && this.removeTextGuideLine(),
          this._attachComponent(e),
          (this._textGuide = e),
          this.markRedraw()
      }),
      (e.prototype.removeTextGuideLine = function () {
        var e = this._textGuide
        e && (this._detachComponent(e), (this._textGuide = null), this.markRedraw())
      }),
      (e.prototype.markRedraw = function () {
        this.__dirty |= REDARAW_BIT
        var e = this.__zr
        e && (this.__inHover ? e.refreshHover() : e.refresh()),
          this.__hostTarget && this.__hostTarget.markRedraw()
      }),
      (e.prototype.dirty = function () {
        this.markRedraw()
      }),
      (e.prototype._toggleHoverLayerFlag = function (e) {
        this.__inHover = e
        var t = this._textContent,
          i = this._textGuide
        t && (t.__inHover = e), i && (i.__inHover = e)
      }),
      (e.prototype.addSelfToZr = function (e) {
        this.__zr = e
        var t = this.animators
        if (t) for (var i = 0; i < t.length; i++) e.animation.addAnimator(t[i])
        this._clipPath && this._clipPath.addSelfToZr(e),
          this._textContent && this._textContent.addSelfToZr(e),
          this._textGuide && this._textGuide.addSelfToZr(e)
      }),
      (e.prototype.removeSelfFromZr = function (e) {
        this.__zr = null
        var t = this.animators
        if (t) for (var i = 0; i < t.length; i++) e.animation.removeAnimator(t[i])
        this._clipPath && this._clipPath.removeSelfFromZr(e),
          this._textContent && this._textContent.removeSelfFromZr(e),
          this._textGuide && this._textGuide.removeSelfFromZr(e)
      }),
      (e.prototype.animate = function (e, t) {
        var i = e ? this[e] : this
        if (i) {
          var r = new Animator(i, t)
          return this.addAnimator(r, e), r
        }
        logError('Property "' + e + '" is not existed in element ' + this.id)
      }),
      (e.prototype.addAnimator = function (e, t) {
        var i = this.__zr,
          r = this
        e
          .during(function () {
            r.updateDuringAnimation(t)
          })
          .done(function () {
            var t = r.animators,
              i = indexOf$1(t, e)
            i >= 0 && t.splice(i, 1)
          }),
          this.animators.push(e),
          i && i.animation.addAnimator(e),
          i && i.wakeUp()
      }),
      (e.prototype.updateDuringAnimation = function (e) {
        this.markRedraw()
      }),
      (e.prototype.stopAnimation = function (e, t) {
        for (var i = this.animators, r = i.length, n = [], a = 0; a < r; a++) {
          var o = i[a]
          e && e !== o.scope ? n.push(o) : o.stop(t)
        }
        return (this.animators = n), this
      }),
      (e.prototype.animateTo = function (e, t, i) {
        animateTo(this, e, t, i)
      }),
      (e.prototype.animateFrom = function (e, t, i) {
        animateTo(this, e, t, i, !0)
      }),
      (e.prototype._transitionState = function (e, t, i, r) {
        for (var n = animateTo(this, t, i, r), a = 0; a < n.length; a++)
          n[a].__fromStateTransition = e
      }),
      (e.prototype.getBoundingRect = function () {
        return null
      }),
      (e.prototype.getPaintRect = function () {
        return null
      }),
      (e.initDefaultProps = (function () {
        var t = e.prototype
        ;(t.type = 'element'),
          (t.name = ''),
          (t.ignore = !1),
          (t.silent = !1),
          (t.isGroup = !1),
          (t.draggable = !1),
          (t.dragging = !1),
          (t.ignoreClip = !1),
          (t.__inHover = !1),
          (t.__dirty = REDARAW_BIT)
        var i = {}
        function r(e, t, r) {
          i[e + t + r] ||
            (console.warn(
              "DEPRECATED: '" + e + "' has been deprecated. use '" + t + "', '" + r + "' instead"
            ),
            (i[e + t + r] = !0))
        }
        function n(e, i, n, a) {
          function o(e, t) {
            Object.defineProperty(t, 0, {
              get: function () {
                return e[n]
              },
              set: function (t) {
                e[n] = t
              }
            }),
              Object.defineProperty(t, 1, {
                get: function () {
                  return e[a]
                },
                set: function (t) {
                  e[a] = t
                }
              })
          }
          Object.defineProperty(t, e, {
            get: function () {
              ;(r(e, n, a), this[i]) || o(this, (this[i] = []))
              return this[i]
            },
            set: function (t) {
              r(e, n, a), (this[n] = t[0]), (this[a] = t[1]), (this[i] = t), o(this, t)
            }
          })
        }
        Object.defineProperty &&
          (!env.browser.ie || env.browser.version > 8) &&
          (n('position', '_legacyPos', 'x', 'y'),
          n('scale', '_legacyScale', 'scaleX', 'scaleY'),
          n('origin', '_legacyOrigin', 'originX', 'originY'))
      })()),
      e
    )
  })()
function animateTo(e, t, i, r, n) {
  var a = []
  animateToShallow(e, '', e, t, (i = i || {}), r, a, n)
  var o = a.length,
    s = !1,
    l = i.done,
    h = i.aborted,
    u = function () {
      ;(s = !0), --o <= 0 && (s ? l && l() : h && h())
    },
    p = function () {
      --o <= 0 && (s ? l && l() : h && h())
    }
  o || (l && l()),
    a.length > 0 &&
      i.during &&
      a[0].during(function (e, t) {
        i.during(t)
      })
  for (var c = 0; c < a.length; c++) {
    var d = a[c]
    u && d.done(u), p && d.aborted(p), d.start(i.easing, i.force)
  }
  return a
}
function copyArrShallow(e, t, i) {
  for (var r = 0; r < i; r++) e[r] = t[r]
}
function is2DArray(e) {
  return isArrayLike(e[0])
}
function copyValue(e, t, i) {
  if (isArrayLike(t[i]))
    if ((isArrayLike(e[i]) || (e[i] = []), isTypedArray(t[i]))) {
      var r = t[i].length
      e[i].length !== r && ((e[i] = new t[i].constructor(r)), copyArrShallow(e[i], t[i], r))
    } else {
      var n = t[i],
        a = e[i],
        o = n.length
      if (is2DArray(n))
        for (var s = n[0].length, l = 0; l < o; l++)
          a[l] ? copyArrShallow(a[l], n[l], s) : (a[l] = Array.prototype.slice.call(n[l]))
      else copyArrShallow(a, n, o)
      a.length = n.length
    }
  else e[i] = t[i]
}
function animateToShallow(e, t, i, r, n, a, o, s) {
  for (
    var l = [],
      h = [],
      u = keys(r),
      p = n.duration,
      c = n.delay,
      d = n.additive,
      f = n.setToFinal,
      m = !isObject$7(a),
      g = 0;
    g < u.length;
    g++
  ) {
    if (null != i[(w = u[g])] && null != r[w] && (m || a[w]))
      if (isObject$7(r[w]) && !isArrayLike(r[w])) {
        if (t) {
          s || ((i[w] = r[w]), e.updateDuringAnimation(t))
          continue
        }
        animateToShallow(e, w, i[w], r[w], n, a && a[w], o, s)
      } else l.push(w), h.push(w)
    else s || ((i[w] = r[w]), e.updateDuringAnimation(t), h.push(w))
  }
  var y = l.length
  if (y > 0 || (n.force && !o.length)) {
    for (var v = e.animators, _ = [], x = 0; x < v.length; x++)
      v[x].targetName === t && _.push(v[x])
    if (!d && _.length)
      for (x = 0; x < _.length; x++) {
        if (_[x].stopTracks(h)) {
          var S = indexOf$1(v, _[x])
          v.splice(S, 1)
        }
      }
    var b = void 0,
      T = void 0,
      A = void 0
    if (s) {
      ;(T = {}), f && (b = {})
      for (x = 0; x < y; x++) {
        ;(T[(w = l[x])] = i[w]), f ? (b[w] = r[w]) : (i[w] = r[w])
      }
    } else if (f) {
      A = {}
      for (x = 0; x < y; x++) {
        var w
        ;(A[(w = l[x])] = cloneValue(i[w])), copyValue(i, r, w)
      }
    }
    var M = new Animator(i, !1, d ? _ : null)
    ;(M.targetName = t),
      n.scope && (M.scope = n.scope),
      f && b && M.whenWithKeys(0, b, l),
      A && M.whenWithKeys(0, A, l),
      M.whenWithKeys(null == p ? 500 : p, s ? T : r, l).delay(c || 0),
      e.addAnimator(M, t),
      o.push(M)
  }
}
mixin(Element, Eventful), mixin(Element, Transformable)
var Group$3 = (function (e) {
  function t(t) {
    var i = e.call(this) || this
    return (i.isGroup = !0), (i._children = []), i.attr(t), i
  }
  return (
    __extends(t, e),
    (t.prototype.childrenRef = function () {
      return this._children
    }),
    (t.prototype.children = function () {
      return this._children.slice()
    }),
    (t.prototype.childAt = function (e) {
      return this._children[e]
    }),
    (t.prototype.childOfName = function (e) {
      for (var t = this._children, i = 0; i < t.length; i++) if (t[i].name === e) return t[i]
    }),
    (t.prototype.childCount = function () {
      return this._children.length
    }),
    (t.prototype.add = function (e) {
      if (
        e &&
        (e !== this && e.parent !== this && (this._children.push(e), this._doAdd(e)),
        e.__hostTarget)
      )
        throw 'This elemenet has been used as an attachment'
      return this
    }),
    (t.prototype.addBefore = function (e, t) {
      if (e && e !== this && e.parent !== this && t && t.parent === this) {
        var i = this._children,
          r = i.indexOf(t)
        r >= 0 && (i.splice(r, 0, e), this._doAdd(e))
      }
      return this
    }),
    (t.prototype.replaceAt = function (e, t) {
      var i = this._children,
        r = i[t]
      if (e && e !== this && e.parent !== this && e !== r) {
        ;(i[t] = e), (r.parent = null)
        var n = this.__zr
        n && r.removeSelfFromZr(n), this._doAdd(e)
      }
      return this
    }),
    (t.prototype._doAdd = function (e) {
      e.parent && e.parent.remove(e), (e.parent = this)
      var t = this.__zr
      t && t !== e.__zr && e.addSelfToZr(t), t && t.refresh()
    }),
    (t.prototype.remove = function (e) {
      var t = this.__zr,
        i = this._children,
        r = indexOf$1(i, e)
      return (
        r < 0 || (i.splice(r, 1), (e.parent = null), t && e.removeSelfFromZr(t), t && t.refresh()),
        this
      )
    }),
    (t.prototype.removeAll = function () {
      for (var e = this._children, t = this.__zr, i = 0; i < e.length; i++) {
        var r = e[i]
        t && r.removeSelfFromZr(t), (r.parent = null)
      }
      return (e.length = 0), this
    }),
    (t.prototype.eachChild = function (e, t) {
      for (var i = this._children, r = 0; r < i.length; r++) {
        var n = i[r]
        e.call(t, n, r)
      }
      return this
    }),
    (t.prototype.traverse = function (e, t) {
      for (var i = 0; i < this._children.length; i++) {
        var r = this._children[i],
          n = e.call(t, r)
        r.isGroup && !n && r.traverse(e, t)
      }
      return this
    }),
    (t.prototype.addSelfToZr = function (t) {
      e.prototype.addSelfToZr.call(this, t)
      for (var i = 0; i < this._children.length; i++) {
        this._children[i].addSelfToZr(t)
      }
    }),
    (t.prototype.removeSelfFromZr = function (t) {
      e.prototype.removeSelfFromZr.call(this, t)
      for (var i = 0; i < this._children.length; i++) {
        this._children[i].removeSelfFromZr(t)
      }
    }),
    (t.prototype.getBoundingRect = function (e) {
      for (
        var t = new BoundingRect(0, 0, 0, 0), i = e || this._children, r = [], n = null, a = 0;
        a < i.length;
        a++
      ) {
        var o = i[a]
        if (!o.ignore && !o.invisible) {
          var s = o.getBoundingRect(),
            l = o.getLocalTransform(r)
          l
            ? (BoundingRect.applyTransform(t, s, l), (n = n || t.clone()).union(t))
            : (n = n || s.clone()).union(s)
        }
      }
      return n || t
    }),
    t
  )
})(Element)
Group$3.prototype.type = 'group'
/*!
 * ZRender, a high performance 2d drawing library.
 *
 * Copyright (c) 2013, Baidu Inc.
 * All rights reserved.
 *
 * LICENSE
 * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
 */
var useVML = !env.canvasSupported,
  painterCtors = {}
function delInstance(e) {}
function isDarkMode(e) {
  if (!e) return !1
  if ('string' == typeof e) return lum(e, 1) < DARK_MODE_THRESHOLD
  if (e.colorStops) {
    for (var t = e.colorStops, i = 0, r = t.length, n = 0; n < r; n++) i += lum(t[n].color, 1)
    return (i /= r) < DARK_MODE_THRESHOLD
  }
  return !1
}
var ZRender = (function () {
  function e(e, t, i) {
    var r = this
    ;(this._sleepAfterStill = 10),
      (this._stillFrameAccum = 0),
      (this._needsRefresh = !0),
      (this._needsRefreshHover = !0),
      (this._darkMode = !1),
      (i = i || {}),
      (this.dom = t),
      (this.id = e)
    var n = new Storage(),
      a = i.renderer || 'canvas'
    if (useVML) throw new Error('IE8 support has been dropped since 5.0')
    if ((painterCtors[a] || (a = keys(painterCtors)[0]), !painterCtors[a]))
      throw new Error("Renderer '" + a + "' is not imported. Please import it first.")
    i.useDirtyRect = null != i.useDirtyRect && i.useDirtyRect
    var o = new painterCtors[a](t, n, i, e)
    ;(this.storage = n), (this.painter = o)
    var s = env.node || env.worker ? null : new HandlerDomProxy(o.getViewportRoot(), o.root)
    ;(this.handler = new Handler(n, o, s, o.root)),
      (this.animation = new Animation({
        stage: {
          update: function () {
            return r._flush(!0)
          }
        }
      })),
      this.animation.start()
  }
  return (
    (e.prototype.add = function (e) {
      e && (this.storage.addRoot(e), e.addSelfToZr(this), this.refresh())
    }),
    (e.prototype.remove = function (e) {
      e && (this.storage.delRoot(e), e.removeSelfFromZr(this), this.refresh())
    }),
    (e.prototype.configLayer = function (e, t) {
      this.painter.configLayer && this.painter.configLayer(e, t), this.refresh()
    }),
    (e.prototype.setBackgroundColor = function (e) {
      this.painter.setBackgroundColor && this.painter.setBackgroundColor(e),
        this.refresh(),
        (this._backgroundColor = e),
        (this._darkMode = isDarkMode(e))
    }),
    (e.prototype.getBackgroundColor = function () {
      return this._backgroundColor
    }),
    (e.prototype.setDarkMode = function (e) {
      this._darkMode = e
    }),
    (e.prototype.isDarkMode = function () {
      return this._darkMode
    }),
    (e.prototype.refreshImmediately = function (e) {
      e || this.animation.update(!0),
        (this._needsRefresh = !1),
        this.painter.refresh(),
        (this._needsRefresh = !1)
    }),
    (e.prototype.refresh = function () {
      ;(this._needsRefresh = !0), this.animation.start()
    }),
    (e.prototype.flush = function () {
      this._flush(!1)
    }),
    (e.prototype._flush = function (e) {
      var t,
        i = new Date().getTime()
      this._needsRefresh && ((t = !0), this.refreshImmediately(e)),
        this._needsRefreshHover && ((t = !0), this.refreshHoverImmediately())
      var r = new Date().getTime()
      t
        ? ((this._stillFrameAccum = 0), this.trigger('rendered', { elapsedTime: r - i }))
        : this._sleepAfterStill > 0 &&
          (this._stillFrameAccum++,
          this._stillFrameAccum > this._sleepAfterStill && this.animation.stop())
    }),
    (e.prototype.setSleepAfterStill = function (e) {
      this._sleepAfterStill = e
    }),
    (e.prototype.wakeUp = function () {
      this.animation.start(), (this._stillFrameAccum = 0)
    }),
    (e.prototype.addHover = function (e) {}),
    (e.prototype.removeHover = function (e) {}),
    (e.prototype.clearHover = function () {}),
    (e.prototype.refreshHover = function () {
      this._needsRefreshHover = !0
    }),
    (e.prototype.refreshHoverImmediately = function () {
      ;(this._needsRefreshHover = !1),
        this.painter.refreshHover &&
          'canvas' === this.painter.getType() &&
          this.painter.refreshHover()
    }),
    (e.prototype.resize = function (e) {
      ;(e = e || {}), this.painter.resize(e.width, e.height), this.handler.resize()
    }),
    (e.prototype.clearAnimation = function () {
      this.animation.clear()
    }),
    (e.prototype.getWidth = function () {
      return this.painter.getWidth()
    }),
    (e.prototype.getHeight = function () {
      return this.painter.getHeight()
    }),
    (e.prototype.pathToImage = function (e, t) {
      if (this.painter.pathToImage) return this.painter.pathToImage(e, t)
    }),
    (e.prototype.setCursorStyle = function (e) {
      this.handler.setCursorStyle(e)
    }),
    (e.prototype.findHover = function (e, t) {
      return this.handler.findHover(e, t)
    }),
    (e.prototype.on = function (e, t, i) {
      return this.handler.on(e, t, i), this
    }),
    (e.prototype.off = function (e, t) {
      this.handler.off(e, t)
    }),
    (e.prototype.trigger = function (e, t) {
      this.handler.trigger(e, t)
    }),
    (e.prototype.clear = function () {
      for (var e = this.storage.getRoots(), t = 0; t < e.length; t++)
        e[t] instanceof Group$3 && e[t].removeSelfFromZr(this)
      this.storage.delAllRoots(), this.painter.clear()
    }),
    (e.prototype.dispose = function () {
      this.animation.stop(),
        this.clear(),
        this.storage.dispose(),
        this.painter.dispose(),
        this.handler.dispose(),
        (this.animation = this.storage = this.painter = this.handler = null),
        delInstance(this.id)
    }),
    e
  )
})()
function init$2(e, t) {
  return new ZRender(guid(), e, t)
}
function registerPainter(e, t) {
  painterCtors[e] = t
}
var RADIAN_EPSILON = 1e-4,
  ROUND_SUPPORTED_PRECISION_MAX = 20
function _trim(e) {
  return e.replace(/^\s+|\s+$/g, '')
}
function linearMap$2(e, t, i, r) {
  var n = t[0],
    a = t[1],
    o = i[0],
    s = i[1],
    l = a - n,
    h = s - o
  if (0 === l) return 0 === h ? o : (o + s) / 2
  if (r)
    if (l > 0) {
      if (e <= n) return o
      if (e >= a) return s
    } else {
      if (e >= n) return o
      if (e <= a) return s
    }
  else {
    if (e === n) return o
    if (e === a) return s
  }
  return ((e - n) / l) * h + o
}
function parsePercent$1(e, t) {
  switch (e) {
    case 'center':
    case 'middle':
      e = '50%'
      break
    case 'left':
    case 'top':
      e = '0%'
      break
    case 'right':
    case 'bottom':
      e = '100%'
  }
  return 'string' == typeof e
    ? _trim(e).match(/%$/)
      ? (parseFloat(e) / 100) * t
      : parseFloat(e)
    : null == e
    ? NaN
    : +e
}
function round$2(e, t, i) {
  return (
    null == t && (t = 10),
    (t = Math.min(Math.max(0, t), ROUND_SUPPORTED_PRECISION_MAX)),
    (e = (+e).toFixed(t)),
    i ? e : +e
  )
}
function asc$2(e) {
  return (
    e.sort(function (e, t) {
      return e - t
    }),
    e
  )
}
function getPrecision(e) {
  if (((e = +e), isNaN(e))) return 0
  if (e > 1e-14)
    for (var t = 1, i = 0; i < 15; i++, t *= 10) if (Math.round(e * t) / t === e) return i
  return getPrecisionSafe(e)
}
function getPrecisionSafe(e) {
  var t = e.toString().toLowerCase(),
    i = t.indexOf('e'),
    r = i > 0 ? +t.slice(i + 1) : 0,
    n = i > 0 ? i : t.length,
    a = t.indexOf('.'),
    o = a < 0 ? 0 : n - 1 - a
  return Math.max(0, o - r)
}
function getPixelPrecision(e, t) {
  var i = Math.log,
    r = Math.LN10,
    n = Math.floor(i(e[1] - e[0]) / r),
    a = Math.round(i(Math.abs(t[1] - t[0])) / r),
    o = Math.min(Math.max(-n + a, 0), 20)
  return isFinite(o) ? o : 20
}
function getPercentWithPrecision(e, t, i) {
  if (!e[t]) return 0
  var r = reduce(
    e,
    function (e, t) {
      return e + (isNaN(t) ? 0 : t)
    },
    0
  )
  if (0 === r) return 0
  for (
    var n = Math.pow(10, i),
      a = map$1(e, function (e) {
        return ((isNaN(e) ? 0 : e) / r) * n * 100
      }),
      o = 100 * n,
      s = map$1(a, function (e) {
        return Math.floor(e)
      }),
      l = reduce(
        s,
        function (e, t) {
          return e + t
        },
        0
      ),
      h = map$1(a, function (e, t) {
        return e - s[t]
      });
    l < o;

  ) {
    for (var u = Number.NEGATIVE_INFINITY, p = null, c = 0, d = h.length; c < d; ++c)
      h[c] > u && ((u = h[c]), (p = c))
    ++s[p], (h[p] = 0), ++l
  }
  return s[t] / n
}
function addSafe(e, t) {
  var i = Math.max(getPrecision(e), getPrecision(t)),
    r = e + t
  return i > ROUND_SUPPORTED_PRECISION_MAX ? r : round$2(r, i)
}
var MAX_SAFE_INTEGER = 9007199254740991
function remRadian(e) {
  var t = 2 * Math.PI
  return ((e % t) + t) % t
}
function isRadianAroundZero(e) {
  return e > -RADIAN_EPSILON && e < RADIAN_EPSILON
}
var TIME_REG =
  /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/
function parseDate(e) {
  if (e instanceof Date) return e
  if ('string' == typeof e) {
    var t = TIME_REG.exec(e)
    if (!t) return new Date(NaN)
    if (t[8]) {
      var i = +t[4] || 0
      return (
        'Z' !== t[8].toUpperCase() && (i -= +t[8].slice(0, 3)),
        new Date(
          Date.UTC(+t[1], +(t[2] || 1) - 1, +t[3] || 1, i, +(t[5] || 0), +t[6] || 0, +t[7] || 0)
        )
      )
    }
    return new Date(
      +t[1],
      +(t[2] || 1) - 1,
      +t[3] || 1,
      +t[4] || 0,
      +(t[5] || 0),
      +t[6] || 0,
      +t[7] || 0
    )
  }
  return null == e ? new Date(NaN) : new Date(Math.round(e))
}
function quantity(e) {
  return Math.pow(10, quantityExponent(e))
}
function quantityExponent(e) {
  if (0 === e) return 0
  var t = Math.floor(Math.log(e) / Math.LN10)
  return e / Math.pow(10, t) >= 10 && t++, t
}
function nice(e, t) {
  var i = quantityExponent(e),
    r = Math.pow(10, i),
    n = e / r
  return (
    (e =
      (t
        ? n < 1.5
          ? 1
          : n < 2.5
          ? 2
          : n < 4
          ? 3
          : n < 7
          ? 5
          : 10
        : n < 1
        ? 1
        : n < 2
        ? 2
        : n < 3
        ? 3
        : n < 5
        ? 5
        : 10) * r),
    i >= -20 ? +e.toFixed(i < 0 ? -i : 0) : e
  )
}
function quantile(e, t) {
  var i = (e.length - 1) * t + 1,
    r = Math.floor(i),
    n = +e[r - 1],
    a = i - r
  return a ? n + a * (e[r] - n) : n
}
function reformIntervals(e) {
  e.sort(function (e, t) {
    return s(e, t, 0) ? -1 : 1
  })
  for (var t = -1 / 0, i = 1, r = 0; r < e.length; ) {
    for (var n = e[r].interval, a = e[r].close, o = 0; o < 2; o++)
      n[o] <= t && ((n[o] = t), (a[o] = o ? 1 : 1 - i)), (t = n[o]), (i = a[o])
    n[0] === n[1] && a[0] * a[1] != 1 ? e.splice(r, 1) : r++
  }
  return e
  function s(e, t, i) {
    return (
      e.interval[i] < t.interval[i] ||
      (e.interval[i] === t.interval[i] &&
        (e.close[i] - t.close[i] == (i ? -1 : 1) || (!i && s(e, t, 1))))
    )
  }
}
function numericToNumber(e) {
  var t = parseFloat(e)
  return t == e && (0 !== t || 'string' != typeof e || e.indexOf('x') <= 0) ? t : NaN
}
function isNumeric(e) {
  return !isNaN(numericToNumber(e))
}
function getRandomIdBase() {
  return Math.round(9 * Math.random())
}
function getGreatestCommonDividor(e, t) {
  return 0 === t ? e : getGreatestCommonDividor(t, e % t)
}
function getLeastCommonMultiple(e, t) {
  return null == e ? t : null == t ? e : (e * t) / getGreatestCommonDividor(e, t)
}
function throwError(e) {
  throw new Error(e)
}
var DUMMY_COMPONENT_NAME_PREFIX = 'series\0',
  INTERNAL_COMPONENT_ID_PREFIX = '\0_ec_\0'
function normalizeToArray(e) {
  return e instanceof Array ? e : null == e ? [] : [e]
}
function defaultEmphasis(e, t, i) {
  if (e) {
    ;(e[t] = e[t] || {}), (e.emphasis = e.emphasis || {}), (e.emphasis[t] = e.emphasis[t] || {})
    for (var r = 0, n = i.length; r < n; r++) {
      var a = i[r]
      !e.emphasis[t].hasOwnProperty(a) && e[t].hasOwnProperty(a) && (e.emphasis[t][a] = e[t][a])
    }
  }
}
var TEXT_STYLE_OPTIONS = [
  'fontStyle',
  'fontWeight',
  'fontSize',
  'fontFamily',
  'rich',
  'tag',
  'color',
  'textBorderColor',
  'textBorderWidth',
  'width',
  'height',
  'lineHeight',
  'align',
  'verticalAlign',
  'baseline',
  'shadowColor',
  'shadowBlur',
  'shadowOffsetX',
  'shadowOffsetY',
  'textShadowColor',
  'textShadowBlur',
  'textShadowOffsetX',
  'textShadowOffsetY',
  'backgroundColor',
  'borderColor',
  'borderWidth',
  'borderRadius',
  'padding'
]
function getDataItemValue(e) {
  return !isObject$7(e) || isArray$1(e) || e instanceof Date ? e : e.value
}
function isDataItemOption(e) {
  return isObject$7(e) && !(e instanceof Array)
}
function mappingToExists(e, t, i) {
  var r = 'normalMerge' === i,
    n = 'replaceMerge' === i,
    a = 'replaceAll' === i
  ;(e = e || []), (t = (t || []).slice())
  var o = createHashMap()
  each$i(t, function (e, i) {
    isObject$7(e) || (t[i] = null)
  })
  var s = prepareResult(e, o, i)
  return (
    (r || n) && mappingById(s, e, o, t),
    r && mappingByName(s, t),
    r || n ? mappingByIndex(s, t, n) : a && mappingInReplaceAllMode(s, t),
    makeIdAndName(s),
    s
  )
}
function prepareResult(e, t, i) {
  var r = []
  if ('replaceAll' === i) return r
  for (var n = 0; n < e.length; n++) {
    var a = e[n]
    a && null != a.id && t.set(a.id, n),
      r.push({
        existing: 'replaceMerge' === i || isComponentIdInternal(a) ? null : a,
        newOption: null,
        keyInfo: null,
        brandNew: null
      })
  }
  return r
}
function mappingById(e, t, i, r) {
  each$i(r, function (n, a) {
    if (n && null != n.id) {
      var o = makeComparableKey(n.id),
        s = i.get(o)
      if (null != s) {
        var l = e[s]
        assert$1(!l.newOption, 'Duplicated option on id "' + o + '".'),
          (l.newOption = n),
          (l.existing = t[s]),
          (r[a] = null)
      }
    }
  })
}
function mappingByName(e, t) {
  each$i(t, function (i, r) {
    if (i && null != i.name)
      for (var n = 0; n < e.length; n++) {
        var a = e[n].existing
        if (
          !e[n].newOption &&
          a &&
          (null == a.id || null == i.id) &&
          !isComponentIdInternal(i) &&
          !isComponentIdInternal(a) &&
          keyExistAndEqual('name', a, i)
        )
          return (e[n].newOption = i), void (t[r] = null)
      }
  })
}
function mappingByIndex(e, t, i) {
  each$i(t, function (t) {
    if (t) {
      for (
        var r, n = 0;
        (r = e[n]) &&
        (r.newOption ||
          isComponentIdInternal(r.existing) ||
          (r.existing && null != t.id && !keyExistAndEqual('id', t, r.existing)));

      )
        n++
      r
        ? ((r.newOption = t), (r.brandNew = i))
        : e.push({ newOption: t, brandNew: i, existing: null, keyInfo: null }),
        n++
    }
  })
}
function mappingInReplaceAllMode(e, t) {
  each$i(t, function (t) {
    e.push({ newOption: t, brandNew: !0, existing: null, keyInfo: null })
  })
}
function makeIdAndName(e) {
  var t = createHashMap()
  each$i(e, function (e) {
    var i = e.existing
    i && t.set(i.id, e)
  }),
    each$i(e, function (e) {
      var i = e.newOption
      assert$1(
        !i || null == i.id || !t.get(i.id) || t.get(i.id) === e,
        'id duplicates: ' + (i && i.id)
      ),
        i && null != i.id && t.set(i.id, e),
        !e.keyInfo && (e.keyInfo = {})
    }),
    each$i(e, function (e, i) {
      var r = e.existing,
        n = e.newOption,
        a = e.keyInfo
      if (isObject$7(n)) {
        if (
          ((a.name =
            null != n.name
              ? makeComparableKey(n.name)
              : r
              ? r.name
              : DUMMY_COMPONENT_NAME_PREFIX + i),
          r)
        )
          a.id = makeComparableKey(r.id)
        else if (null != n.id) a.id = makeComparableKey(n.id)
        else {
          var o = 0
          do {
            a.id = '\0' + a.name + '\0' + o++
          } while (t.get(a.id))
        }
        t.set(a.id, e)
      }
    })
}
function keyExistAndEqual(e, t, i) {
  var r = convertOptionIdName(t[e], null),
    n = convertOptionIdName(i[e], null)
  return null != r && null != n && r === n
}
function makeComparableKey(e) {
  return convertOptionIdName(e, '')
}
function convertOptionIdName(e, t) {
  if (null == e) return t
  var i = typeof e
  return 'string' === i ? e : 'number' === i || isStringSafe(e) ? e + '' : t
}
function isNameSpecified(e) {
  var t = e.name
  return !(!t || !t.indexOf(DUMMY_COMPONENT_NAME_PREFIX))
}
function isComponentIdInternal(e) {
  return e && null != e.id && 0 === makeComparableKey(e.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX)
}
function makeInternalComponentId(e) {
  return INTERNAL_COMPONENT_ID_PREFIX + e
}
function setComponentTypeToKeyInfo(e, t, i) {
  each$i(e, function (e) {
    var r = e.newOption
    isObject$7(r) &&
      ((e.keyInfo.mainType = t), (e.keyInfo.subType = determineSubType(t, r, e.existing, i)))
  })
}
function determineSubType(e, t, i, r) {
  return t.type ? t.type : i ? i.subType : r.determineSubType(e, t)
}
function compressBatches(e, t) {
  var i = {},
    r = {}
  return n(e || [], i), n(t || [], r, i), [a(i), a(r)]
  function n(e, t, i) {
    for (var r = 0, n = e.length; r < n; r++) {
      var a = convertOptionIdName(e[r].seriesId, null)
      if (null == a) return
      for (
        var o = normalizeToArray(e[r].dataIndex), s = i && i[a], l = 0, h = o.length;
        l < h;
        l++
      ) {
        var u = o[l]
        s && s[u] ? (s[u] = null) : ((t[a] || (t[a] = {}))[u] = 1)
      }
    }
  }
  function a(e, t) {
    var i = []
    for (var r in e)
      if (e.hasOwnProperty(r) && null != e[r])
        if (t) i.push(+r)
        else {
          var n = a(e[r], !0)
          n.length && i.push({ seriesId: r, dataIndex: n })
        }
    return i
  }
}
function queryDataIndex(e, t) {
  return null != t.dataIndexInside
    ? t.dataIndexInside
    : null != t.dataIndex
    ? isArray$1(t.dataIndex)
      ? map$1(t.dataIndex, function (t) {
          return e.indexOfRawIndex(t)
        })
      : e.indexOfRawIndex(t.dataIndex)
    : null != t.name
    ? isArray$1(t.name)
      ? map$1(t.name, function (t) {
          return e.indexOfName(t)
        })
      : e.indexOfName(t.name)
    : void 0
}
function makeInner() {
  var e = '__ec_inner_' + innerUniqueIndex++
  return function (t) {
    return t[e] || (t[e] = {})
  }
}
var innerUniqueIndex = getRandomIdBase()
function parseFinder$1(e, t, i) {
  var r = preParseFinder(t, i),
    n = r.mainTypeSpecified,
    a = r.queryOptionMap,
    o = r.others,
    s = i ? i.defaultMainType : null
  return (
    !n && s && a.set(s, {}),
    a.each(function (t, r) {
      var n = queryReferringComponents(e, r, t, {
        useDefault: s === r,
        enableAll: !i || null == i.enableAll || i.enableAll,
        enableNone: !i || null == i.enableNone || i.enableNone
      })
      ;(o[r + 'Models'] = n.models), (o[r + 'Model'] = n.models[0])
    }),
    o
  )
}
function preParseFinder(e, t) {
  var i
  if (isString(e)) {
    var r = {}
    ;(r[e + 'Index'] = 0), (i = r)
  } else i = e
  var n = createHashMap(),
    a = {},
    o = !1
  return (
    each$i(i, function (e, i) {
      if ('dataIndex' !== i && 'dataIndexInside' !== i) {
        var r = i.match(/^(\w+)(Index|Id|Name)$/) || [],
          s = r[1],
          l = (r[2] || '').toLowerCase()
        if (s && l && !(t && t.includeMainTypes && indexOf$1(t.includeMainTypes, s) < 0))
          (o = o || !!s), ((n.get(s) || n.set(s, {}))[l] = e)
      } else a[i] = e
    }),
    { mainTypeSpecified: o, queryOptionMap: n, others: a }
  )
}
var SINGLE_REFERRING = { useDefault: !0, enableAll: !1, enableNone: !1 },
  MULTIPLE_REFERRING = { useDefault: !1, enableAll: !0, enableNone: !0 }
function queryReferringComponents(e, t, i, r) {
  r = r || SINGLE_REFERRING
  var n = i.index,
    a = i.id,
    o = i.name,
    s = { models: null, specified: null != n || null != a || null != o }
  if (!s.specified) {
    var l = void 0
    return (s.models = r.useDefault && (l = e.getComponent(t)) ? [l] : []), s
  }
  return 'none' === n || !1 === n
    ? (assert$1(r.enableNone, '`"none"` or `false` is not a valid value on index option.'),
      (s.models = []),
      s)
    : ('all' === n &&
        (assert$1(r.enableAll, '`"all"` is not a valid value on index option.'),
        (n = a = o = null)),
      (s.models = e.queryComponents({ mainType: t, index: n, id: a, name: o })),
      s)
}
function setAttribute(e, t, i) {
  e.setAttribute ? e.setAttribute(t, i) : (e[t] = i)
}
function getAttribute(e, t) {
  return e.getAttribute ? e.getAttribute(t) : e[t]
}
function getTooltipRenderMode(e) {
  return 'auto' === e ? (env.domSupported ? 'html' : 'richText') : e || 'html'
}
function groupData(e, t) {
  var i = createHashMap(),
    r = []
  return (
    each$i(e, function (e) {
      var n = t(e)
      ;(i.get(n) || (r.push(n), i.set(n, []))).push(e)
    }),
    { keys: r, buckets: i }
  )
}
function interpolateRawValues(e, t, i, r, n) {
  var a = null == t || 'auto' === t
  if (null == r) return r
  if ('number' == typeof r)
    return round$2(
      (d = interpolateNumber(i || 0, r, n)),
      a ? Math.max(getPrecision(i || 0), getPrecision(r)) : t
    )
  if ('string' == typeof r) return n < 1 ? i : r
  for (var o = [], s = i, l = r, h = Math.max(s ? s.length : 0, l.length), u = 0; u < h; ++u) {
    if ('ordinal' === e.getDimensionInfo(u).type) o[u] = (n < 1 && s ? s : l)[u]
    else {
      var p = s && s[u] ? s[u] : 0,
        c = l[u],
        d = interpolateNumber(p, c, n)
      o[u] = round$2(d, a ? Math.max(getPrecision(p), getPrecision(c)) : t)
    }
  }
  return o
}
var TYPE_DELIMITER = '.',
  IS_CONTAINER = '___EC__COMPONENT__CONTAINER___',
  IS_EXTENDED_CLASS = '___EC__EXTENDED_CLASS___'
function parseClassType(e) {
  var t = { main: '', sub: '' }
  if (e) {
    var i = e.split(TYPE_DELIMITER)
    ;(t.main = i[0] || ''), (t.sub = i[1] || '')
  }
  return t
}
function checkClassType(e) {
  assert$1(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(e), 'componentType "' + e + '" illegal')
}
function isExtendedClass(e) {
  return !(!e || !e[IS_EXTENDED_CLASS])
}
function enableClassExtend(e, t) {
  ;(e.$constructor = e),
    (e.extend = function (e) {
      var t = this
      function i() {
        for (var r = [], n = 0; n < arguments.length; n++) r[n] = arguments[n]
        if (e.$constructor) e.$constructor.apply(this, arguments)
        else {
          if (isESClass(t)) {
            var a = createObject(i.prototype, new (t.bind.apply(t, __spreadArrays([void 0], r)))())
            return a
          }
          t.apply(this, arguments)
        }
      }
      return (
        (i[IS_EXTENDED_CLASS] = !0),
        extend$3(i.prototype, e),
        (i.extend = this.extend),
        (i.superCall = superCall),
        (i.superApply = superApply),
        inherits(i, this),
        (i.superClass = t),
        i
      )
    })
}
function isESClass(e) {
  return 'function' == typeof e && /^class\s/.test(Function.prototype.toString.call(e))
}
function mountExtend(e, t) {
  e.extend = t.extend
}
var classBase = Math.round(10 * Math.random())
function enableClassCheck(e) {
  var t = ['__\0is_clz', classBase++].join('_')
  ;(e.prototype[t] = !0),
    (e.isInstance = function (e) {
      return !(!e || !e[t])
    })
}
function superCall(e, t) {
  for (var i = [], r = 2; r < arguments.length; r++) i[r - 2] = arguments[r]
  return this.superClass.prototype[t].apply(e, i)
}
function superApply(e, t, i) {
  return this.superClass.prototype[t].apply(e, i)
}
function enableClassManagement(e) {
  var t = {}
  ;(e.registerClass = function (e) {
    var i = e.type || e.prototype.type
    if (i) {
      checkClassType(i), (e.prototype.type = i)
      var r = parseClassType(i)
      if (r.sub) {
        if (r.sub !== IS_CONTAINER) {
          ;(function (e) {
            var i = t[e.main]
            ;(i && i[IS_CONTAINER]) || ((i = t[e.main] = {})[IS_CONTAINER] = !0)
            return i
          })(r)[r.sub] = e
        }
      } else t[r.main] = e
    }
    return e
  }),
    (e.getClass = function (e, i, r) {
      var n = t[e]
      if ((n && n[IS_CONTAINER] && (n = i ? n[i] : null), r && !n))
        throw new Error(
          i
            ? 'Component ' + e + '.' + (i || '') + ' is used but not imported.'
            : e + '.type should be specified.'
        )
      return n
    }),
    (e.getClassesByMainType = function (e) {
      var i = parseClassType(e),
        r = [],
        n = t[i.main]
      return (
        n && n[IS_CONTAINER]
          ? each$i(n, function (e, t) {
              t !== IS_CONTAINER && r.push(e)
            })
          : r.push(n),
        r
      )
    }),
    (e.hasClass = function (e) {
      var i = parseClassType(e)
      return !!t[i.main]
    }),
    (e.getAllClassMainTypes = function () {
      var e = []
      return (
        each$i(t, function (t, i) {
          e.push(i)
        }),
        e
      )
    }),
    (e.hasSubTypes = function (e) {
      var i = parseClassType(e),
        r = t[i.main]
      return r && r[IS_CONTAINER]
    })
}
function makeStyleMapper(e, t) {
  for (var i = 0; i < e.length; i++) e[i][1] || (e[i][1] = e[i][0])
  return (
    (t = t || !1),
    function (i, r, n) {
      for (var a = {}, o = 0; o < e.length; o++) {
        var s = e[o][1]
        if (!((r && indexOf$1(r, s) >= 0) || (n && indexOf$1(n, s) < 0))) {
          var l = i.getShallow(s, t)
          null != l && (a[e[o][0]] = l)
        }
      }
      return a
    }
  )
}
var AREA_STYLE_KEY_MAP = [
    ['fill', 'color'],
    ['shadowBlur'],
    ['shadowOffsetX'],
    ['shadowOffsetY'],
    ['opacity'],
    ['shadowColor']
  ],
  getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP),
  AreaStyleMixin = (function () {
    function e() {}
    return (
      (e.prototype.getAreaStyle = function (e, t) {
        return getAreaStyle(this, e, t)
      }),
      e
    )
  })(),
  globalImageCache = new LRU(50)
function findExistImage(e) {
  if ('string' == typeof e) {
    var t = globalImageCache.get(e)
    return t && t.image
  }
  return e
}
function createOrUpdateImage(e, t, i, r, n) {
  if (e) {
    if ('string' == typeof e) {
      if ((t && t.__zrImageSrc === e) || !i) return t
      var a = globalImageCache.get(e),
        o = { hostEl: i, cb: r, cbPayload: n }
      return (
        a
          ? !isImageReady((t = a.image)) && a.pending.push(o)
          : (((t = new Image()).onload = t.onerror = imageOnLoad),
            globalImageCache.put(e, (t.__cachedImgObj = { image: t, pending: [o] })),
            (t.src = t.__zrImageSrc = e)),
        t
      )
    }
    return e
  }
  return t
}
function imageOnLoad() {
  var e = this.__cachedImgObj
  this.onload = this.onerror = this.__cachedImgObj = null
  for (var t = 0; t < e.pending.length; t++) {
    var i = e.pending[t],
      r = i.cb
    r && r(this, i.cbPayload), i.hostEl.dirty()
  }
  e.pending.length = 0
}
function isImageReady(e) {
  return e && e.width && e.height
}
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g
function truncateText(e, t, i, r, n) {
  if (!t) return ''
  var a = (e + '').split('\n')
  n = prepareTruncateOptions(t, i, r, n)
  for (var o = 0, s = a.length; o < s; o++) a[o] = truncateSingleLine(a[o], n)
  return a.join('\n')
}
function prepareTruncateOptions(e, t, i, r) {
  var n = extend$3({}, (r = r || {}))
  ;(n.font = t), (i = retrieve2(i, '...')), (n.maxIterations = retrieve2(r.maxIterations, 2))
  var a = (n.minChar = retrieve2(r.minChar, 0))
  n.cnCharWidth = getWidth('', t)
  var o = (n.ascCharWidth = getWidth('a', t))
  n.placeholder = retrieve2(r.placeholder, '')
  for (var s = (e = Math.max(0, e - 1)), l = 0; l < a && s >= o; l++) s -= o
  var h = getWidth(i, t)
  return (
    h > s && ((i = ''), (h = 0)),
    (s = e - h),
    (n.ellipsis = i),
    (n.ellipsisWidth = h),
    (n.contentWidth = s),
    (n.containerWidth = e),
    n
  )
}
function truncateSingleLine(e, t) {
  var i = t.containerWidth,
    r = t.font,
    n = t.contentWidth
  if (!i) return ''
  var a = getWidth(e, r)
  if (a <= i) return e
  for (var o = 0; ; o++) {
    if (a <= n || o >= t.maxIterations) {
      e += t.ellipsis
      break
    }
    var s =
      0 === o
        ? estimateLength(e, n, t.ascCharWidth, t.cnCharWidth)
        : a > 0
        ? Math.floor((e.length * n) / a)
        : 0
    a = getWidth((e = e.substr(0, s)), r)
  }
  return '' === e && (e = t.placeholder), e
}
function estimateLength(e, t, i, r) {
  for (var n = 0, a = 0, o = e.length; a < o && n < t; a++) {
    var s = e.charCodeAt(a)
    n += 0 <= s && s <= 127 ? i : r
  }
  return a
}
function parsePlainText(e, t) {
  null != e && (e += '')
  var i,
    r = t.overflow,
    n = t.padding,
    a = t.font,
    o = 'truncate' === r,
    s = getLineHeight(a),
    l = retrieve2(t.lineHeight, s),
    h = 'truncate' === t.lineOverflow,
    u = t.width,
    p =
      (i =
        (null != u && 'break' === r) || 'breakAll' === r
          ? e
            ? wrapText(e, t.font, u, 'breakAll' === r, 0).lines
            : []
          : e
          ? e.split('\n')
          : []).length * l,
    c = retrieve2(t.height, p)
  if (p > c && h) {
    var d = Math.floor(c / l)
    i = i.slice(0, d)
  }
  var f = c,
    m = u
  if ((n && ((f += n[0] + n[2]), null != m && (m += n[1] + n[3])), e && o && null != m))
    for (
      var g = prepareTruncateOptions(u, a, t.ellipsis, {
          minChar: t.truncateMinChar,
          placeholder: t.placeholder
        }),
        y = 0;
      y < i.length;
      y++
    )
      i[y] = truncateSingleLine(i[y], g)
  if (null == u) {
    var v = 0
    for (y = 0; y < i.length; y++) v = Math.max(getWidth(i[y], a), v)
    u = v
  }
  return {
    lines: i,
    height: c,
    outerHeight: f,
    lineHeight: l,
    calculatedLineHeight: s,
    contentHeight: p,
    width: u
  }
}
var RichTextToken = function () {},
  RichTextLine = function (e) {
    ;(this.tokens = []), e && (this.tokens = e)
  },
  RichTextContentBlock = function () {
    ;(this.width = 0),
      (this.height = 0),
      (this.contentWidth = 0),
      (this.contentHeight = 0),
      (this.outerWidth = 0),
      (this.outerHeight = 0),
      (this.lines = [])
  }
function parseRichText(e, t) {
  var i = new RichTextContentBlock()
  if ((null != e && (e += ''), !e)) return i
  for (
    var r,
      n = t.width,
      a = t.height,
      o = t.overflow,
      s =
        ('break' !== o && 'breakAll' !== o) || null == n
          ? null
          : { width: n, accumWidth: 0, breakAll: 'breakAll' === o },
      l = (STYLE_REG.lastIndex = 0);
    null != (r = STYLE_REG.exec(e));

  ) {
    var h = r.index
    h > l && pushTokens(i, e.substring(l, h), t, s),
      pushTokens(i, r[2], t, s, r[1]),
      (l = STYLE_REG.lastIndex)
  }
  l < e.length && pushTokens(i, e.substring(l, e.length), t, s)
  var u = [],
    p = 0,
    c = 0,
    d = t.padding,
    f = 'truncate' === o,
    m = 'truncate' === t.lineOverflow
  function g(e, t, i) {
    ;(e.width = t), (e.lineHeight = i), (p += i), (c = Math.max(c, t))
  }
  e: for (var y = 0; y < i.lines.length; y++) {
    for (var v = i.lines[y], _ = 0, x = 0, S = 0; S < v.tokens.length; S++) {
      var b = ((L = v.tokens[S]).styleName && t.rich[L.styleName]) || {},
        T = (L.textPadding = b.padding),
        A = T ? T[1] + T[3] : 0,
        w = (L.font = b.font || t.font)
      L.contentHeight = getLineHeight(w)
      var M = retrieve2(b.height, L.contentHeight)
      if (
        ((L.innerHeight = M),
        T && (M += T[0] + T[2]),
        (L.height = M),
        (L.lineHeight = retrieve3(b.lineHeight, t.lineHeight, M)),
        (L.align = (b && b.align) || t.align),
        (L.verticalAlign = (b && b.verticalAlign) || 'middle'),
        m && null != a && p + L.lineHeight > a)
      ) {
        S > 0
          ? ((v.tokens = v.tokens.slice(0, S)), g(v, x, _), (i.lines = i.lines.slice(0, y + 1)))
          : (i.lines = i.lines.slice(0, y))
        break e
      }
      var C = b.width,
        P = null == C || 'auto' === C
      if ('string' == typeof C && '%' === C.charAt(C.length - 1))
        (L.percentWidth = C), u.push(L), (L.contentWidth = getWidth(L.text, w))
      else {
        if (P) {
          var E = b.backgroundColor,
            I = E && E.image
          I &&
            isImageReady((I = findExistImage(I))) &&
            (L.width = Math.max(L.width, (I.width * M) / I.height))
        }
        var D = f && null != n ? n - x : null
        null != D && D < L.width
          ? !P || D < A
            ? ((L.text = ''), (L.width = L.contentWidth = 0))
            : ((L.text = truncateText(L.text, D - A, w, t.ellipsis, {
                minChar: t.truncateMinChar
              })),
              (L.width = L.contentWidth = getWidth(L.text, w)))
          : (L.contentWidth = getWidth(L.text, w))
      }
      ;(L.width += A), (x += L.width), b && (_ = Math.max(_, L.lineHeight))
    }
    g(v, x, _)
  }
  ;(i.outerWidth = i.width = retrieve2(n, c)),
    (i.outerHeight = i.height = retrieve2(a, p)),
    (i.contentHeight = p),
    (i.contentWidth = c),
    d && ((i.outerWidth += d[1] + d[3]), (i.outerHeight += d[0] + d[2]))
  for (y = 0; y < u.length; y++) {
    var L,
      R = (L = u[y]).percentWidth
    L.width = (parseInt(R, 10) / 100) * i.width
  }
  return i
}
function pushTokens(e, t, i, r, n) {
  var a,
    o,
    s = '' === t,
    l = (n && i.rich[n]) || {},
    h = e.lines,
    u = l.font || i.font,
    p = !1
  if (r) {
    var c = l.padding,
      d = c ? c[1] + c[3] : 0
    if (null != l.width && 'auto' !== l.width) {
      var f = parsePercent$2(l.width, r.width) + d
      h.length > 0 && f + r.accumWidth > r.width && ((a = t.split('\n')), (p = !0)),
        (r.accumWidth = f)
    } else {
      var m = wrapText(t, u, r.width, r.breakAll, r.accumWidth)
      ;(r.accumWidth = m.accumWidth + d), (o = m.linesWidths), (a = m.lines)
    }
  } else a = t.split('\n')
  for (var g = 0; g < a.length; g++) {
    var y = a[g],
      v = new RichTextToken()
    if (
      ((v.styleName = n),
      (v.text = y),
      (v.isLineHolder = !y && !s),
      'number' == typeof l.width ? (v.width = l.width) : (v.width = o ? o[g] : getWidth(y, u)),
      g || p)
    )
      h.push(new RichTextLine([v]))
    else {
      var _ = (h[h.length - 1] || (h[0] = new RichTextLine())).tokens,
        x = _.length
      1 === x && _[0].isLineHolder ? (_[0] = v) : (y || !x || s) && _.push(v)
    }
  }
}
function isLatin(e) {
  var t = e.charCodeAt(0)
  return t >= 33 && t <= 255
}
var breakCharMap = reduce(
  ',&?/;] '.split(''),
  function (e, t) {
    return (e[t] = !0), e
  },
  {}
)
function isWordBreakChar(e) {
  return !isLatin(e) || !!breakCharMap[e]
}
function wrapText(e, t, i, r, n) {
  for (var a = [], o = [], s = '', l = '', h = 0, u = 0, p = 0; p < e.length; p++) {
    var c = e.charAt(p)
    if ('\n' !== c) {
      var d = getWidth(c, t),
        f = !r && !isWordBreakChar(c)
      ;(a.length ? u + d > i : n + u + d > i)
        ? u
          ? (s || l) &&
            (f
              ? (s || ((s = l), (l = ''), (u = h = 0)),
                a.push(s),
                o.push(u - h),
                (l += c),
                (s = ''),
                (u = h += d))
              : (l && ((s += l), (u += h), (l = ''), (h = 0)),
                a.push(s),
                o.push(u),
                (s = c),
                (u = d)))
          : f
          ? (a.push(l), o.push(h), (l = c), (h = d))
          : (a.push(c), o.push(d))
        : ((u += d), f ? ((l += c), (h += d)) : (l && ((s += l), (l = ''), (h = 0)), (s += c)))
    } else l && ((s += l), (u += h)), a.push(s), o.push(u), (s = ''), (l = ''), (h = 0), (u = 0)
  }
  return (
    a.length || s || ((s = e), (l = ''), (h = 0)),
    l && (s += l),
    s && (a.push(s), o.push(u)),
    1 === a.length && (u += n),
    { accumWidth: u, lines: a, linesWidths: o }
  )
}
var STYLE_MAGIC_KEY = '__zr_style_' + Math.round(10 * Math.random()),
  DEFAULT_COMMON_STYLE = {
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: '#000',
    opacity: 1,
    blend: 'source-over'
  },
  DEFAULT_COMMON_ANIMATION_PROPS = {
    style: { shadowBlur: !0, shadowOffsetX: !0, shadowOffsetY: !0, shadowColor: !0, opacity: !0 }
  }
DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = !0
var PRIMARY_STATES_KEYS = ['z', 'z2', 'invisible'],
  PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ['invisible'],
  Displayable = (function (e) {
    function t(t) {
      return e.call(this, t) || this
    }
    var i
    return (
      __extends(t, e),
      (t.prototype._init = function (t) {
        for (var i = keys(t), r = 0; r < i.length; r++) {
          var n = i[r]
          'style' === n ? this.useStyle(t[n]) : e.prototype.attrKV.call(this, n, t[n])
        }
        this.style || this.useStyle({})
      }),
      (t.prototype.beforeBrush = function () {}),
      (t.prototype.afterBrush = function () {}),
      (t.prototype.innerBeforeBrush = function () {}),
      (t.prototype.innerAfterBrush = function () {}),
      (t.prototype.shouldBePainted = function (e, t, i, r) {
        var n = this.transform
        if (
          this.ignore ||
          this.invisible ||
          0 === this.style.opacity ||
          (this.culling && isDisplayableCulled(this, e, t)) ||
          (n && !n[0] && !n[3])
        )
          return !1
        if (i && this.__clipPaths)
          for (var a = 0; a < this.__clipPaths.length; ++a)
            if (this.__clipPaths[a].isZeroArea()) return !1
        if (r && this.parent)
          for (var o = this.parent; o; ) {
            if (o.ignore) return !1
            o = o.parent
          }
        return !0
      }),
      (t.prototype.contain = function (e, t) {
        return this.rectContain(e, t)
      }),
      (t.prototype.traverse = function (e, t) {
        e.call(t, this)
      }),
      (t.prototype.rectContain = function (e, t) {
        var i = this.transformCoordToLocal(e, t)
        return this.getBoundingRect().contain(i[0], i[1])
      }),
      (t.prototype.getPaintRect = function () {
        var e = this._paintRect
        if (!this._paintRect || this.__dirty) {
          var t = this.transform,
            i = this.getBoundingRect(),
            r = this.style,
            n = r.shadowBlur || 0,
            a = r.shadowOffsetX || 0,
            o = r.shadowOffsetY || 0
          ;(e = this._paintRect || (this._paintRect = new BoundingRect(0, 0, 0, 0))),
            t ? BoundingRect.applyTransform(e, i, t) : e.copy(i),
            (n || a || o) &&
              ((e.width += 2 * n + Math.abs(a)),
              (e.height += 2 * n + Math.abs(o)),
              (e.x = Math.min(e.x, e.x + a - n)),
              (e.y = Math.min(e.y, e.y + o - n)))
          var s = this.dirtyRectTolerance
          e.isZero() ||
            ((e.x = Math.floor(e.x - s)),
            (e.y = Math.floor(e.y - s)),
            (e.width = Math.ceil(e.width + 1 + 2 * s)),
            (e.height = Math.ceil(e.height + 1 + 2 * s)))
        }
        return e
      }),
      (t.prototype.setPrevPaintRect = function (e) {
        e
          ? ((this._prevPaintRect = this._prevPaintRect || new BoundingRect(0, 0, 0, 0)),
            this._prevPaintRect.copy(e))
          : (this._prevPaintRect = null)
      }),
      (t.prototype.getPrevPaintRect = function () {
        return this._prevPaintRect
      }),
      (t.prototype.animateStyle = function (e) {
        return this.animate('style', e)
      }),
      (t.prototype.updateDuringAnimation = function (e) {
        'style' === e ? this.dirtyStyle() : this.markRedraw()
      }),
      (t.prototype.attrKV = function (t, i) {
        'style' !== t
          ? e.prototype.attrKV.call(this, t, i)
          : this.style
          ? this.setStyle(i)
          : this.useStyle(i)
      }),
      (t.prototype.setStyle = function (e, t) {
        return (
          'string' == typeof e ? (this.style[e] = t) : extend$3(this.style, e),
          this.dirtyStyle(),
          this
        )
      }),
      (t.prototype.dirtyStyle = function (e) {
        e || this.markRedraw(),
          (this.__dirty |= STYLE_CHANGED_BIT),
          this._rect && (this._rect = null)
      }),
      (t.prototype.dirty = function () {
        this.dirtyStyle()
      }),
      (t.prototype.styleChanged = function () {
        return !!(this.__dirty & STYLE_CHANGED_BIT)
      }),
      (t.prototype.styleUpdated = function () {
        this.__dirty &= ~STYLE_CHANGED_BIT
      }),
      (t.prototype.createStyle = function (e) {
        return createObject(DEFAULT_COMMON_STYLE, e)
      }),
      (t.prototype.useStyle = function (e) {
        e[STYLE_MAGIC_KEY] || (e = this.createStyle(e)),
          this.__inHover ? (this.__hoverStyle = e) : (this.style = e),
          this.dirtyStyle()
      }),
      (t.prototype.isStyleObject = function (e) {
        return e[STYLE_MAGIC_KEY]
      }),
      (t.prototype._innerSaveToNormal = function (t) {
        e.prototype._innerSaveToNormal.call(this, t)
        var i = this._normalState
        t.style && !i.style && (i.style = this._mergeStyle(this.createStyle(), this.style)),
          this._savePrimaryToNormal(t, i, PRIMARY_STATES_KEYS)
      }),
      (t.prototype._applyStateObj = function (t, i, r, n, a, o) {
        e.prototype._applyStateObj.call(this, t, i, r, n, a, o)
        var s,
          l = !(i && n)
        if (
          (i && i.style
            ? a
              ? n
                ? (s = i.style)
                : ((s = this._mergeStyle(this.createStyle(), r.style)),
                  this._mergeStyle(s, i.style))
              : ((s = this._mergeStyle(this.createStyle(), n ? this.style : r.style)),
                this._mergeStyle(s, i.style))
            : l && (s = r.style),
          s)
        )
          if (a) {
            var h = this.style
            if (((this.style = this.createStyle(l ? {} : h)), l))
              for (var u = keys(h), p = 0; p < u.length; p++) {
                ;(d = u[p]) in s && ((s[d] = s[d]), (this.style[d] = h[d]))
              }
            var c = keys(s)
            for (p = 0; p < c.length; p++) {
              var d = c[p]
              this.style[d] = this.style[d]
            }
            this._transitionState(t, { style: s }, o, this.getAnimationStyleProps())
          } else this.useStyle(s)
        var f = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS
        for (p = 0; p < f.length; p++) {
          d = f[p]
          i && null != i[d] ? (this[d] = i[d]) : l && null != r[d] && (this[d] = r[d])
        }
      }),
      (t.prototype._mergeStates = function (t) {
        for (var i, r = e.prototype._mergeStates.call(this, t), n = 0; n < t.length; n++) {
          var a = t[n]
          a.style && ((i = i || {}), this._mergeStyle(i, a.style))
        }
        return i && (r.style = i), r
      }),
      (t.prototype._mergeStyle = function (e, t) {
        return extend$3(e, t), e
      }),
      (t.prototype.getAnimationStyleProps = function () {
        return DEFAULT_COMMON_ANIMATION_PROPS
      }),
      (t.initDefaultProps =
        (((i = t.prototype).type = 'displayable'),
        (i.invisible = !1),
        (i.z = 0),
        (i.z2 = 0),
        (i.zlevel = 0),
        (i.culling = !1),
        (i.cursor = 'pointer'),
        (i.rectHover = !1),
        (i.incremental = !1),
        (i._rect = null),
        (i.dirtyRectTolerance = 0),
        void (i.__dirty = REDARAW_BIT | STYLE_CHANGED_BIT))),
      t
    )
  })(Element),
  tmpRect = new BoundingRect(0, 0, 0, 0),
  viewRect = new BoundingRect(0, 0, 0, 0)
function isDisplayableCulled(e, t, i) {
  return (
    tmpRect.copy(e.getBoundingRect()),
    e.transform && tmpRect.applyTransform(e.transform),
    (viewRect.width = t),
    (viewRect.height = i),
    !tmpRect.intersect(viewRect)
  )
}
var mathPow$2 = Math.pow,
  mathSqrt$4 = Math.sqrt,
  EPSILON$3 = 1e-8,
  EPSILON_NUMERIC = 1e-4,
  THREE_SQRT = mathSqrt$4(3),
  ONE_THIRD = 1 / 3,
  _v0 = create$2(),
  _v1 = create$2(),
  _v2 = create$2()
function isAroundZero$1(e) {
  return e > -EPSILON$3 && e < EPSILON$3
}
function isNotAroundZero(e) {
  return e > EPSILON$3 || e < -EPSILON$3
}
function cubicAt(e, t, i, r, n) {
  var a = 1 - n
  return a * a * (a * e + 3 * n * t) + n * n * (n * r + 3 * a * i)
}
function cubicDerivativeAt(e, t, i, r, n) {
  var a = 1 - n
  return 3 * (((t - e) * a + 2 * (i - t) * n) * a + (r - i) * n * n)
}
function cubicRootAt(e, t, i, r, n, a) {
  var o = r + 3 * (t - i) - e,
    s = 3 * (i - 2 * t + e),
    l = 3 * (t - e),
    h = e - n,
    u = s * s - 3 * o * l,
    p = s * l - 9 * o * h,
    c = l * l - 3 * s * h,
    d = 0
  if (isAroundZero$1(u) && isAroundZero$1(p)) {
    if (isAroundZero$1(s)) a[0] = 0
    else (A = -l / s) >= 0 && A <= 1 && (a[d++] = A)
  } else {
    var f = p * p - 4 * u * c
    if (isAroundZero$1(f)) {
      var m = p / u,
        g = -m / 2
      ;(A = -s / o + m) >= 0 && A <= 1 && (a[d++] = A), g >= 0 && g <= 1 && (a[d++] = g)
    } else if (f > 0) {
      var y = mathSqrt$4(f),
        v = u * s + 1.5 * o * (-p + y),
        _ = u * s + 1.5 * o * (-p - y)
      ;(A =
        (-s -
          ((v = v < 0 ? -mathPow$2(-v, ONE_THIRD) : mathPow$2(v, ONE_THIRD)) +
            (_ = _ < 0 ? -mathPow$2(-_, ONE_THIRD) : mathPow$2(_, ONE_THIRD)))) /
        (3 * o)) >= 0 &&
        A <= 1 &&
        (a[d++] = A)
    } else {
      var x = (2 * u * s - 3 * o * p) / (2 * mathSqrt$4(u * u * u)),
        S = Math.acos(x) / 3,
        b = mathSqrt$4(u),
        T = Math.cos(S),
        A = (-s - 2 * b * T) / (3 * o),
        w =
          ((g = (-s + b * (T + THREE_SQRT * Math.sin(S))) / (3 * o)),
          (-s + b * (T - THREE_SQRT * Math.sin(S))) / (3 * o))
      A >= 0 && A <= 1 && (a[d++] = A),
        g >= 0 && g <= 1 && (a[d++] = g),
        w >= 0 && w <= 1 && (a[d++] = w)
    }
  }
  return d
}
function cubicExtrema(e, t, i, r, n) {
  var a = 6 * i - 12 * t + 6 * e,
    o = 9 * t + 3 * r - 3 * e - 9 * i,
    s = 3 * t - 3 * e,
    l = 0
  if (isAroundZero$1(o)) {
    if (isNotAroundZero(a)) (u = -s / a) >= 0 && u <= 1 && (n[l++] = u)
  } else {
    var h = a * a - 4 * o * s
    if (isAroundZero$1(h)) n[0] = -a / (2 * o)
    else if (h > 0) {
      var u,
        p = mathSqrt$4(h),
        c = (-a - p) / (2 * o)
      ;(u = (-a + p) / (2 * o)) >= 0 && u <= 1 && (n[l++] = u), c >= 0 && c <= 1 && (n[l++] = c)
    }
  }
  return l
}
function cubicSubdivide(e, t, i, r, n, a) {
  var o = (t - e) * n + e,
    s = (i - t) * n + t,
    l = (r - i) * n + i,
    h = (s - o) * n + o,
    u = (l - s) * n + s,
    p = (u - h) * n + h
  ;(a[0] = e), (a[1] = o), (a[2] = h), (a[3] = p), (a[4] = p), (a[5] = u), (a[6] = l), (a[7] = r)
}
function cubicProjectPoint(e, t, i, r, n, a, o, s, l, h, u) {
  var p,
    c,
    d,
    f,
    m,
    g = 0.005,
    y = 1 / 0
  ;(_v0[0] = l), (_v0[1] = h)
  for (var v = 0; v < 1; v += 0.05)
    (_v1[0] = cubicAt(e, i, n, o, v)),
      (_v1[1] = cubicAt(t, r, a, s, v)),
      (f = distSquare(_v0, _v1)) < y && ((p = v), (y = f))
  y = 1 / 0
  for (var _ = 0; _ < 32 && !(g < EPSILON_NUMERIC); _++)
    (c = p - g),
      (d = p + g),
      (_v1[0] = cubicAt(e, i, n, o, c)),
      (_v1[1] = cubicAt(t, r, a, s, c)),
      (f = distSquare(_v1, _v0)),
      c >= 0 && f < y
        ? ((p = c), (y = f))
        : ((_v2[0] = cubicAt(e, i, n, o, d)),
          (_v2[1] = cubicAt(t, r, a, s, d)),
          (m = distSquare(_v2, _v0)),
          d <= 1 && m < y ? ((p = d), (y = m)) : (g *= 0.5))
  return u && ((u[0] = cubicAt(e, i, n, o, p)), (u[1] = cubicAt(t, r, a, s, p))), mathSqrt$4(y)
}
function cubicLength(e, t, i, r, n, a, o, s, l) {
  for (var h = e, u = t, p = 0, c = 1 / l, d = 1; d <= l; d++) {
    var f = d * c,
      m = cubicAt(e, i, n, o, f),
      g = cubicAt(t, r, a, s, f),
      y = m - h,
      v = g - u
    ;(p += Math.sqrt(y * y + v * v)), (h = m), (u = g)
  }
  return p
}
function quadraticAt$1(e, t, i, r) {
  var n = 1 - r
  return n * (n * e + 2 * r * t) + r * r * i
}
function quadraticDerivativeAt(e, t, i, r) {
  return 2 * ((1 - r) * (t - e) + r * (i - t))
}
function quadraticRootAt(e, t, i, r, n) {
  var a = e - 2 * t + i,
    o = 2 * (t - e),
    s = e - r,
    l = 0
  if (isAroundZero$1(a)) {
    if (isNotAroundZero(o)) (u = -s / o) >= 0 && u <= 1 && (n[l++] = u)
  } else {
    var h = o * o - 4 * a * s
    if (isAroundZero$1(h)) (u = -o / (2 * a)) >= 0 && u <= 1 && (n[l++] = u)
    else if (h > 0) {
      var u,
        p = mathSqrt$4(h),
        c = (-o - p) / (2 * a)
      ;(u = (-o + p) / (2 * a)) >= 0 && u <= 1 && (n[l++] = u), c >= 0 && c <= 1 && (n[l++] = c)
    }
  }
  return l
}
function quadraticExtremum(e, t, i) {
  var r = e + i - 2 * t
  return 0 === r ? 0.5 : (e - t) / r
}
function quadraticSubdivide(e, t, i, r, n) {
  var a = (t - e) * r + e,
    o = (i - t) * r + t,
    s = (o - a) * r + a
  ;(n[0] = e), (n[1] = a), (n[2] = s), (n[3] = s), (n[4] = o), (n[5] = i)
}
function quadraticProjectPoint(e, t, i, r, n, a, o, s, l) {
  var h,
    u = 0.005,
    p = 1 / 0
  ;(_v0[0] = o), (_v0[1] = s)
  for (var c = 0; c < 1; c += 0.05) {
    ;(_v1[0] = quadraticAt$1(e, i, n, c)),
      (_v1[1] = quadraticAt$1(t, r, a, c)),
      (g = distSquare(_v0, _v1)) < p && ((h = c), (p = g))
  }
  p = 1 / 0
  for (var d = 0; d < 32 && !(u < EPSILON_NUMERIC); d++) {
    var f = h - u,
      m = h + u
    ;(_v1[0] = quadraticAt$1(e, i, n, f)), (_v1[1] = quadraticAt$1(t, r, a, f))
    var g = distSquare(_v1, _v0)
    if (f >= 0 && g < p) (h = f), (p = g)
    else {
      ;(_v2[0] = quadraticAt$1(e, i, n, m)), (_v2[1] = quadraticAt$1(t, r, a, m))
      var y = distSquare(_v2, _v0)
      m <= 1 && y < p ? ((h = m), (p = y)) : (u *= 0.5)
    }
  }
  return (
    l && ((l[0] = quadraticAt$1(e, i, n, h)), (l[1] = quadraticAt$1(t, r, a, h))), mathSqrt$4(p)
  )
}
function quadraticLength(e, t, i, r, n, a, o) {
  for (var s = e, l = t, h = 0, u = 1 / o, p = 1; p <= o; p++) {
    var c = p * u,
      d = quadraticAt$1(e, i, n, c),
      f = quadraticAt$1(t, r, a, c),
      m = d - s,
      g = f - l
    ;(h += Math.sqrt(m * m + g * g)), (s = d), (l = f)
  }
  return h
}
var mathMin$9 = Math.min,
  mathMax$9 = Math.max,
  mathSin$4 = Math.sin,
  mathCos$4 = Math.cos,
  PI2$a = 2 * Math.PI,
  start = create$2(),
  end = create$2(),
  extremity = create$2()
function fromPoints(e, t, i) {
  if (0 !== e.length) {
    for (var r = e[0], n = r[0], a = r[0], o = r[1], s = r[1], l = 1; l < e.length; l++)
      (r = e[l]),
        (n = mathMin$9(n, r[0])),
        (a = mathMax$9(a, r[0])),
        (o = mathMin$9(o, r[1])),
        (s = mathMax$9(s, r[1]))
    ;(t[0] = n), (t[1] = o), (i[0] = a), (i[1] = s)
  }
}
function fromLine(e, t, i, r, n, a) {
  ;(n[0] = mathMin$9(e, i)),
    (n[1] = mathMin$9(t, r)),
    (a[0] = mathMax$9(e, i)),
    (a[1] = mathMax$9(t, r))
}
var xDim = [],
  yDim = []
function fromCubic(e, t, i, r, n, a, o, s, l, h) {
  var u = cubicExtrema,
    p = cubicAt,
    c = u(e, i, n, o, xDim)
  ;(l[0] = 1 / 0), (l[1] = 1 / 0), (h[0] = -1 / 0), (h[1] = -1 / 0)
  for (var d = 0; d < c; d++) {
    var f = p(e, i, n, o, xDim[d])
    ;(l[0] = mathMin$9(f, l[0])), (h[0] = mathMax$9(f, h[0]))
  }
  c = u(t, r, a, s, yDim)
  for (d = 0; d < c; d++) {
    var m = p(t, r, a, s, yDim[d])
    ;(l[1] = mathMin$9(m, l[1])), (h[1] = mathMax$9(m, h[1]))
  }
  ;(l[0] = mathMin$9(e, l[0])),
    (h[0] = mathMax$9(e, h[0])),
    (l[0] = mathMin$9(o, l[0])),
    (h[0] = mathMax$9(o, h[0])),
    (l[1] = mathMin$9(t, l[1])),
    (h[1] = mathMax$9(t, h[1])),
    (l[1] = mathMin$9(s, l[1])),
    (h[1] = mathMax$9(s, h[1]))
}
function fromQuadratic(e, t, i, r, n, a, o, s) {
  var l = quadraticExtremum,
    h = quadraticAt$1,
    u = mathMax$9(mathMin$9(l(e, i, n), 1), 0),
    p = mathMax$9(mathMin$9(l(t, r, a), 1), 0),
    c = h(e, i, n, u),
    d = h(t, r, a, p)
  ;(o[0] = mathMin$9(e, n, c)),
    (o[1] = mathMin$9(t, a, d)),
    (s[0] = mathMax$9(e, n, c)),
    (s[1] = mathMax$9(t, a, d))
}
function fromArc(e, t, i, r, n, a, o, s, l) {
  var h = min$1,
    u = max$1,
    p = Math.abs(n - a)
  if (p % PI2$a < 1e-4 && p > 1e-4)
    return (s[0] = e - i), (s[1] = t - r), (l[0] = e + i), void (l[1] = t + r)
  if (
    ((start[0] = mathCos$4(n) * i + e),
    (start[1] = mathSin$4(n) * r + t),
    (end[0] = mathCos$4(a) * i + e),
    (end[1] = mathSin$4(a) * r + t),
    h(s, start, end),
    u(l, start, end),
    (n %= PI2$a) < 0 && (n += PI2$a),
    (a %= PI2$a) < 0 && (a += PI2$a),
    n > a && !o ? (a += PI2$a) : n < a && o && (n += PI2$a),
    o)
  ) {
    var c = a
    ;(a = n), (n = c)
  }
  for (var d = 0; d < a; d += Math.PI / 2)
    d > n &&
      ((extremity[0] = mathCos$4(d) * i + e),
      (extremity[1] = mathSin$4(d) * r + t),
      h(s, extremity, s),
      u(l, extremity, l))
}
var CMD$4 = { M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, R: 7 },
  tmpOutX = [],
  tmpOutY = [],
  min = [],
  max = [],
  min2 = [],
  max2 = [],
  mathMin$8 = Math.min,
  mathMax$8 = Math.max,
  mathCos$3 = Math.cos,
  mathSin$3 = Math.sin,
  mathSqrt$3 = Math.sqrt,
  mathAbs$2 = Math.abs,
  PI$8 = Math.PI,
  PI2$9 = 2 * PI$8,
  hasTypedArray = 'undefined' != typeof Float32Array,
  tmpAngles = []
function modPI2(e) {
  return ((Math.round((e / PI$8) * 1e8) / 1e8) % 2) * PI$8
}
function normalizeArcAngles(e, t) {
  var i = modPI2(e[0])
  i < 0 && (i += PI2$9)
  var r = i - e[0],
    n = e[1]
  ;(n += r),
    !t && n - i >= PI2$9
      ? (n = i + PI2$9)
      : t && i - n >= PI2$9
      ? (n = i - PI2$9)
      : !t && i > n
      ? (n = i + (PI2$9 - modPI2(i - n)))
      : t && i < n && (n = i - (PI2$9 - modPI2(n - i))),
    (e[0] = i),
    (e[1] = n)
}
var PathProxy = (function () {
  function e(e) {
    ;(this.dpr = 1),
      (this._xi = 0),
      (this._yi = 0),
      (this._x0 = 0),
      (this._y0 = 0),
      (this._len = 0),
      e && (this._saveData = !1),
      this._saveData && (this.data = [])
  }
  var t
  return (
    (e.prototype.increaseVersion = function () {
      this._version++
    }),
    (e.prototype.getVersion = function () {
      return this._version
    }),
    (e.prototype.setScale = function (e, t, i) {
      ;(i = i || 0) > 0 &&
        ((this._ux = mathAbs$2(i / devicePixelRatio / e) || 0),
        (this._uy = mathAbs$2(i / devicePixelRatio / t) || 0))
    }),
    (e.prototype.setDPR = function (e) {
      this.dpr = e
    }),
    (e.prototype.setContext = function (e) {
      this._ctx = e
    }),
    (e.prototype.getContext = function () {
      return this._ctx
    }),
    (e.prototype.beginPath = function () {
      return this._ctx && this._ctx.beginPath(), this.reset(), this
    }),
    (e.prototype.reset = function () {
      this._saveData && (this._len = 0),
        this._lineDash && ((this._lineDash = null), (this._dashOffset = 0)),
        this._pathSegLen && ((this._pathSegLen = null), (this._pathLen = 0)),
        this._version++
    }),
    (e.prototype.moveTo = function (e, t) {
      return (
        this._drawPendingPt(),
        this.addData(CMD$4.M, e, t),
        this._ctx && this._ctx.moveTo(e, t),
        (this._x0 = e),
        (this._y0 = t),
        (this._xi = e),
        (this._yi = t),
        this
      )
    }),
    (e.prototype.lineTo = function (e, t) {
      var i = mathAbs$2(e - this._xi),
        r = mathAbs$2(t - this._yi),
        n = i > this._ux || r > this._uy
      if (
        (this.addData(CMD$4.L, e, t),
        this._ctx && n && (this._needsDash ? this._dashedLineTo(e, t) : this._ctx.lineTo(e, t)),
        n)
      )
        (this._xi = e), (this._yi = t), (this._pendingPtDist = 0)
      else {
        var a = i * i + r * r
        a > this._pendingPtDist &&
          ((this._pendingPtX = e), (this._pendingPtY = t), (this._pendingPtDist = a))
      }
      return this
    }),
    (e.prototype.bezierCurveTo = function (e, t, i, r, n, a) {
      return (
        this.addData(CMD$4.C, e, t, i, r, n, a),
        this._ctx &&
          (this._needsDash
            ? this._dashedBezierTo(e, t, i, r, n, a)
            : this._ctx.bezierCurveTo(e, t, i, r, n, a)),
        (this._xi = n),
        (this._yi = a),
        this
      )
    }),
    (e.prototype.quadraticCurveTo = function (e, t, i, r) {
      return (
        this.addData(CMD$4.Q, e, t, i, r),
        this._ctx &&
          (this._needsDash
            ? this._dashedQuadraticTo(e, t, i, r)
            : this._ctx.quadraticCurveTo(e, t, i, r)),
        (this._xi = i),
        (this._yi = r),
        this
      )
    }),
    (e.prototype.arc = function (e, t, i, r, n, a) {
      ;(tmpAngles[0] = r), (tmpAngles[1] = n), normalizeArcAngles(tmpAngles, a), (r = tmpAngles[0])
      var o = (n = tmpAngles[1]) - r
      return (
        this.addData(CMD$4.A, e, t, i, i, r, o, 0, a ? 0 : 1),
        this._ctx && this._ctx.arc(e, t, i, r, n, a),
        (this._xi = mathCos$3(n) * i + e),
        (this._yi = mathSin$3(n) * i + t),
        this
      )
    }),
    (e.prototype.arcTo = function (e, t, i, r, n) {
      return this._ctx && this._ctx.arcTo(e, t, i, r, n), this
    }),
    (e.prototype.rect = function (e, t, i, r) {
      return this._ctx && this._ctx.rect(e, t, i, r), this.addData(CMD$4.R, e, t, i, r), this
    }),
    (e.prototype.closePath = function () {
      this._drawPendingPt(), this.addData(CMD$4.Z)
      var e = this._ctx,
        t = this._x0,
        i = this._y0
      return (
        e && (this._needsDash && this._dashedLineTo(t, i), e.closePath()),
        (this._xi = t),
        (this._yi = i),
        this
      )
    }),
    (e.prototype.fill = function (e) {
      e && e.fill(), this.toStatic()
    }),
    (e.prototype.stroke = function (e) {
      e && e.stroke(), this.toStatic()
    }),
    (e.prototype.setLineDash = function (e) {
      if (e instanceof Array) {
        ;(this._lineDash = e), (this._dashIdx = 0)
        for (var t = 0, i = 0; i < e.length; i++) t += e[i]
        ;(this._dashSum = t), (this._needsDash = !0)
      } else (this._lineDash = null), (this._needsDash = !1)
      return this
    }),
    (e.prototype.setLineDashOffset = function (e) {
      return (this._dashOffset = e), this
    }),
    (e.prototype.len = function () {
      return this._len
    }),
    (e.prototype.setData = function (e) {
      var t = e.length
      ;(this.data && this.data.length === t) || !hasTypedArray || (this.data = new Float32Array(t))
      for (var i = 0; i < t; i++) this.data[i] = e[i]
      this._len = t
    }),
    (e.prototype.appendPath = function (e) {
      e instanceof Array || (e = [e])
      for (var t = e.length, i = 0, r = this._len, n = 0; n < t; n++) i += e[n].len()
      hasTypedArray && this.data instanceof Float32Array && (this.data = new Float32Array(r + i))
      for (n = 0; n < t; n++)
        for (var a = e[n].data, o = 0; o < a.length; o++) this.data[r++] = a[o]
      this._len = r
    }),
    (e.prototype.addData = function (e, t, i, r, n, a, o, s, l) {
      if (this._saveData) {
        var h = this.data
        this._len + arguments.length > h.length && (this._expandData(), (h = this.data))
        for (var u = 0; u < arguments.length; u++) h[this._len++] = arguments[u]
      }
    }),
    (e.prototype._drawPendingPt = function () {
      this._pendingPtDist > 0 &&
        (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY),
        (this._pendingPtDist = 0))
    }),
    (e.prototype._expandData = function () {
      if (!(this.data instanceof Array)) {
        for (var e = [], t = 0; t < this._len; t++) e[t] = this.data[t]
        this.data = e
      }
    }),
    (e.prototype._dashedLineTo = function (e, t) {
      var i,
        r,
        n = this._dashSum,
        a = this._lineDash,
        o = this._ctx,
        s = this._dashOffset,
        l = this._xi,
        h = this._yi,
        u = e - l,
        p = t - h,
        c = mathSqrt$3(u * u + p * p),
        d = l,
        f = h,
        m = a.length
      for (
        s < 0 && (s = n + s), d -= (s %= n) * (u /= c), f -= s * (p /= c);
        (u > 0 && d <= e) ||
        (u < 0 && d >= e) ||
        (0 === u && ((p > 0 && f <= t) || (p < 0 && f >= t)));

      )
        (d += u * (i = a[(r = this._dashIdx)])),
          (f += p * i),
          (this._dashIdx = (r + 1) % m),
          (u > 0 && d < l) ||
            (u < 0 && d > l) ||
            (p > 0 && f < h) ||
            (p < 0 && f > h) ||
            o[r % 2 ? 'moveTo' : 'lineTo'](
              u >= 0 ? mathMin$8(d, e) : mathMax$8(d, e),
              p >= 0 ? mathMin$8(f, t) : mathMax$8(f, t)
            )
      ;(u = d - e), (p = f - t), (this._dashOffset = -mathSqrt$3(u * u + p * p))
    }),
    (e.prototype._dashedBezierTo = function (e, t, i, r, n, a) {
      var o,
        s,
        l,
        h,
        u,
        p = this._ctx,
        c = this._dashSum,
        d = this._dashOffset,
        f = this._lineDash,
        m = this._xi,
        g = this._yi,
        y = 0,
        v = this._dashIdx,
        _ = f.length,
        x = 0
      for (d < 0 && (d = c + d), d %= c, o = 0; o < 1; o += 0.1)
        (s = cubicAt(m, e, i, n, o + 0.1) - cubicAt(m, e, i, n, o)),
          (l = cubicAt(g, t, r, a, o + 0.1) - cubicAt(g, t, r, a, o)),
          (y += mathSqrt$3(s * s + l * l))
      for (; v < _ && !((x += f[v]) > d); v++);
      for (o = (x - d) / y; o <= 1; )
        (h = cubicAt(m, e, i, n, o)),
          (u = cubicAt(g, t, r, a, o)),
          v % 2 ? p.moveTo(h, u) : p.lineTo(h, u),
          (o += f[v] / y),
          (v = (v + 1) % _)
      v % 2 != 0 && p.lineTo(n, a),
        (s = n - h),
        (l = a - u),
        (this._dashOffset = -mathSqrt$3(s * s + l * l))
    }),
    (e.prototype._dashedQuadraticTo = function (e, t, i, r) {
      var n = i,
        a = r
      ;(i = (i + 2 * e) / 3),
        (r = (r + 2 * t) / 3),
        (e = (this._xi + 2 * e) / 3),
        (t = (this._yi + 2 * t) / 3),
        this._dashedBezierTo(e, t, i, r, n, a)
    }),
    (e.prototype.toStatic = function () {
      if (this._saveData) {
        this._drawPendingPt()
        var e = this.data
        e instanceof Array &&
          ((e.length = this._len),
          hasTypedArray && this._len > 11 && (this.data = new Float32Array(e)))
      }
    }),
    (e.prototype.getBoundingRect = function () {
      ;(min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE),
        (max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE)
      var e,
        t = this.data,
        i = 0,
        r = 0,
        n = 0,
        a = 0
      for (e = 0; e < this._len; ) {
        var o = t[e++],
          s = 1 === e
        switch ((s && ((n = i = t[e]), (a = r = t[e + 1])), o)) {
          case CMD$4.M:
            ;(i = n = t[e++]),
              (r = a = t[e++]),
              (min2[0] = n),
              (min2[1] = a),
              (max2[0] = n),
              (max2[1] = a)
            break
          case CMD$4.L:
            fromLine(i, r, t[e], t[e + 1], min2, max2), (i = t[e++]), (r = t[e++])
            break
          case CMD$4.C:
            fromCubic(i, r, t[e++], t[e++], t[e++], t[e++], t[e], t[e + 1], min2, max2),
              (i = t[e++]),
              (r = t[e++])
            break
          case CMD$4.Q:
            fromQuadratic(i, r, t[e++], t[e++], t[e], t[e + 1], min2, max2),
              (i = t[e++]),
              (r = t[e++])
            break
          case CMD$4.A:
            var l = t[e++],
              h = t[e++],
              u = t[e++],
              p = t[e++],
              c = t[e++],
              d = t[e++] + c
            e += 1
            var f = !t[e++]
            s && ((n = mathCos$3(c) * u + l), (a = mathSin$3(c) * p + h)),
              fromArc(l, h, u, p, c, d, f, min2, max2),
              (i = mathCos$3(d) * u + l),
              (r = mathSin$3(d) * p + h)
            break
          case CMD$4.R:
            fromLine((n = i = t[e++]), (a = r = t[e++]), n + t[e++], a + t[e++], min2, max2)
            break
          case CMD$4.Z:
            ;(i = n), (r = a)
        }
        min$1(min, min, min2), max$1(max, max, max2)
      }
      return (
        0 === e && (min[0] = min[1] = max[0] = max[1] = 0),
        new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1])
      )
    }),
    (e.prototype._calculateLength = function () {
      var e = this.data,
        t = this._len,
        i = this._ux,
        r = this._uy,
        n = 0,
        a = 0,
        o = 0,
        s = 0
      this._pathSegLen || (this._pathSegLen = [])
      for (var l = this._pathSegLen, h = 0, u = 0, p = 0; p < t; ) {
        var c = e[p++],
          d = 1 === p
        d && ((o = n = e[p]), (s = a = e[p + 1]))
        var f = -1
        switch (c) {
          case CMD$4.M:
            ;(n = o = e[p++]), (a = s = e[p++])
            break
          case CMD$4.L:
            var m = e[p++],
              g = (_ = e[p++]) - a
            ;(mathAbs$2((E = m - n)) > i || mathAbs$2(g) > r || p === t - 1) &&
              ((f = Math.sqrt(E * E + g * g)), (n = m), (a = _))
            break
          case CMD$4.C:
            var y = e[p++],
              v = e[p++],
              _ = ((m = e[p++]), e[p++]),
              x = e[p++],
              S = e[p++]
            ;(f = cubicLength(n, a, y, v, m, _, x, S, 10)), (n = x), (a = S)
            break
          case CMD$4.Q:
            ;(f = quadraticLength(
              n,
              a,
              (y = e[p++]),
              (v = e[p++]),
              (m = e[p++]),
              (_ = e[p++]),
              10
            )),
              (n = m),
              (a = _)
            break
          case CMD$4.A:
            var b = e[p++],
              T = e[p++],
              A = e[p++],
              w = e[p++],
              M = e[p++],
              C = e[p++],
              P = C + M
            ;(p += 1),
              e[p++],
              d && ((o = mathCos$3(M) * A + b), (s = mathSin$3(M) * w + T)),
              (f = mathMax$8(A, w) * mathMin$8(PI2$9, Math.abs(C))),
              (n = mathCos$3(P) * A + b),
              (a = mathSin$3(P) * w + T)
            break
          case CMD$4.R:
            ;(o = n = e[p++]), (s = a = e[p++]), (f = 2 * e[p++] + 2 * e[p++])
            break
          case CMD$4.Z:
            var E = o - n
            g = s - a
            ;(f = Math.sqrt(E * E + g * g)), (n = o), (a = s)
        }
        f >= 0 && ((l[u++] = f), (h += f))
      }
      return (this._pathLen = h), h
    }),
    (e.prototype.rebuildPath = function (e, t) {
      var i,
        r,
        n,
        a,
        o,
        s,
        l,
        h,
        u,
        p,
        c = this.data,
        d = this._ux,
        f = this._uy,
        m = this._len,
        g = t < 1,
        y = 0,
        v = 0,
        _ = 0
      if (
        !g ||
        (this._pathSegLen || this._calculateLength(),
        (l = this._pathSegLen),
        (h = t * this._pathLen))
      )
        e: for (var x = 0; x < m; ) {
          var S = c[x++],
            b = 1 === x
          switch ((b && ((i = n = c[x]), (r = a = c[x + 1])), S)) {
            case CMD$4.M:
              _ > 0 && (e.lineTo(u, p), (_ = 0)), (i = n = c[x++]), (r = a = c[x++]), e.moveTo(n, a)
              break
            case CMD$4.L:
              ;(o = c[x++]), (s = c[x++])
              var T = mathAbs$2(o - n),
                A = mathAbs$2(s - a)
              if (T > d || A > f) {
                if (g) {
                  if (y + (Z = l[v++]) > h) {
                    var w = (h - y) / Z
                    e.lineTo(n * (1 - w) + o * w, a * (1 - w) + s * w)
                    break e
                  }
                  y += Z
                }
                e.lineTo(o, s), (n = o), (a = s), (_ = 0)
              } else {
                var M = T * T + A * A
                M > _ && ((u = o), (p = s), (_ = M))
              }
              break
            case CMD$4.C:
              var C = c[x++],
                P = c[x++],
                E = c[x++],
                I = c[x++],
                D = c[x++],
                L = c[x++]
              if (g) {
                if (y + (Z = l[v++]) > h) {
                  cubicSubdivide(n, C, E, D, (w = (h - y) / Z), tmpOutX),
                    cubicSubdivide(a, P, I, L, w, tmpOutY),
                    e.bezierCurveTo(
                      tmpOutX[1],
                      tmpOutY[1],
                      tmpOutX[2],
                      tmpOutY[2],
                      tmpOutX[3],
                      tmpOutY[3]
                    )
                  break e
                }
                y += Z
              }
              e.bezierCurveTo(C, P, E, I, D, L), (n = D), (a = L)
              break
            case CMD$4.Q:
              ;(C = c[x++]), (P = c[x++]), (E = c[x++]), (I = c[x++])
              if (g) {
                if (y + (Z = l[v++]) > h) {
                  quadraticSubdivide(n, C, E, (w = (h - y) / Z), tmpOutX),
                    quadraticSubdivide(a, P, I, w, tmpOutY),
                    e.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2])
                  break e
                }
                y += Z
              }
              e.quadraticCurveTo(C, P, E, I), (n = E), (a = I)
              break
            case CMD$4.A:
              var R = c[x++],
                O = c[x++],
                k = c[x++],
                $ = c[x++],
                N = c[x++],
                F = c[x++],
                B = c[x++],
                V = !c[x++],
                z = k > $ ? k : $,
                G = mathAbs$2(k - $) > 0.001,
                H = N + F,
                U = !1
              if (g) y + (Z = l[v++]) > h && ((H = N + (F * (h - y)) / Z), (U = !0)), (y += Z)
              if ((G && e.ellipse ? e.ellipse(R, O, k, $, B, N, H, V) : e.arc(R, O, z, N, H, V), U))
                break e
              b && ((i = mathCos$3(N) * k + R), (r = mathSin$3(N) * $ + O)),
                (n = mathCos$3(H) * k + R),
                (a = mathSin$3(H) * $ + O)
              break
            case CMD$4.R:
              ;(i = n = c[x]), (r = a = c[x + 1]), (o = c[x++]), (s = c[x++])
              var Y = c[x++],
                W = c[x++]
              if (g) {
                if (y + (Z = l[v++]) > h) {
                  var j = h - y
                  e.moveTo(o, s),
                    e.lineTo(o + mathMin$8(j, Y), s),
                    (j -= Y) > 0 && e.lineTo(o + Y, s + mathMin$8(j, W)),
                    (j -= W) > 0 && e.lineTo(o + mathMax$8(Y - j, 0), s + W),
                    (j -= Y) > 0 && e.lineTo(o, s + mathMax$8(W - j, 0))
                  break e
                }
                y += Z
              }
              e.rect(o, s, Y, W)
              break
            case CMD$4.Z:
              if ((_ > 0 && (e.lineTo(u, p), (_ = 0)), g)) {
                var Z
                if (y + (Z = l[v++]) > h) {
                  w = (h - y) / Z
                  e.lineTo(n * (1 - w) + i * w, a * (1 - w) + r * w)
                  break e
                }
                y += Z
              }
              e.closePath(), (n = i), (a = r)
          }
        }
    }),
    (e.CMD = CMD$4),
    (e.initDefaultProps =
      (((t = e.prototype)._saveData = !0),
      (t._needsDash = !1),
      (t._dashOffset = 0),
      (t._dashIdx = 0),
      (t._dashSum = 0),
      (t._ux = 0),
      (t._uy = 0),
      (t._pendingPtDist = 0),
      void (t._version = 0))),
    e
  )
})()
function containStroke$4(e, t, i, r, n, a, o) {
  if (0 === n) return !1
  var s = n,
    l = 0
  if (
    (o > t + s && o > r + s) ||
    (o < t - s && o < r - s) ||
    (a > e + s && a > i + s) ||
    (a < e - s && a < i - s)
  )
    return !1
  if (e === i) return Math.abs(a - e) <= s / 2
  var h = (l = (t - r) / (e - i)) * a - o + (e * r - i * t) / (e - i)
  return (h * h) / (l * l + 1) <= ((s / 2) * s) / 2
}
function containStroke$3(e, t, i, r, n, a, o, s, l, h, u) {
  if (0 === l) return !1
  var p = l
  return (
    !(
      (u > t + p && u > r + p && u > a + p && u > s + p) ||
      (u < t - p && u < r - p && u < a - p && u < s - p) ||
      (h > e + p && h > i + p && h > n + p && h > o + p) ||
      (h < e - p && h < i - p && h < n - p && h < o - p)
    ) && cubicProjectPoint(e, t, i, r, n, a, o, s, h, u, null) <= p / 2
  )
}
function containStroke$2(e, t, i, r, n, a, o, s, l) {
  if (0 === o) return !1
  var h = o
  return (
    !(
      (l > t + h && l > r + h && l > a + h) ||
      (l < t - h && l < r - h && l < a - h) ||
      (s > e + h && s > i + h && s > n + h) ||
      (s < e - h && s < i - h && s < n - h)
    ) && quadraticProjectPoint(e, t, i, r, n, a, s, l, null) <= h / 2
  )
}
var PI2$8 = 2 * Math.PI
function normalizeRadian$1(e) {
  return (e %= PI2$8) < 0 && (e += PI2$8), e
}
var PI2$7 = 2 * Math.PI
function containStroke$1(e, t, i, r, n, a, o, s, l) {
  if (0 === o) return !1
  var h = o
  ;(s -= e), (l -= t)
  var u = Math.sqrt(s * s + l * l)
  if (u - h > i || u + h < i) return !1
  if (Math.abs(r - n) % PI2$7 < 1e-4) return !0
  if (a) {
    var p = r
    ;(r = normalizeRadian$1(n)), (n = normalizeRadian$1(p))
  } else (r = normalizeRadian$1(r)), (n = normalizeRadian$1(n))
  r > n && (n += PI2$7)
  var c = Math.atan2(l, s)
  return c < 0 && (c += PI2$7), (c >= r && c <= n) || (c + PI2$7 >= r && c + PI2$7 <= n)
}
function windingLine(e, t, i, r, n, a) {
  if ((a > t && a > r) || (a < t && a < r)) return 0
  if (r === t) return 0
  var o = (a - t) / (r - t),
    s = r < t ? 1 : -1
  ;(1 !== o && 0 !== o) || (s = r < t ? 0.5 : -0.5)
  var l = o * (i - e) + e
  return l === n ? 1 / 0 : l > n ? s : 0
}
var CMD$3 = PathProxy.CMD,
  PI2$6 = 2 * Math.PI,
  EPSILON$2 = 1e-4
function isAroundEqual$1(e, t) {
  return Math.abs(e - t) < EPSILON$2
}
var roots = [-1, -1, -1],
  extrema = [-1, -1]
function swapExtrema() {
  var e = extrema[0]
  ;(extrema[0] = extrema[1]), (extrema[1] = e)
}
function windingCubic(e, t, i, r, n, a, o, s, l, h) {
  if ((h > t && h > r && h > a && h > s) || (h < t && h < r && h < a && h < s)) return 0
  var u = cubicRootAt(t, r, a, s, h, roots)
  if (0 === u) return 0
  for (var p = 0, c = -1, d = void 0, f = void 0, m = 0; m < u; m++) {
    var g = roots[m],
      y = 0 === g || 1 === g ? 0.5 : 1
    cubicAt(e, i, n, o, g) < l ||
      (c < 0 &&
        ((c = cubicExtrema(t, r, a, s, extrema)),
        extrema[1] < extrema[0] && c > 1 && swapExtrema(),
        (d = cubicAt(t, r, a, s, extrema[0])),
        c > 1 && (f = cubicAt(t, r, a, s, extrema[1]))),
      2 === c
        ? g < extrema[0]
          ? (p += d < t ? y : -y)
          : g < extrema[1]
          ? (p += f < d ? y : -y)
          : (p += s < f ? y : -y)
        : g < extrema[0]
        ? (p += d < t ? y : -y)
        : (p += s < d ? y : -y))
  }
  return p
}
function windingQuadratic(e, t, i, r, n, a, o, s) {
  if ((s > t && s > r && s > a) || (s < t && s < r && s < a)) return 0
  var l = quadraticRootAt(t, r, a, s, roots)
  if (0 === l) return 0
  var h = quadraticExtremum(t, r, a)
  if (h >= 0 && h <= 1) {
    for (var u = 0, p = quadraticAt$1(t, r, a, h), c = 0; c < l; c++) {
      var d = 0 === roots[c] || 1 === roots[c] ? 0.5 : 1
      quadraticAt$1(e, i, n, roots[c]) < o ||
        (roots[c] < h ? (u += p < t ? d : -d) : (u += a < p ? d : -d))
    }
    return u
  }
  d = 0 === roots[0] || 1 === roots[0] ? 0.5 : 1
  return quadraticAt$1(e, i, n, roots[0]) < o ? 0 : a < t ? d : -d
}
function windingArc(e, t, i, r, n, a, o, s) {
  if ((s -= t) > i || s < -i) return 0
  var l = Math.sqrt(i * i - s * s)
  ;(roots[0] = -l), (roots[1] = l)
  var h = Math.abs(r - n)
  if (h < 1e-4) return 0
  if (h >= PI2$6 - 1e-4) {
    ;(r = 0), (n = PI2$6)
    var u = a ? 1 : -1
    return o >= roots[0] + e && o <= roots[1] + e ? u : 0
  }
  if (r > n) {
    var p = r
    ;(r = n), (n = p)
  }
  r < 0 && ((r += PI2$6), (n += PI2$6))
  for (var c = 0, d = 0; d < 2; d++) {
    var f = roots[d]
    if (f + e > o) {
      var m = Math.atan2(s, f)
      u = a ? 1 : -1
      m < 0 && (m = PI2$6 + m),
        ((m >= r && m <= n) || (m + PI2$6 >= r && m + PI2$6 <= n)) &&
          (m > Math.PI / 2 && m < 1.5 * Math.PI && (u = -u), (c += u))
    }
  }
  return c
}
function containPath(e, t, i, r, n) {
  for (var a, o, s = e.data, l = e.len(), h = 0, u = 0, p = 0, c = 0, d = 0, f = 0; f < l; ) {
    var m = s[f++],
      g = 1 === f
    switch (
      (m === CMD$3.M && f > 1 && (i || (h += windingLine(u, p, c, d, r, n))),
      g && ((c = u = s[f]), (d = p = s[f + 1])),
      m)
    ) {
      case CMD$3.M:
        ;(u = c = s[f++]), (p = d = s[f++])
        break
      case CMD$3.L:
        if (i) {
          if (containStroke$4(u, p, s[f], s[f + 1], t, r, n)) return !0
        } else h += windingLine(u, p, s[f], s[f + 1], r, n) || 0
        ;(u = s[f++]), (p = s[f++])
        break
      case CMD$3.C:
        if (i) {
          if (containStroke$3(u, p, s[f++], s[f++], s[f++], s[f++], s[f], s[f + 1], t, r, n))
            return !0
        } else h += windingCubic(u, p, s[f++], s[f++], s[f++], s[f++], s[f], s[f + 1], r, n) || 0
        ;(u = s[f++]), (p = s[f++])
        break
      case CMD$3.Q:
        if (i) {
          if (containStroke$2(u, p, s[f++], s[f++], s[f], s[f + 1], t, r, n)) return !0
        } else h += windingQuadratic(u, p, s[f++], s[f++], s[f], s[f + 1], r, n) || 0
        ;(u = s[f++]), (p = s[f++])
        break
      case CMD$3.A:
        var y = s[f++],
          v = s[f++],
          _ = s[f++],
          x = s[f++],
          S = s[f++],
          b = s[f++]
        f += 1
        var T = !!(1 - s[f++])
        ;(a = Math.cos(S) * _ + y),
          (o = Math.sin(S) * x + v),
          g ? ((c = a), (d = o)) : (h += windingLine(u, p, a, o, r, n))
        var A = ((r - y) * x) / _ + y
        if (i) {
          if (containStroke$1(y, v, x, S, S + b, T, t, A, n)) return !0
        } else h += windingArc(y, v, x, S, S + b, T, A, n)
        ;(u = Math.cos(S + b) * _ + y), (p = Math.sin(S + b) * x + v)
        break
      case CMD$3.R:
        if (((c = u = s[f++]), (d = p = s[f++]), (a = c + s[f++]), (o = d + s[f++]), i)) {
          if (
            containStroke$4(c, d, a, d, t, r, n) ||
            containStroke$4(a, d, a, o, t, r, n) ||
            containStroke$4(a, o, c, o, t, r, n) ||
            containStroke$4(c, o, c, d, t, r, n)
          )
            return !0
        } else (h += windingLine(a, d, a, o, r, n)), (h += windingLine(c, o, c, d, r, n))
        break
      case CMD$3.Z:
        if (i) {
          if (containStroke$4(u, p, c, d, t, r, n)) return !0
        } else h += windingLine(u, p, c, d, r, n)
        ;(u = c), (p = d)
    }
  }
  return i || isAroundEqual$1(p, d) || (h += windingLine(u, p, c, d, r, n) || 0), 0 !== h
}
function contain$2(e, t, i) {
  return containPath(e, 0, !1, t, i)
}
function containStroke(e, t, i, r) {
  return containPath(e, t, !0, i, r)
}
var DEFAULT_PATH_STYLE = defaults$1(
    {
      fill: '#000',
      stroke: null,
      strokePercent: 1,
      fillOpacity: 1,
      strokeOpacity: 1,
      lineDashOffset: 0,
      lineWidth: 1,
      lineCap: 'butt',
      miterLimit: 10,
      strokeNoScale: !1,
      strokeFirst: !1
    },
    DEFAULT_COMMON_STYLE
  ),
  DEFAULT_PATH_ANIMATION_PROPS = {
    style: defaults$1(
      {
        fill: !0,
        stroke: !0,
        strokePercent: !0,
        fillOpacity: !0,
        strokeOpacity: !0,
        lineDashOffset: !0,
        lineWidth: !0,
        miterLimit: !0
      },
      DEFAULT_COMMON_ANIMATION_PROPS.style
    )
  },
  pathCopyParams = [
    'x',
    'y',
    'rotation',
    'scaleX',
    'scaleY',
    'originX',
    'originY',
    'invisible',
    'culling',
    'z',
    'z2',
    'zlevel',
    'parent'
  ],
  Path = (function (e) {
    function t(t) {
      return e.call(this, t) || this
    }
    var i
    return (
      __extends(t, e),
      (t.prototype.update = function () {
        var i = this
        e.prototype.update.call(this)
        var r = this.style
        if (r.decal) {
          var n = (this._decalEl = this._decalEl || new t())
          n.buildPath === t.prototype.buildPath &&
            (n.buildPath = function (e) {
              i.buildPath(e, i.shape)
            }),
            (n.silent = !0)
          var a = n.style
          for (var o in r) a[o] !== r[o] && (a[o] = r[o])
          ;(a.fill = r.fill ? r.decal : null),
            (a.decal = null),
            (a.shadowColor = null),
            r.strokeFirst && (a.stroke = null)
          for (var s = 0; s < pathCopyParams.length; ++s)
            n[pathCopyParams[s]] = this[pathCopyParams[s]]
          n.__dirty |= REDARAW_BIT
        } else this._decalEl && (this._decalEl = null)
      }),
      (t.prototype.getDecalElement = function () {
        return this._decalEl
      }),
      (t.prototype._init = function (t) {
        var i = keys(t)
        this.shape = this.getDefaultShape()
        var r = this.getDefaultStyle()
        r && this.useStyle(r)
        for (var n = 0; n < i.length; n++) {
          var a = i[n],
            o = t[a]
          'style' === a
            ? this.style
              ? extend$3(this.style, o)
              : this.useStyle(o)
            : 'shape' === a
            ? extend$3(this.shape, o)
            : e.prototype.attrKV.call(this, a, o)
        }
        this.style || this.useStyle({})
      }),
      (t.prototype.getDefaultStyle = function () {
        return null
      }),
      (t.prototype.getDefaultShape = function () {
        return {}
      }),
      (t.prototype.canBeInsideText = function () {
        return this.hasFill()
      }),
      (t.prototype.getInsideTextFill = function () {
        var e = this.style.fill
        if ('none' !== e) {
          if (isString(e)) {
            var t = lum(e, 0)
            return t > 0.5 ? DARK_LABEL_COLOR : t > 0.2 ? LIGHTER_LABEL_COLOR : LIGHT_LABEL_COLOR
          }
          if (e) return LIGHT_LABEL_COLOR
        }
        return DARK_LABEL_COLOR
      }),
      (t.prototype.getInsideTextStroke = function (e) {
        var t = this.style.fill
        if (isString(t)) {
          var i = this.__zr
          if (!(!i || !i.isDarkMode()) === lum(e, 0) < DARK_MODE_THRESHOLD) return t
        }
      }),
      (t.prototype.buildPath = function (e, t, i) {}),
      (t.prototype.pathUpdated = function () {
        this.__dirty &= ~SHAPE_CHANGED_BIT
      }),
      (t.prototype.createPathProxy = function () {
        this.path = new PathProxy(!1)
      }),
      (t.prototype.hasStroke = function () {
        var e = this.style,
          t = e.stroke
        return !(null == t || 'none' === t || !(e.lineWidth > 0))
      }),
      (t.prototype.hasFill = function () {
        var e = this.style.fill
        return null != e && 'none' !== e
      }),
      (t.prototype.getBoundingRect = function () {
        var e = this._rect,
          t = this.style,
          i = !e
        if (i) {
          var r = !1
          this.path || ((r = !0), this.createPathProxy())
          var n = this.path
          ;(r || this.__dirty & SHAPE_CHANGED_BIT) &&
            (n.beginPath(), this.buildPath(n, this.shape, !1), this.pathUpdated()),
            (e = n.getBoundingRect())
        }
        if (((this._rect = e), this.hasStroke() && this.path && this.path.len() > 0)) {
          var a = this._rectWithStroke || (this._rectWithStroke = e.clone())
          if (this.__dirty || i) {
            a.copy(e)
            var o = t.strokeNoScale ? this.getLineScale() : 1,
              s = t.lineWidth
            if (!this.hasFill()) {
              var l = this.strokeContainThreshold
              s = Math.max(s, null == l ? 4 : l)
            }
            o > 1e-10 &&
              ((a.width += s / o), (a.height += s / o), (a.x -= s / o / 2), (a.y -= s / o / 2))
          }
          return a
        }
        return e
      }),
      (t.prototype.contain = function (e, t) {
        var i = this.transformCoordToLocal(e, t),
          r = this.getBoundingRect(),
          n = this.style
        if (((e = i[0]), (t = i[1]), r.contain(e, t))) {
          var a = this.path
          if (this.hasStroke()) {
            var o = n.lineWidth,
              s = n.strokeNoScale ? this.getLineScale() : 1
            if (
              s > 1e-10 &&
              (this.hasFill() || (o = Math.max(o, this.strokeContainThreshold)),
              containStroke(a, o / s, e, t))
            )
              return !0
          }
          if (this.hasFill()) return contain$2(a, e, t)
        }
        return !1
      }),
      (t.prototype.dirtyShape = function () {
        ;(this.__dirty |= SHAPE_CHANGED_BIT),
          this._rect && (this._rect = null),
          this._decalEl && this._decalEl.dirtyShape(),
          this.markRedraw()
      }),
      (t.prototype.dirty = function () {
        this.dirtyStyle(), this.dirtyShape()
      }),
      (t.prototype.animateShape = function (e) {
        return this.animate('shape', e)
      }),
      (t.prototype.updateDuringAnimation = function (e) {
        'style' === e ? this.dirtyStyle() : 'shape' === e ? this.dirtyShape() : this.markRedraw()
      }),
      (t.prototype.attrKV = function (t, i) {
        'shape' === t ? this.setShape(i) : e.prototype.attrKV.call(this, t, i)
      }),
      (t.prototype.setShape = function (e, t) {
        var i = this.shape
        return (
          i || (i = this.shape = {}),
          'string' == typeof e ? (i[e] = t) : extend$3(i, e),
          this.dirtyShape(),
          this
        )
      }),
      (t.prototype.shapeChanged = function () {
        return !!(this.__dirty & SHAPE_CHANGED_BIT)
      }),
      (t.prototype.createStyle = function (e) {
        return createObject(DEFAULT_PATH_STYLE, e)
      }),
      (t.prototype._innerSaveToNormal = function (t) {
        e.prototype._innerSaveToNormal.call(this, t)
        var i = this._normalState
        t.shape && !i.shape && (i.shape = extend$3({}, this.shape))
      }),
      (t.prototype._applyStateObj = function (t, i, r, n, a, o) {
        e.prototype._applyStateObj.call(this, t, i, r, n, a, o)
        var s,
          l = !(i && n)
        if (
          (i && i.shape
            ? a
              ? n
                ? (s = i.shape)
                : ((s = extend$3({}, r.shape)), extend$3(s, i.shape))
              : ((s = extend$3({}, n ? this.shape : r.shape)), extend$3(s, i.shape))
            : l && (s = r.shape),
          s)
        )
          if (a) {
            this.shape = extend$3({}, this.shape)
            for (var h = {}, u = keys(s), p = 0; p < u.length; p++) {
              var c = u[p]
              'object' == typeof s[c] ? (this.shape[c] = s[c]) : (h[c] = s[c])
            }
            this._transitionState(t, { shape: h }, o)
          } else (this.shape = s), this.dirtyShape()
      }),
      (t.prototype._mergeStates = function (t) {
        for (var i, r = e.prototype._mergeStates.call(this, t), n = 0; n < t.length; n++) {
          var a = t[n]
          a.shape && ((i = i || {}), this._mergeStyle(i, a.shape))
        }
        return i && (r.shape = i), r
      }),
      (t.prototype.getAnimationStyleProps = function () {
        return DEFAULT_PATH_ANIMATION_PROPS
      }),
      (t.prototype.isZeroArea = function () {
        return !1
      }),
      (t.extend = function (e) {
        var i = (function (t) {
          function i(i) {
            var r = t.call(this, i) || this
            return e.init && e.init.call(r, i), r
          }
          return (
            __extends(i, t),
            (i.prototype.getDefaultStyle = function () {
              return clone$3(e.style)
            }),
            (i.prototype.getDefaultShape = function () {
              return clone$3(e.shape)
            }),
            i
          )
        })(t)
        for (var r in e) 'function' == typeof e[r] && (i.prototype[r] = e[r])
        return i
      }),
      (t.initDefaultProps =
        (((i = t.prototype).type = 'path'),
        (i.strokeContainThreshold = 5),
        (i.segmentIgnoreThreshold = 0),
        (i.subPixelOptimize = !1),
        (i.autoBatch = !1),
        void (i.__dirty = REDARAW_BIT | STYLE_CHANGED_BIT | SHAPE_CHANGED_BIT))),
      t
    )
  })(Displayable),
  DEFAULT_TSPAN_STYLE = defaults$1(
    {
      strokeFirst: !0,
      font: DEFAULT_FONT,
      x: 0,
      y: 0,
      textAlign: 'left',
      textBaseline: 'top',
      miterLimit: 2
    },
    DEFAULT_PATH_STYLE
  ),
  TSpan = (function (e) {
    function t() {
      return (null !== e && e.apply(this, arguments)) || this
    }
    return (
      __extends(t, e),
      (t.prototype.hasStroke = function () {
        var e = this.style,
          t = e.stroke
        return null != t && 'none' !== t && e.lineWidth > 0
      }),
      (t.prototype.hasFill = function () {
        var e = this.style.fill
        return null != e && 'none' !== e
      }),
      (t.prototype.createStyle = function (e) {
        return createObject(DEFAULT_TSPAN_STYLE, e)
      }),
      (t.prototype.setBoundingRect = function (e) {
        this._rect = e
      }),
      (t.prototype.getBoundingRect = function () {
        var e = this.style
        if (!this._rect) {
          var t = e.text
          null != t ? (t += '') : (t = '')
          var i = getBoundingRect(t, e.font, e.textAlign, e.textBaseline)
          if (((i.x += e.x || 0), (i.y += e.y || 0), this.hasStroke())) {
            var r = e.lineWidth
            ;(i.x -= r / 2), (i.y -= r / 2), (i.width += r), (i.height += r)
          }
          this._rect = i
        }
        return this._rect
      }),
      (t.initDefaultProps = void (t.prototype.dirtyRectTolerance = 10)),
      t
    )
  })(Displayable)
TSpan.prototype.type = 'tspan'
var DEFAULT_IMAGE_STYLE = defaults$1({ x: 0, y: 0 }, DEFAULT_COMMON_STYLE),
  DEFAULT_IMAGE_ANIMATION_PROPS = {
    style: defaults$1(
      { x: !0, y: !0, width: !0, height: !0, sx: !0, sy: !0, sWidth: !0, sHeight: !0 },
      DEFAULT_COMMON_ANIMATION_PROPS.style
    )
  }
function isImageLike(e) {
  return !!(e && 'string' != typeof e && e.width && e.height)
}
var ZRImage = (function (e) {
  function t() {
    return (null !== e && e.apply(this, arguments)) || this
  }
  return (
    __extends(t, e),
    (t.prototype.createStyle = function (e) {
      return createObject(DEFAULT_IMAGE_STYLE, e)
    }),
    (t.prototype._getSize = function (e) {
      var t = this.style,
        i = t[e]
      if (null != i) return i
      var r = isImageLike(t.image) ? t.image : this.__image
      if (!r) return 0
      var n = 'width' === e ? 'height' : 'width',
        a = t[n]
      return null == a ? r[e] : (r[e] / r[n]) * a
    }),
    (t.prototype.getWidth = function () {
      return this._getSize('width')
    }),
    (t.prototype.getHeight = function () {
      return this._getSize('height')
    }),
    (t.prototype.getAnimationStyleProps = function () {
      return DEFAULT_IMAGE_ANIMATION_PROPS
    }),
    (t.prototype.getBoundingRect = function () {
      var e = this.style
      return (
        this._rect ||
          (this._rect = new BoundingRect(e.x || 0, e.y || 0, this.getWidth(), this.getHeight())),
        this._rect
      )
    }),
    t
  )
})(Displayable)
function buildPath$2(e, t) {
  var i,
    r,
    n,
    a,
    o,
    s = t.x,
    l = t.y,
    h = t.width,
    u = t.height,
    p = t.r
  h < 0 && ((s += h), (h = -h)),
    u < 0 && ((l += u), (u = -u)),
    'number' == typeof p
      ? (i = r = n = a = p)
      : p instanceof Array
      ? 1 === p.length
        ? (i = r = n = a = p[0])
        : 2 === p.length
        ? ((i = n = p[0]), (r = a = p[1]))
        : 3 === p.length
        ? ((i = p[0]), (r = a = p[1]), (n = p[2]))
        : ((i = p[0]), (r = p[1]), (n = p[2]), (a = p[3]))
      : (i = r = n = a = 0),
    i + r > h && ((i *= h / (o = i + r)), (r *= h / o)),
    n + a > h && ((n *= h / (o = n + a)), (a *= h / o)),
    r + n > u && ((r *= u / (o = r + n)), (n *= u / o)),
    i + a > u && ((i *= u / (o = i + a)), (a *= u / o)),
    e.moveTo(s + i, l),
    e.lineTo(s + h - r, l),
    0 !== r && e.arc(s + h - r, l + r, r, -Math.PI / 2, 0),
    e.lineTo(s + h, l + u - n),
    0 !== n && e.arc(s + h - n, l + u - n, n, 0, Math.PI / 2),
    e.lineTo(s + a, l + u),
    0 !== a && e.arc(s + a, l + u - a, a, Math.PI / 2, Math.PI),
    e.lineTo(s, l + i),
    0 !== i && e.arc(s + i, l + i, i, Math.PI, 1.5 * Math.PI)
}
ZRImage.prototype.type = 'image'
var round$1 = Math.round
function subPixelOptimizeLine$1(e, t, i) {
  if (t) {
    var r = t.x1,
      n = t.x2,
      a = t.y1,
      o = t.y2
    ;(e.x1 = r), (e.x2 = n), (e.y1 = a), (e.y2 = o)
    var s = i && i.lineWidth
    return s
      ? (round$1(2 * r) === round$1(2 * n) && (e.x1 = e.x2 = subPixelOptimize$1(r, s, !0)),
        round$1(2 * a) === round$1(2 * o) && (e.y1 = e.y2 = subPixelOptimize$1(a, s, !0)),
        e)
      : e
  }
}
function subPixelOptimizeRect$1(e, t, i) {
  if (t) {
    var r = t.x,
      n = t.y,
      a = t.width,
      o = t.height
    ;(e.x = r), (e.y = n), (e.width = a), (e.height = o)
    var s = i && i.lineWidth
    return s
      ? ((e.x = subPixelOptimize$1(r, s, !0)),
        (e.y = subPixelOptimize$1(n, s, !0)),
        (e.width = Math.max(subPixelOptimize$1(r + a, s, !1) - e.x, 0 === a ? 0 : 1)),
        (e.height = Math.max(subPixelOptimize$1(n + o, s, !1) - e.y, 0 === o ? 0 : 1)),
        e)
      : e
  }
}
function subPixelOptimize$1(e, t, i) {
  if (!t) return e
  var r = round$1(2 * e)
  return (r + round$1(t)) % 2 == 0 ? r / 2 : (r + (i ? 1 : -1)) / 2
}
var RectShape = function () {
    ;(this.x = 0), (this.y = 0), (this.width = 0), (this.height = 0)
  },
  subPixelOptimizeOutputShape$1 = {},
  Rect$2 = (function (e) {
    function t(t) {
      return e.call(this, t) || this
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultShape = function () {
        return new RectShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        var i, r, n, a
        if (this.subPixelOptimize) {
          var o = subPixelOptimizeRect$1(subPixelOptimizeOutputShape$1, t, this.style)
          ;(i = o.x), (r = o.y), (n = o.width), (a = o.height), (o.r = t.r), (t = o)
        } else (i = t.x), (r = t.y), (n = t.width), (a = t.height)
        t.r ? buildPath$2(e, t) : e.rect(i, r, n, a)
      }),
      (t.prototype.isZeroArea = function () {
        return !this.shape.width || !this.shape.height
      }),
      t
    )
  })(Path)
Rect$2.prototype.type = 'rect'
var DEFAULT_RICH_TEXT_COLOR = { fill: '#000' },
  DEFAULT_STROKE_LINE_WIDTH = 2,
  DEFAULT_TEXT_ANIMATION_PROPS = {
    style: defaults$1(
      {
        fill: !0,
        stroke: !0,
        fillOpacity: !0,
        strokeOpacity: !0,
        lineWidth: !0,
        fontSize: !0,
        lineHeight: !0,
        width: !0,
        height: !0,
        textShadowColor: !0,
        textShadowBlur: !0,
        textShadowOffsetX: !0,
        textShadowOffsetY: !0,
        backgroundColor: !0,
        padding: !0,
        borderColor: !0,
        borderWidth: !0,
        borderRadius: !0
      },
      DEFAULT_COMMON_ANIMATION_PROPS.style
    )
  },
  ZRText = (function (e) {
    function t(t) {
      var i = e.call(this) || this
      return (
        (i.type = 'text'),
        (i._children = []),
        (i._defaultStyle = DEFAULT_RICH_TEXT_COLOR),
        i.attr(t),
        i
      )
    }
    return (
      __extends(t, e),
      (t.prototype.childrenRef = function () {
        return this._children
      }),
      (t.prototype.update = function () {
        this.styleChanged() && this._updateSubTexts()
        for (var t = 0; t < this._children.length; t++) {
          var i = this._children[t]
          ;(i.zlevel = this.zlevel),
            (i.z = this.z),
            (i.z2 = this.z2),
            (i.culling = this.culling),
            (i.cursor = this.cursor),
            (i.invisible = this.invisible)
        }
        var r = this.attachedTransform
        if (r) {
          r.updateTransform()
          var n = r.transform
          n
            ? ((this.transform = this.transform || []), copy(this.transform, n))
            : (this.transform = null)
        } else e.prototype.update.call(this)
      }),
      (t.prototype.getComputedTransform = function () {
        return (
          this.__hostTarget &&
            (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)),
          this.attachedTransform
            ? this.attachedTransform.getComputedTransform()
            : e.prototype.getComputedTransform.call(this)
        )
      }),
      (t.prototype._updateSubTexts = function () {
        ;(this._childCursor = 0),
          normalizeTextStyle(this.style),
          this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(),
          (this._children.length = this._childCursor),
          this.styleUpdated()
      }),
      (t.prototype.addSelfToZr = function (t) {
        e.prototype.addSelfToZr.call(this, t)
        for (var i = 0; i < this._children.length; i++) this._children[i].__zr = t
      }),
      (t.prototype.removeSelfFromZr = function (t) {
        e.prototype.removeSelfFromZr.call(this, t)
        for (var i = 0; i < this._children.length; i++) this._children[i].__zr = null
      }),
      (t.prototype.getBoundingRect = function () {
        if ((this.styleChanged() && this._updateSubTexts(), !this._rect)) {
          for (
            var e = new BoundingRect(0, 0, 0, 0), t = this._children, i = [], r = null, n = 0;
            n < t.length;
            n++
          ) {
            var a = t[n],
              o = a.getBoundingRect(),
              s = a.getLocalTransform(i)
            s
              ? (e.copy(o), e.applyTransform(s), (r = r || e.clone()).union(e))
              : (r = r || o.clone()).union(o)
          }
          this._rect = r || e
        }
        return this._rect
      }),
      (t.prototype.setDefaultTextStyle = function (e) {
        this._defaultStyle = e || DEFAULT_RICH_TEXT_COLOR
      }),
      (t.prototype.setTextContent = function (e) {
        throw new Error("Can't attach text on another text")
      }),
      (t.prototype._mergeStyle = function (e, t) {
        if (!t) return e
        var i = t.rich,
          r = e.rich || (i && {})
        return extend$3(e, t), i && r ? (this._mergeRich(r, i), (e.rich = r)) : r && (e.rich = r), e
      }),
      (t.prototype._mergeRich = function (e, t) {
        for (var i = keys(t), r = 0; r < i.length; r++) {
          var n = i[r]
          ;(e[n] = e[n] || {}), extend$3(e[n], t[n])
        }
      }),
      (t.prototype.getAnimationStyleProps = function () {
        return DEFAULT_TEXT_ANIMATION_PROPS
      }),
      (t.prototype._getOrCreateChild = function (e) {
        var t = this._children[this._childCursor]
        return (
          (t && t instanceof e) || (t = new e()),
          (this._children[this._childCursor++] = t),
          (t.__zr = this.__zr),
          (t.parent = this),
          t
        )
      }),
      (t.prototype._updatePlainTexts = function () {
        var e = this.style,
          t = e.font || DEFAULT_FONT,
          i = e.padding,
          r = parsePlainText(getStyleText(e), e),
          n = needDrawBackground(e),
          a = !!e.backgroundColor,
          o = r.outerHeight,
          s = r.lines,
          l = r.lineHeight,
          h = this._defaultStyle,
          u = e.x || 0,
          p = e.y || 0,
          c = e.align || h.align || 'left',
          d = e.verticalAlign || h.verticalAlign || 'top',
          f = u,
          m = adjustTextY$1(p, r.contentHeight, d)
        if (n || i) {
          var g = r.width
          i && (g += i[1] + i[3])
          var y = adjustTextX(u, g, c),
            v = adjustTextY$1(p, o, d)
          n && this._renderBackground(e, e, y, v, g, o)
        }
        ;(m += l / 2),
          i &&
            ((f = getTextXForPadding(u, c, i)),
            'top' === d ? (m += i[0]) : 'bottom' === d && (m -= i[2]))
        for (
          var _ = 0,
            x = !1,
            S = getFill(('fill' in e) ? e.fill : ((x = !0), h.fill)),
            b = getStroke(
              ('stroke' in e)
                ? e.stroke
                : a || (h.autoStroke && !x)
                ? null
                : ((_ = DEFAULT_STROKE_LINE_WIDTH), h.stroke)
            ),
            T = e.textShadowBlur > 0,
            A =
              null != e.width &&
              ('truncate' === e.overflow || 'break' === e.overflow || 'breakAll' === e.overflow),
            w = r.calculatedLineHeight,
            M = 0;
          M < s.length;
          M++
        ) {
          var C = this._getOrCreateChild(TSpan),
            P = C.createStyle()
          C.useStyle(P),
            (P.text = s[M]),
            (P.x = f),
            (P.y = m),
            c && (P.textAlign = c),
            (P.textBaseline = 'middle'),
            (P.opacity = e.opacity),
            (P.strokeFirst = !0),
            T &&
              ((P.shadowBlur = e.textShadowBlur || 0),
              (P.shadowColor = e.textShadowColor || 'transparent'),
              (P.shadowOffsetX = e.textShadowOffsetX || 0),
              (P.shadowOffsetY = e.textShadowOffsetY || 0)),
            b &&
              ((P.stroke = b),
              (P.lineWidth = e.lineWidth || _),
              (P.lineDash = e.lineDash),
              (P.lineDashOffset = e.lineDashOffset || 0)),
            S && (P.fill = S),
            (P.font = t),
            (m += l),
            A &&
              C.setBoundingRect(
                new BoundingRect(
                  adjustTextX(P.x, e.width, P.textAlign),
                  adjustTextY$1(P.y, w, P.textBaseline),
                  e.width,
                  w
                )
              )
        }
      }),
      (t.prototype._updateRichTexts = function () {
        var e = this.style,
          t = parseRichText(getStyleText(e), e),
          i = t.width,
          r = t.outerWidth,
          n = t.outerHeight,
          a = e.padding,
          o = e.x || 0,
          s = e.y || 0,
          l = this._defaultStyle,
          h = e.align || l.align,
          u = e.verticalAlign || l.verticalAlign,
          p = adjustTextX(o, r, h),
          c = adjustTextY$1(s, n, u),
          d = p,
          f = c
        a && ((d += a[3]), (f += a[0]))
        var m = d + i
        needDrawBackground(e) && this._renderBackground(e, e, p, c, r, n)
        for (var g = !!e.backgroundColor, y = 0; y < t.lines.length; y++) {
          for (
            var v = t.lines[y],
              _ = v.tokens,
              x = _.length,
              S = v.lineHeight,
              b = v.width,
              T = 0,
              A = d,
              w = m,
              M = x - 1,
              C = void 0;
            T < x && (!(C = _[T]).align || 'left' === C.align);

          )
            this._placeToken(C, e, S, f, A, 'left', g), (b -= C.width), (A += C.width), T++
          for (; M >= 0 && 'right' === (C = _[M]).align; )
            this._placeToken(C, e, S, f, w, 'right', g), (b -= C.width), (w -= C.width), M--
          for (A += (i - (A - d) - (m - w) - b) / 2; T <= M; )
            (C = _[T]),
              this._placeToken(C, e, S, f, A + C.width / 2, 'center', g),
              (A += C.width),
              T++
          f += S
        }
      }),
      (t.prototype._placeToken = function (e, t, i, r, n, a, o) {
        var s = t.rich[e.styleName] || {}
        s.text = e.text
        var l = e.verticalAlign,
          h = r + i / 2
        'top' === l ? (h = r + e.height / 2) : 'bottom' === l && (h = r + i - e.height / 2),
          !e.isLineHolder &&
            needDrawBackground(s) &&
            this._renderBackground(
              s,
              t,
              'right' === a ? n - e.width : 'center' === a ? n - e.width / 2 : n,
              h - e.height / 2,
              e.width,
              e.height
            )
        var u = !!s.backgroundColor,
          p = e.textPadding
        p && ((n = getTextXForPadding(n, a, p)), (h -= e.height / 2 - p[0] - e.innerHeight / 2))
        var c = this._getOrCreateChild(TSpan),
          d = c.createStyle()
        c.useStyle(d)
        var f = this._defaultStyle,
          m = !1,
          g = 0,
          y = getStroke('fill' in s ? s.fill : 'fill' in t ? t.fill : ((m = !0), f.fill)),
          v = getStroke(
            'stroke' in s
              ? s.stroke
              : 'stroke' in t
              ? t.stroke
              : u || o || (f.autoStroke && !m)
              ? null
              : ((g = DEFAULT_STROKE_LINE_WIDTH), f.stroke)
          ),
          _ = s.textShadowBlur > 0 || t.textShadowBlur > 0
        ;(d.text = e.text),
          (d.x = n),
          (d.y = h),
          _ &&
            ((d.shadowBlur = s.textShadowBlur || t.textShadowBlur || 0),
            (d.shadowColor = s.textShadowColor || t.textShadowColor || 'transparent'),
            (d.shadowOffsetX = s.textShadowOffsetX || t.textShadowOffsetX || 0),
            (d.shadowOffsetY = s.textShadowOffsetY || t.textShadowOffsetY || 0)),
          (d.textAlign = a),
          (d.textBaseline = 'middle'),
          (d.font = e.font || DEFAULT_FONT),
          (d.opacity = retrieve3(s.opacity, t.opacity, 1)),
          v &&
            ((d.lineWidth = retrieve3(s.lineWidth, t.lineWidth, g)),
            (d.lineDash = retrieve2(s.lineDash, t.lineDash)),
            (d.lineDashOffset = t.lineDashOffset || 0),
            (d.stroke = v)),
          y && (d.fill = y)
        var x = e.contentWidth,
          S = e.contentHeight
        c.setBoundingRect(
          new BoundingRect(
            adjustTextX(d.x, x, d.textAlign),
            adjustTextY$1(d.y, S, d.textBaseline),
            x,
            S
          )
        )
      }),
      (t.prototype._renderBackground = function (e, t, i, r, n, a) {
        var o,
          s,
          l,
          h = e.backgroundColor,
          u = e.borderWidth,
          p = e.borderColor,
          c = h && h.image,
          d = h && !c,
          f = e.borderRadius,
          m = this
        if (d || (u && p)) {
          ;(o = this._getOrCreateChild(Rect$2)).useStyle(o.createStyle()), (o.style.fill = null)
          var g = o.shape
          ;(g.x = i), (g.y = r), (g.width = n), (g.height = a), (g.r = f), o.dirtyShape()
        }
        if (d) ((l = o.style).fill = h || null), (l.fillOpacity = retrieve2(e.fillOpacity, 1))
        else if (c) {
          ;(s = this._getOrCreateChild(ZRImage)).onload = function () {
            m.dirtyStyle()
          }
          var y = s.style
          ;(y.image = h.image), (y.x = i), (y.y = r), (y.width = n), (y.height = a)
        }
        u &&
          p &&
          (((l = o.style).lineWidth = u),
          (l.stroke = p),
          (l.strokeOpacity = retrieve2(e.strokeOpacity, 1)),
          (l.lineDash = e.borderDash),
          (l.lineDashOffset = e.borderDashOffset || 0),
          (o.strokeContainThreshold = 0),
          o.hasFill() && o.hasStroke() && ((l.strokeFirst = !0), (l.lineWidth *= 2)))
        var v = (o || s).style
        ;(v.shadowBlur = e.shadowBlur || 0),
          (v.shadowColor = e.shadowColor || 'transparent'),
          (v.shadowOffsetX = e.shadowOffsetX || 0),
          (v.shadowOffsetY = e.shadowOffsetY || 0),
          (v.opacity = retrieve3(e.opacity, t.opacity, 1))
      }),
      (t.makeFont = function (e) {
        var t = ''
        if (e.fontSize || e.fontFamily || e.fontWeight) {
          var i = ''
          ;(i =
            'string' != typeof e.fontSize ||
            (-1 === e.fontSize.indexOf('px') &&
              -1 === e.fontSize.indexOf('rem') &&
              -1 === e.fontSize.indexOf('em'))
              ? isNaN(+e.fontSize)
                ? '12px'
                : e.fontSize + 'px'
              : e.fontSize),
            (t = [e.fontStyle, e.fontWeight, i, e.fontFamily || 'sans-serif'].join(' '))
        }
        return (t && trim$1(t)) || e.textFont || e.font
      }),
      t
    )
  })(Displayable),
  VALID_TEXT_ALIGN = { left: !0, right: 1, center: 1 },
  VALID_TEXT_VERTICAL_ALIGN = { top: 1, bottom: 1, middle: 1 }
function normalizeTextStyle(e) {
  return normalizeStyle(e), each$i(e.rich, normalizeStyle), e
}
function normalizeStyle(e) {
  if (e) {
    e.font = ZRText.makeFont(e)
    var t = e.align
    'middle' === t && (t = 'center'), (e.align = null == t || VALID_TEXT_ALIGN[t] ? t : 'left')
    var i = e.verticalAlign
    'center' === i && (i = 'middle'),
      (e.verticalAlign = null == i || VALID_TEXT_VERTICAL_ALIGN[i] ? i : 'top'),
      e.padding && (e.padding = normalizeCssArray$1(e.padding))
  }
}
function getStroke(e, t) {
  return null == e || t <= 0 || 'transparent' === e || 'none' === e
    ? null
    : e.image || e.colorStops
    ? '#000'
    : e
}
function getFill(e) {
  return null == e || 'none' === e ? null : e.image || e.colorStops ? '#000' : e
}
function getTextXForPadding(e, t, i) {
  return 'right' === t ? e - i[1] : 'center' === t ? e + i[3] / 2 - i[1] / 2 : e + i[3]
}
function getStyleText(e) {
  var t = e.text
  return null != t && (t += ''), t
}
function needDrawBackground(e) {
  return !!(e.backgroundColor || (e.borderWidth && e.borderColor))
}
var getECData = makeInner(),
  _highlightNextDigit = 1,
  _highlightKeyMap = {},
  getSavedStates = makeInner(),
  HOVER_STATE_NORMAL = 0,
  HOVER_STATE_BLUR = 1,
  HOVER_STATE_EMPHASIS = 2,
  SPECIAL_STATES = ['emphasis', 'blur', 'select'],
  DISPLAY_STATES = ['normal', 'emphasis', 'blur', 'select'],
  Z2_EMPHASIS_LIFT = 10,
  Z2_SELECT_LIFT = 9,
  HIGHLIGHT_ACTION_TYPE = 'highlight',
  DOWNPLAY_ACTION_TYPE = 'downplay',
  SELECT_ACTION_TYPE = 'select',
  UNSELECT_ACTION_TYPE = 'unselect',
  TOGGLE_SELECT_ACTION_TYPE = 'toggleSelect'
function hasFillOrStroke(e) {
  return null != e && 'none' !== e
}
var liftedColorCache = new LRU(100)
function liftColor(e) {
  if ('string' != typeof e) return e
  var t = liftedColorCache.get(e)
  return t || ((t = lift(e, -0.1)), liftedColorCache.put(e, t)), t
}
function doChangeHoverState(e, t, i) {
  e.onHoverStateChange && (e.hoverState || 0) !== i && e.onHoverStateChange(t), (e.hoverState = i)
}
function singleEnterEmphasis(e) {
  doChangeHoverState(e, 'emphasis', HOVER_STATE_EMPHASIS)
}
function singleLeaveEmphasis(e) {
  e.hoverState === HOVER_STATE_EMPHASIS && doChangeHoverState(e, 'normal', HOVER_STATE_NORMAL)
}
function singleEnterBlur(e) {
  doChangeHoverState(e, 'blur', HOVER_STATE_BLUR)
}
function singleLeaveBlur(e) {
  e.hoverState === HOVER_STATE_BLUR && doChangeHoverState(e, 'normal', HOVER_STATE_NORMAL)
}
function singleEnterSelect(e) {
  e.selected = !0
}
function singleLeaveSelect(e) {
  e.selected = !1
}
function updateElementState(e, t, i) {
  t(e, i)
}
function traverseUpdateState(e, t, i) {
  updateElementState(e, t, i),
    e.isGroup &&
      e.traverse(function (e) {
        updateElementState(e, t, i)
      })
}
function setStatesFlag(e, t) {
  switch (t) {
    case 'emphasis':
      e.hoverState = HOVER_STATE_EMPHASIS
      break
    case 'normal':
      e.hoverState = HOVER_STATE_NORMAL
      break
    case 'blur':
      e.hoverState = HOVER_STATE_BLUR
      break
    case 'select':
      e.selected = !0
  }
}
function getFromStateStyle(e, t, i, r) {
  for (var n = e.style, a = {}, o = 0; o < t.length; o++) {
    var s = t[o],
      l = n[s]
    a[s] = null == l ? r && r[s] : l
  }
  for (o = 0; o < e.animators.length; o++) {
    var h = e.animators[o]
    h.__fromStateTransition &&
      h.__fromStateTransition.indexOf(i) < 0 &&
      'style' === h.targetName &&
      h.saveFinalToTarget(a, t)
  }
  return a
}
function createEmphasisDefaultState(e, t, i, r) {
  var n = i && indexOf$1(i, 'select') >= 0,
    a = !1
  if (e instanceof Path) {
    var o = getSavedStates(e),
      s = (n && o.selectFill) || o.normalFill,
      l = (n && o.selectStroke) || o.normalStroke
    if (hasFillOrStroke(s) || hasFillOrStroke(l)) {
      var h = (r = r || {}).style || {}
      !hasFillOrStroke(h.fill) && hasFillOrStroke(s)
        ? ((a = !0), (r = extend$3({}, r)), ((h = extend$3({}, h)).fill = liftColor(s)))
        : !hasFillOrStroke(h.stroke) &&
          hasFillOrStroke(l) &&
          (a || ((r = extend$3({}, r)), (h = extend$3({}, h))), (h.stroke = liftColor(l))),
        (r.style = h)
    }
  }
  if (r && null == r.z2) {
    a || (r = extend$3({}, r))
    var u = e.z2EmphasisLift
    r.z2 = e.z2 + (null != u ? u : Z2_EMPHASIS_LIFT)
  }
  return r
}
function createSelectDefaultState(e, t, i) {
  if (i && null == i.z2) {
    i = extend$3({}, i)
    var r = e.z2SelectLift
    i.z2 = e.z2 + (null != r ? r : Z2_SELECT_LIFT)
  }
  return i
}
function createBlurDefaultState(e, t, i) {
  var r = indexOf$1(e.currentStates, t) >= 0,
    n = e.style.opacity,
    a = r ? null : getFromStateStyle(e, ['opacity'], t, { opacity: 1 }),
    o = (i = i || {}).style || {}
  return (
    null == o.opacity &&
      ((i = extend$3({}, i)),
      (o = extend$3({ opacity: r ? n : 0.1 * a.opacity }, o)),
      (i.style = o)),
    i
  )
}
function elementStateProxy(e, t) {
  var i = this.states[e]
  if (this.style) {
    if ('emphasis' === e) return createEmphasisDefaultState(this, e, t, i)
    if ('blur' === e) return createBlurDefaultState(this, e, i)
    if ('select' === e) return createSelectDefaultState(this, e, i)
  }
  return i
}
function setDefaultStateProxy(e) {
  e.stateProxy = elementStateProxy
  var t = e.getTextContent(),
    i = e.getTextGuideLine()
  t && (t.stateProxy = elementStateProxy), i && (i.stateProxy = elementStateProxy)
}
function enterEmphasisWhenMouseOver(e, t) {
  !shouldSilent(e, t) && !e.__highByOuter && traverseUpdateState(e, singleEnterEmphasis)
}
function leaveEmphasisWhenMouseOut(e, t) {
  !shouldSilent(e, t) && !e.__highByOuter && traverseUpdateState(e, singleLeaveEmphasis)
}
function enterEmphasis(e, t) {
  ;(e.__highByOuter |= 1 << (t || 0)), traverseUpdateState(e, singleEnterEmphasis)
}
function leaveEmphasis(e, t) {
  !(e.__highByOuter &= ~(1 << (t || 0))) && traverseUpdateState(e, singleLeaveEmphasis)
}
function enterBlur(e) {
  traverseUpdateState(e, singleEnterBlur)
}
function leaveBlur(e) {
  traverseUpdateState(e, singleLeaveBlur)
}
function enterSelect(e) {
  traverseUpdateState(e, singleEnterSelect)
}
function leaveSelect(e) {
  traverseUpdateState(e, singleLeaveSelect)
}
function shouldSilent(e, t) {
  return e.__highDownSilentOnTouch && t.zrByTouch
}
function allLeaveBlur(e) {
  e.getModel().eachComponent(function (t, i) {
    ;('series' === t ? e.getViewOfSeriesModel(i) : e.getViewOfComponentModel(i)).group.traverse(
      function (e) {
        singleLeaveBlur(e)
      }
    )
  })
}
function blurSeries(e, t, i, r) {
  var n = r.getModel()
  function a(e, t) {
    for (var i = 0; i < t.length; i++) {
      var r = e.getItemGraphicEl(t[i])
      r && leaveBlur(r)
    }
  }
  if (((i = i || 'coordinateSystem'), null != e && t && 'none' !== t)) {
    var o = n.getSeriesByIndex(e),
      s = o.coordinateSystem
    s && s.master && (s = s.master)
    var l = []
    n.eachSeries(function (e) {
      var n = o === e,
        h = e.coordinateSystem
      if (
        (h && h.master && (h = h.master),
        !(
          ('series' === i && !n) ||
          ('coordinateSystem' === i && !(h && s ? h === s : n)) ||
          ('series' === t && n)
        ))
      ) {
        if (
          (r.getViewOfSeriesModel(e).group.traverse(function (e) {
            singleEnterBlur(e)
          }),
          isArrayLike(t))
        )
          a(e.getData(), t)
        else if (isObject$7(t))
          for (var u = keys(t), p = 0; p < u.length; p++) a(e.getData(u[p]), t[u[p]])
        l.push(e)
      }
    }),
      n.eachComponent(function (e, t) {
        if ('series' !== e) {
          var i = r.getViewOfComponentModel(t)
          i && i.blurSeries && i.blurSeries(l, n)
        }
      })
  }
}
function blurComponent(e, t, i) {
  if (null != e && null != t) {
    var r = i.getModel().getComponent(e, t)
    if (r) {
      var n = i.getViewOfComponentModel(r)
      n &&
        n.focusBlurEnabled &&
        n.group.traverse(function (e) {
          singleEnterBlur(e)
        })
    }
  }
}
function blurSeriesFromHighlightPayload(e, t, i) {
  var r = e.seriesIndex,
    n = e.getData(t.dataType),
    a = queryDataIndex(n, t)
  a = (isArray$1(a) ? a[0] : a) || 0
  var o = n.getItemGraphicEl(a)
  if (!o) for (var s = n.count(), l = 0; !o && l < s; ) o = n.getItemGraphicEl(l++)
  if (o) {
    var h = getECData(o)
    blurSeries(r, h.focus, h.blurScope, i)
  } else {
    var u = e.get(['emphasis', 'focus']),
      p = e.get(['emphasis', 'blurScope'])
    null != u && blurSeries(r, u, p, i)
  }
}
function findComponentHighDownDispatchers(e, t, i, r) {
  var n = { focusSelf: !1, dispatchers: null }
  if (null == e || 'series' === e || null == t || null == i) return n
  var a = r.getModel().getComponent(e, t)
  if (!a) return n
  var o = r.getViewOfComponentModel(a)
  if (!o || !o.findHighDownDispatchers) return n
  for (var s, l = o.findHighDownDispatchers(i), h = 0; h < l.length; h++)
    if ('self' === getECData(l[h]).focus) {
      s = !0
      break
    }
  return { focusSelf: s, dispatchers: l }
}
function handleGlobalMouseOverForHighDown(e, t, i) {
  var r = getECData(e),
    n = findComponentHighDownDispatchers(
      r.componentMainType,
      r.componentIndex,
      r.componentHighDownName,
      i
    ),
    a = n.dispatchers,
    o = n.focusSelf
  a
    ? (o && blurComponent(r.componentMainType, r.componentIndex, i),
      each$i(a, function (e) {
        return enterEmphasisWhenMouseOver(e, t)
      }))
    : (blurSeries(r.seriesIndex, r.focus, r.blurScope, i),
      'self' === r.focus && blurComponent(r.componentMainType, r.componentIndex, i),
      enterEmphasisWhenMouseOver(e, t))
}
function handleGlboalMouseOutForHighDown(e, t, i) {
  allLeaveBlur(i)
  var r = getECData(e),
    n = findComponentHighDownDispatchers(
      r.componentMainType,
      r.componentIndex,
      r.componentHighDownName,
      i
    ).dispatchers
  n
    ? each$i(n, function (e) {
        return leaveEmphasisWhenMouseOut(e, t)
      })
    : leaveEmphasisWhenMouseOut(e, t)
}
function toggleSelectionFromPayload(e, t, i) {
  if (isSelectChangePayload(t)) {
    var r = t.dataType,
      n = queryDataIndex(e.getData(r), t)
    isArray$1(n) || (n = [n]),
      e[
        t.type === TOGGLE_SELECT_ACTION_TYPE
          ? 'toggleSelect'
          : t.type === SELECT_ACTION_TYPE
          ? 'select'
          : 'unselect'
      ](n, r)
  }
}
function updateSeriesElementSelection(e) {
  each$i(e.getAllData(), function (t) {
    var i = t.data,
      r = t.type
    i.eachItemGraphicEl(function (t, i) {
      e.isSelected(i, r) ? enterSelect(t) : leaveSelect(t)
    })
  })
}
function getAllSelectedIndices(e) {
  var t = []
  return (
    e.eachSeries(function (e) {
      each$i(e.getAllData(), function (i) {
        i.data
        var r = i.type,
          n = e.getSelectedDataIndices()
        if (n.length > 0) {
          var a = { dataIndex: n, seriesIndex: e.seriesIndex }
          null != r && (a.dataType = r), t.push(a)
        }
      })
    }),
    t
  )
}
function enableHoverEmphasis(e, t, i) {
  setAsHighDownDispatcher(e, !0),
    traverseUpdateState(e, setDefaultStateProxy),
    enableHoverFocus(e, t, i)
}
function enableHoverFocus(e, t, i) {
  var r = getECData(e)
  null != t ? ((r.focus = t), (r.blurScope = i)) : r.focus && (r.focus = null)
}
var OTHER_STATES = ['emphasis', 'blur', 'select'],
  defaultStyleGetterMap = {
    itemStyle: 'getItemStyle',
    lineStyle: 'getLineStyle',
    areaStyle: 'getAreaStyle'
  }
function setStatesStylesFromModel(e, t, i, r) {
  i = i || 'itemStyle'
  for (var n = 0; n < OTHER_STATES.length; n++) {
    var a = OTHER_STATES[n],
      o = t.getModel([a, i])
    e.ensureState(a).style = r ? r(o) : o[defaultStyleGetterMap[i]]()
  }
}
function setAsHighDownDispatcher(e, t) {
  var i = !1 === t,
    r = e
  e.highDownSilentOnTouch && (r.__highDownSilentOnTouch = e.highDownSilentOnTouch),
    (i && !r.__highDownDispatcher) ||
      ((r.__highByOuter = r.__highByOuter || 0), (r.__highDownDispatcher = !i))
}
function isHighDownDispatcher(e) {
  return !(!e || !e.__highDownDispatcher)
}
function enableComponentHighDownFeatures(e, t, i) {
  var r = getECData(e)
  ;(r.componentMainType = t.mainType),
    (r.componentIndex = t.componentIndex),
    (r.componentHighDownName = i)
}
function getHighlightDigit(e) {
  var t = _highlightKeyMap[e]
  return (
    null == t && _highlightNextDigit <= 32 && (t = _highlightKeyMap[e] = _highlightNextDigit++), t
  )
}
function isSelectChangePayload(e) {
  var t = e.type
  return t === SELECT_ACTION_TYPE || t === UNSELECT_ACTION_TYPE || t === TOGGLE_SELECT_ACTION_TYPE
}
function isHighDownPayload(e) {
  var t = e.type
  return t === HIGHLIGHT_ACTION_TYPE || t === DOWNPLAY_ACTION_TYPE
}
function savePathStates(e) {
  var t = getSavedStates(e)
  ;(t.normalFill = e.style.fill), (t.normalStroke = e.style.stroke)
  var i = e.states.select || {}
  ;(t.selectFill = (i.style && i.style.fill) || null),
    (t.selectStroke = (i.style && i.style.stroke) || null)
}
var CMD$2 = PathProxy.CMD,
  points$2 = [[], [], []],
  mathSqrt$2 = Math.sqrt,
  mathAtan2 = Math.atan2
function transformPath(e, t) {
  var i,
    r,
    n,
    a,
    o,
    s,
    l = e.data,
    h = e.len(),
    u = CMD$2.M,
    p = CMD$2.C,
    c = CMD$2.L,
    d = CMD$2.R,
    f = CMD$2.A,
    m = CMD$2.Q
  for (n = 0, a = 0; n < h; ) {
    switch (((i = l[n++]), (a = n), (r = 0), i)) {
      case u:
      case c:
        r = 1
        break
      case p:
        r = 3
        break
      case m:
        r = 2
        break
      case f:
        var g = t[4],
          y = t[5],
          v = mathSqrt$2(t[0] * t[0] + t[1] * t[1]),
          _ = mathSqrt$2(t[2] * t[2] + t[3] * t[3]),
          x = mathAtan2(-t[1] / _, t[0] / v)
        ;(l[n] *= v),
          (l[n++] += g),
          (l[n] *= _),
          (l[n++] += y),
          (l[n++] *= v),
          (l[n++] *= _),
          (l[n++] += x),
          (l[n++] += x),
          (a = n += 2)
        break
      case d:
        ;(s[0] = l[n++]),
          (s[1] = l[n++]),
          applyTransform$1(s, s, t),
          (l[a++] = s[0]),
          (l[a++] = s[1]),
          (s[0] += l[n++]),
          (s[1] += l[n++]),
          applyTransform$1(s, s, t),
          (l[a++] = s[0]),
          (l[a++] = s[1])
    }
    for (o = 0; o < r; o++) {
      var S = points$2[o]
      ;(S[0] = l[n++]), (S[1] = l[n++]), applyTransform$1(S, S, t), (l[a++] = S[0]), (l[a++] = S[1])
    }
  }
  e.increaseVersion()
}
var mathSqrt$1 = Math.sqrt,
  mathSin$2 = Math.sin,
  mathCos$2 = Math.cos,
  PI$7 = Math.PI
function vMag(e) {
  return Math.sqrt(e[0] * e[0] + e[1] * e[1])
}
function vRatio(e, t) {
  return (e[0] * t[0] + e[1] * t[1]) / (vMag(e) * vMag(t))
}
function vAngle(e, t) {
  return (e[0] * t[1] < e[1] * t[0] ? -1 : 1) * Math.acos(vRatio(e, t))
}
function processArc(e, t, i, r, n, a, o, s, l, h, u) {
  var p = l * (PI$7 / 180),
    c = (mathCos$2(p) * (e - i)) / 2 + (mathSin$2(p) * (t - r)) / 2,
    d = (-1 * mathSin$2(p) * (e - i)) / 2 + (mathCos$2(p) * (t - r)) / 2,
    f = (c * c) / (o * o) + (d * d) / (s * s)
  f > 1 && ((o *= mathSqrt$1(f)), (s *= mathSqrt$1(f)))
  var m =
      (n === a ? -1 : 1) *
        mathSqrt$1(
          (o * o * (s * s) - o * o * (d * d) - s * s * (c * c)) /
            (o * o * (d * d) + s * s * (c * c))
        ) || 0,
    g = (m * o * d) / s,
    y = (m * -s * c) / o,
    v = (e + i) / 2 + mathCos$2(p) * g - mathSin$2(p) * y,
    _ = (t + r) / 2 + mathSin$2(p) * g + mathCos$2(p) * y,
    x = vAngle([1, 0], [(c - g) / o, (d - y) / s]),
    S = [(c - g) / o, (d - y) / s],
    b = [(-1 * c - g) / o, (-1 * d - y) / s],
    T = vAngle(S, b)
  if ((vRatio(S, b) <= -1 && (T = PI$7), vRatio(S, b) >= 1 && (T = 0), T < 0)) {
    var A = Math.round((T / PI$7) * 1e6) / 1e6
    T = 2 * PI$7 + (A % 2) * PI$7
  }
  u.addData(h, v, _, o, s, x, T, p, a)
}
var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/gi,
  numberReg$1 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g
function createPathProxyFromString(e) {
  var t = new PathProxy()
  if (!e) return t
  var i,
    r = 0,
    n = 0,
    a = r,
    o = n,
    s = PathProxy.CMD,
    l = e.match(commandReg)
  if (!l) return t
  for (var h = 0; h < l.length; h++) {
    for (
      var u = l[h],
        p = u.charAt(0),
        c = void 0,
        d = u.match(numberReg$1) || [],
        f = d.length,
        m = 0;
      m < f;
      m++
    )
      d[m] = parseFloat(d[m])
    for (var g = 0; g < f; ) {
      var y = void 0,
        v = void 0,
        _ = void 0,
        x = void 0,
        S = void 0,
        b = void 0,
        T = void 0,
        A = r,
        w = n,
        M = void 0,
        C = void 0
      switch (p) {
        case 'l':
          ;(r += d[g++]), (n += d[g++]), (c = s.L), t.addData(c, r, n)
          break
        case 'L':
          ;(r = d[g++]), (n = d[g++]), (c = s.L), t.addData(c, r, n)
          break
        case 'm':
          ;(r += d[g++]), (n += d[g++]), (c = s.M), t.addData(c, r, n), (a = r), (o = n), (p = 'l')
          break
        case 'M':
          ;(r = d[g++]), (n = d[g++]), (c = s.M), t.addData(c, r, n), (a = r), (o = n), (p = 'L')
          break
        case 'h':
          ;(r += d[g++]), (c = s.L), t.addData(c, r, n)
          break
        case 'H':
          ;(r = d[g++]), (c = s.L), t.addData(c, r, n)
          break
        case 'v':
          ;(n += d[g++]), (c = s.L), t.addData(c, r, n)
          break
        case 'V':
          ;(n = d[g++]), (c = s.L), t.addData(c, r, n)
          break
        case 'C':
          ;(c = s.C),
            t.addData(c, d[g++], d[g++], d[g++], d[g++], d[g++], d[g++]),
            (r = d[g - 2]),
            (n = d[g - 1])
          break
        case 'c':
          ;(c = s.C),
            t.addData(c, d[g++] + r, d[g++] + n, d[g++] + r, d[g++] + n, d[g++] + r, d[g++] + n),
            (r += d[g - 2]),
            (n += d[g - 1])
          break
        case 'S':
          ;(y = r),
            (v = n),
            (M = t.len()),
            (C = t.data),
            i === s.C && ((y += r - C[M - 4]), (v += n - C[M - 3])),
            (c = s.C),
            (A = d[g++]),
            (w = d[g++]),
            (r = d[g++]),
            (n = d[g++]),
            t.addData(c, y, v, A, w, r, n)
          break
        case 's':
          ;(y = r),
            (v = n),
            (M = t.len()),
            (C = t.data),
            i === s.C && ((y += r - C[M - 4]), (v += n - C[M - 3])),
            (c = s.C),
            (A = r + d[g++]),
            (w = n + d[g++]),
            (r += d[g++]),
            (n += d[g++]),
            t.addData(c, y, v, A, w, r, n)
          break
        case 'Q':
          ;(A = d[g++]),
            (w = d[g++]),
            (r = d[g++]),
            (n = d[g++]),
            (c = s.Q),
            t.addData(c, A, w, r, n)
          break
        case 'q':
          ;(A = d[g++] + r),
            (w = d[g++] + n),
            (r += d[g++]),
            (n += d[g++]),
            (c = s.Q),
            t.addData(c, A, w, r, n)
          break
        case 'T':
          ;(y = r),
            (v = n),
            (M = t.len()),
            (C = t.data),
            i === s.Q && ((y += r - C[M - 4]), (v += n - C[M - 3])),
            (r = d[g++]),
            (n = d[g++]),
            (c = s.Q),
            t.addData(c, y, v, r, n)
          break
        case 't':
          ;(y = r),
            (v = n),
            (M = t.len()),
            (C = t.data),
            i === s.Q && ((y += r - C[M - 4]), (v += n - C[M - 3])),
            (r += d[g++]),
            (n += d[g++]),
            (c = s.Q),
            t.addData(c, y, v, r, n)
          break
        case 'A':
          ;(_ = d[g++]),
            (x = d[g++]),
            (S = d[g++]),
            (b = d[g++]),
            (T = d[g++]),
            processArc((A = r), (w = n), (r = d[g++]), (n = d[g++]), b, T, _, x, S, (c = s.A), t)
          break
        case 'a':
          ;(_ = d[g++]),
            (x = d[g++]),
            (S = d[g++]),
            (b = d[g++]),
            (T = d[g++]),
            processArc((A = r), (w = n), (r += d[g++]), (n += d[g++]), b, T, _, x, S, (c = s.A), t)
      }
    }
    ;('z' !== p && 'Z' !== p) || ((c = s.Z), t.addData(c), (r = a), (n = o)), (i = c)
  }
  return t.toStatic(), t
}
var SVGPath = (function (e) {
  function t() {
    return (null !== e && e.apply(this, arguments)) || this
  }
  return __extends(t, e), (t.prototype.applyTransform = function (e) {}), t
})(Path)
function isPathProxy(e) {
  return null != e.setData
}
function createPathOptions(e, t) {
  var i = createPathProxyFromString(e),
    r = extend$3({}, t)
  return (
    (r.buildPath = function (e) {
      if (isPathProxy(e)) {
        e.setData(i.data), (t = e.getContext()) && e.rebuildPath(t, 1)
      } else {
        var t = e
        i.rebuildPath(t, 1)
      }
    }),
    (r.applyTransform = function (e) {
      transformPath(i, e), this.dirtyShape()
    }),
    r
  )
}
function createFromString(e, t) {
  return new SVGPath(createPathOptions(e, t))
}
function extendFromString(e, t) {
  var i = createPathOptions(e, t)
  return (function (e) {
    function t(t) {
      var r = e.call(this, t) || this
      return (r.applyTransform = i.applyTransform), (r.buildPath = i.buildPath), r
    }
    return __extends(t, e), t
  })(SVGPath)
}
function mergePath$1(e, t) {
  for (var i = [], r = e.length, n = 0; n < r; n++) {
    var a = e[n]
    a.path || a.createPathProxy(),
      a.shapeChanged() && a.buildPath(a.path, a.shape, !0),
      i.push(a.path)
  }
  var o = new Path(t)
  return (
    o.createPathProxy(),
    (o.buildPath = function (e) {
      if (isPathProxy(e)) {
        e.appendPath(i)
        var t = e.getContext()
        t && e.rebuildPath(t, 1)
      }
    }),
    o
  )
}
var CircleShape = function () {
    ;(this.cx = 0), (this.cy = 0), (this.r = 0)
  },
  Circle = (function (e) {
    function t(t) {
      return e.call(this, t) || this
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultShape = function () {
        return new CircleShape()
      }),
      (t.prototype.buildPath = function (e, t, i) {
        i && e.moveTo(t.cx + t.r, t.cy), e.arc(t.cx, t.cy, t.r, 0, 2 * Math.PI)
      }),
      t
    )
  })(Path)
Circle.prototype.type = 'circle'
var EllipseShape = function () {
    ;(this.cx = 0), (this.cy = 0), (this.rx = 0), (this.ry = 0)
  },
  Ellipse = (function (e) {
    function t(t) {
      return e.call(this, t) || this
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultShape = function () {
        return new EllipseShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        var i = 0.5522848,
          r = t.cx,
          n = t.cy,
          a = t.rx,
          o = t.ry,
          s = a * i,
          l = o * i
        e.moveTo(r - a, n),
          e.bezierCurveTo(r - a, n - l, r - s, n - o, r, n - o),
          e.bezierCurveTo(r + s, n - o, r + a, n - l, r + a, n),
          e.bezierCurveTo(r + a, n + l, r + s, n + o, r, n + o),
          e.bezierCurveTo(r - s, n + o, r - a, n + l, r - a, n),
          e.closePath()
      }),
      t
    )
  })(Path)
Ellipse.prototype.type = 'ellipse'
var PI$6 = Math.PI,
  PI2$5 = 2 * PI$6,
  mathSin$1 = Math.sin,
  mathCos$1 = Math.cos,
  mathACos = Math.acos,
  mathATan2 = Math.atan2,
  mathAbs$1 = Math.abs,
  mathSqrt = Math.sqrt,
  mathMax$7 = Math.max,
  mathMin$7 = Math.min,
  e = 1e-4
function intersect(t, i, r, n, a, o, s, l) {
  var h = r - t,
    u = n - i,
    p = s - a,
    c = l - o,
    d = c * h - p * u
  if (!(d * d < e)) return [t + (d = (p * (i - o) - c * (t - a)) / d) * h, i + d * u]
}
function computeCornerTangents(e, t, i, r, n, a, o) {
  var s = e - i,
    l = t - r,
    h = (o ? a : -a) / mathSqrt(s * s + l * l),
    u = h * l,
    p = -h * s,
    c = e + u,
    d = t + p,
    f = i + u,
    m = r + p,
    g = (c + f) / 2,
    y = (d + m) / 2,
    v = f - c,
    _ = m - d,
    x = v * v + _ * _,
    S = n - a,
    b = c * m - f * d,
    T = (_ < 0 ? -1 : 1) * mathSqrt(mathMax$7(0, S * S * x - b * b)),
    A = (b * _ - v * T) / x,
    w = (-b * v - _ * T) / x,
    M = (b * _ + v * T) / x,
    C = (-b * v + _ * T) / x,
    P = A - g,
    E = w - y,
    I = M - g,
    D = C - y
  return (
    P * P + E * E > I * I + D * D && ((A = M), (w = C)),
    { cx: A, cy: w, x01: -u, y01: -p, x11: A * (n / S - 1), y11: w * (n / S - 1) }
  )
}
function buildPath$1(t, i) {
  var r = mathMax$7(i.r, 0),
    n = mathMax$7(i.r0 || 0, 0),
    a = r > 0
  if (a || n > 0) {
    if ((a || ((r = n), (n = 0)), n > r)) {
      var o = r
      ;(r = n), (n = o)
    }
    var s,
      l = !!i.clockwise,
      h = i.startAngle,
      u = i.endAngle
    if (h === u) s = 0
    else {
      var p = [h, u]
      normalizeArcAngles(p, !l), (s = mathAbs$1(p[0] - p[1]))
    }
    var c = i.cx,
      d = i.cy,
      f = i.cornerRadius || 0,
      m = i.innerCornerRadius || 0
    if (r > e)
      if (s > PI2$5 - e)
        t.moveTo(c + r * mathCos$1(h), d + r * mathSin$1(h)),
          t.arc(c, d, r, h, u, !l),
          n > e && (t.moveTo(c + n * mathCos$1(u), d + n * mathSin$1(u)), t.arc(c, d, n, u, h, l))
      else {
        var g = mathAbs$1(r - n) / 2,
          y = mathMin$7(g, f),
          v = mathMin$7(g, m),
          _ = v,
          x = y,
          S = r * mathCos$1(h),
          b = r * mathSin$1(h),
          T = n * mathCos$1(u),
          A = n * mathSin$1(u),
          w = void 0,
          M = void 0,
          C = void 0,
          P = void 0
        if (
          (y > e || v > e) &&
          ((w = r * mathCos$1(u)),
          (M = r * mathSin$1(u)),
          (C = n * mathCos$1(h)),
          (P = n * mathSin$1(h)),
          s < PI$6)
        ) {
          var E = intersect(S, b, C, P, w, M, T, A)
          if (E) {
            var I = S - E[0],
              D = b - E[1],
              L = w - E[0],
              R = M - E[1],
              O =
                1 /
                mathSin$1(
                  mathACos((I * L + D * R) / (mathSqrt(I * I + D * D) * mathSqrt(L * L + R * R))) /
                    2
                ),
              k = mathSqrt(E[0] * E[0] + E[1] * E[1])
            ;(_ = mathMin$7(v, (n - k) / (O - 1))), (x = mathMin$7(y, (r - k) / (O + 1)))
          }
        }
        if (s > e)
          if (x > e) {
            var $ = computeCornerTangents(C, P, S, b, r, x, l),
              N = computeCornerTangents(w, M, T, A, r, x, l)
            t.moveTo(c + $.cx + $.x01, d + $.cy + $.y01),
              x < y
                ? t.arc(c + $.cx, d + $.cy, x, mathATan2($.y01, $.x01), mathATan2(N.y01, N.x01), !l)
                : (t.arc(
                    c + $.cx,
                    d + $.cy,
                    x,
                    mathATan2($.y01, $.x01),
                    mathATan2($.y11, $.x11),
                    !l
                  ),
                  t.arc(
                    c,
                    d,
                    r,
                    mathATan2($.cy + $.y11, $.cx + $.x11),
                    mathATan2(N.cy + N.y11, N.cx + N.x11),
                    !l
                  ),
                  t.arc(
                    c + N.cx,
                    d + N.cy,
                    x,
                    mathATan2(N.y11, N.x11),
                    mathATan2(N.y01, N.x01),
                    !l
                  ))
          } else t.moveTo(c + S, d + b), t.arc(c, d, r, h, u, !l)
        else t.moveTo(c + S, d + b)
        if (n > e && s > e)
          if (_ > e) {
            ;($ = computeCornerTangents(T, A, w, M, n, -_, l)),
              (N = computeCornerTangents(S, b, C, P, n, -_, l))
            t.lineTo(c + $.cx + $.x01, d + $.cy + $.y01),
              _ < v
                ? t.arc(c + $.cx, d + $.cy, _, mathATan2($.y01, $.x01), mathATan2(N.y01, N.x01), !l)
                : (t.arc(
                    c + $.cx,
                    d + $.cy,
                    _,
                    mathATan2($.y01, $.x01),
                    mathATan2($.y11, $.x11),
                    !l
                  ),
                  t.arc(
                    c,
                    d,
                    n,
                    mathATan2($.cy + $.y11, $.cx + $.x11),
                    mathATan2(N.cy + N.y11, N.cx + N.x11),
                    l
                  ),
                  t.arc(
                    c + N.cx,
                    d + N.cy,
                    _,
                    mathATan2(N.y11, N.x11),
                    mathATan2(N.y01, N.x01),
                    !l
                  ))
          } else t.lineTo(c + T, d + A), t.arc(c, d, n, u, h, l)
        else t.lineTo(c + T, d + A)
      }
    else t.moveTo(c, d)
    t.closePath()
  }
}
var SectorShape = function () {
    ;(this.cx = 0),
      (this.cy = 0),
      (this.r0 = 0),
      (this.r = 0),
      (this.startAngle = 0),
      (this.endAngle = 2 * Math.PI),
      (this.clockwise = !0),
      (this.cornerRadius = 0),
      (this.innerCornerRadius = 0)
  },
  Sector = (function (e) {
    function t(t) {
      return e.call(this, t) || this
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultShape = function () {
        return new SectorShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        buildPath$1(e, t)
      }),
      (t.prototype.isZeroArea = function () {
        return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0
      }),
      t
    )
  })(Path)
Sector.prototype.type = 'sector'
var RingShape = function () {
    ;(this.cx = 0), (this.cy = 0), (this.r = 0), (this.r0 = 0)
  },
  Ring = (function (e) {
    function t(t) {
      return e.call(this, t) || this
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultShape = function () {
        return new RingShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        var i = t.cx,
          r = t.cy,
          n = 2 * Math.PI
        e.moveTo(i + t.r, r),
          e.arc(i, r, t.r, 0, n, !1),
          e.moveTo(i + t.r0, r),
          e.arc(i, r, t.r0, 0, n, !0)
      }),
      t
    )
  })(Path)
function interpolate(e, t, i, r, n, a, o) {
  var s = 0.5 * (i - e),
    l = 0.5 * (r - t)
  return (2 * (t - i) + s + l) * o + (-3 * (t - i) - 2 * s - l) * a + s * n + t
}
function smoothSpline(e, t) {
  for (var i = e.length, r = [], n = 0, a = 1; a < i; a++) n += distance(e[a - 1], e[a])
  var o = n / 2
  o = o < i ? i : o
  for (a = 0; a < o; a++) {
    var s = (a / (o - 1)) * (t ? i : i - 1),
      l = Math.floor(s),
      h = s - l,
      u = void 0,
      p = e[l % i],
      c = void 0,
      d = void 0
    t
      ? ((u = e[(l - 1 + i) % i]), (c = e[(l + 1) % i]), (d = e[(l + 2) % i]))
      : ((u = e[0 === l ? l : l - 1]),
        (c = e[l > i - 2 ? i - 1 : l + 1]),
        (d = e[l > i - 3 ? i - 1 : l + 2]))
    var f = h * h,
      m = h * f
    r.push([
      interpolate(u[0], p[0], c[0], d[0], h, f, m),
      interpolate(u[1], p[1], c[1], d[1], h, f, m)
    ])
  }
  return r
}
function smoothBezier(e, t, i, r) {
  var n,
    a,
    o,
    s,
    l = [],
    h = [],
    u = [],
    p = []
  if (r) {
    ;(o = [1 / 0, 1 / 0]), (s = [-1 / 0, -1 / 0])
    for (var c = 0, d = e.length; c < d; c++) min$1(o, o, e[c]), max$1(s, s, e[c])
    min$1(o, o, r[0]), max$1(s, s, r[1])
  }
  for (c = 0, d = e.length; c < d; c++) {
    var f = e[c]
    if (i) (n = e[c ? c - 1 : d - 1]), (a = e[(c + 1) % d])
    else {
      if (0 === c || c === d - 1) {
        l.push(clone$2(e[c]))
        continue
      }
      ;(n = e[c - 1]), (a = e[c + 1])
    }
    sub(h, a, n), scale$2(h, h, t)
    var m = distance(f, n),
      g = distance(f, a),
      y = m + g
    0 !== y && ((m /= y), (g /= y)), scale$2(u, h, -m), scale$2(p, h, g)
    var v = add([], f, u),
      _ = add([], f, p)
    r && (max$1(v, v, o), min$1(v, v, s), max$1(_, _, o), min$1(_, _, s)), l.push(v), l.push(_)
  }
  return i && l.push(l.shift()), l
}
function buildPath(e, t, i) {
  var r = t.smooth,
    n = t.points
  if (n && n.length >= 2) {
    if (r && 'spline' !== r) {
      var a = smoothBezier(n, r, i, t.smoothConstraint)
      e.moveTo(n[0][0], n[0][1])
      for (var o = n.length, s = 0; s < (i ? o : o - 1); s++) {
        var l = a[2 * s],
          h = a[2 * s + 1],
          u = n[(s + 1) % o]
        e.bezierCurveTo(l[0], l[1], h[0], h[1], u[0], u[1])
      }
    } else {
      'spline' === r && (n = smoothSpline(n, i)), e.moveTo(n[0][0], n[0][1])
      s = 1
      for (var p = n.length; s < p; s++) e.lineTo(n[s][0], n[s][1])
    }
    i && e.closePath()
  }
}
Ring.prototype.type = 'ring'
var PolygonShape = function () {
    ;(this.points = null), (this.smooth = 0), (this.smoothConstraint = null)
  },
  Polygon = (function (e) {
    function t(t) {
      return e.call(this, t) || this
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultShape = function () {
        return new PolygonShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        buildPath(e, t, !0)
      }),
      t
    )
  })(Path)
Polygon.prototype.type = 'polygon'
var PolylineShape = function () {
    ;(this.points = null), (this.percent = 1), (this.smooth = 0), (this.smoothConstraint = null)
  },
  Polyline$1 = (function (e) {
    function t(t) {
      return e.call(this, t) || this
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultStyle = function () {
        return { stroke: '#000', fill: null }
      }),
      (t.prototype.getDefaultShape = function () {
        return new PolylineShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        buildPath(e, t, !1)
      }),
      t
    )
  })(Path)
Polyline$1.prototype.type = 'polyline'
var subPixelOptimizeOutputShape = {},
  LineShape = function () {
    ;(this.x1 = 0), (this.y1 = 0), (this.x2 = 0), (this.y2 = 0), (this.percent = 1)
  },
  Line$1 = (function (e) {
    function t(t) {
      return e.call(this, t) || this
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultStyle = function () {
        return { stroke: '#000', fill: null }
      }),
      (t.prototype.getDefaultShape = function () {
        return new LineShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        var i, r, n, a
        if (this.subPixelOptimize) {
          var o = subPixelOptimizeLine$1(subPixelOptimizeOutputShape, t, this.style)
          ;(i = o.x1), (r = o.y1), (n = o.x2), (a = o.y2)
        } else (i = t.x1), (r = t.y1), (n = t.x2), (a = t.y2)
        var s = t.percent
        0 !== s &&
          (e.moveTo(i, r),
          s < 1 && ((n = i * (1 - s) + n * s), (a = r * (1 - s) + a * s)),
          e.lineTo(n, a))
      }),
      (t.prototype.pointAt = function (e) {
        var t = this.shape
        return [t.x1 * (1 - e) + t.x2 * e, t.y1 * (1 - e) + t.y2 * e]
      }),
      t
    )
  })(Path)
Line$1.prototype.type = 'line'
var out = [],
  BezierCurveShape = function () {
    ;(this.x1 = 0),
      (this.y1 = 0),
      (this.x2 = 0),
      (this.y2 = 0),
      (this.cpx1 = 0),
      (this.cpy1 = 0),
      (this.percent = 1)
  }
function someVectorAt(e, t, i) {
  var r = e.cpx2,
    n = e.cpy2
  return null === r || null === n
    ? [
        (i ? cubicDerivativeAt : cubicAt)(e.x1, e.cpx1, e.cpx2, e.x2, t),
        (i ? cubicDerivativeAt : cubicAt)(e.y1, e.cpy1, e.cpy2, e.y2, t)
      ]
    : [
        (i ? quadraticDerivativeAt : quadraticAt$1)(e.x1, e.cpx1, e.x2, t),
        (i ? quadraticDerivativeAt : quadraticAt$1)(e.y1, e.cpy1, e.y2, t)
      ]
}
var BezierCurve = (function (e) {
  function t(t) {
    return e.call(this, t) || this
  }
  return (
    __extends(t, e),
    (t.prototype.getDefaultStyle = function () {
      return { stroke: '#000', fill: null }
    }),
    (t.prototype.getDefaultShape = function () {
      return new BezierCurveShape()
    }),
    (t.prototype.buildPath = function (e, t) {
      var i = t.x1,
        r = t.y1,
        n = t.x2,
        a = t.y2,
        o = t.cpx1,
        s = t.cpy1,
        l = t.cpx2,
        h = t.cpy2,
        u = t.percent
      0 !== u &&
        (e.moveTo(i, r),
        null == l || null == h
          ? (u < 1 &&
              (quadraticSubdivide(i, o, n, u, out),
              (o = out[1]),
              (n = out[2]),
              quadraticSubdivide(r, s, a, u, out),
              (s = out[1]),
              (a = out[2])),
            e.quadraticCurveTo(o, s, n, a))
          : (u < 1 &&
              (cubicSubdivide(i, o, l, n, u, out),
              (o = out[1]),
              (l = out[2]),
              (n = out[3]),
              cubicSubdivide(r, s, h, a, u, out),
              (s = out[1]),
              (h = out[2]),
              (a = out[3])),
            e.bezierCurveTo(o, s, l, h, n, a)))
    }),
    (t.prototype.pointAt = function (e) {
      return someVectorAt(this.shape, e, !1)
    }),
    (t.prototype.tangentAt = function (e) {
      var t = someVectorAt(this.shape, e, !0)
      return normalize$3(t, t)
    }),
    t
  )
})(Path)
BezierCurve.prototype.type = 'bezier-curve'
var ArcShape = function () {
    ;(this.cx = 0),
      (this.cy = 0),
      (this.r = 0),
      (this.startAngle = 0),
      (this.endAngle = 2 * Math.PI),
      (this.clockwise = !0)
  },
  Arc = (function (e) {
    function t(t) {
      return e.call(this, t) || this
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultStyle = function () {
        return { stroke: '#000', fill: null }
      }),
      (t.prototype.getDefaultShape = function () {
        return new ArcShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        var i = t.cx,
          r = t.cy,
          n = Math.max(t.r, 0),
          a = t.startAngle,
          o = t.endAngle,
          s = t.clockwise,
          l = Math.cos(a),
          h = Math.sin(a)
        e.moveTo(l * n + i, h * n + r), e.arc(i, r, n, a, o, !s)
      }),
      t
    )
  })(Path)
Arc.prototype.type = 'arc'
var CompoundPath = (function (e) {
    function t() {
      var t = (null !== e && e.apply(this, arguments)) || this
      return (t.type = 'compound'), t
    }
    return (
      __extends(t, e),
      (t.prototype._updatePathDirty = function () {
        for (var e = this.shape.paths, t = this.shapeChanged(), i = 0; i < e.length; i++)
          t = t || e[i].shapeChanged()
        t && this.dirtyShape()
      }),
      (t.prototype.beforeBrush = function () {
        this._updatePathDirty()
        for (var e = this.shape.paths || [], t = this.getGlobalScale(), i = 0; i < e.length; i++)
          e[i].path || e[i].createPathProxy(),
            e[i].path.setScale(t[0], t[1], e[i].segmentIgnoreThreshold)
      }),
      (t.prototype.buildPath = function (e, t) {
        for (var i = t.paths || [], r = 0; r < i.length; r++) i[r].buildPath(e, i[r].shape, !0)
      }),
      (t.prototype.afterBrush = function () {
        for (var e = this.shape.paths || [], t = 0; t < e.length; t++) e[t].pathUpdated()
      }),
      (t.prototype.getBoundingRect = function () {
        return this._updatePathDirty.call(this), Path.prototype.getBoundingRect.call(this)
      }),
      t
    )
  })(Path),
  Gradient = (function () {
    function e(e) {
      this.colorStops = e || []
    }
    return (
      (e.prototype.addColorStop = function (e, t) {
        this.colorStops.push({ offset: e, color: t })
      }),
      e
    )
  })(),
  LinearGradient = (function (e) {
    function t(t, i, r, n, a, o) {
      var s = e.call(this, a) || this
      return (
        (s.x = null == t ? 0 : t),
        (s.y = null == i ? 0 : i),
        (s.x2 = null == r ? 1 : r),
        (s.y2 = null == n ? 0 : n),
        (s.type = 'linear'),
        (s.global = o || !1),
        s
      )
    }
    return __extends(t, e), t
  })(Gradient),
  RadialGradient = (function (e) {
    function t(t, i, r, n, a) {
      var o = e.call(this, n) || this
      return (
        (o.x = null == t ? 0.5 : t),
        (o.y = null == i ? 0.5 : i),
        (o.r = null == r ? 0.5 : r),
        (o.type = 'radial'),
        (o.global = a || !1),
        o
      )
    }
    return __extends(t, e), t
  })(Gradient),
  extent = [0, 0],
  extent2 = [0, 0],
  minTv = new Point(),
  maxTv = new Point(),
  OrientedBoundingRect = (function () {
    function e(e, t) {
      ;(this._corners = []), (this._axes = []), (this._origin = [0, 0])
      for (var i = 0; i < 4; i++) this._corners[i] = new Point()
      for (i = 0; i < 2; i++) this._axes[i] = new Point()
      e && this.fromBoundingRect(e, t)
    }
    return (
      (e.prototype.fromBoundingRect = function (e, t) {
        var i = this._corners,
          r = this._axes,
          n = e.x,
          a = e.y,
          o = n + e.width,
          s = a + e.height
        if ((i[0].set(n, a), i[1].set(o, a), i[2].set(o, s), i[3].set(n, s), t))
          for (var l = 0; l < 4; l++) i[l].transform(t)
        Point.sub(r[0], i[1], i[0]), Point.sub(r[1], i[3], i[0]), r[0].normalize(), r[1].normalize()
        for (l = 0; l < 2; l++) this._origin[l] = r[l].dot(i[0])
      }),
      (e.prototype.intersect = function (e, t) {
        var i = !0,
          r = !t
        return (
          minTv.set(1 / 0, 1 / 0),
          maxTv.set(0, 0),
          (!this._intersectCheckOneSide(this, e, minTv, maxTv, r, 1) && ((i = !1), r)) ||
            (!this._intersectCheckOneSide(e, this, minTv, maxTv, r, -1) && ((i = !1), r)) ||
            r ||
            Point.copy(t, i ? minTv : maxTv),
          i
        )
      }),
      (e.prototype._intersectCheckOneSide = function (e, t, i, r, n, a) {
        for (var o = !0, s = 0; s < 2; s++) {
          var l = this._axes[s]
          if (
            (this._getProjMinMaxOnAxis(s, e._corners, extent),
            this._getProjMinMaxOnAxis(s, t._corners, extent2),
            extent[1] < extent2[0] || extent[0] > extent2[1])
          ) {
            if (((o = !1), n)) return o
            var h = Math.abs(extent2[0] - extent[1]),
              u = Math.abs(extent[0] - extent2[1])
            Math.min(h, u) > r.len() &&
              (h < u ? Point.scale(r, l, -h * a) : Point.scale(r, l, u * a))
          } else if (i) {
            ;(h = Math.abs(extent2[0] - extent[1])), (u = Math.abs(extent[0] - extent2[1]))
            Math.min(h, u) < i.len() &&
              (h < u ? Point.scale(i, l, h * a) : Point.scale(i, l, -u * a))
          }
        }
        return o
      }),
      (e.prototype._getProjMinMaxOnAxis = function (e, t, i) {
        for (
          var r = this._axes[e], n = this._origin, a = t[0].dot(r) + n[e], o = a, s = a, l = 1;
          l < t.length;
          l++
        ) {
          var h = t[l].dot(r) + n[e]
          ;(o = Math.min(h, o)), (s = Math.max(h, s))
        }
        ;(i[0] = o), (i[1] = s)
      }),
      e
    )
  })(),
  m = [],
  IncrementalDisplayable = (function (e) {
    function t() {
      var t = (null !== e && e.apply(this, arguments)) || this
      return (
        (t.notClear = !0),
        (t.incremental = !0),
        (t._displayables = []),
        (t._temporaryDisplayables = []),
        (t._cursor = 0),
        t
      )
    }
    return (
      __extends(t, e),
      (t.prototype.traverse = function (e, t) {
        e.call(t, this)
      }),
      (t.prototype.useStyle = function () {
        this.style = {}
      }),
      (t.prototype.getCursor = function () {
        return this._cursor
      }),
      (t.prototype.innerAfterBrush = function () {
        this._cursor = this._displayables.length
      }),
      (t.prototype.clearDisplaybles = function () {
        ;(this._displayables = []),
          (this._temporaryDisplayables = []),
          (this._cursor = 0),
          this.markRedraw(),
          (this.notClear = !1)
      }),
      (t.prototype.clearTemporalDisplayables = function () {
        this._temporaryDisplayables = []
      }),
      (t.prototype.addDisplayable = function (e, t) {
        t ? this._temporaryDisplayables.push(e) : this._displayables.push(e), this.markRedraw()
      }),
      (t.prototype.addDisplayables = function (e, t) {
        t = t || !1
        for (var i = 0; i < e.length; i++) this.addDisplayable(e[i], t)
      }),
      (t.prototype.getDisplayables = function () {
        return this._displayables
      }),
      (t.prototype.getTemporalDisplayables = function () {
        return this._temporaryDisplayables
      }),
      (t.prototype.eachPendingDisplayable = function (e) {
        for (var t = this._cursor; t < this._displayables.length; t++) e && e(this._displayables[t])
        for (t = 0; t < this._temporaryDisplayables.length; t++)
          e && e(this._temporaryDisplayables[t])
      }),
      (t.prototype.update = function () {
        this.updateTransform()
        for (var e = this._cursor; e < this._displayables.length; e++) {
          ;((t = this._displayables[e]).parent = this), t.update(), (t.parent = null)
        }
        for (e = 0; e < this._temporaryDisplayables.length; e++) {
          var t
          ;((t = this._temporaryDisplayables[e]).parent = this), t.update(), (t.parent = null)
        }
      }),
      (t.prototype.getBoundingRect = function () {
        if (!this._rect) {
          for (
            var e = new BoundingRect(1 / 0, 1 / 0, -1 / 0, -1 / 0), t = 0;
            t < this._displayables.length;
            t++
          ) {
            var i = this._displayables[t],
              r = i.getBoundingRect().clone()
            i.needLocalTransform() && r.applyTransform(i.getLocalTransform(m)), e.union(r)
          }
          this._rect = e
        }
        return this._rect
      }),
      (t.prototype.contain = function (e, t) {
        var i = this.transformCoordToLocal(e, t)
        if (this.getBoundingRect().contain(i[0], i[1]))
          for (var r = 0; r < this._displayables.length; r++) {
            if (this._displayables[r].contain(e, t)) return !0
          }
        return !1
      }),
      t
    )
  })(Displayable),
  mathMax$6 = Math.max,
  mathMin$6 = Math.min,
  _customShapeMap = {}
function extendShape(e) {
  return Path.extend(e)
}
var extendPathFromString = extendFromString
function extendPath(e, t) {
  return extendPathFromString(e, t)
}
function registerShape(e, t) {
  _customShapeMap[e] = t
}
function getShapeClass(e) {
  if (_customShapeMap.hasOwnProperty(e)) return _customShapeMap[e]
}
function makePath(e, t, i, r) {
  var n = createFromString(e, t)
  return i && ('center' === r && (i = centerGraphic(i, n.getBoundingRect())), resizePath(n, i)), n
}
function makeImage(e, t, i) {
  var r = new ZRImage({
    style: { image: e, x: t.x, y: t.y, width: t.width, height: t.height },
    onload: function (e) {
      if ('center' === i) {
        var n = { width: e.width, height: e.height }
        r.setStyle(centerGraphic(t, n))
      }
    }
  })
  return r
}
function centerGraphic(e, t) {
  var i,
    r = t.width / t.height,
    n = e.height * r
  return (
    (i = n <= e.width ? e.height : (n = e.width) / r),
    { x: e.x + e.width / 2 - n / 2, y: e.y + e.height / 2 - i / 2, width: n, height: i }
  )
}
var mergePath = mergePath$1
function resizePath(e, t) {
  if (e.applyTransform) {
    var i = e.getBoundingRect().calculateTransform(t)
    e.applyTransform(i)
  }
}
function subPixelOptimizeLine(e) {
  return subPixelOptimizeLine$1(e.shape, e.shape, e.style), e
}
function subPixelOptimizeRect(e) {
  return subPixelOptimizeRect$1(e.shape, e.shape, e.style), e
}
var subPixelOptimize = subPixelOptimize$1
function animateOrSetProps(e, t, i, r, n, a, o) {
  var s,
    l = !1
  'function' == typeof n
    ? ((o = a), (a = n), (n = null))
    : isObject$7(n) &&
      ((a = n.cb), (o = n.during), (l = n.isFrom), (s = n.removeOpt), (n = n.dataIndex))
  var h,
    u = 'update' === e,
    p = 'remove' === e
  if (r && r.ecModel) {
    var c = r.ecModel.getUpdatePayload()
    h = c && c.animation
  }
  var d = r && r.isAnimationEnabled()
  if ((p || t.stopAnimation('remove'), d)) {
    var f = void 0,
      m = void 0,
      g = void 0
    h
      ? ((f = h.duration || 0), (m = h.easing || 'cubicOut'), (g = h.delay || 0))
      : p
      ? ((f = retrieve2((s = s || {}).duration, 200)),
        (m = retrieve2(s.easing, 'cubicOut')),
        (g = 0))
      : ((f = r.getShallow(u ? 'animationDurationUpdate' : 'animationDuration')),
        (m = r.getShallow(u ? 'animationEasingUpdate' : 'animationEasing')),
        (g = r.getShallow(u ? 'animationDelayUpdate' : 'animationDelay'))),
      'function' == typeof g &&
        (g = g(n, r.getAnimationDelayParams ? r.getAnimationDelayParams(t, n) : null)),
      'function' == typeof f && (f = f(n)),
      f > 0
        ? l
          ? t.animateFrom(i, {
              duration: f,
              delay: g || 0,
              easing: m,
              done: a,
              force: !!a || !!o,
              scope: e,
              during: o
            })
          : t.animateTo(i, {
              duration: f,
              delay: g || 0,
              easing: m,
              done: a,
              force: !!a || !!o,
              setToFinal: !0,
              scope: e,
              during: o
            })
        : (t.stopAnimation(), !l && t.attr(i), a && a())
  } else t.stopAnimation(), !l && t.attr(i), o && o(1), a && a()
}
function updateProps$1(e, t, i, r, n, a) {
  animateOrSetProps('update', e, t, i, r, n, a)
}
function initProps(e, t, i, r, n, a) {
  animateOrSetProps('init', e, t, i, r, n, a)
}
function removeElement(e, t, i, r, n, a) {
  isElementRemoved(e) || animateOrSetProps('remove', e, t, i, r, n, a)
}
function fadeOutDisplayable(e, t, i, r) {
  e.removeTextContent(),
    e.removeTextGuideLine(),
    removeElement(e, { style: { opacity: 0 } }, t, i, r)
}
function removeElementWithFadeOut(e, t, i) {
  function r() {
    e.parent && e.parent.remove(e)
  }
  e.isGroup
    ? e.traverse(function (e) {
        e.isGroup || fadeOutDisplayable(e, t, i, r)
      })
    : fadeOutDisplayable(e, t, i, r)
}
function isElementRemoved(e) {
  if (!e.__zr) return !0
  for (var t = 0; t < e.animators.length; t++) {
    if ('remove' === e.animators[t].scope) return !0
  }
  return !1
}
function getTransform$1(e, t) {
  for (var i = identity([]); e && e !== t; ) mul(i, e.getLocalTransform(), i), (e = e.parent)
  return i
}
function applyTransform(e, t, i) {
  return (
    t && !isArrayLike(t) && (t = Transformable.getLocalTransform(t)),
    i && (t = invert([], t)),
    applyTransform$1([], e, t)
  )
}
function transformDirection(e, t, i) {
  var r = 0 === t[4] || 0 === t[5] || 0 === t[0] ? 1 : Math.abs((2 * t[4]) / t[0]),
    n = 0 === t[4] || 0 === t[5] || 0 === t[2] ? 1 : Math.abs((2 * t[4]) / t[2]),
    a = ['left' === e ? -r : 'right' === e ? r : 0, 'top' === e ? -n : 'bottom' === e ? n : 0]
  return (
    (a = applyTransform(a, t, i)),
    Math.abs(a[0]) > Math.abs(a[1]) ? (a[0] > 0 ? 'right' : 'left') : a[1] > 0 ? 'bottom' : 'top'
  )
}
function isNotGroup(e) {
  return !e.isGroup
}
function isPath$1(e) {
  return null != e.shape
}
function groupTransition(e, t, i) {
  if (e && t) {
    var r,
      n =
        ((r = {}),
        e.traverse(function (e) {
          isNotGroup(e) && e.anid && (r[e.anid] = e)
        }),
        r)
    t.traverse(function (e) {
      if (isNotGroup(e) && e.anid) {
        var t = n[e.anid]
        if (t) {
          var r = a(e)
          e.attr(a(t)), updateProps$1(e, r, i, getECData(e).dataIndex)
        }
      }
    })
  }
  function a(e) {
    var t = { x: e.x, y: e.y, rotation: e.rotation }
    return isPath$1(e) && (t.shape = extend$3({}, e.shape)), t
  }
}
function clipPointsByRect(e, t) {
  return map$1(e, function (e) {
    var i = e[0]
    ;(i = mathMax$6(i, t.x)), (i = mathMin$6(i, t.x + t.width))
    var r = e[1]
    return (r = mathMax$6(r, t.y)), [i, (r = mathMin$6(r, t.y + t.height))]
  })
}
function clipRectByRect(e, t) {
  var i = mathMax$6(e.x, t.x),
    r = mathMin$6(e.x + e.width, t.x + t.width),
    n = mathMax$6(e.y, t.y),
    a = mathMin$6(e.y + e.height, t.y + t.height)
  if (r >= i && a >= n) return { x: i, y: n, width: r - i, height: a - n }
}
function createIcon(e, t, i) {
  var r = extend$3({ rectHover: !0 }, t),
    n = (r.style = { strokeNoScale: !0 })
  if (((i = i || { x: -1, y: -1, width: 2, height: 2 }), e))
    return 0 === e.indexOf('image://')
      ? ((n.image = e.slice(8)), defaults$1(n, i), new ZRImage(r))
      : makePath(e.replace('path://', ''), r, i, 'center')
}
function linePolygonIntersect(e, t, i, r, n) {
  for (var a = 0, o = n[n.length - 1]; a < n.length; a++) {
    var s = n[a]
    if (lineLineIntersect(e, t, i, r, s[0], s[1], o[0], o[1])) return !0
    o = s
  }
}
function lineLineIntersect(e, t, i, r, n, a, o, s) {
  var l = i - e,
    h = r - t,
    u = o - n,
    p = s - a,
    c = crossProduct2d(u, p, l, h)
  if (nearZero(c)) return !1
  var d = e - n,
    f = t - a,
    m = crossProduct2d(d, f, l, h) / c
  if (m < 0 || m > 1) return !1
  var g = crossProduct2d(d, f, u, p) / c
  return !(g < 0 || g > 1)
}
function crossProduct2d(e, t, i, r) {
  return e * r - i * t
}
function nearZero(e) {
  return e <= 1e-6 && e >= -1e-6
}
function setTooltipConfig(e) {
  var t = e.itemTooltipOption,
    i = e.componentModel,
    r = e.itemName,
    n = isString(t) ? { formatter: t } : t,
    a = i.mainType,
    o = i.componentIndex,
    s = { componentType: a, name: r, $vars: ['name'] }
  s[a + 'Index'] = o
  var l = e.formatterParamsExtra
  l &&
    each$i(keys(l), function (e) {
      hasOwn(s, e) || ((s[e] = l[e]), s.$vars.push(e))
    })
  var h = getECData(e.el)
  ;(h.componentMainType = a),
    (h.componentIndex = o),
    (h.tooltipConfig = { name: r, option: defaults$1({ content: r, formatterParams: s }, n) })
}
registerShape('circle', Circle),
  registerShape('ellipse', Ellipse),
  registerShape('sector', Sector),
  registerShape('ring', Ring),
  registerShape('polygon', Polygon),
  registerShape('polyline', Polyline$1),
  registerShape('rect', Rect$2),
  registerShape('line', Line$1),
  registerShape('bezierCurve', BezierCurve),
  registerShape('arc', Arc)
var graphic = Object.freeze({
    __proto__: null,
    [Symbol.toStringTag]: 'Module',
    extendShape: extendShape,
    extendPath: extendPath,
    registerShape: registerShape,
    getShapeClass: getShapeClass,
    makePath: makePath,
    makeImage: makeImage,
    mergePath: mergePath,
    resizePath: resizePath,
    subPixelOptimizeLine: subPixelOptimizeLine,
    subPixelOptimizeRect: subPixelOptimizeRect,
    subPixelOptimize: subPixelOptimize,
    updateProps: updateProps$1,
    initProps: initProps,
    removeElement: removeElement,
    removeElementWithFadeOut: removeElementWithFadeOut,
    isElementRemoved: isElementRemoved,
    getTransform: getTransform$1,
    applyTransform: applyTransform,
    transformDirection: transformDirection,
    groupTransition: groupTransition,
    clipPointsByRect: clipPointsByRect,
    clipRectByRect: clipRectByRect,
    createIcon: createIcon,
    linePolygonIntersect: linePolygonIntersect,
    lineLineIntersect: lineLineIntersect,
    setTooltipConfig: setTooltipConfig,
    Group: Group$3,
    Image: ZRImage,
    Text: ZRText,
    Circle: Circle,
    Ellipse: Ellipse,
    Sector: Sector,
    Ring: Ring,
    Polygon: Polygon,
    Polyline: Polyline$1,
    Rect: Rect$2,
    Line: Line$1,
    BezierCurve: BezierCurve,
    Arc: Arc,
    IncrementalDisplayable: IncrementalDisplayable,
    CompoundPath: CompoundPath,
    LinearGradient: LinearGradient,
    RadialGradient: RadialGradient,
    BoundingRect: BoundingRect,
    OrientedBoundingRect: OrientedBoundingRect,
    Point: Point,
    Path: Path
  }),
  EMPTY_OBJ = {}
function setLabelText(e, t) {
  for (var i = 0; i < SPECIAL_STATES.length; i++) {
    var r = SPECIAL_STATES[i],
      n = t[r],
      a = e.ensureState(r)
    ;(a.style = a.style || {}), (a.style.text = n)
  }
  var o = e.currentStates.slice()
  e.clearStates(!0), e.setStyle({ text: t.normal }), e.useStates(o, !0)
}
function getLabelText(e, t, i) {
  var r,
    n = e.labelFetcher,
    a = e.labelDataIndex,
    o = e.labelDimIndex,
    s = t.normal
  n &&
    (r = n.getFormattedLabel(
      a,
      'normal',
      null,
      o,
      s && s.get('formatter'),
      null != i ? { interpolatedValue: i } : null
    )),
    null == r && (r = isFunction$1(e.defaultText) ? e.defaultText(a, e, i) : e.defaultText)
  for (var l = { normal: r }, h = 0; h < SPECIAL_STATES.length; h++) {
    var u = SPECIAL_STATES[h],
      p = t[u]
    l[u] = retrieve2(n ? n.getFormattedLabel(a, u, null, o, p && p.get('formatter')) : null, r)
  }
  return l
}
function setLabelStyle(e, t, i, r) {
  i = i || EMPTY_OBJ
  for (var n = e instanceof ZRText, a = !1, o = 0; o < DISPLAY_STATES.length; o++) {
    if ((c = t[DISPLAY_STATES[o]]) && c.getShallow('show')) {
      a = !0
      break
    }
  }
  var s = n ? e : e.getTextContent()
  if (a) {
    n ||
      (s || ((s = new ZRText()), e.setTextContent(s)),
      e.stateProxy && (s.stateProxy = e.stateProxy))
    var l = getLabelText(i, t),
      h = t.normal,
      u = !!h.getShallow('show'),
      p = createTextStyle(h, r && r.normal, i, !1, !n)
    ;(p.text = l.normal), n || e.setTextConfig(createTextConfig(h, i, !1))
    for (o = 0; o < SPECIAL_STATES.length; o++) {
      var c,
        d = SPECIAL_STATES[o]
      if ((c = t[d])) {
        var f = s.ensureState(d),
          m = !!retrieve2(c.getShallow('show'), u)
        if (
          (m !== u && (f.ignore = !m),
          (f.style = createTextStyle(c, r && r[d], i, !0, !n)),
          (f.style.text = l[d]),
          !n)
        )
          e.ensureState(d).textConfig = createTextConfig(c, i, !0)
      }
    }
    ;(s.silent = !!h.getShallow('silent')),
      null != s.style.x && (p.x = s.style.x),
      null != s.style.y && (p.y = s.style.y),
      (s.ignore = !u),
      s.useStyle(p),
      s.dirty(),
      i.enableTextSetter &&
        (labelInner(s).setLabelText = function (e) {
          var r = getLabelText(i, t, e)
          setLabelText(s, r)
        })
  } else s && (s.ignore = !0)
  e.dirty()
}
function getLabelStatesModels(e, t) {
  t = t || 'label'
  for (var i = { normal: e.getModel(t) }, r = 0; r < SPECIAL_STATES.length; r++) {
    var n = SPECIAL_STATES[r]
    i[n] = e.getModel([n, t])
  }
  return i
}
function createTextStyle(e, t, i, r, n) {
  var a = {}
  return setTextStyleCommon(a, e, i, r, n), t && extend$3(a, t), a
}
function createTextConfig(e, t, i) {
  t = t || {}
  var r,
    n = {},
    a = e.getShallow('rotate'),
    o = retrieve2(e.getShallow('distance'), i ? null : 5),
    s = e.getShallow('offset')
  return (
    'outside' === (r = e.getShallow('position') || (i ? null : 'inside')) &&
      (r = t.defaultOutsidePosition || 'top'),
    null != r && (n.position = r),
    null != s && (n.offset = s),
    null != a && ((a *= Math.PI / 180), (n.rotation = a)),
    null != o && (n.distance = o),
    (n.outsideFill = 'inherit' === e.get('color') ? t.inheritColor || null : 'auto'),
    n
  )
}
function setTextStyleCommon(e, t, i, r, n) {
  i = i || EMPTY_OBJ
  var a,
    o = t.ecModel,
    s = o && o.option.textStyle,
    l = getRichItemNames(t)
  if (l)
    for (var h in ((a = {}), l))
      if (l.hasOwnProperty(h)) {
        var u = t.getModel(['rich', h])
        setTokenTextStyle((a[h] = {}), u, s, i, r, n, !1, !0)
      }
  a && (e.rich = a)
  var p = t.get('overflow')
  p && (e.overflow = p)
  var c = t.get('minMargin')
  null != c && (e.margin = c), setTokenTextStyle(e, t, s, i, r, n, !0, !1)
}
function getRichItemNames(e) {
  for (var t; e && e !== e.ecModel; ) {
    var i = (e.option || EMPTY_OBJ).rich
    if (i) {
      t = t || {}
      for (var r = keys(i), n = 0; n < r.length; n++) {
        t[r[n]] = 1
      }
    }
    e = e.parentModel
  }
  return t
}
var TEXT_PROPS_WITH_GLOBAL = [
    'fontStyle',
    'fontWeight',
    'fontSize',
    'fontFamily',
    'textShadowColor',
    'textShadowBlur',
    'textShadowOffsetX',
    'textShadowOffsetY'
  ],
  TEXT_PROPS_SELF = ['align', 'lineHeight', 'width', 'height', 'tag', 'verticalAlign'],
  TEXT_PROPS_BOX = [
    'padding',
    'borderWidth',
    'borderRadius',
    'borderDashOffset',
    'backgroundColor',
    'borderColor',
    'shadowColor',
    'shadowBlur',
    'shadowOffsetX',
    'shadowOffsetY'
  ]
function setTokenTextStyle(e, t, i, r, n, a, o, s) {
  i = (!n && i) || EMPTY_OBJ
  var l = r && r.inheritColor,
    h = t.getShallow('color'),
    u = t.getShallow('textBorderColor'),
    p = retrieve2(t.getShallow('opacity'), i.opacity)
  ;('inherit' !== h && 'auto' !== h) || (h = l || null),
    ('inherit' !== u && 'auto' !== u) || (u = l || null),
    a || ((h = h || i.color), (u = u || i.textBorderColor)),
    null != h && (e.fill = h),
    null != u && (e.stroke = u)
  var c = retrieve2(t.getShallow('textBorderWidth'), i.textBorderWidth)
  null != c && (e.lineWidth = c)
  var d = retrieve2(t.getShallow('textBorderType'), i.textBorderType)
  null != d && (e.lineDash = d)
  var f = retrieve2(t.getShallow('textBorderDashOffset'), i.textBorderDashOffset)
  null != f && (e.lineDashOffset = f),
    n || null != p || s || (p = r && r.defaultOpacity),
    null != p && (e.opacity = p),
    n || a || (null == e.fill && r.inheritColor && (e.fill = r.inheritColor))
  for (var m = 0; m < TEXT_PROPS_WITH_GLOBAL.length; m++) {
    var g = TEXT_PROPS_WITH_GLOBAL[m]
    null != (v = retrieve2(t.getShallow(g), i[g])) && (e[g] = v)
  }
  for (m = 0; m < TEXT_PROPS_SELF.length; m++) {
    g = TEXT_PROPS_SELF[m]
    null != (v = t.getShallow(g)) && (e[g] = v)
  }
  if (null == e.verticalAlign) {
    var y = t.getShallow('baseline')
    null != y && (e.verticalAlign = y)
  }
  if (!o || !r.disableBox) {
    for (m = 0; m < TEXT_PROPS_BOX.length; m++) {
      var v
      g = TEXT_PROPS_BOX[m]
      null != (v = t.getShallow(g)) && (e[g] = v)
    }
    var _ = t.getShallow('borderType')
    null != _ && (e.borderDash = _),
      ('auto' !== e.backgroundColor && 'inherit' !== e.backgroundColor) ||
        !l ||
        (e.backgroundColor = l),
      ('auto' !== e.borderColor && 'inherit' !== e.borderColor) || !l || (e.borderColor = l)
  }
}
function getFont(e, t) {
  var i = t && t.getModel('textStyle')
  return trim$1(
    [
      e.fontStyle || (i && i.getShallow('fontStyle')) || '',
      e.fontWeight || (i && i.getShallow('fontWeight')) || '',
      (e.fontSize || (i && i.getShallow('fontSize')) || 12) + 'px',
      e.fontFamily || (i && i.getShallow('fontFamily')) || 'sans-serif'
    ].join(' ')
  )
}
var labelInner = makeInner()
function setLabelValueAnimation(e, t, i, r) {
  if (e) {
    var n = labelInner(e)
    ;(n.prevValue = n.value), (n.value = i)
    var a = t.normal
    ;(n.valueAnimation = a.get('valueAnimation')),
      n.valueAnimation &&
        ((n.precision = a.get('precision')), (n.defaultInterpolatedText = r), (n.statesModels = t))
  }
}
function animateLabelValue(e, t, i, r, n) {
  var a = labelInner(e)
  if (a.valueAnimation) {
    var o = a.defaultInterpolatedText,
      s = retrieve2(a.interpolatedValue, a.prevValue),
      l = a.value
    ;(null == s ? initProps : updateProps$1)(e, {}, r, t, null, function (r) {
      var h = interpolateRawValues(i, a.precision, s, l, r)
      a.interpolatedValue = 1 === r ? null : h
      var u = getLabelText(
        { labelDataIndex: t, labelFetcher: n, defaultText: o ? o(h) : h + '' },
        a.statesModels,
        h
      )
      setLabelText(e, u)
    })
  }
}
var PATH_COLOR = ['textStyle', 'color'],
  tmpRichText = new ZRText(),
  TextStyleMixin = (function () {
    function e() {}
    return (
      (e.prototype.getTextColor = function (e) {
        var t = this.ecModel
        return this.getShallow('color') || (!e && t ? t.get(PATH_COLOR) : null)
      }),
      (e.prototype.getFont = function () {
        return getFont(
          {
            fontStyle: this.getShallow('fontStyle'),
            fontWeight: this.getShallow('fontWeight'),
            fontSize: this.getShallow('fontSize'),
            fontFamily: this.getShallow('fontFamily')
          },
          this.ecModel
        )
      }),
      (e.prototype.getTextRect = function (e) {
        return (
          tmpRichText.useStyle({
            text: e,
            fontStyle: this.getShallow('fontStyle'),
            fontWeight: this.getShallow('fontWeight'),
            fontSize: this.getShallow('fontSize'),
            fontFamily: this.getShallow('fontFamily'),
            verticalAlign: this.getShallow('verticalAlign') || this.getShallow('baseline'),
            padding: this.getShallow('padding'),
            lineHeight: this.getShallow('lineHeight'),
            rich: this.getShallow('rich')
          }),
          tmpRichText.update(),
          tmpRichText.getBoundingRect()
        )
      }),
      e
    )
  })(),
  LINE_STYLE_KEY_MAP = [
    ['lineWidth', 'width'],
    ['stroke', 'color'],
    ['opacity'],
    ['shadowBlur'],
    ['shadowOffsetX'],
    ['shadowOffsetY'],
    ['shadowColor'],
    ['lineDash', 'type'],
    ['lineDashOffset', 'dashOffset'],
    ['lineCap', 'cap'],
    ['lineJoin', 'join'],
    ['miterLimit']
  ],
  getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP),
  LineStyleMixin = (function () {
    function e() {}
    return (
      (e.prototype.getLineStyle = function (e) {
        return getLineStyle(this, e)
      }),
      e
    )
  })(),
  ITEM_STYLE_KEY_MAP = [
    ['fill', 'color'],
    ['stroke', 'borderColor'],
    ['lineWidth', 'borderWidth'],
    ['opacity'],
    ['shadowBlur'],
    ['shadowOffsetX'],
    ['shadowOffsetY'],
    ['shadowColor'],
    ['lineDash', 'borderType'],
    ['lineDashOffset', 'borderDashOffset'],
    ['lineCap', 'borderCap'],
    ['lineJoin', 'borderJoin'],
    ['miterLimit', 'borderMiterLimit']
  ],
  getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP),
  ItemStyleMixin = (function () {
    function e() {}
    return (
      (e.prototype.getItemStyle = function (e, t) {
        return getItemStyle(this, e, t)
      }),
      e
    )
  })(),
  Model = (function () {
    function e(e, t, i) {
      ;(this.parentModel = t), (this.ecModel = i), (this.option = e)
    }
    return (
      (e.prototype.init = function (e, t, i) {
        for (var r = [], n = 3; n < arguments.length; n++) r[n - 3] = arguments[n]
      }),
      (e.prototype.mergeOption = function (e, t) {
        merge(this.option, e, !0)
      }),
      (e.prototype.get = function (e, t) {
        return null == e ? this.option : this._doGet(this.parsePath(e), !t && this.parentModel)
      }),
      (e.prototype.getShallow = function (e, t) {
        var i = this.option,
          r = null == i ? i : i[e]
        if (null == r && !t) {
          var n = this.parentModel
          n && (r = n.getShallow(e))
        }
        return r
      }),
      (e.prototype.getModel = function (t, i) {
        var r = null != t,
          n = r ? this.parsePath(t) : null
        return new e(
          r ? this._doGet(n) : this.option,
          (i = i || (this.parentModel && this.parentModel.getModel(this.resolveParentPath(n)))),
          this.ecModel
        )
      }),
      (e.prototype.isEmpty = function () {
        return null == this.option
      }),
      (e.prototype.restoreData = function () {}),
      (e.prototype.clone = function () {
        return new (0, this.constructor)(clone$3(this.option))
      }),
      (e.prototype.parsePath = function (e) {
        return 'string' == typeof e ? e.split('.') : e
      }),
      (e.prototype.resolveParentPath = function (e) {
        return e
      }),
      (e.prototype.isAnimationEnabled = function () {
        if (!env.node && this.option) {
          if (null != this.option.animation) return !!this.option.animation
          if (this.parentModel) return this.parentModel.isAnimationEnabled()
        }
      }),
      (e.prototype._doGet = function (e, t) {
        var i = this.option
        if (!e) return i
        for (
          var r = 0;
          r < e.length && (!e[r] || null != (i = i && 'object' == typeof i ? i[e[r]] : null));
          r++
        );
        return null == i && t && (i = t._doGet(this.resolveParentPath(e), t.parentModel)), i
      }),
      e
    )
  })()
enableClassExtend(Model),
  enableClassCheck(Model),
  mixin(Model, LineStyleMixin),
  mixin(Model, ItemStyleMixin),
  mixin(Model, AreaStyleMixin),
  mixin(Model, TextStyleMixin)
var base = Math.round(10 * Math.random())
function getUID(e) {
  return [e || '', base++].join('_')
}
function enableSubTypeDefaulter(e) {
  var t = {}
  ;(e.registerSubTypeDefaulter = function (e, i) {
    var r = parseClassType(e)
    t[r.main] = i
  }),
    (e.determineSubType = function (i, r) {
      var n = r.type
      if (!n) {
        var a = parseClassType(i).main
        e.hasSubTypes(i) && t[a] && (n = t[a](r))
      }
      return n
    })
}
function enableTopologicalTravel(e, t) {
  function i(e, t) {
    return e[t] || (e[t] = { predecessor: [], successor: [] }), e[t]
  }
  e.topologicalTravel = function (e, r, n, a) {
    if (e.length) {
      var o = (function (e) {
          var r = {},
            n = []
          return (
            each$i(e, function (a) {
              var o = i(r, a),
                s = (function (e, t) {
                  var i = []
                  return (
                    each$i(e, function (e) {
                      indexOf$1(t, e) >= 0 && i.push(e)
                    }),
                    i
                  )
                })((o.originalDeps = t(a)), e)
              ;(o.entryCount = s.length),
                0 === o.entryCount && n.push(a),
                each$i(s, function (e) {
                  indexOf$1(o.predecessor, e) < 0 && o.predecessor.push(e)
                  var t = i(r, e)
                  indexOf$1(t.successor, e) < 0 && t.successor.push(a)
                })
            }),
            { graph: r, noEntryList: n }
          )
        })(r),
        s = o.graph,
        l = o.noEntryList,
        h = {}
      for (
        each$i(e, function (e) {
          h[e] = !0
        });
        l.length;

      ) {
        var u = l.pop(),
          p = s[u],
          c = !!h[u]
        c && (n.call(a, u, p.originalDeps.slice()), delete h[u]), each$i(p.successor, c ? f : d)
      }
      each$i(h, function () {
        throw new Error('')
      })
    }
    function d(e) {
      s[e].entryCount--, 0 === s[e].entryCount && l.push(e)
    }
    function f(e) {
      ;(h[e] = !0), d(e)
    }
  }
}
function inheritDefaultOption(e, t) {
  return merge(merge({}, e, !0), t, !0)
}
var langEN = {
    time: {
      month: [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December'
      ],
      monthAbbr: [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec'
      ],
      dayOfWeek: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      dayOfWeekAbbr: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
    },
    legend: { selector: { all: 'All', inverse: 'Inv' } },
    toolbox: {
      brush: {
        title: {
          rect: 'Box Select',
          polygon: 'Lasso Select',
          lineX: 'Horizontally Select',
          lineY: 'Vertically Select',
          keep: 'Keep Selections',
          clear: 'Clear Selections'
        }
      },
      dataView: { title: 'Data View', lang: ['Data View', 'Close', 'Refresh'] },
      dataZoom: { title: { zoom: 'Zoom', back: 'Zoom Reset' } },
      magicType: {
        title: {
          line: 'Switch to Line Chart',
          bar: 'Switch to Bar Chart',
          stack: 'Stack',
          tiled: 'Tile'
        }
      },
      restore: { title: 'Restore' },
      saveAsImage: { title: 'Save as Image', lang: ['Right Click to Save Image'] }
    },
    series: {
      typeNames: {
        pie: 'Pie chart',
        bar: 'Bar chart',
        line: 'Line chart',
        scatter: 'Scatter plot',
        effectScatter: 'Ripple scatter plot',
        radar: 'Radar chart',
        tree: 'Tree',
        treemap: 'Treemap',
        boxplot: 'Boxplot',
        candlestick: 'Candlestick',
        k: 'K line chart',
        heatmap: 'Heat map',
        map: 'Map',
        parallel: 'Parallel coordinate map',
        lines: 'Line graph',
        graph: 'Relationship graph',
        sankey: 'Sankey diagram',
        funnel: 'Funnel chart',
        gauge: 'Gauge',
        pictorialBar: 'Pictorial bar',
        themeRiver: 'Theme River Map',
        sunburst: 'Sunburst'
      }
    },
    aria: {
      general: { withTitle: 'This is a chart about "{title}"', withoutTitle: 'This is a chart' },
      series: {
        single: {
          prefix: '',
          withName: ' with type {seriesType} named {seriesName}.',
          withoutName: ' with type {seriesType}.'
        },
        multiple: {
          prefix: '. It consists of {seriesCount} series count.',
          withName: ' The {seriesId} series is a {seriesType} representing {seriesName}.',
          withoutName: ' The {seriesId} series is a {seriesType}.',
          separator: { middle: '', end: '' }
        }
      },
      data: {
        allData: 'The data is as follows: ',
        partialData: 'The first {displayCnt} items are: ',
        withName: 'the data for {name} is {value}',
        withoutName: '{value}',
        separator: { middle: ', ', end: '. ' }
      }
    }
  },
  langZH = {
    time: {
      month: [
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        '',
        ''
      ],
      monthAbbr: [
        '1',
        '2',
        '3',
        '4',
        '5',
        '6',
        '7',
        '8',
        '9',
        '10',
        '11',
        '12'
      ],
      dayOfWeek: ['', '', '', '', '', '', ''],
      dayOfWeekAbbr: ['', '', '', '', '', '', '']
    },
    legend: { selector: { all: '', inverse: '' } },
    toolbox: {
      brush: {
        title: {
          rect: '',
          polygon: '',
          lineX: '',
          lineY: '',
          keep: '',
          clear: ''
        }
      },
      dataView: { title: '', lang: ['', '', ''] },
      dataZoom: { title: { zoom: '', back: '' } },
      magicType: {
        title: {
          line: '',
          bar: '',
          stack: '',
          tiled: ''
        }
      },
      restore: { title: '' },
      saveAsImage: { title: '', lang: [''] }
    },
    series: {
      typeNames: {
        pie: '',
        bar: '',
        line: '',
        scatter: '',
        effectScatter: '',
        radar: '',
        tree: '',
        treemap: '',
        boxplot: '',
        candlestick: 'K',
        k: 'K',
        heatmap: '',
        map: '',
        parallel: '',
        lines: '',
        graph: '',
        sankey: '',
        funnel: '',
        gauge: '',
        pictorialBar: '',
        themeRiver: '',
        sunburst: ''
      }
    },
    aria: {
      general: { withTitle: '{title}', withoutTitle: '' },
      series: {
        single: {
          prefix: '',
          withName: '{seriesType}{seriesName}',
          withoutName: '{seriesType}'
        },
        multiple: {
          prefix: '{seriesCount}',
          withName: '{seriesId}{seriesName}{seriesType}',
          withoutName: '{seriesId}{seriesType}',
          separator: { middle: '', end: '' }
        }
      },
      data: {
        allData: '',
        partialData: '{displayCnt}',
        withName: '{name}{value}',
        withoutName: '{value}',
        separator: { middle: '', end: '' }
      }
    }
  },
  LOCALE_ZH = 'ZH',
  LOCALE_EN = 'EN',
  DEFAULT_LOCALE = LOCALE_EN,
  localeStorage = {},
  localeModels = {},
  SYSTEM_LANG =
    env.domSupported &&
    (document.documentElement.lang || navigator.language || navigator.browserLanguage)
      .toUpperCase()
      .indexOf(LOCALE_ZH) > -1
      ? LOCALE_ZH
      : DEFAULT_LOCALE
function registerLocale(e, t) {
  ;(e = e.toUpperCase()), (localeModels[e] = new Model(t)), (localeStorage[e] = t)
}
function createLocaleObject(e) {
  if (isString(e)) {
    var t = localeStorage[e.toUpperCase()] || {}
    return e === LOCALE_ZH || e === LOCALE_EN
      ? clone$3(t)
      : merge(clone$3(t), clone$3(localeStorage[DEFAULT_LOCALE]), !1)
  }
  return merge(clone$3(e), clone$3(localeStorage[DEFAULT_LOCALE]), !1)
}
function getLocaleModel(e) {
  return localeModels[e]
}
function getDefaultLocaleModel() {
  return localeModels[DEFAULT_LOCALE]
}
registerLocale(LOCALE_EN, langEN), registerLocale(LOCALE_ZH, langZH)
var ONE_SECOND = 1e3,
  ONE_MINUTE = 60 * ONE_SECOND,
  ONE_HOUR = 60 * ONE_MINUTE,
  ONE_DAY = 24 * ONE_HOUR,
  ONE_YEAR = 365 * ONE_DAY,
  defaultLeveledFormatter = {
    year: '{yyyy}',
    month: '{MMM}',
    day: '{d}',
    hour: '{HH}:{mm}',
    minute: '{HH}:{mm}',
    second: '{HH}:{mm}:{ss}',
    millisecond: '{hh}:{mm}:{ss} {SSS}',
    none: '{yyyy}-{MM}-{dd} {hh}:{mm}:{ss} {SSS}'
  },
  fullDayFormatter = '{yyyy}-{MM}-{dd}',
  fullLeveledFormatter = {
    year: '{yyyy}',
    month: '{yyyy}-{MM}',
    day: fullDayFormatter,
    hour: fullDayFormatter + ' ' + defaultLeveledFormatter.hour,
    minute: fullDayFormatter + ' ' + defaultLeveledFormatter.minute,
    second: fullDayFormatter + ' ' + defaultLeveledFormatter.second,
    millisecond: defaultLeveledFormatter.none
  },
  primaryTimeUnits = ['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond'],
  timeUnits = [
    'year',
    'half-year',
    'quarter',
    'month',
    'week',
    'half-week',
    'day',
    'half-day',
    'quarter-day',
    'hour',
    'minute',
    'second',
    'millisecond'
  ]
function pad(e, t) {
  return '0000'.substr(0, t - (e += '').length) + e
}
function getPrimaryTimeUnit(e) {
  switch (e) {
    case 'half-year':
    case 'quarter':
      return 'month'
    case 'week':
    case 'half-week':
      return 'day'
    case 'half-day':
    case 'quarter-day':
      return 'hour'
    default:
      return e
  }
}
function isPrimaryTimeUnit(e) {
  return e === getPrimaryTimeUnit(e)
}
function getDefaultFormatPrecisionOfInterval(e) {
  switch (e) {
    case 'year':
    case 'month':
      return 'day'
    case 'millisecond':
      return 'millisecond'
    default:
      return 'second'
  }
}
function format(e, t, i, r) {
  var n = parseDate(e),
    a = n[fullYearGetterName(i)](),
    o = n[monthGetterName(i)]() + 1,
    s = Math.floor((o - 1) / 4) + 1,
    l = n[dateGetterName(i)](),
    h = n['get' + (i ? 'UTC' : '') + 'Day'](),
    u = n[hoursGetterName(i)](),
    p = ((u - 1) % 12) + 1,
    c = n[minutesGetterName(i)](),
    d = n[secondsGetterName(i)](),
    f = n[millisecondsGetterName(i)](),
    m = (
      r instanceof Model ? r : getLocaleModel(r || SYSTEM_LANG) || getDefaultLocaleModel()
    ).getModel('time'),
    g = m.get('month'),
    y = m.get('monthAbbr'),
    v = m.get('dayOfWeek'),
    _ = m.get('dayOfWeekAbbr')
  return (t || '')
    .replace(/{yyyy}/g, a + '')
    .replace(/{yy}/g, (a % 100) + '')
    .replace(/{Q}/g, s + '')
    .replace(/{MMMM}/g, g[o - 1])
    .replace(/{MMM}/g, y[o - 1])
    .replace(/{MM}/g, pad(o, 2))
    .replace(/{M}/g, o + '')
    .replace(/{dd}/g, pad(l, 2))
    .replace(/{d}/g, l + '')
    .replace(/{eeee}/g, v[h])
    .replace(/{ee}/g, _[h])
    .replace(/{e}/g, h + '')
    .replace(/{HH}/g, pad(u, 2))
    .replace(/{H}/g, u + '')
    .replace(/{hh}/g, pad(p + '', 2))
    .replace(/{h}/g, p + '')
    .replace(/{mm}/g, pad(c, 2))
    .replace(/{m}/g, c + '')
    .replace(/{ss}/g, pad(d, 2))
    .replace(/{s}/g, d + '')
    .replace(/{SSS}/g, pad(f, 3))
    .replace(/{S}/g, f + '')
}
function leveledFormat(e, t, i, r, n) {
  var a = null
  if ('string' == typeof i) a = i
  else if ('function' == typeof i) a = i(e.value, t, { level: e.level })
  else {
    var o = extend$3({}, defaultLeveledFormatter)
    if (e.level > 0)
      for (var s = 0; s < primaryTimeUnits.length; ++s)
        o[primaryTimeUnits[s]] = '{primary|' + o[primaryTimeUnits[s]] + '}'
    var l = i ? (!1 === i.inherit ? i : defaults$1(i, o)) : o,
      h = getUnitFromValue(e.value, n)
    if (l[h]) a = l[h]
    else if (l.inherit) {
      for (s = timeUnits.indexOf(h) - 1; s >= 0; --s)
        if (l[h]) {
          a = l[h]
          break
        }
      a = a || o.none
    }
    if (isArray$1(a)) {
      var u = null == e.level ? 0 : e.level >= 0 ? e.level : a.length + e.level
      a = a[(u = Math.min(u, a.length - 1))]
    }
  }
  return format(new Date(e.value), a, n, r)
}
function getUnitFromValue(e, t) {
  var i = parseDate(e),
    r = i[monthGetterName(t)]() + 1,
    n = i[dateGetterName(t)](),
    a = i[hoursGetterName(t)](),
    o = i[minutesGetterName(t)](),
    s = i[secondsGetterName(t)](),
    l = 0 === i[millisecondsGetterName(t)](),
    h = l && 0 === s,
    u = h && 0 === o,
    p = u && 0 === a,
    c = p && 1 === n
  return c && 1 === r
    ? 'year'
    : c
    ? 'month'
    : p
    ? 'day'
    : u
    ? 'hour'
    : h
    ? 'minute'
    : l
    ? 'second'
    : 'millisecond'
}
function getUnitValue(e, t, i) {
  var r = 'number' == typeof e ? parseDate(e) : e
  switch ((t = t || getUnitFromValue(e, i))) {
    case 'year':
      return r[fullYearGetterName(i)]()
    case 'half-year':
      return r[monthGetterName(i)]() >= 6 ? 1 : 0
    case 'quarter':
      return Math.floor((r[monthGetterName(i)]() + 1) / 4)
    case 'month':
      return r[monthGetterName(i)]()
    case 'day':
      return r[dateGetterName(i)]()
    case 'half-day':
      return r[hoursGetterName(i)]() / 24
    case 'hour':
      return r[hoursGetterName(i)]()
    case 'minute':
      return r[minutesGetterName(i)]()
    case 'second':
      return r[secondsGetterName(i)]()
    case 'millisecond':
      return r[millisecondsGetterName(i)]()
  }
}
function fullYearGetterName(e) {
  return e ? 'getUTCFullYear' : 'getFullYear'
}
function monthGetterName(e) {
  return e ? 'getUTCMonth' : 'getMonth'
}
function dateGetterName(e) {
  return e ? 'getUTCDate' : 'getDate'
}
function hoursGetterName(e) {
  return e ? 'getUTCHours' : 'getHours'
}
function minutesGetterName(e) {
  return e ? 'getUTCMinutes' : 'getMinutes'
}
function secondsGetterName(e) {
  return e ? 'getUTCSeconds' : 'getSeconds'
}
function millisecondsGetterName(e) {
  return e ? 'getUTCSeconds' : 'getSeconds'
}
function fullYearSetterName(e) {
  return e ? 'setUTCFullYear' : 'setFullYear'
}
function monthSetterName(e) {
  return e ? 'setUTCMonth' : 'setMonth'
}
function dateSetterName(e) {
  return e ? 'setUTCDate' : 'setDate'
}
function hoursSetterName(e) {
  return e ? 'setUTCHours' : 'setHours'
}
function minutesSetterName(e) {
  return e ? 'setUTCMinutes' : 'setMinutes'
}
function secondsSetterName(e) {
  return e ? 'setUTCSeconds' : 'setSeconds'
}
function millisecondsSetterName(e) {
  return e ? 'setUTCSeconds' : 'setSeconds'
}
function addCommas(e) {
  if (!isNumeric(e)) return isString(e) ? e : '-'
  var t = (e + '').split('.')
  return t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (t.length > 1 ? '.' + t[1] : '')
}
function toCamelCase(e, t) {
  return (
    (e = (e || '').toLowerCase().replace(/-(.)/g, function (e, t) {
      return t.toUpperCase()
    })),
    t && e && (e = e.charAt(0).toUpperCase() + e.slice(1)),
    e
  )
}
var normalizeCssArray = normalizeCssArray$1,
  replaceReg = /([&<>"'])/g,
  replaceMap = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }
function encodeHTML(e) {
  return null == e
    ? ''
    : (e + '').replace(replaceReg, function (e, t) {
        return replaceMap[t]
      })
}
function makeValueReadable(e, t, i) {
  function r(e) {
    return e && trim$1(e) ? e : '-'
  }
  function n(e) {
    return !(null == e || isNaN(e) || !isFinite(e))
  }
  var a = 'time' === t,
    o = e instanceof Date
  if (a || o) {
    var s = a ? parseDate(e) : e
    if (!isNaN(+s)) return format(s, '{yyyy}-{MM}-{dd} {hh}:{mm}:{ss}', i)
    if (o) return '-'
  }
  if ('ordinal' === t) return isStringSafe(e) ? r(e) : isNumber(e) && n(e) ? e + '' : '-'
  var l = numericToNumber(e)
  return n(l) ? addCommas(l) : isStringSafe(e) ? r(e) : '-'
}
var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'],
  wrapVar = function (e, t) {
    return '{' + e + (null == t ? '' : t) + '}'
  }
function formatTpl(e, t, i) {
  isArray$1(t) || (t = [t])
  var r = t.length
  if (!r) return ''
  for (var n = t[0].$vars || [], a = 0; a < n.length; a++) {
    var o = TPL_VAR_ALIAS[a]
    e = e.replace(wrapVar(o), wrapVar(o, 0))
  }
  for (var s = 0; s < r; s++)
    for (var l = 0; l < n.length; l++) {
      var h = t[s][n[l]]
      e = e.replace(wrapVar(TPL_VAR_ALIAS[l], s), i ? encodeHTML(h) : h)
    }
  return e
}
function formatTplSimple(e, t, i) {
  return (
    each$i(t, function (t, r) {
      e = e.replace('{' + r + '}', i ? encodeHTML(t) : t)
    }),
    e
  )
}
function getTooltipMarker(e, t) {
  var i = isString(e) ? { color: e, extraCssText: t } : e || {},
    r = i.color,
    n = i.type
  t = i.extraCssText
  var a = i.renderMode || 'html'
  return r
    ? 'html' === a
      ? 'subItem' === n
        ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' +
          encodeHTML(r) +
          ';' +
          (t || '') +
          '"></span>'
        : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' +
          encodeHTML(r) +
          ';' +
          (t || '') +
          '"></span>'
      : {
          renderMode: a,
          content: '{' + (i.markerId || 'markerX') + '|}  ',
          style:
            'subItem' === n
              ? { width: 4, height: 4, borderRadius: 2, backgroundColor: r }
              : { width: 10, height: 10, borderRadius: 5, backgroundColor: r }
        }
    : ''
}
function convertToColorString(e, t) {
  return (
    (t = t || 'transparent'),
    isString(e) ? e : (isObject$7(e) && e.colorStops && (e.colorStops[0] || {}).color) || t
  )
}
function windowOpen(e, t) {
  if ('_blank' === t || 'blank' === t) {
    var i = window.open()
    ;(i.opener = null), (i.location.href = e)
  } else window.open(e, t)
}
var each$h = each$i,
  LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'],
  HV_NAMES = [
    ['width', 'left', 'right'],
    ['height', 'top', 'bottom']
  ]
function boxLayout(e, t, i, r, n) {
  var a = 0,
    o = 0
  null == r && (r = 1 / 0), null == n && (n = 1 / 0)
  var s = 0
  t.eachChild(function (l, h) {
    var u,
      p,
      c = l.getBoundingRect(),
      d = t.childAt(h + 1),
      f = d && d.getBoundingRect()
    if ('horizontal' === e) {
      var m = c.width + (f ? -f.x + c.x : 0)
      ;(u = a + m) > r || l.newline
        ? ((a = 0), (u = m), (o += s + i), (s = c.height))
        : (s = Math.max(s, c.height))
    } else {
      var g = c.height + (f ? -f.y + c.y : 0)
      ;(p = o + g) > n || l.newline
        ? ((a += s + i), (o = 0), (p = g), (s = c.width))
        : (s = Math.max(s, c.width))
    }
    l.newline ||
      ((l.x = a), (l.y = o), l.markRedraw(), 'horizontal' === e ? (a = u + i) : (o = p + i))
  })
}
var box = boxLayout
function getAvailableSize(e, t, i) {
  var r = t.width,
    n = t.height,
    a = parsePercent$1(e.left, r),
    o = parsePercent$1(e.top, n),
    s = parsePercent$1(e.right, r),
    l = parsePercent$1(e.bottom, n)
  return (
    (isNaN(a) || isNaN(parseFloat(e.left))) && (a = 0),
    (isNaN(s) || isNaN(parseFloat(e.right))) && (s = r),
    (isNaN(o) || isNaN(parseFloat(e.top))) && (o = 0),
    (isNaN(l) || isNaN(parseFloat(e.bottom))) && (l = n),
    (i = normalizeCssArray(i || 0)),
    { width: Math.max(s - a - i[1] - i[3], 0), height: Math.max(l - o - i[0] - i[2], 0) }
  )
}
function getLayoutRect(e, t, i) {
  i = normalizeCssArray(i || 0)
  var r = t.width,
    n = t.height,
    a = parsePercent$1(e.left, r),
    o = parsePercent$1(e.top, n),
    s = parsePercent$1(e.right, r),
    l = parsePercent$1(e.bottom, n),
    h = parsePercent$1(e.width, r),
    u = parsePercent$1(e.height, n),
    p = i[2] + i[0],
    c = i[1] + i[3],
    d = e.aspect
  switch (
    (isNaN(h) && (h = r - s - c - a),
    isNaN(u) && (u = n - l - p - o),
    null != d &&
      (isNaN(h) && isNaN(u) && (d > r / n ? (h = 0.8 * r) : (u = 0.8 * n)),
      isNaN(h) && (h = d * u),
      isNaN(u) && (u = h / d)),
    isNaN(a) && (a = r - s - h - c),
    isNaN(o) && (o = n - l - u - p),
    e.left || e.right)
  ) {
    case 'center':
      a = r / 2 - h / 2 - i[3]
      break
    case 'right':
      a = r - h - c
  }
  switch (e.top || e.bottom) {
    case 'middle':
    case 'center':
      o = n / 2 - u / 2 - i[0]
      break
    case 'bottom':
      o = n - u - p
  }
  ;(a = a || 0),
    (o = o || 0),
    isNaN(h) && (h = r - c - a - (s || 0)),
    isNaN(u) && (u = n - p - o - (l || 0))
  var f = new BoundingRect(a + i[3], o + i[0], h, u)
  return (f.margin = i), f
}
function positionElement(e, t, i, r, n) {
  var a = !n || !n.hv || n.hv[0],
    o = !n || !n.hv || n.hv[1],
    s = (n && n.boundingMode) || 'all'
  if (a || o) {
    var l
    if ('raw' === s)
      l =
        'group' === e.type
          ? new BoundingRect(0, 0, +t.width || 0, +t.height || 0)
          : e.getBoundingRect()
    else if (((l = e.getBoundingRect()), e.needLocalTransform())) {
      var h = e.getLocalTransform()
      ;(l = l.clone()).applyTransform(h)
    }
    var u = getLayoutRect(defaults$1({ width: l.width, height: l.height }, t), i, r),
      p = a ? u.x - l.x : 0,
      c = o ? u.y - l.y : 0
    'raw' === s ? ((e.x = p), (e.y = c)) : ((e.x += p), (e.y += c)), e.markRedraw()
  }
}
function sizeCalculable(e, t) {
  return null != e[HV_NAMES[t][0]] || (null != e[HV_NAMES[t][1]] && null != e[HV_NAMES[t][2]])
}
function fetchLayoutMode(e) {
  var t = e.layoutMode || e.constructor.layoutMode
  return isObject$7(t) ? t : t ? { type: t } : null
}
function mergeLayoutParam(e, t, i) {
  var r = i && i.ignoreSize
  !isArray$1(r) && (r = [r, r])
  var n = o(HV_NAMES[0], 0),
    a = o(HV_NAMES[1], 1)
  function o(i, n) {
    var a = {},
      o = 0,
      h = {},
      u = 0
    if (
      (each$h(i, function (t) {
        h[t] = e[t]
      }),
      each$h(i, function (e) {
        s(t, e) && (a[e] = h[e] = t[e]), l(a, e) && o++, l(h, e) && u++
      }),
      r[n])
    )
      return l(t, i[1]) ? (h[i[2]] = null) : l(t, i[2]) && (h[i[1]] = null), h
    if (2 !== u && o) {
      if (o >= 2) return a
      for (var p = 0; p < i.length; p++) {
        var c = i[p]
        if (!s(a, c) && s(e, c)) {
          a[c] = e[c]
          break
        }
      }
      return a
    }
    return h
  }
  function s(e, t) {
    return e.hasOwnProperty(t)
  }
  function l(e, t) {
    return null != e[t] && 'auto' !== e[t]
  }
  function h(e, t, i) {
    each$h(e, function (e) {
      t[e] = i[e]
    })
  }
  h(HV_NAMES[0], e, n), h(HV_NAMES[1], e, a)
}
function getLayoutParams(e) {
  return copyLayoutParams({}, e)
}
function copyLayoutParams(e, t) {
  return (
    t &&
      e &&
      each$h(LOCATION_PARAMS, function (i) {
        t.hasOwnProperty(i) && (e[i] = t[i])
      }),
    e
  )
}
curry$1(boxLayout, 'vertical'), curry$1(boxLayout, 'horizontal')
var inner$l = makeInner(),
  ComponentModel = (function (e) {
    function t(t, i, r) {
      var n = e.call(this, t, i, r) || this
      return (n.uid = getUID('ec_cpt_model')), n
    }
    var i
    return (
      __extends(t, e),
      (t.prototype.init = function (e, t, i) {
        this.mergeDefaultAndTheme(e, i)
      }),
      (t.prototype.mergeDefaultAndTheme = function (e, t) {
        var i = fetchLayoutMode(this),
          r = i ? getLayoutParams(e) : {}
        merge(e, t.getTheme().get(this.mainType)),
          merge(e, this.getDefaultOption()),
          i && mergeLayoutParam(e, r, i)
      }),
      (t.prototype.mergeOption = function (e, t) {
        merge(this.option, e, !0)
        var i = fetchLayoutMode(this)
        i && mergeLayoutParam(this.option, e, i)
      }),
      (t.prototype.optionUpdated = function (e, t) {}),
      (t.prototype.getDefaultOption = function () {
        var e = this.constructor
        if (!isExtendedClass(e)) return e.defaultOption
        var t = inner$l(this)
        if (!t.defaultOption) {
          for (var i = [], r = e; r; ) {
            var n = r.prototype.defaultOption
            n && i.push(n), (r = r.superClass)
          }
          for (var a = {}, o = i.length - 1; o >= 0; o--) a = merge(a, i[o], !0)
          t.defaultOption = a
        }
        return t.defaultOption
      }),
      (t.prototype.getReferringComponents = function (e, t) {
        var i = e + 'Index',
          r = e + 'Id'
        return queryReferringComponents(
          this.ecModel,
          e,
          { index: this.get(i, !0), id: this.get(r, !0) },
          t
        )
      }),
      (t.prototype.getBoxLayoutParams = function () {
        var e = this
        return {
          left: e.get('left'),
          top: e.get('top'),
          right: e.get('right'),
          bottom: e.get('bottom'),
          width: e.get('width'),
          height: e.get('height')
        }
      }),
      (t.protoInitialize =
        (((i = t.prototype).type = 'component'),
        (i.id = ''),
        (i.name = ''),
        (i.mainType = ''),
        (i.subType = ''),
        void (i.componentIndex = 0))),
      t
    )
  })(Model)
function getDependencies(e) {
  var t = []
  return (
    each$i(ComponentModel.getClassesByMainType(e), function (e) {
      t = t.concat(e.dependencies || e.prototype.dependencies || [])
    }),
    (t = map$1(t, function (e) {
      return parseClassType(e).main
    })),
    'dataset' !== e && indexOf$1(t, 'dataset') <= 0 && t.unshift('dataset'),
    t
  )
}
mountExtend(ComponentModel, Model),
  enableClassManagement(ComponentModel),
  enableSubTypeDefaulter(ComponentModel),
  enableTopologicalTravel(ComponentModel, getDependencies)
var platform = ''
'undefined' != typeof navigator && (platform = navigator.platform || '')
var decalColor = 'rgba(0, 0, 0, 0.2)',
  globalDefault = {
    darkMode: 'auto',
    color: [
      '#5470c6',
      '#91cc75',
      '#fac858',
      '#ee6666',
      '#73c0de',
      '#3ba272',
      '#fc8452',
      '#9a60b4',
      '#ea7ccc'
    ],
    gradientColor: ['#f6efa6', '#d88273', '#bf444c'],
    aria: {
      decal: {
        decals: [
          {
            color: decalColor,
            dashArrayX: [1, 0],
            dashArrayY: [2, 5],
            symbolSize: 1,
            rotation: Math.PI / 6
          },
          {
            color: decalColor,
            symbol: 'circle',
            dashArrayX: [
              [8, 8],
              [0, 8, 8, 0]
            ],
            dashArrayY: [6, 0],
            symbolSize: 0.8
          },
          { color: decalColor, dashArrayX: [1, 0], dashArrayY: [4, 3], rotation: -Math.PI / 4 },
          {
            color: decalColor,
            dashArrayX: [
              [6, 6],
              [0, 6, 6, 0]
            ],
            dashArrayY: [6, 0]
          },
          {
            color: decalColor,
            dashArrayX: [
              [1, 0],
              [1, 6]
            ],
            dashArrayY: [1, 0, 6, 0],
            rotation: Math.PI / 4
          },
          {
            color: decalColor,
            symbol: 'triangle',
            dashArrayX: [
              [9, 9],
              [0, 9, 9, 0]
            ],
            dashArrayY: [7, 2],
            symbolSize: 0.75
          }
        ]
      }
    },
    textStyle: {
      fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',
      fontSize: 12,
      fontStyle: 'normal',
      fontWeight: 'normal'
    },
    blendMode: null,
    stateAnimation: { duration: 300, easing: 'cubicOut' },
    animation: 'auto',
    animationDuration: 1e3,
    animationDurationUpdate: 500,
    animationEasing: 'cubicInOut',
    animationEasingUpdate: 'cubicInOut',
    animationThreshold: 2e3,
    progressiveThreshold: 3e3,
    progressive: 400,
    hoverLayerThreshold: 3e3,
    useUTC: !1
  },
  VISUAL_DIMENSIONS = createHashMap(['tooltip', 'label', 'itemName', 'itemId', 'seriesName']),
  SOURCE_FORMAT_ORIGINAL = 'original',
  SOURCE_FORMAT_ARRAY_ROWS = 'arrayRows',
  SOURCE_FORMAT_OBJECT_ROWS = 'objectRows',
  SOURCE_FORMAT_KEYED_COLUMNS = 'keyedColumns',
  SOURCE_FORMAT_TYPED_ARRAY = 'typedArray',
  SOURCE_FORMAT_UNKNOWN = 'unknown',
  SERIES_LAYOUT_BY_COLUMN = 'column',
  SERIES_LAYOUT_BY_ROW = 'row',
  BE_ORDINAL = { Must: 1, Might: 2, Not: 3 },
  innerGlobalModel = makeInner()
function resetSourceDefaulter(e) {
  innerGlobalModel(e).datasetMap = createHashMap()
}
function makeSeriesEncodeForAxisCoordSys(e, t, i) {
  var r = {},
    n = querySeriesUpstreamDatasetModel(t)
  if (!n || !e) return r
  var a,
    o,
    s = [],
    l = [],
    h = t.ecModel,
    u = innerGlobalModel(h).datasetMap,
    p = n.uid + '_' + i.seriesLayoutBy
  each$i((e = e.slice()), function (t, i) {
    var n = isObject$7(t) ? t : (e[i] = { name: t })
    'ordinal' === n.type && null == a && ((a = i), (o = f(n))), (r[n.name] = [])
  })
  var c = u.get(p) || u.set(p, { categoryWayDim: o, valueWayDim: 0 })
  function d(e, t, i) {
    for (var r = 0; r < i; r++) e.push(t + r)
  }
  function f(e) {
    var t = e.dimsDef
    return t ? t.length : 1
  }
  return (
    each$i(e, function (e, t) {
      var i = e.name,
        n = f(e)
      if (null == a) {
        var o = c.valueWayDim
        d(r[i], o, n), d(l, o, n), (c.valueWayDim += n)
      } else if (a === t) d(r[i], 0, n), d(s, 0, n)
      else {
        o = c.categoryWayDim
        d(r[i], o, n), d(l, o, n), (c.categoryWayDim += n)
      }
    }),
    s.length && (r.itemName = s),
    l.length && (r.seriesName = l),
    r
  )
}
function makeSeriesEncodeForNameBased(e, t, i) {
  var r = {}
  if (!querySeriesUpstreamDatasetModel(e)) return r
  var n,
    a = t.sourceFormat,
    o = t.dimensionsDefine
  ;(a !== SOURCE_FORMAT_OBJECT_ROWS && a !== SOURCE_FORMAT_KEYED_COLUMNS) ||
    each$i(o, function (e, t) {
      'name' === (isObject$7(e) ? e.name : e) && (n = t)
    })
  var s = (function () {
    for (var e = {}, r = {}, s = [], l = 0, h = Math.min(5, i); l < h; l++) {
      var u = doGuessOrdinal(t.data, a, t.seriesLayoutBy, o, t.startIndex, l)
      s.push(u)
      var p = u === BE_ORDINAL.Not
      if (
        (p && null == e.v && l !== n && (e.v = l),
        (null == e.n || e.n === e.v || (!p && s[e.n] === BE_ORDINAL.Not)) && (e.n = l),
        c(e) && s[e.n] !== BE_ORDINAL.Not)
      )
        return e
      p ||
        (u === BE_ORDINAL.Might && null == r.v && l !== n && (r.v = l),
        (null != r.n && r.n !== r.v) || (r.n = l))
    }
    function c(e) {
      return null != e.v && null != e.n
    }
    return c(e) ? e : c(r) ? r : null
  })()
  if (s) {
    r.value = [s.v]
    var l = null != n ? n : s.n
    ;(r.itemName = [l]), (r.seriesName = [l])
  }
  return r
}
function querySeriesUpstreamDatasetModel(e) {
  if (!e.get('data', !0))
    return queryReferringComponents(
      e.ecModel,
      'dataset',
      { index: e.get('datasetIndex', !0), id: e.get('datasetId', !0) },
      SINGLE_REFERRING
    ).models[0]
}
function queryDatasetUpstreamDatasetModels(e) {
  return e.get('transform', !0) || e.get('fromTransformResult', !0)
    ? queryReferringComponents(
        e.ecModel,
        'dataset',
        { index: e.get('fromDatasetIndex', !0), id: e.get('fromDatasetId', !0) },
        SINGLE_REFERRING
      ).models
    : []
}
function guessOrdinal(e, t) {
  return doGuessOrdinal(
    e.data,
    e.sourceFormat,
    e.seriesLayoutBy,
    e.dimensionsDefine,
    e.startIndex,
    t
  )
}
function doGuessOrdinal(e, t, i, r, n, a) {
  var o, s, l
  if (isTypedArray(e)) return BE_ORDINAL.Not
  if (r) {
    var h = r[a]
    isObject$7(h) ? ((s = h.name), (l = h.type)) : isString(h) && (s = h)
  }
  if (null != l) return 'ordinal' === l ? BE_ORDINAL.Must : BE_ORDINAL.Not
  if (t === SOURCE_FORMAT_ARRAY_ROWS) {
    var u = e
    if (i === SERIES_LAYOUT_BY_ROW) {
      for (var p = u[a], c = 0; c < (p || []).length && c < 5; c++)
        if (null != (o = _(p[n + c]))) return o
    } else
      for (c = 0; c < u.length && c < 5; c++) {
        var d = u[n + c]
        if (d && null != (o = _(d[a]))) return o
      }
  } else if (t === SOURCE_FORMAT_OBJECT_ROWS) {
    var f = e
    if (!s) return BE_ORDINAL.Not
    for (c = 0; c < f.length && c < 5; c++) {
      if ((y = f[c]) && null != (o = _(y[s]))) return o
    }
  } else if (t === SOURCE_FORMAT_KEYED_COLUMNS) {
    var m = e
    if (!s) return BE_ORDINAL.Not
    if (!(p = m[s]) || isTypedArray(p)) return BE_ORDINAL.Not
    for (c = 0; c < p.length && c < 5; c++) if (null != (o = _(p[c]))) return o
  } else if (t === SOURCE_FORMAT_ORIGINAL) {
    var g = e
    for (c = 0; c < g.length && c < 5; c++) {
      var y,
        v = getDataItemValue((y = g[c]))
      if (!isArray$1(v)) return BE_ORDINAL.Not
      if (null != (o = _(v[a]))) return o
    }
  }
  function _(e) {
    var t = isString(e)
    return null != e && isFinite(e) && '' !== e
      ? t
        ? BE_ORDINAL.Might
        : BE_ORDINAL.Not
      : t && '-' !== e
      ? BE_ORDINAL.Must
      : void 0
  }
  return BE_ORDINAL.Not
}
var internalOptionCreatorMap = createHashMap()
function registerInternalOptionCreator(e, t) {
  assert$1(null == internalOptionCreatorMap.get(e) && t), internalOptionCreatorMap.set(e, t)
}
function concatInternalOptions(e, t, i) {
  var r = internalOptionCreatorMap.get(t)
  if (!r) return i
  var n = r(e)
  return n ? i.concat(n) : i
}
var innerColor = makeInner(),
  innerDecal = makeInner(),
  PaletteMixin = (function () {
    function e() {}
    return (
      (e.prototype.getColorFromPalette = function (e, t, i) {
        var r = normalizeToArray(this.get('color', !0)),
          n = this.get('colorLayer', !0)
        return getFromPalette(this, innerColor, r, n, e, t, i)
      }),
      (e.prototype.clearColorPalette = function () {
        clearPalette(this, innerColor)
      }),
      e
    )
  })(),
  reCreateSeriesIndices,
  assertSeriesInitialized,
  initBase
function getDecalFromPalette(e, t, i, r) {
  var n = normalizeToArray(e.get(['aria', 'decal', 'decals']))
  return getFromPalette(e, innerDecal, n, null, t, i, r)
}
function getNearestPalette(e, t) {
  for (var i = e.length, r = 0; r < i; r++) if (e[r].length > t) return e[r]
  return e[i - 1]
}
function getFromPalette(e, t, i, r, n, a, o) {
  var s = t((a = a || e)),
    l = s.paletteIdx || 0,
    h = (s.paletteNameMap = s.paletteNameMap || {})
  if (h.hasOwnProperty(n)) return h[n]
  var u = null != o && r ? getNearestPalette(r, o) : i
  if ((u = u || i) && u.length) {
    var p = u[l]
    return n && (h[n] = p), (s.paletteIdx = (l + 1) % u.length), p
  }
}
function clearPalette(e, t) {
  ;(t(e).paletteIdx = 0), (t(e).paletteNameMap = {})
}
var OPTION_INNER_KEY = '\0_ec_inner',
  OPTION_INNER_VALUE = 1,
  GlobalModel = (function (e) {
    function t() {
      return (null !== e && e.apply(this, arguments)) || this
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (e, t, i, r, n, a) {
        ;(r = r || {}),
          (this.option = null),
          (this._theme = new Model(r)),
          (this._locale = new Model(n)),
          (this._optionManager = a)
      }),
      (t.prototype.setOption = function (e, t, i) {
        var r = normalizeSetOptionInput(t)
        this._optionManager.setOption(e, i, r), this._resetOption(null, r)
      }),
      (t.prototype.resetOption = function (e, t) {
        return this._resetOption(e, normalizeSetOptionInput(t))
      }),
      (t.prototype._resetOption = function (e, t) {
        var i = !1,
          r = this._optionManager
        if (!e || 'recreate' === e) {
          var n = r.mountOption('recreate' === e)
          this.option && 'recreate' !== e
            ? (this.restoreData(), this._mergeOption(n, t))
            : initBase(this, n),
            (i = !0)
        }
        if (
          (('timeline' !== e && 'media' !== e) || this.restoreData(),
          !e || 'recreate' === e || 'timeline' === e)
        ) {
          var a = r.getTimelineOption(this)
          a && ((i = !0), this._mergeOption(a, t))
        }
        if (!e || 'recreate' === e || 'media' === e) {
          var o = r.getMediaOption(this)
          o.length &&
            each$i(
              o,
              function (e) {
                ;(i = !0), this._mergeOption(e, t)
              },
              this
            )
        }
        return i
      }),
      (t.prototype.mergeOption = function (e) {
        this._mergeOption(e, null)
      }),
      (t.prototype._mergeOption = function (e, t) {
        var i = this.option,
          r = this._componentsMap,
          n = this._componentsCount,
          a = [],
          o = createHashMap(),
          s = t && t.replaceMergeMainTypeMap
        resetSourceDefaulter(this),
          each$i(e, function (e, t) {
            null != e &&
              (ComponentModel.hasClass(t)
                ? t && (a.push(t), o.set(t, !0))
                : (i[t] = null == i[t] ? clone$3(e) : merge(i[t], e, !0)))
          }),
          s &&
            s.each(function (e, t) {
              ComponentModel.hasClass(t) && !o.get(t) && (a.push(t), o.set(t, !0))
            }),
          ComponentModel.topologicalTravel(
            a,
            ComponentModel.getAllClassMainTypes(),
            function (t) {
              var a = concatInternalOptions(this, t, normalizeToArray(e[t])),
                o = r.get(t),
                l = o ? (s && s.get(t) ? 'replaceMerge' : 'normalMerge') : 'replaceAll',
                h = mappingToExists(o, a, l)
              setComponentTypeToKeyInfo(h, t, ComponentModel),
                (i[t] = null),
                r.set(t, null),
                n.set(t, 0)
              var u = [],
                p = [],
                c = 0
              each$i(
                h,
                function (e, i) {
                  var r = e.existing,
                    n = e.newOption
                  if (n) {
                    var a = 'series' === t,
                      o = ComponentModel.getClass(t, e.keyInfo.subType, !a)
                    if (!o) return
                    if (r && r.constructor === o)
                      (r.name = e.keyInfo.name), r.mergeOption(n, this), r.optionUpdated(n, !1)
                    else {
                      var s = extend$3({ componentIndex: i }, e.keyInfo)
                      extend$3((r = new o(n, this, this, s)), s),
                        e.brandNew && (r.__requireNewView = !0),
                        r.init(n, this, this),
                        r.optionUpdated(null, !0)
                    }
                  } else r && (r.mergeOption({}, this), r.optionUpdated({}, !1))
                  r ? (u.push(r.option), p.push(r), c++) : (u.push(void 0), p.push(void 0))
                },
                this
              ),
                (i[t] = u),
                r.set(t, p),
                n.set(t, c),
                'series' === t && reCreateSeriesIndices(this)
            },
            this
          ),
          this._seriesIndices || reCreateSeriesIndices(this)
      }),
      (t.prototype.getOption = function () {
        var e = clone$3(this.option)
        return (
          each$i(e, function (t, i) {
            if (ComponentModel.hasClass(i)) {
              for (var r = normalizeToArray(t), n = r.length, a = !1, o = n - 1; o >= 0; o--)
                r[o] && !isComponentIdInternal(r[o]) ? (a = !0) : ((r[o] = null), !a && n--)
              ;(r.length = n), (e[i] = r)
            }
          }),
          delete e[OPTION_INNER_KEY],
          e
        )
      }),
      (t.prototype.getTheme = function () {
        return this._theme
      }),
      (t.prototype.getLocaleModel = function () {
        return this._locale
      }),
      (t.prototype.getLocale = function (e) {
        return this.getLocaleModel().get(e)
      }),
      (t.prototype.setUpdatePayload = function (e) {
        this._payload = e
      }),
      (t.prototype.getUpdatePayload = function () {
        return this._payload
      }),
      (t.prototype.getComponent = function (e, t) {
        var i = this._componentsMap.get(e)
        if (i) {
          var r = i[t || 0]
          if (r) return r
          if (null == t) for (var n = 0; n < i.length; n++) if (i[n]) return i[n]
        }
      }),
      (t.prototype.queryComponents = function (e) {
        var t = e.mainType
        if (!t) return []
        var i,
          r = e.index,
          n = e.id,
          a = e.name,
          o = this._componentsMap.get(t)
        return o && o.length
          ? (null != r
              ? ((i = []),
                each$i(normalizeToArray(r), function (e) {
                  o[e] && i.push(o[e])
                }))
              : (i =
                  null != n
                    ? queryByIdOrName('id', n, o)
                    : null != a
                    ? queryByIdOrName('name', a, o)
                    : filter$1(o, function (e) {
                        return !!e
                      })),
            filterBySubType(i, e))
          : []
      }),
      (t.prototype.findComponents = function (e) {
        var t,
          i,
          r,
          n,
          a,
          o = e.query,
          s = e.mainType,
          l =
            ((i = s + 'Index'),
            (r = s + 'Id'),
            (n = s + 'Name'),
            !(t = o) || (null == t[i] && null == t[r] && null == t[n])
              ? null
              : { mainType: s, index: t[i], id: t[r], name: t[n] }),
          h = l
            ? this.queryComponents(l)
            : filter$1(this._componentsMap.get(s), function (e) {
                return !!e
              })
        return (a = filterBySubType(h, e)), e.filter ? filter$1(a, e.filter) : a
      }),
      (t.prototype.eachComponent = function (e, t, i) {
        var r = this._componentsMap
        if (isFunction$1(e)) {
          var n = t,
            a = e
          r.each(function (e, t) {
            for (var i = 0; e && i < e.length; i++) {
              var r = e[i]
              r && a.call(n, t, r, r.componentIndex)
            }
          })
        } else
          for (
            var o = isString(e) ? r.get(e) : isObject$7(e) ? this.findComponents(e) : null, s = 0;
            o && s < o.length;
            s++
          ) {
            var l = o[s]
            l && t.call(i, l, l.componentIndex)
          }
      }),
      (t.prototype.getSeriesByName = function (e) {
        var t = convertOptionIdName(e, null)
        return filter$1(this._componentsMap.get('series'), function (e) {
          return !!e && null != t && e.name === t
        })
      }),
      (t.prototype.getSeriesByIndex = function (e) {
        return this._componentsMap.get('series')[e]
      }),
      (t.prototype.getSeriesByType = function (e) {
        return filter$1(this._componentsMap.get('series'), function (t) {
          return !!t && t.subType === e
        })
      }),
      (t.prototype.getSeries = function () {
        return filter$1(this._componentsMap.get('series').slice(), function (e) {
          return !!e
        })
      }),
      (t.prototype.getSeriesCount = function () {
        return this._componentsCount.get('series')
      }),
      (t.prototype.eachSeries = function (e, t) {
        assertSeriesInitialized(this),
          each$i(
            this._seriesIndices,
            function (i) {
              var r = this._componentsMap.get('series')[i]
              e.call(t, r, i)
            },
            this
          )
      }),
      (t.prototype.eachRawSeries = function (e, t) {
        each$i(this._componentsMap.get('series'), function (i) {
          i && e.call(t, i, i.componentIndex)
        })
      }),
      (t.prototype.eachSeriesByType = function (e, t, i) {
        assertSeriesInitialized(this),
          each$i(
            this._seriesIndices,
            function (r) {
              var n = this._componentsMap.get('series')[r]
              n.subType === e && t.call(i, n, r)
            },
            this
          )
      }),
      (t.prototype.eachRawSeriesByType = function (e, t, i) {
        return each$i(this.getSeriesByType(e), t, i)
      }),
      (t.prototype.isSeriesFiltered = function (e) {
        return assertSeriesInitialized(this), null == this._seriesIndicesMap.get(e.componentIndex)
      }),
      (t.prototype.getCurrentSeriesIndices = function () {
        return (this._seriesIndices || []).slice()
      }),
      (t.prototype.filterSeries = function (e, t) {
        assertSeriesInitialized(this)
        var i = []
        each$i(
          this._seriesIndices,
          function (r) {
            var n = this._componentsMap.get('series')[r]
            e.call(t, n, r) && i.push(r)
          },
          this
        ),
          (this._seriesIndices = i),
          (this._seriesIndicesMap = createHashMap(i))
      }),
      (t.prototype.restoreData = function (e) {
        reCreateSeriesIndices(this)
        var t = this._componentsMap,
          i = []
        t.each(function (e, t) {
          ComponentModel.hasClass(t) && i.push(t)
        }),
          ComponentModel.topologicalTravel(i, ComponentModel.getAllClassMainTypes(), function (i) {
            each$i(t.get(i), function (t) {
              !t || ('series' === i && isNotTargetSeries(t, e)) || t.restoreData()
            })
          })
      }),
      (t.internalField =
        ((reCreateSeriesIndices = function (e) {
          var t = (e._seriesIndices = [])
          each$i(e._componentsMap.get('series'), function (e) {
            e && t.push(e.componentIndex)
          }),
            (e._seriesIndicesMap = createHashMap(t))
        }),
        (assertSeriesInitialized = function (e) {}),
        void (initBase = function (e, t) {
          ;(e.option = {}),
            (e.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE),
            (e._componentsMap = createHashMap({ series: [] })),
            (e._componentsCount = createHashMap())
          var i = t.aria
          isObject$7(i) && null == i.enabled && (i.enabled = !0),
            mergeTheme(t, e._theme.option),
            merge(t, globalDefault, !1),
            e._mergeOption(t, null)
        }))),
      t
    )
  })(Model)
function isNotTargetSeries(e, t) {
  if (t) {
    var i = t.seriesIndex,
      r = t.seriesId,
      n = t.seriesName
    return (
      (null != i && e.componentIndex !== i) ||
      (null != r && e.id !== r) ||
      (null != n && e.name !== n)
    )
  }
}
function mergeTheme(e, t) {
  var i = e.color && !e.colorLayer
  each$i(t, function (t, r) {
    ;('colorLayer' === r && i) ||
      ComponentModel.hasClass(r) ||
      ('object' == typeof t
        ? (e[r] = e[r] ? merge(e[r], t, !1) : clone$3(t))
        : null == e[r] && (e[r] = t))
  })
}
function queryByIdOrName(e, t, i) {
  if (isArray$1(t)) {
    var r = createHashMap()
    return (
      each$i(t, function (e) {
        null != e && null != convertOptionIdName(e, null) && r.set(e, !0)
      }),
      filter$1(i, function (t) {
        return t && r.get(t[e])
      })
    )
  }
  var n = convertOptionIdName(t, null)
  return filter$1(i, function (t) {
    return t && null != n && t[e] === n
  })
}
function filterBySubType(e, t) {
  return t.hasOwnProperty('subType')
    ? filter$1(e, function (e) {
        return e && e.subType === t.subType
      })
    : e
}
function normalizeSetOptionInput(e) {
  var t = createHashMap()
  return (
    e &&
      each$i(normalizeToArray(e.replaceMerge), function (e) {
        t.set(e, !0)
      }),
    { replaceMergeMainTypeMap: t }
  )
}
mixin(GlobalModel, PaletteMixin)
var availableMethods = [
    'getDom',
    'getZr',
    'getWidth',
    'getHeight',
    'getDevicePixelRatio',
    'dispatchAction',
    'isDisposed',
    'on',
    'off',
    'getDataURL',
    'getConnectedDataURL',
    'getOption',
    'getId',
    'updateLabelLayout'
  ],
  ExtensionAPI = function (e) {
    each$i(
      availableMethods,
      function (t) {
        this[t] = bind$2(e[t], e)
      },
      this
    )
  },
  coordinateSystemCreators = {},
  CoordinateSystemManager = (function () {
    function e() {
      this._coordinateSystems = []
    }
    return (
      (e.prototype.create = function (e, t) {
        var i = []
        each$i(coordinateSystemCreators, function (r, n) {
          var a = r.create(e, t)
          i = i.concat(a || [])
        }),
          (this._coordinateSystems = i)
      }),
      (e.prototype.update = function (e, t) {
        each$i(this._coordinateSystems, function (i) {
          i.update && i.update(e, t)
        })
      }),
      (e.prototype.getCoordinateSystems = function () {
        return this._coordinateSystems.slice()
      }),
      (e.register = function (e, t) {
        coordinateSystemCreators[e] = t
      }),
      (e.get = function (e) {
        return coordinateSystemCreators[e]
      }),
      e
    )
  })(),
  QUERY_REG = /^(min|max)?(.+)$/,
  OptionManager = (function () {
    function e(e) {
      ;(this._timelineOptions = []),
        (this._mediaList = []),
        (this._currentMediaIndices = []),
        (this._api = e)
    }
    return (
      (e.prototype.setOption = function (e, t, i) {
        e &&
          (each$i(normalizeToArray(e.series), function (e) {
            e && e.data && isTypedArray(e.data) && setAsPrimitive(e.data)
          }),
          each$i(normalizeToArray(e.dataset), function (e) {
            e && e.source && isTypedArray(e.source) && setAsPrimitive(e.source)
          })),
          (e = clone$3(e))
        var r = this._optionBackup,
          n = parseRawOption(e, t, !r)
        ;(this._newBaseOption = n.baseOption),
          r
            ? (n.timelineOptions.length && (r.timelineOptions = n.timelineOptions),
              n.mediaList.length && (r.mediaList = n.mediaList),
              n.mediaDefault && (r.mediaDefault = n.mediaDefault))
            : (this._optionBackup = n)
      }),
      (e.prototype.mountOption = function (e) {
        var t = this._optionBackup
        return (
          (this._timelineOptions = t.timelineOptions),
          (this._mediaList = t.mediaList),
          (this._mediaDefault = t.mediaDefault),
          (this._currentMediaIndices = []),
          clone$3(e ? t.baseOption : this._newBaseOption)
        )
      }),
      (e.prototype.getTimelineOption = function (e) {
        var t,
          i = this._timelineOptions
        if (i.length) {
          var r = e.getComponent('timeline')
          r && (t = clone$3(i[r.getCurrentIndex()]))
        }
        return t
      }),
      (e.prototype.getMediaOption = function (e) {
        var t = this._api.getWidth(),
          i = this._api.getHeight(),
          r = this._mediaList,
          n = this._mediaDefault,
          a = [],
          o = []
        if (!r.length && !n) return o
        for (var s = 0, l = r.length; s < l; s++) applyMediaQuery(r[s].query, t, i) && a.push(s)
        return (
          !a.length && n && (a = [-1]),
          a.length &&
            !indicesEquals(a, this._currentMediaIndices) &&
            (o = map$1(a, function (e) {
              return clone$3(-1 === e ? n.option : r[e].option)
            })),
          (this._currentMediaIndices = a),
          o
        )
      }),
      e
    )
  })()
function parseRawOption(e, t, i) {
  var r,
    n,
    a = [],
    o = e.baseOption,
    s = e.timeline,
    l = e.options,
    h = e.media,
    u = !!e.media,
    p = !!(l || s || (o && o.timeline))
  function c(e) {
    each$i(t, function (t) {
      t(e, i)
    })
  }
  return (
    o ? (n = o).timeline || (n.timeline = s) : ((p || u) && (e.options = e.media = null), (n = e)),
    u &&
      isArray$1(h) &&
      each$i(h, function (e) {
        e && e.option && (e.query ? a.push(e) : r || (r = e))
      }),
    c(n),
    each$i(l, function (e) {
      return c(e)
    }),
    each$i(a, function (e) {
      return c(e.option)
    }),
    { baseOption: n, timelineOptions: l || [], mediaDefault: r, mediaList: a }
  )
}
function applyMediaQuery(e, t, i) {
  var r = { width: t, height: i, aspectratio: t / i },
    n = !0
  return (
    each$i(e, function (e, t) {
      var i = t.match(QUERY_REG)
      if (i && i[1] && i[2]) {
        var a = i[1],
          o = i[2].toLowerCase()
        compare(r[o], e, a) || (n = !1)
      }
    }),
    n
  )
}
function compare(e, t, i) {
  return 'min' === i ? e >= t : 'max' === i ? e <= t : e === t
}
function indicesEquals(e, t) {
  return e.join(',') === t.join(',')
}
var each$g = each$i,
  isObject$6 = isObject$7,
  POSSIBLE_STYLES = [
    'areaStyle',
    'lineStyle',
    'nodeStyle',
    'linkStyle',
    'chordStyle',
    'label',
    'labelLine'
  ]
function compatEC2ItemStyle(e) {
  var t = e && e.itemStyle
  if (t)
    for (var i = 0, r = POSSIBLE_STYLES.length; i < r; i++) {
      var n = POSSIBLE_STYLES[i],
        a = t.normal,
        o = t.emphasis
      a &&
        a[n] &&
        ((e[n] = e[n] || {}),
        e[n].normal ? merge(e[n].normal, a[n]) : (e[n].normal = a[n]),
        (a[n] = null)),
        o &&
          o[n] &&
          ((e[n] = e[n] || {}),
          e[n].emphasis ? merge(e[n].emphasis, o[n]) : (e[n].emphasis = o[n]),
          (o[n] = null))
    }
}
function convertNormalEmphasis(e, t, i) {
  if (e && e[t] && (e[t].normal || e[t].emphasis)) {
    var r = e[t].normal,
      n = e[t].emphasis
    r && (i ? ((e[t].normal = e[t].emphasis = null), defaults$1(e[t], r)) : (e[t] = r)),
      n &&
        ((e.emphasis = e.emphasis || {}),
        (e.emphasis[t] = n),
        n.focus && (e.emphasis.focus = n.focus),
        n.blurScope && (e.emphasis.blurScope = n.blurScope))
  }
}
function removeEC3NormalStatus(e) {
  convertNormalEmphasis(e, 'itemStyle'),
    convertNormalEmphasis(e, 'lineStyle'),
    convertNormalEmphasis(e, 'areaStyle'),
    convertNormalEmphasis(e, 'label'),
    convertNormalEmphasis(e, 'labelLine'),
    convertNormalEmphasis(e, 'upperLabel'),
    convertNormalEmphasis(e, 'edgeLabel')
}
function compatTextStyle(e, t) {
  var i = isObject$6(e) && e[t],
    r = isObject$6(i) && i.textStyle
  if (r)
    for (var n = 0, a = TEXT_STYLE_OPTIONS.length; n < a; n++) {
      var o = TEXT_STYLE_OPTIONS[n]
      r.hasOwnProperty(o) && (i[o] = r[o])
    }
}
function compatEC3CommonStyles(e) {
  e &&
    (removeEC3NormalStatus(e),
    compatTextStyle(e, 'label'),
    e.emphasis && compatTextStyle(e.emphasis, 'label'))
}
function processSeries(e) {
  if (isObject$6(e)) {
    compatEC2ItemStyle(e),
      removeEC3NormalStatus(e),
      compatTextStyle(e, 'label'),
      compatTextStyle(e, 'upperLabel'),
      compatTextStyle(e, 'edgeLabel'),
      e.emphasis &&
        (compatTextStyle(e.emphasis, 'label'),
        compatTextStyle(e.emphasis, 'upperLabel'),
        compatTextStyle(e.emphasis, 'edgeLabel'))
    var t = e.markPoint
    t && (compatEC2ItemStyle(t), compatEC3CommonStyles(t))
    var i = e.markLine
    i && (compatEC2ItemStyle(i), compatEC3CommonStyles(i))
    var r = e.markArea
    r && compatEC3CommonStyles(r)
    var n = e.data
    if ('graph' === e.type) {
      n = n || e.nodes
      var a = e.links || e.edges
      if (a && !isTypedArray(a)) for (var o = 0; o < a.length; o++) compatEC3CommonStyles(a[o])
      each$i(e.categories, function (e) {
        removeEC3NormalStatus(e)
      })
    }
    if (n && !isTypedArray(n)) for (o = 0; o < n.length; o++) compatEC3CommonStyles(n[o])
    if ((t = e.markPoint) && t.data) {
      var s = t.data
      for (o = 0; o < s.length; o++) compatEC3CommonStyles(s[o])
    }
    if ((i = e.markLine) && i.data) {
      var l = i.data
      for (o = 0; o < l.length; o++)
        isArray$1(l[o])
          ? (compatEC3CommonStyles(l[o][0]), compatEC3CommonStyles(l[o][1]))
          : compatEC3CommonStyles(l[o])
    }
    'gauge' === e.type
      ? (compatTextStyle(e, 'axisLabel'), compatTextStyle(e, 'title'), compatTextStyle(e, 'detail'))
      : 'treemap' === e.type
      ? (convertNormalEmphasis(e.breadcrumb, 'itemStyle'),
        each$i(e.levels, function (e) {
          removeEC3NormalStatus(e)
        }))
      : 'tree' === e.type && removeEC3NormalStatus(e.leaves)
  }
}
function toArr(e) {
  return isArray$1(e) ? e : e ? [e] : []
}
function toObj(e) {
  return (isArray$1(e) ? e[0] : e) || {}
}
function globalCompatStyle(e, t) {
  each$g(toArr(e.series), function (e) {
    isObject$6(e) && processSeries(e)
  })
  var i = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar']
  t && i.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis'),
    each$g(i, function (t) {
      each$g(toArr(e[t]), function (e) {
        e && (compatTextStyle(e, 'axisLabel'), compatTextStyle(e.axisPointer, 'label'))
      })
    }),
    each$g(toArr(e.parallel), function (e) {
      var t = e && e.parallelAxisDefault
      compatTextStyle(t, 'axisLabel'), compatTextStyle(t && t.axisPointer, 'label')
    }),
    each$g(toArr(e.calendar), function (e) {
      convertNormalEmphasis(e, 'itemStyle'),
        compatTextStyle(e, 'dayLabel'),
        compatTextStyle(e, 'monthLabel'),
        compatTextStyle(e, 'yearLabel')
    }),
    each$g(toArr(e.radar), function (e) {
      compatTextStyle(e, 'name'),
        e.name && null == e.axisName && ((e.axisName = e.name), delete e.name),
        null != e.nameGap &&
          null == e.axisNameGap &&
          ((e.axisNameGap = e.nameGap), delete e.nameGap)
    }),
    each$g(toArr(e.geo), function (e) {
      isObject$6(e) &&
        (compatEC3CommonStyles(e),
        each$g(toArr(e.regions), function (e) {
          compatEC3CommonStyles(e)
        }))
    }),
    each$g(toArr(e.timeline), function (e) {
      compatEC3CommonStyles(e),
        convertNormalEmphasis(e, 'label'),
        convertNormalEmphasis(e, 'itemStyle'),
        convertNormalEmphasis(e, 'controlStyle', !0)
      var t = e.data
      isArray$1(t) &&
        each$i(t, function (e) {
          isObject$7(e) &&
            (convertNormalEmphasis(e, 'label'), convertNormalEmphasis(e, 'itemStyle'))
        })
    }),
    each$g(toArr(e.toolbox), function (e) {
      convertNormalEmphasis(e, 'iconStyle'),
        each$g(e.feature, function (e) {
          convertNormalEmphasis(e, 'iconStyle')
        })
    }),
    compatTextStyle(toObj(e.axisPointer), 'label'),
    compatTextStyle(toObj(e.tooltip).axisPointer, 'label')
}
function get(e, t) {
  for (var i = t.split(','), r = e, n = 0; n < i.length && null != (r = r && r[i[n]]); n++);
  return r
}
function set(e, t, i, r) {
  for (var n, a = t.split(','), o = e, s = 0; s < a.length - 1; s++)
    null == o[(n = a[s])] && (o[n] = {}), (o = o[n])
  ;(r || null == o[a[s]]) && (o[a[s]] = i)
}
function compatLayoutProperties(e) {
  e &&
    each$i(LAYOUT_PROPERTIES, function (t) {
      t[0] in e && !(t[1] in e) && (e[t[1]] = e[t[0]])
    })
}
var LAYOUT_PROPERTIES = [
    ['x', 'left'],
    ['y', 'top'],
    ['x2', 'right'],
    ['y2', 'bottom']
  ],
  COMPATITABLE_COMPONENTS = [
    'grid',
    'geo',
    'parallel',
    'legend',
    'toolbox',
    'title',
    'visualMap',
    'dataZoom',
    'timeline'
  ],
  BAR_ITEM_STYLE_MAP = [
    ['borderRadius', 'barBorderRadius'],
    ['borderColor', 'barBorderColor'],
    ['borderWidth', 'barBorderWidth']
  ]
function compatBarItemStyle(e) {
  var t = e && e.itemStyle
  if (t)
    for (var i = 0; i < BAR_ITEM_STYLE_MAP.length; i++) {
      var r = BAR_ITEM_STYLE_MAP[i][1],
        n = BAR_ITEM_STYLE_MAP[i][0]
      null != t[r] && (t[n] = t[r])
    }
}
function compatPieLabel(e) {
  e &&
    'edge' === e.alignTo &&
    null != e.margin &&
    null == e.edgeDistance &&
    (e.edgeDistance = e.margin)
}
function compatSunburstState(e) {
  e && e.downplay && !e.blur && (e.blur = e.downplay)
}
function compatGraphFocus(e) {
  e &&
    null != e.focusNodeAdjacency &&
    ((e.emphasis = e.emphasis || {}), null == e.emphasis.focus && (e.emphasis.focus = 'adjacency'))
}
function traverseTree(e, t) {
  if (e) for (var i = 0; i < e.length; i++) t(e[i]), e[i] && traverseTree(e[i].children, t)
}
function globalBackwardCompat(e, t) {
  globalCompatStyle(e, t),
    (e.series = normalizeToArray(e.series)),
    each$i(e.series, function (e) {
      if (isObject$7(e)) {
        var t = e.type
        if ('line' === t) null != e.clipOverflow && (e.clip = e.clipOverflow)
        else if ('pie' === t || 'gauge' === t) {
          if (
            (null != e.clockWise && (e.clockwise = e.clockWise),
            compatPieLabel(e.label),
            (n = e.data) && !isTypedArray(n))
          )
            for (var i = 0; i < n.length; i++) compatPieLabel(n[i])
          null != e.hoverOffset &&
            ((e.emphasis = e.emphasis || {}),
            (e.emphasis.scaleSize = null) && (e.emphasis.scaleSize = e.hoverOffset))
        } else if ('gauge' === t) {
          var r = get(e, 'pointer.color')
          null != r && set(e, 'itemStyle.color', r)
        } else if ('bar' === t) {
          var n
          if (
            (compatBarItemStyle(e),
            compatBarItemStyle(e.backgroundStyle),
            compatBarItemStyle(e.emphasis),
            (n = e.data) && !isTypedArray(n))
          )
            for (i = 0; i < n.length; i++)
              'object' == typeof n[i] &&
                (compatBarItemStyle(n[i]), compatBarItemStyle(n[i] && n[i].emphasis))
        } else if ('sunburst' === t) {
          var a = e.highlightPolicy
          a && ((e.emphasis = e.emphasis || {}), e.emphasis.focus || (e.emphasis.focus = a)),
            compatSunburstState(e),
            traverseTree(e.data, compatSunburstState)
        } else
          'graph' === t || 'sankey' === t
            ? compatGraphFocus(e)
            : 'map' === t &&
              (e.mapType && !e.map && (e.map = e.mapType),
              e.mapLocation && defaults$1(e, e.mapLocation))
        null != e.hoverAnimation &&
          ((e.emphasis = e.emphasis || {}),
          e.emphasis && null == e.emphasis.scale && (e.emphasis.scale = e.hoverAnimation)),
          compatLayoutProperties(e)
      }
    }),
    e.dataRange && (e.visualMap = e.dataRange),
    each$i(COMPATITABLE_COMPONENTS, function (t) {
      var i = e[t]
      i &&
        (isArray$1(i) || (i = [i]),
        each$i(i, function (e) {
          compatLayoutProperties(e)
        }))
    })
}
function dataStack(e) {
  var t = createHashMap()
  e.eachSeries(function (e) {
    var i = e.get('stack')
    if (i) {
      var r = t.get(i) || t.set(i, []),
        n = e.getData(),
        a = {
          stackResultDimension: n.getCalculationInfo('stackResultDimension'),
          stackedOverDimension: n.getCalculationInfo('stackedOverDimension'),
          stackedDimension: n.getCalculationInfo('stackedDimension'),
          stackedByDimension: n.getCalculationInfo('stackedByDimension'),
          isStackedByIndex: n.getCalculationInfo('isStackedByIndex'),
          data: n,
          seriesModel: e
        }
      if (!a.stackedDimension || (!a.isStackedByIndex && !a.stackedByDimension)) return
      r.length && n.setCalculationInfo('stackedOnSeries', r[r.length - 1].seriesModel), r.push(a)
    }
  }),
    t.each(calculateStack)
}
function calculateStack(e) {
  each$i(e, function (t, i) {
    var r = [],
      n = [NaN, NaN],
      a = [t.stackResultDimension, t.stackedOverDimension],
      o = t.data,
      s = t.isStackedByIndex,
      l = o.map(a, function (a, l, h) {
        var u,
          p,
          c = o.get(t.stackedDimension, h)
        if (isNaN(c)) return n
        s ? (p = o.getRawIndex(h)) : (u = o.get(t.stackedByDimension, h))
        for (var d = NaN, f = i - 1; f >= 0; f--) {
          var m = e[f]
          if ((s || (p = m.data.rawIndexOf(m.stackedByDimension, u)), p >= 0)) {
            var g = m.data.getByRawIndex(m.stackResultDimension, p)
            if ((c >= 0 && g > 0) || (c <= 0 && g < 0)) {
              ;(c = addSafe(c, g)), (d = g)
              break
            }
          }
        }
        return (r[0] = c), (r[1] = d), r
      })
    o.hostModel.setData(l), (t.data = l)
  })
}
var SourceImpl = function (e) {
    ;(this.data = e.data || (e.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : [])),
      (this.sourceFormat = e.sourceFormat || SOURCE_FORMAT_UNKNOWN),
      (this.seriesLayoutBy = e.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN),
      (this.startIndex = e.startIndex || 0),
      (this.dimensionsDefine = e.dimensionsDefine),
      (this.dimensionsDetectedCount = e.dimensionsDetectedCount),
      (this.encodeDefine = e.encodeDefine),
      (this.metaRawOption = e.metaRawOption)
  },
  _a,
  _b,
  _c,
  providerMethods,
  mountMethods
function isSourceInstance(e) {
  return e instanceof SourceImpl
}
function createSource(e, t, i, r) {
  i = i || detectSourceFormat(e)
  var n = t.seriesLayoutBy,
    a = determineSourceDimensions(e, i, n, t.sourceHeader, t.dimensions)
  return new SourceImpl({
    data: e,
    sourceFormat: i,
    seriesLayoutBy: n,
    dimensionsDefine: a.dimensionsDefine,
    startIndex: a.startIndex,
    dimensionsDetectedCount: a.dimensionsDetectedCount,
    encodeDefine: makeEncodeDefine(r),
    metaRawOption: clone$3(t)
  })
}
function createSourceFromSeriesDataOption(e) {
  return new SourceImpl({
    data: e,
    sourceFormat: isTypedArray(e) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
  })
}
function cloneSourceShallow(e) {
  return new SourceImpl({
    data: e.data,
    sourceFormat: e.sourceFormat,
    seriesLayoutBy: e.seriesLayoutBy,
    dimensionsDefine: clone$3(e.dimensionsDefine),
    startIndex: e.startIndex,
    dimensionsDetectedCount: e.dimensionsDetectedCount,
    encodeDefine: makeEncodeDefine(e.encodeDefine)
  })
}
function makeEncodeDefine(e) {
  return e ? createHashMap(e) : null
}
function detectSourceFormat(e) {
  var t = SOURCE_FORMAT_UNKNOWN
  if (isTypedArray(e)) t = SOURCE_FORMAT_TYPED_ARRAY
  else if (isArray$1(e)) {
    0 === e.length && (t = SOURCE_FORMAT_ARRAY_ROWS)
    for (var i = 0, r = e.length; i < r; i++) {
      var n = e[i]
      if (null != n) {
        if (isArray$1(n)) {
          t = SOURCE_FORMAT_ARRAY_ROWS
          break
        }
        if (isObject$7(n)) {
          t = SOURCE_FORMAT_OBJECT_ROWS
          break
        }
      }
    }
  } else if (isObject$7(e))
    for (var a in e)
      if (hasOwn(e, a) && isArrayLike(e[a])) {
        t = SOURCE_FORMAT_KEYED_COLUMNS
        break
      }
  return t
}
function determineSourceDimensions(e, t, i, r, n) {
  var a, o
  if (!e)
    return {
      dimensionsDefine: normalizeDimensionsOption(n),
      startIndex: o,
      dimensionsDetectedCount: a
    }
  if (t === SOURCE_FORMAT_ARRAY_ROWS) {
    var s = e
    'auto' === r || null == r
      ? arrayRowsTravelFirst(
          function (e) {
            null != e && '-' !== e && (isString(e) ? null == o && (o = 1) : (o = 0))
          },
          i,
          s,
          10
        )
      : (o = isNumber(r) ? r : r ? 1 : 0),
      n ||
        1 !== o ||
        ((n = []),
        arrayRowsTravelFirst(
          function (e, t) {
            n[t] = null != e ? e + '' : ''
          },
          i,
          s,
          1 / 0
        )),
      (a = n ? n.length : i === SERIES_LAYOUT_BY_ROW ? s.length : s[0] ? s[0].length : null)
  } else if (t === SOURCE_FORMAT_OBJECT_ROWS) n || (n = objectRowsCollectDimensions(e))
  else if (t === SOURCE_FORMAT_KEYED_COLUMNS)
    n ||
      ((n = []),
      each$i(e, function (e, t) {
        n.push(t)
      }))
  else if (t === SOURCE_FORMAT_ORIGINAL) {
    var l = getDataItemValue(e[0])
    a = (isArray$1(l) && l.length) || 1
  }
  return {
    startIndex: o,
    dimensionsDefine: normalizeDimensionsOption(n),
    dimensionsDetectedCount: a
  }
}
function objectRowsCollectDimensions(e) {
  for (var t, i = 0; i < e.length && !(t = e[i++]); );
  if (t) {
    var r = []
    return (
      each$i(t, function (e, t) {
        r.push(t)
      }),
      r
    )
  }
}
function normalizeDimensionsOption(e) {
  if (e) {
    var t = createHashMap()
    return map$1(e, function (e, i) {
      var r = {
        name: (e = isObject$7(e) ? e : { name: e }).name,
        displayName: e.displayName,
        type: e.type
      }
      if (null == r.name) return r
      ;(r.name += ''), null == r.displayName && (r.displayName = r.name)
      var n = t.get(r.name)
      return n ? (r.name += '-' + n.count++) : t.set(r.name, { count: 1 }), r
    })
  }
}
function arrayRowsTravelFirst(e, t, i, r) {
  if (t === SERIES_LAYOUT_BY_ROW)
    for (var n = 0; n < i.length && n < r; n++) e(i[n] ? i[n][0] : null, n)
  else {
    var a = i[0] || []
    for (n = 0; n < a.length && n < r; n++) e(a[n], n)
  }
}
var DefaultDataProvider = (function () {
    function e(e, t) {
      var i = isSourceInstance(e) ? e : createSourceFromSeriesDataOption(e)
      this._source = i
      var r = (this._data = i.data)
      i.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY &&
        ((this._offset = 0), (this._dimSize = t), (this._data = r)),
        mountMethods(this, r, i)
    }
    var t
    return (
      (e.prototype.getSource = function () {
        return this._source
      }),
      (e.prototype.count = function () {
        return 0
      }),
      (e.prototype.getItem = function (e, t) {}),
      (e.prototype.appendData = function (e) {}),
      (e.prototype.clean = function () {}),
      (e.protoInitialize = (((t = e.prototype).pure = !1), void (t.persistent = !0))),
      (e.internalField = (function () {
        var e
        mountMethods = function (e, n, a) {
          var o = a.sourceFormat,
            s = a.seriesLayoutBy,
            l = a.startIndex,
            h = a.dimensionsDefine
          if (
            (extend$3(e, providerMethods[getMethodMapKey(o, s)]), o === SOURCE_FORMAT_TYPED_ARRAY)
          )
            (e.getItem = t), (e.count = r), (e.fillStorage = i)
          else {
            var u = getRawSourceItemGetter(o, s)
            e.getItem = bind$2(u, null, n, l, h)
            var p = getRawSourceDataCounter(o, s)
            e.count = bind$2(p, null, n, l, h)
          }
        }
        var t = function (e, t) {
            ;(e -= this._offset), (t = t || [])
            for (var i = this._data, r = this._dimSize, n = r * e, a = 0; a < r; a++)
              t[a] = i[n + a]
            return t
          },
          i = function (e, t, i, r) {
            for (var n = this._data, a = this._dimSize, o = 0; o < a; o++) {
              for (
                var s = r[o],
                  l = null == s[0] ? 1 / 0 : s[0],
                  h = null == s[1] ? -1 / 0 : s[1],
                  u = t - e,
                  p = i[o],
                  c = 0;
                c < u;
                c++
              ) {
                var d = n[c * a + o]
                ;(p[e + c] = d), d < l && (l = d), d > h && (h = d)
              }
              ;(s[0] = l), (s[1] = h)
            }
          },
          r = function () {
            return this._data ? this._data.length / this._dimSize : 0
          }
        function n(e) {
          for (var t = 0; t < e.length; t++) this._data.push(e[t])
        }
        ;((e = {})[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = {
          pure: !0,
          appendData: n
        }),
          (e[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = {
            pure: !0,
            appendData: function () {
              throw new Error('Do not support appendData when set seriesLayoutBy: "row".')
            }
          }),
          (e[SOURCE_FORMAT_OBJECT_ROWS] = { pure: !0, appendData: n }),
          (e[SOURCE_FORMAT_KEYED_COLUMNS] = {
            pure: !0,
            appendData: function (e) {
              var t = this._data
              each$i(e, function (e, i) {
                for (var r = t[i] || (t[i] = []), n = 0; n < (e || []).length; n++) r.push(e[n])
              })
            }
          }),
          (e[SOURCE_FORMAT_ORIGINAL] = { appendData: n }),
          (e[SOURCE_FORMAT_TYPED_ARRAY] = {
            persistent: !1,
            pure: !0,
            appendData: function (e) {
              this._data = e
            },
            clean: function () {
              ;(this._offset += this.count()), (this._data = null)
            }
          }),
          (providerMethods = e)
      })()),
      e
    )
  })(),
  getItemSimply = function (e, t, i, r) {
    return e[r]
  },
  rawSourceItemGetterMap =
    ((_a = {}),
    (_a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (e, t, i, r) {
      return e[r + t]
    }),
    (_a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (e, t, i, r) {
      r += t
      for (var n = [], a = e, o = 0; o < a.length; o++) {
        var s = a[o]
        n.push(s ? s[r] : null)
      }
      return n
    }),
    (_a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply),
    (_a[SOURCE_FORMAT_KEYED_COLUMNS] = function (e, t, i, r) {
      for (var n = [], a = 0; a < i.length; a++) {
        var o = e[i[a].name]
        n.push(o ? o[r] : null)
      }
      return n
    }),
    (_a[SOURCE_FORMAT_ORIGINAL] = getItemSimply),
    _a)
function getRawSourceItemGetter(e, t) {
  return rawSourceItemGetterMap[getMethodMapKey(e, t)]
}
var countSimply = function (e, t, i) {
    return e.length
  },
  rawSourceDataCounterMap =
    ((_b = {}),
    (_b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (e, t, i) {
      return Math.max(0, e.length - t)
    }),
    (_b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (e, t, i) {
      var r = e[0]
      return r ? Math.max(0, r.length - t) : 0
    }),
    (_b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply),
    (_b[SOURCE_FORMAT_KEYED_COLUMNS] = function (e, t, i) {
      var r = e[i[0].name]
      return r ? r.length : 0
    }),
    (_b[SOURCE_FORMAT_ORIGINAL] = countSimply),
    _b)
function getRawSourceDataCounter(e, t) {
  return rawSourceDataCounterMap[getMethodMapKey(e, t)]
}
var getRawValueSimply = function (e, t, i) {
    return null != t ? e[t] : e
  },
  rawSourceValueGetterMap =
    ((_c = {}),
    (_c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply),
    (_c[SOURCE_FORMAT_OBJECT_ROWS] = function (e, t, i) {
      return null != t ? e[i] : e
    }),
    (_c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply),
    (_c[SOURCE_FORMAT_ORIGINAL] = function (e, t, i) {
      var r = getDataItemValue(e)
      return null != t && r instanceof Array ? r[t] : r
    }),
    (_c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply),
    _c)
function getRawSourceValueGetter(e) {
  return rawSourceValueGetterMap[e]
}
function getMethodMapKey(e, t) {
  return e === SOURCE_FORMAT_ARRAY_ROWS ? e + '_' + t : e
}
function retrieveRawValue(e, t, i) {
  if (e) {
    var r = e.getRawDataItem(t)
    if (null != r) {
      var n,
        a,
        o = e.getProvider().getSource().sourceFormat,
        s = e.getDimensionInfo(i)
      return s && ((n = s.name), (a = s.index)), getRawSourceValueGetter(o)(r, a, n)
    }
  }
}
var DIMENSION_LABEL_REG = /\{@(.+?)\}/g,
  DataFormatMixin = (function () {
    function e() {}
    return (
      (e.prototype.getDataParams = function (e, t) {
        var i = this.getData(t),
          r = this.getRawValue(e, t),
          n = i.getRawIndex(e),
          a = i.getName(e),
          o = i.getRawDataItem(e),
          s = i.getItemVisual(e, 'style'),
          l = s && s[i.getItemVisual(e, 'drawType') || 'fill'],
          h = s && s.stroke,
          u = this.mainType,
          p = 'series' === u,
          c = i.userOutput
        return {
          componentType: u,
          componentSubType: this.subType,
          componentIndex: this.componentIndex,
          seriesType: p ? this.subType : null,
          seriesIndex: this.seriesIndex,
          seriesId: p ? this.id : null,
          seriesName: p ? this.name : null,
          name: a,
          dataIndex: n,
          data: o,
          dataType: t,
          value: r,
          color: l,
          borderColor: h,
          dimensionNames: c ? c.dimensionNames : null,
          encode: c ? c.encode : null,
          $vars: ['seriesName', 'name', 'value']
        }
      }),
      (e.prototype.getFormattedLabel = function (e, t, i, r, n, a) {
        t = t || 'normal'
        var o = this.getData(i),
          s = this.getDataParams(e, i)
        ;(a && (s.value = a.interpolatedValue),
        null != r && isArray$1(s.value) && (s.value = s.value[r]),
        n) ||
          (n = o
            .getItemModel(e)
            .get('normal' === t ? ['label', 'formatter'] : [t, 'label', 'formatter']))
        return 'function' == typeof n
          ? ((s.status = t), (s.dimensionIndex = r), n(s))
          : 'string' == typeof n
          ? formatTpl(n, s).replace(DIMENSION_LABEL_REG, function (t, i) {
              var r = i.length,
                n = '[' === i.charAt(0) && ']' === i.charAt(r - 1) ? +i.slice(1, r - 1) : i,
                s = retrieveRawValue(o, e, n)
              if (a && isArray$1(a.interpolatedValue)) {
                var l = o.getDimensionInfo(n)
                l && (s = a.interpolatedValue[l.index])
              }
              return null != s ? s + '' : ''
            })
          : void 0
      }),
      (e.prototype.getRawValue = function (e, t) {
        return retrieveRawValue(this.getData(t), e)
      }),
      (e.prototype.formatTooltip = function (e, t, i) {}),
      e
    )
  })()
function normalizeTooltipFormatResult(e) {
  var t, i
  return isObject$7(e) ? e.type && (i = e) : (t = e), { markupText: t, markupFragment: i }
}
function createTask(e) {
  return new Task(e)
}
var Task = (function () {
    function e(e) {
      ;(e = e || {}),
        (this._reset = e.reset),
        (this._plan = e.plan),
        (this._count = e.count),
        (this._onDirty = e.onDirty),
        (this._dirty = !0)
    }
    return (
      (e.prototype.perform = function (e) {
        var t,
          i = this._upstream,
          r = e && e.skip
        if (this._dirty && i) {
          var n = this.context
          n.data = n.outputData = i.context.outputData
        }
        this.__pipeline && (this.__pipeline.currentTask = this),
          this._plan && !r && (t = this._plan(this.context))
        var a,
          o = u(this._modBy),
          s = this._modDataCount || 0,
          l = u(e && e.modBy),
          h = (e && e.modDataCount) || 0
        function u(e) {
          return !(e >= 1) && (e = 1), e
        }
        ;(o === l && s === h) || (t = 'reset'),
          (this._dirty || 'reset' === t) && ((this._dirty = !1), (a = this._doReset(r))),
          (this._modBy = l),
          (this._modDataCount = h)
        var p = e && e.step
        if (
          ((this._dueEnd = i ? i._outputDueEnd : this._count ? this._count(this.context) : 1 / 0),
          this._progress)
        ) {
          var c = this._dueIndex,
            d = Math.min(null != p ? this._dueIndex + p : 1 / 0, this._dueEnd)
          if (!r && (a || c < d)) {
            var f = this._progress
            if (isArray$1(f)) for (var m = 0; m < f.length; m++) this._doProgress(f[m], c, d, l, h)
            else this._doProgress(f, c, d, l, h)
          }
          this._dueIndex = d
          var g = null != this._settedOutputEnd ? this._settedOutputEnd : d
          this._outputDueEnd = g
        } else
          this._dueIndex = this._outputDueEnd =
            null != this._settedOutputEnd ? this._settedOutputEnd : this._dueEnd
        return this.unfinished()
      }),
      (e.prototype.dirty = function () {
        ;(this._dirty = !0), this._onDirty && this._onDirty(this.context)
      }),
      (e.prototype._doProgress = function (e, t, i, r, n) {
        iterator.reset(t, i, r, n),
          (this._callingProgress = e),
          this._callingProgress(
            { start: t, end: i, count: i - t, next: iterator.next },
            this.context
          )
      }),
      (e.prototype._doReset = function (e) {
        var t, i
        ;(this._dueIndex = this._outputDueEnd = this._dueEnd = 0),
          (this._settedOutputEnd = null),
          !e &&
            this._reset &&
            ((t = this._reset(this.context)) &&
              t.progress &&
              ((i = t.forceFirstProgress), (t = t.progress)),
            isArray$1(t) && !t.length && (t = null)),
          (this._progress = t),
          (this._modBy = this._modDataCount = null)
        var r = this._downstream
        return r && r.dirty(), i
      }),
      (e.prototype.unfinished = function () {
        return this._progress && this._dueIndex < this._dueEnd
      }),
      (e.prototype.pipe = function (e) {
        ;(this._downstream !== e || this._dirty) &&
          ((this._downstream = e), (e._upstream = this), e.dirty())
      }),
      (e.prototype.dispose = function () {
        this._disposed ||
          (this._upstream && (this._upstream._downstream = null),
          this._downstream && (this._downstream._upstream = null),
          (this._dirty = !1),
          (this._disposed = !0))
      }),
      (e.prototype.getUpstream = function () {
        return this._upstream
      }),
      (e.prototype.getDownstream = function () {
        return this._downstream
      }),
      (e.prototype.setOutputEnd = function (e) {
        this._outputDueEnd = this._settedOutputEnd = e
      }),
      e
    )
  })(),
  iterator = (function () {
    var e,
      t,
      i,
      r,
      n,
      a = {
        reset: function (l, h, u, p) {
          ;(t = l),
            (e = h),
            (i = u),
            (r = p),
            (n = Math.ceil(r / i)),
            (a.next = i > 1 && r > 0 ? s : o)
        }
      }
    return a
    function o() {
      return t < e ? t++ : null
    }
    function s() {
      var a = (t % n) * i + Math.ceil(t / n),
        o = t >= e ? null : a < r ? a : t
      return t++, o
    }
  })()
function parseDataValue(e, t) {
  var i = t && t.type
  if ('ordinal' === i) {
    var r = t && t.ordinalMeta
    return r ? r.parseAndCollect(e) : e
  }
  return (
    'time' === i && 'number' != typeof e && null != e && '-' !== e && (e = +parseDate(e)),
    null == e || '' === e ? NaN : +e
  )
}
var valueParserMap = createHashMap({
  number: function (e) {
    return parseFloat(e)
  },
  time: function (e) {
    return +parseDate(e)
  },
  trim: function (e) {
    return 'string' == typeof e ? trim$1(e) : e
  }
})
function getRawValueParser(e) {
  return valueParserMap.get(e)
}
var ORDER_COMPARISON_OP_MAP = {
    lt: function (e, t) {
      return e < t
    },
    lte: function (e, t) {
      return e <= t
    },
    gt: function (e, t) {
      return e > t
    },
    gte: function (e, t) {
      return e >= t
    }
  },
  FilterOrderComparator = (function () {
    function e(e, t) {
      if ('number' != typeof t) {
        throwError('')
      }
      ;(this._opFn = ORDER_COMPARISON_OP_MAP[e]), (this._rvalFloat = numericToNumber(t))
    }
    return (
      (e.prototype.evaluate = function (e) {
        return 'number' == typeof e
          ? this._opFn(e, this._rvalFloat)
          : this._opFn(numericToNumber(e), this._rvalFloat)
      }),
      e
    )
  })(),
  SortOrderComparator = (function () {
    function e(e, t) {
      var i = 'desc' === e
      ;(this._resultLT = i ? 1 : -1),
        null == t && (t = i ? 'min' : 'max'),
        (this._incomparable = 'min' === t ? -1 / 0 : 1 / 0)
    }
    return (
      (e.prototype.evaluate = function (e, t) {
        var i = typeof e,
          r = typeof t,
          n = 'number' === i ? e : numericToNumber(e),
          a = 'number' === r ? t : numericToNumber(t),
          o = isNaN(n),
          s = isNaN(a)
        if ((o && (n = this._incomparable), s && (a = this._incomparable), o && s)) {
          var l = 'string' === i,
            h = 'string' === r
          l && (n = h ? e : 0), h && (a = l ? t : 0)
        }
        return n < a ? this._resultLT : n > a ? -this._resultLT : 0
      }),
      e
    )
  })(),
  FilterEqualityComparator = (function () {
    function e(e, t) {
      ;(this._rval = t),
        (this._isEQ = e),
        (this._rvalTypeof = typeof t),
        (this._rvalFloat = numericToNumber(t))
    }
    return (
      (e.prototype.evaluate = function (e) {
        var t = e === this._rval
        if (!t) {
          var i = typeof e
          i === this._rvalTypeof ||
            ('number' !== i && 'number' !== this._rvalTypeof) ||
            (t = numericToNumber(e) === this._rvalFloat)
        }
        return this._isEQ ? t : !t
      }),
      e
    )
  })()
function createFilterComparator(e, t) {
  return 'eq' === e || 'ne' === e
    ? new FilterEqualityComparator('eq' === e, t)
    : hasOwn(ORDER_COMPARISON_OP_MAP, e)
    ? new FilterOrderComparator(e, t)
    : null
}
var ExternalSource = (function () {
  function e() {}
  return (
    (e.prototype.getRawData = function () {
      throw new Error('not supported')
    }),
    (e.prototype.getRawDataItem = function (e) {
      throw new Error('not supported')
    }),
    (e.prototype.cloneRawData = function () {}),
    (e.prototype.getDimensionInfo = function (e) {}),
    (e.prototype.cloneAllDimensionInfo = function () {}),
    (e.prototype.count = function () {}),
    (e.prototype.retrieveValue = function (e, t) {}),
    (e.prototype.retrieveValueFromItem = function (e, t) {}),
    (e.prototype.convertValue = function (e, t) {
      return parseDataValue(e, t)
    }),
    e
  )
})()
function createExternalSource(e, t) {
  var i = new ExternalSource(),
    r = e.data,
    n = (i.sourceFormat = e.sourceFormat),
    a = e.startIndex
  e.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN && throwError('')
  var o = [],
    s = {},
    l = e.dimensionsDefine
  if (l)
    each$i(l, function (e, t) {
      var i = e.name,
        r = { index: t, name: i, displayName: e.displayName }
      if ((o.push(r), null != i)) {
        hasOwn(s, i) && throwError(''), (s[i] = r)
      }
    })
  else for (var h = 0; h < e.dimensionsDetectedCount; h++) o.push({ index: h })
  var u = getRawSourceItemGetter(n, SERIES_LAYOUT_BY_COLUMN)
  t.__isBuiltIn &&
    ((i.getRawDataItem = function (e) {
      return u(r, a, o, e)
    }),
    (i.getRawData = bind$2(getRawData, null, e))),
    (i.cloneRawData = bind$2(cloneRawData, null, e))
  var p = getRawSourceDataCounter(n, SERIES_LAYOUT_BY_COLUMN)
  i.count = bind$2(p, null, r, a, o)
  var c = getRawSourceValueGetter(n)
  i.retrieveValue = function (e, t) {
    var i = u(r, a, o, e)
    return d(i, t)
  }
  var d = (i.retrieveValueFromItem = function (e, t) {
    if (null != e) {
      var i = o[t]
      return i ? c(e, t, i.name) : void 0
    }
  })
  return (
    (i.getDimensionInfo = bind$2(getDimensionInfo, null, o, s)),
    (i.cloneAllDimensionInfo = bind$2(cloneAllDimensionInfo, null, o)),
    i
  )
}
function getRawData(e) {
  if (!isSupportedSourceFormat(e.sourceFormat)) {
    throwError('')
  }
  return e.data
}
function cloneRawData(e) {
  var t = e.sourceFormat,
    i = e.data
  if (!isSupportedSourceFormat(t)) {
    throwError('')
  }
  if (t === SOURCE_FORMAT_ARRAY_ROWS) {
    for (var r = [], n = 0, a = i.length; n < a; n++) r.push(i[n].slice())
    return r
  }
  if (t === SOURCE_FORMAT_OBJECT_ROWS) {
    for (r = [], n = 0, a = i.length; n < a; n++) r.push(extend$3({}, i[n]))
    return r
  }
}
function getDimensionInfo(e, t, i) {
  if (null != i)
    return 'number' == typeof i || (!isNaN(i) && !hasOwn(t, i))
      ? e[i]
      : hasOwn(t, i)
      ? t[i]
      : void 0
}
function cloneAllDimensionInfo(e) {
  return clone$3(e)
}
var externalTransformMap = createHashMap()
function registerExternalTransform(e) {
  var t = (e = clone$3(e)).type
  t || throwError('')
  var i = t.split(':')
  2 !== i.length && throwError('')
  var r = !1
  'echarts' === i[0] && ((t = i[1]), (r = !0)), (e.__isBuiltIn = r), externalTransformMap.set(t, e)
}
function applyDataTransform(e, t, i) {
  var r = normalizeToArray(e),
    n = r.length
  n || throwError('')
  for (var a = 0, o = n; a < o; a++) {
    ;(t = applySingleDataTransform(r[a], t)), a !== o - 1 && (t.length = Math.max(t.length, 1))
  }
  return t
}
function applySingleDataTransform(e, t, i, r) {
  t.length || throwError(''), isObject$7(e) || throwError('')
  var n = e.type,
    a = externalTransformMap.get(n)
  a || throwError('')
  var o = map$1(t, function (e) {
    return createExternalSource(e, a)
  })
  return map$1(
    normalizeToArray(a.transform({ upstream: o[0], upstreamList: o, config: clone$3(e.config) })),
    function (e, i) {
      var r
      isObject$7(e) || throwError(''),
        e.data || throwError(''),
        isSupportedSourceFormat(detectSourceFormat(e.data)) || throwError('')
      var n = t[0]
      if (n && 0 === i && !e.dimensions) {
        var a = n.startIndex
        a && (e.data = n.data.slice(0, a).concat(e.data)),
          (r = {
            seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
            sourceHeader: a,
            dimensions: n.metaRawOption.dimensions
          })
      } else
        r = { seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN, sourceHeader: 0, dimensions: e.dimensions }
      return createSource(e.data, r, null, null)
    }
  )
}
function isSupportedSourceFormat(e) {
  return e === SOURCE_FORMAT_ARRAY_ROWS || e === SOURCE_FORMAT_OBJECT_ROWS
}
var SourceManager = (function () {
  function e(e) {
    ;(this._sourceList = []),
      (this._upstreamSignList = []),
      (this._versionSignBase = 0),
      (this._sourceHost = e)
  }
  return (
    (e.prototype.dirty = function () {
      this._setLocalSource([], [])
    }),
    (e.prototype._setLocalSource = function (e, t) {
      ;(this._sourceList = e),
        (this._upstreamSignList = t),
        this._versionSignBase++,
        this._versionSignBase > 9e10 && (this._versionSignBase = 0)
    }),
    (e.prototype._getVersionSign = function () {
      return this._sourceHost.uid + '_' + this._versionSignBase
    }),
    (e.prototype.prepareSource = function () {
      this._isDirty() && this._createSource()
    }),
    (e.prototype._createSource = function () {
      this._setLocalSource([], [])
      var e,
        t,
        i = this._sourceHost,
        r = this._getUpstreamSourceManagers(),
        n = !!r.length
      if (isSeries(i)) {
        var a = i,
          o = void 0,
          s = void 0,
          l = void 0
        if (n) {
          var h = r[0]
          h.prepareSource(),
            (o = (l = h.getSource()).data),
            (s = l.sourceFormat),
            (t = [h._getVersionSign()])
        } else
          (s = isTypedArray((o = a.get('data', !0)))
            ? SOURCE_FORMAT_TYPED_ARRAY
            : SOURCE_FORMAT_ORIGINAL),
            (t = [])
        var u = this._getSourceMetaRawOption(),
          p = l ? l.metaRawOption : null
        e = [
          createSource(
            o,
            {
              seriesLayoutBy: retrieve2(u.seriesLayoutBy, p ? p.seriesLayoutBy : null),
              sourceHeader: retrieve2(u.sourceHeader, p ? p.sourceHeader : null),
              dimensions: retrieve2(u.dimensions, p ? p.dimensions : null)
            },
            s,
            a.get('encode', !0)
          )
        ]
      } else {
        var c = i
        if (n) {
          var d = this._applyTransform(r)
          ;(e = d.sourceList), (t = d.upstreamSignList)
        } else {
          ;(e = [createSource(c.get('source', !0), this._getSourceMetaRawOption(), null, null)]),
            (t = [])
        }
      }
      this._setLocalSource(e, t)
    }),
    (e.prototype._applyTransform = function (e) {
      var t,
        i = this._sourceHost,
        r = i.get('transform', !0),
        n = i.get('fromTransformResult', !0)
      if (null != n) {
        1 !== e.length && doThrow('')
      }
      var a = [],
        o = []
      return (
        each$i(e, function (e) {
          e.prepareSource()
          var t = e.getSource(n || 0)
          null == n || t || doThrow(''), a.push(t), o.push(e._getVersionSign())
        }),
        r
          ? (t = applyDataTransform(r, a, { datasetIndex: i.componentIndex }))
          : null != n && (t = [cloneSourceShallow(a[0])]),
        { sourceList: t, upstreamSignList: o }
      )
    }),
    (e.prototype._isDirty = function () {
      if (!this._sourceList.length) return !0
      for (var e = this._getUpstreamSourceManagers(), t = 0; t < e.length; t++) {
        var i = e[t]
        if (i._isDirty() || this._upstreamSignList[t] !== i._getVersionSign()) return !0
      }
    }),
    (e.prototype.getSource = function (e) {
      return this._sourceList[e || 0]
    }),
    (e.prototype._getUpstreamSourceManagers = function () {
      var e = this._sourceHost
      if (isSeries(e)) {
        var t = querySeriesUpstreamDatasetModel(e)
        return t ? [t.getSourceManager()] : []
      }
      return map$1(queryDatasetUpstreamDatasetModels(e), function (e) {
        return e.getSourceManager()
      })
    }),
    (e.prototype._getSourceMetaRawOption = function () {
      var e,
        t,
        i,
        r = this._sourceHost
      if (isSeries(r))
        (e = r.get('seriesLayoutBy', !0)),
          (t = r.get('sourceHeader', !0)),
          (i = r.get('dimensions', !0))
      else if (!this._getUpstreamSourceManagers().length) {
        var n = r
        ;(e = n.get('seriesLayoutBy', !0)),
          (t = n.get('sourceHeader', !0)),
          (i = n.get('dimensions', !0))
      }
      return { seriesLayoutBy: e, sourceHeader: t, dimensions: i }
    }),
    e
  )
})()
function disableTransformOptionMerge(e) {
  e.option.transform && setAsPrimitive(e.option.transform)
}
function isSeries(e) {
  return 'series' === e.mainType
}
function doThrow(e) {
  throw new Error(e)
}
var TOOLTIP_LINE_HEIGHT_CSS = 'line-height:1'
function getTooltipTextStyle(e, t) {
  var i = e.color || '#6e7079',
    r = e.fontSize || 12,
    n = e.fontWeight || '400',
    a = e.color || '#464646',
    o = e.fontSize || 14,
    s = e.fontWeight || '900'
  return 'html' === t
    ? {
        nameStyle:
          'font-size:' +
          encodeHTML(r + '') +
          'px;color:' +
          encodeHTML(i) +
          ';font-weight:' +
          encodeHTML(n + ''),
        valueStyle:
          'font-size:' +
          encodeHTML(o + '') +
          'px;color:' +
          encodeHTML(a) +
          ';font-weight:' +
          encodeHTML(s + '')
      }
    : {
        nameStyle: { fontSize: r, fill: i, fontWeight: n },
        valueStyle: { fontSize: o, fill: a, fontWeight: s }
      }
}
var HTML_GAPS = [0, 10, 20, 30],
  RICH_TEXT_GAPS = ['', '\n', '\n\n', '\n\n\n']
function createTooltipMarkup(e, t) {
  return (t.type = e), t
}
function getBuilder(e) {
  return hasOwn(builderMap, e.type) && builderMap[e.type]
}
var builderMap = {
  section: {
    planLayout: function (e) {
      var t = e.blocks.length,
        i = t > 1 || (t > 0 && !e.noHeader),
        r = 0
      each$i(e.blocks, function (e) {
        getBuilder(e).planLayout(e)
        var t = e.__gapLevelBetweenSubBlocks
        t >= r && (r = t + (!i || (t && ('section' !== e.type || e.noHeader)) ? 0 : 1))
      }),
        (e.__gapLevelBetweenSubBlocks = r)
    },
    build: function (e, t, i, r) {
      var n = t.noHeader,
        a = getGap(t),
        o = buildSubBlocks(e, t, n ? i : a.html, r)
      if (n) return o
      var s = makeValueReadable(t.header, 'ordinal', e.useUTC),
        l = getTooltipTextStyle(r, e.renderMode).nameStyle
      return 'richText' === e.renderMode
        ? wrapInlineNameRichText(e, s, l) + a.richText + o
        : wrapBlockHTML(
            '<div style="' +
              l +
              ';' +
              TOOLTIP_LINE_HEIGHT_CSS +
              ';">' +
              encodeHTML(s) +
              '</div>' +
              o,
            i
          )
    }
  },
  nameValue: {
    planLayout: function (e) {
      e.__gapLevelBetweenSubBlocks = 0
    },
    build: function (e, t, i, r) {
      var n = e.renderMode,
        a = t.noName,
        o = t.noValue,
        s = !t.markerType,
        l = t.name,
        h = t.value,
        u = e.useUTC
      if (!a || !o) {
        var p = s
            ? ''
            : e.markupStyleCreator.makeTooltipMarker(t.markerType, t.markerColor || '#333', n),
          c = a ? '' : makeValueReadable(l, 'ordinal', u),
          d = t.valueType,
          f = o
            ? []
            : isArray$1(h)
            ? map$1(h, function (e, t) {
                return makeValueReadable(e, isArray$1(d) ? d[t] : d, u)
              })
            : [makeValueReadable(h, isArray$1(d) ? d[0] : d, u)],
          m = !s || !a,
          g = !s && a,
          y = getTooltipTextStyle(r, n),
          v = y.nameStyle,
          _ = y.valueStyle
        return 'richText' === n
          ? (s ? '' : p) +
              (a ? '' : wrapInlineNameRichText(e, c, v)) +
              (o ? '' : wrapInlineValueRichText(e, f, m, g, _))
          : wrapBlockHTML(
              (s ? '' : p) +
                (a ? '' : wrapInlineNameHTML(c, !s, v)) +
                (o ? '' : wrapInlineValueHTML(f, m, g, _)),
              i
            )
      }
    }
  }
}
function buildSubBlocks(e, t, i, r) {
  var n = [],
    a = t.blocks || []
  assert$1(!a || isArray$1(a)), (a = a || [])
  var o = e.orderMode
  if (t.sortBlocks && o) {
    a = a.slice()
    var s = { valueAsc: 'asc', valueDesc: 'desc' }
    if (hasOwn(s, o)) {
      var l = new SortOrderComparator(s[o], null)
      a.sort(function (e, t) {
        return l.evaluate(e.sortParam, t.sortParam)
      })
    } else 'seriesDesc' === o && a.reverse()
  }
  var h = getGap(t)
  if (
    (each$i(a, function (t, i) {
      var a = getBuilder(t).build(e, t, i > 0 ? h.html : 0, r)
      null != a && n.push(a)
    }),
    n.length)
  )
    return 'richText' === e.renderMode ? n.join(h.richText) : wrapBlockHTML(n.join(''), i)
}
function buildTooltipMarkup(e, t, i, r, n, a) {
  if (e) {
    var o = getBuilder(e)
    o.planLayout(e)
    var s = { useUTC: n, renderMode: i, orderMode: r, markupStyleCreator: t }
    return o.build(s, e, 0, a)
  }
}
function getGap(e) {
  var t = e.__gapLevelBetweenSubBlocks
  return { html: HTML_GAPS[t], richText: RICH_TEXT_GAPS[t] }
}
function wrapBlockHTML(e, t) {
  return (
    '<div style="' +
    ('margin: ' + t + 'px 0 0') +
    ';' +
    TOOLTIP_LINE_HEIGHT_CSS +
    ';">' +
    e +
    '<div style="clear:both"></div></div>'
  )
}
function wrapInlineNameHTML(e, t, i) {
  return '<span style="' + i + ';' + (t ? 'margin-left:2px' : '') + '">' + encodeHTML(e) + '</span>'
}
function wrapInlineValueHTML(e, t, i, r) {
  return (
    '<span style="' +
    (t ? 'float:right;margin-left:' + (i ? '10px' : '20px') : '') +
    ';' +
    r +
    '">' +
    map$1(e, function (e) {
      return encodeHTML(e)
    }).join('&nbsp;&nbsp;') +
    '</span>'
  )
}
function wrapInlineNameRichText(e, t, i) {
  return e.markupStyleCreator.wrapRichTextStyle(t, i)
}
function wrapInlineValueRichText(e, t, i, r, n) {
  var a = [n],
    o = r ? 10 : 20
  return (
    i && a.push({ padding: [0, 0, 0, o], align: 'right' }),
    e.markupStyleCreator.wrapRichTextStyle(t.join('  '), a)
  )
}
function retrieveVisualColorForTooltipMarker(e, t) {
  return convertToColorString(e.getData().getItemVisual(t, 'style')[e.visualDrawType])
}
function getPaddingFromTooltipModel(e, t) {
  var i = e.get('padding')
  return null != i ? i : 'richText' === t ? [8, 10] : 10
}
var TooltipMarkupStyleCreator = (function () {
  function e() {
    ;(this.richTextStyles = {}), (this._nextStyleNameId = getRandomIdBase())
  }
  return (
    (e.prototype._generateStyleName = function () {
      return '__EC_aUTo_' + this._nextStyleNameId++
    }),
    (e.prototype.makeTooltipMarker = function (e, t, i) {
      var r = 'richText' === i ? this._generateStyleName() : null,
        n = getTooltipMarker({ color: t, type: e, renderMode: i, markerId: r })
      return isString(n) ? n : ((this.richTextStyles[r] = n.style), n.content)
    }),
    (e.prototype.wrapRichTextStyle = function (e, t) {
      var i = {}
      isArray$1(t)
        ? each$i(t, function (e) {
            return extend$3(i, e)
          })
        : extend$3(i, t)
      var r = this._generateStyleName()
      return (this.richTextStyles[r] = i), '{' + r + '|' + e + '}'
    }),
    e
  )
})()
function defaultSeriesFormatTooltip(e) {
  var t,
    i,
    r,
    n,
    a = e.series,
    o = e.dataIndex,
    s = e.multipleSeries,
    l = a.getData(),
    h = l.mapDimensionsAll('defaultedTooltip'),
    u = h.length,
    p = a.getRawValue(o),
    c = isArray$1(p),
    d = retrieveVisualColorForTooltipMarker(a, o)
  if (u > 1 || (c && !u)) {
    var f = formatTooltipArrayValue(p, a, o, h, d)
    ;(t = f.inlineValues), (i = f.inlineValueTypes), (r = f.blocks), (n = f.inlineValues[0])
  } else if (u) {
    var m = l.getDimensionInfo(h[0])
    ;(n = t = retrieveRawValue(l, o, h[0])), (i = m.type)
  } else n = t = c ? p[0] : p
  var g = isNameSpecified(a),
    y = (g && a.name) || '',
    v = l.getName(o),
    _ = s ? y : v
  return createTooltipMarkup('section', {
    header: y,
    noHeader: s || !g,
    sortParam: n,
    blocks: [
      createTooltipMarkup('nameValue', {
        markerType: 'item',
        markerColor: d,
        name: _,
        noName: !trim$1(_),
        value: t,
        valueType: i
      })
    ].concat(r || [])
  })
}
function formatTooltipArrayValue(e, t, i, r, n) {
  var a = t.getData(),
    o = reduce(
      e,
      function (e, t, i) {
        var r = a.getDimensionInfo(i)
        return e || (r && !1 !== r.tooltip && null != r.displayName)
      },
      !1
    ),
    s = [],
    l = [],
    h = []
  function u(e, t) {
    var i = a.getDimensionInfo(t)
    i &&
      !1 !== i.otherDims.tooltip &&
      (o
        ? h.push(
            createTooltipMarkup('nameValue', {
              markerType: 'subItem',
              markerColor: n,
              name: i.displayName,
              value: e,
              valueType: i.type
            })
          )
        : (s.push(e), l.push(i.type)))
  }
  return (
    r.length
      ? each$i(r, function (e) {
          u(retrieveRawValue(a, i, e), e)
        })
      : each$i(e, u),
    { inlineValues: s, inlineValueTypes: l, blocks: h }
  )
}
var inner$k = makeInner()
function getSelectionKey(e, t) {
  return e.getName(t) || e.getId(t)
}
var SeriesModel = (function (e) {
  function t() {
    var t = (null !== e && e.apply(this, arguments)) || this
    return (t._selectedDataIndicesMap = {}), t
  }
  var i
  return (
    __extends(t, e),
    (t.prototype.init = function (e, t, i) {
      ;(this.seriesIndex = this.componentIndex),
        (this.dataTask = createTask({ count: dataTaskCount, reset: dataTaskReset })),
        (this.dataTask.context = { model: this }),
        this.mergeDefaultAndTheme(e, i),
        (inner$k(this).sourceManager = new SourceManager(this)).prepareSource()
      var r = this.getInitialData(e, i)
      wrapData(r, this),
        (this.dataTask.context.data = r),
        (inner$k(this).dataBeforeProcessed = r),
        autoSeriesName(this),
        this._initSelectedMapFromData(r)
    }),
    (t.prototype.mergeDefaultAndTheme = function (e, t) {
      var i = fetchLayoutMode(this),
        r = i ? getLayoutParams(e) : {},
        n = this.subType
      ComponentModel.hasClass(n) && (n += 'Series'),
        merge(e, t.getTheme().get(this.subType)),
        merge(e, this.getDefaultOption()),
        defaultEmphasis(e, 'label', ['show']),
        this.fillDataTextStyle(e.data),
        i && mergeLayoutParam(e, r, i)
    }),
    (t.prototype.mergeOption = function (e, t) {
      ;(e = merge(this.option, e, !0)), this.fillDataTextStyle(e.data)
      var i = fetchLayoutMode(this)
      i && mergeLayoutParam(this.option, e, i)
      var r = inner$k(this).sourceManager
      r.dirty(), r.prepareSource()
      var n = this.getInitialData(e, t)
      wrapData(n, this),
        this.dataTask.dirty(),
        (this.dataTask.context.data = n),
        (inner$k(this).dataBeforeProcessed = n),
        autoSeriesName(this),
        this._initSelectedMapFromData(n)
    }),
    (t.prototype.fillDataTextStyle = function (e) {
      if (e && !isTypedArray(e))
        for (var t = ['show'], i = 0; i < e.length; i++)
          e[i] && e[i].label && defaultEmphasis(e[i], 'label', t)
    }),
    (t.prototype.getInitialData = function (e, t) {}),
    (t.prototype.appendData = function (e) {
      this.getRawData().appendData(e.data)
    }),
    (t.prototype.getData = function (e) {
      var t = getCurrentTask(this)
      if (t) {
        var i = t.context.data
        return null == e ? i : i.getLinkedData(e)
      }
      return inner$k(this).data
    }),
    (t.prototype.getAllData = function () {
      var e = this.getData()
      return e && e.getLinkedDataAll ? e.getLinkedDataAll() : [{ data: e }]
    }),
    (t.prototype.setData = function (e) {
      var t = getCurrentTask(this)
      if (t) {
        var i = t.context
        ;(i.outputData = e), t !== this.dataTask && (i.data = e)
      }
      inner$k(this).data = e
    }),
    (t.prototype.getSource = function () {
      return inner$k(this).sourceManager.getSource()
    }),
    (t.prototype.getRawData = function () {
      return inner$k(this).dataBeforeProcessed
    }),
    (t.prototype.getBaseAxis = function () {
      var e = this.coordinateSystem
      return e && e.getBaseAxis && e.getBaseAxis()
    }),
    (t.prototype.formatTooltip = function (e, t, i) {
      return defaultSeriesFormatTooltip({ series: this, dataIndex: e, multipleSeries: t })
    }),
    (t.prototype.isAnimationEnabled = function () {
      if (env.node) return !1
      var e = this.getShallow('animation')
      return e && this.getData().count() > this.getShallow('animationThreshold') && (e = !1), !!e
    }),
    (t.prototype.restoreData = function () {
      this.dataTask.dirty()
    }),
    (t.prototype.getColorFromPalette = function (e, t, i) {
      var r = this.ecModel,
        n = PaletteMixin.prototype.getColorFromPalette.call(this, e, t, i)
      return n || (n = r.getColorFromPalette(e, t, i)), n
    }),
    (t.prototype.coordDimToDataDim = function (e) {
      return this.getRawData().mapDimensionsAll(e)
    }),
    (t.prototype.getProgressive = function () {
      return this.get('progressive')
    }),
    (t.prototype.getProgressiveThreshold = function () {
      return this.get('progressiveThreshold')
    }),
    (t.prototype.select = function (e, t) {
      this._innerSelect(this.getData(t), e)
    }),
    (t.prototype.unselect = function (e, t) {
      var i = this.option.selectedMap
      if (i)
        for (var r = this.getData(t), n = 0; n < e.length; n++) {
          var a = getSelectionKey(r, e[n])
          ;(i[a] = !1), (this._selectedDataIndicesMap[a] = -1)
        }
    }),
    (t.prototype.toggleSelect = function (e, t) {
      for (var i = [], r = 0; r < e.length; r++)
        (i[0] = e[r]), this.isSelected(e[r], t) ? this.unselect(i, t) : this.select(i, t)
    }),
    (t.prototype.getSelectedDataIndices = function () {
      for (var e = this._selectedDataIndicesMap, t = keys(e), i = [], r = 0; r < t.length; r++) {
        var n = e[t[r]]
        n >= 0 && i.push(n)
      }
      return i
    }),
    (t.prototype.isSelected = function (e, t) {
      var i = this.option.selectedMap
      return (i && i[getSelectionKey(this.getData(t), e)]) || !1
    }),
    (t.prototype._innerSelect = function (e, t) {
      var i,
        r,
        n = this.option.selectedMode,
        a = t.length
      if (n && a)
        if ('multiple' === n)
          for (
            var o = this.option.selectedMap || (this.option.selectedMap = {}), s = 0;
            s < a;
            s++
          ) {
            var l = t[s]
            ;(o[(u = getSelectionKey(e, l))] = !0),
              (this._selectedDataIndicesMap[u] = e.getRawIndex(l))
          }
        else if ('single' === n || !0 === n) {
          var h = t[a - 1],
            u = getSelectionKey(e, h)
          ;(this.option.selectedMap = (((i = {})[u] = !0), i)),
            (this._selectedDataIndicesMap = (((r = {})[u] = e.getRawIndex(h)), r))
        }
    }),
    (t.prototype._initSelectedMapFromData = function (e) {
      if (!this.option.selectedMap) {
        var t = []
        e.hasItemOption &&
          e.each(function (i) {
            var r = e.getRawDataItem(i)
            r && r.selected && t.push(i)
          }),
          t.length > 0 && this._innerSelect(e, t)
      }
    }),
    (t.registerClass = function (e) {
      return ComponentModel.registerClass(e)
    }),
    (t.protoInitialize =
      (((i = t.prototype).type = 'series.__base__'),
      (i.seriesIndex = 0),
      (i.useColorPaletteOnData = !1),
      (i.ignoreStyleOnData = !1),
      (i.hasSymbolVisual = !1),
      (i.defaultSymbol = 'circle'),
      (i.visualStyleAccessPath = 'itemStyle'),
      void (i.visualDrawType = 'fill'))),
    t
  )
})(ComponentModel)
function autoSeriesName(e) {
  var t = e.name
  isNameSpecified(e) || (e.name = getSeriesAutoName(e) || t)
}
function getSeriesAutoName(e) {
  var t = e.getRawData(),
    i = t.mapDimensionsAll('seriesName'),
    r = []
  return (
    each$i(i, function (e) {
      var i = t.getDimensionInfo(e)
      i.displayName && r.push(i.displayName)
    }),
    r.join(' ')
  )
}
function dataTaskCount(e) {
  return e.model.getRawData().count()
}
function dataTaskReset(e) {
  var t = e.model
  return t.setData(t.getRawData().cloneShallow()), dataTaskProgress
}
function dataTaskProgress(e, t) {
  t.outputData && e.end > t.outputData.count() && t.model.getRawData().cloneShallow(t.outputData)
}
function wrapData(e, t) {
  each$i(__spreadArrays(e.CHANGABLE_METHODS, e.DOWNSAMPLE_METHODS), function (i) {
    e.wrapMethod(i, curry$1(onDataChange, t))
  })
}
function onDataChange(e, t) {
  var i = getCurrentTask(e)
  return i && i.setOutputEnd((t || this).count()), t
}
function getCurrentTask(e) {
  var t = (e.ecModel || {}).scheduler,
    i = t && t.getPipeline(e.uid)
  if (i) {
    var r = i.currentTask
    if (r) {
      var n = r.agentStubMap
      n && (r = n.get(e.uid))
    }
    return r
  }
}
mixin(SeriesModel, DataFormatMixin),
  mixin(SeriesModel, PaletteMixin),
  mountExtend(SeriesModel, ComponentModel)
var ComponentView = (function () {
  function e() {
    ;(this.group = new Group$3()), (this.uid = getUID('viewComponent'))
  }
  return (
    (e.prototype.init = function (e, t) {}),
    (e.prototype.render = function (e, t, i, r) {}),
    (e.prototype.dispose = function (e, t) {}),
    (e.prototype.updateView = function (e, t, i, r) {}),
    (e.prototype.updateLayout = function (e, t, i, r) {}),
    (e.prototype.updateVisual = function (e, t, i, r) {}),
    (e.prototype.blurSeries = function (e, t) {}),
    e
  )
})()
function createRenderPlanner() {
  var e = makeInner()
  return function (t) {
    var i = e(t),
      r = t.pipelineContext,
      n = !!i.large,
      a = !!i.progressiveRender,
      o = (i.large = !(!r || !r.large)),
      s = (i.progressiveRender = !(!r || !r.progressiveRender))
    return !(n === o && a === s) && 'reset'
  }
}
enableClassExtend(ComponentView), enableClassManagement(ComponentView)
var inner$j = makeInner(),
  renderPlanner = createRenderPlanner(),
  ChartView = (function () {
    function e() {
      ;(this.group = new Group$3()),
        (this.uid = getUID('viewChart')),
        (this.renderTask = createTask({ plan: renderTaskPlan, reset: renderTaskReset })),
        (this.renderTask.context = { view: this })
    }
    return (
      (e.prototype.init = function (e, t) {}),
      (e.prototype.render = function (e, t, i, r) {}),
      (e.prototype.highlight = function (e, t, i, r) {
        toggleHighlight(e.getData(), r, 'emphasis')
      }),
      (e.prototype.downplay = function (e, t, i, r) {
        toggleHighlight(e.getData(), r, 'normal')
      }),
      (e.prototype.remove = function (e, t) {
        this.group.removeAll()
      }),
      (e.prototype.dispose = function (e, t) {}),
      (e.prototype.updateView = function (e, t, i, r) {
        this.render(e, t, i, r)
      }),
      (e.prototype.updateLayout = function (e, t, i, r) {
        this.render(e, t, i, r)
      }),
      (e.prototype.updateVisual = function (e, t, i, r) {
        this.render(e, t, i, r)
      }),
      (e.markUpdateMethod = function (e, t) {
        inner$j(e).updateMethod = t
      }),
      (e.protoInitialize = void (e.prototype.type = 'chart')),
      e
    )
  })()
function elSetState(e, t, i) {
  e && ('emphasis' === t ? enterEmphasis : leaveEmphasis)(e, i)
}
function toggleHighlight(e, t, i) {
  var r = queryDataIndex(e, t),
    n = t && null != t.highlightKey ? getHighlightDigit(t.highlightKey) : null
  null != r
    ? each$i(normalizeToArray(r), function (t) {
        elSetState(e.getItemGraphicEl(t), i, n)
      })
    : e.eachItemGraphicEl(function (e) {
        elSetState(e, i, n)
      })
}
function renderTaskPlan(e) {
  return renderPlanner(e.model)
}
function renderTaskReset(e) {
  var t = e.model,
    i = e.ecModel,
    r = e.api,
    n = e.payload,
    a = t.pipelineContext.progressiveRender,
    o = e.view,
    s = n && inner$j(n).updateMethod,
    l = a ? 'incrementalPrepareRender' : s && o[s] ? s : 'render'
  return 'render' !== l && o[l](t, i, r, n), progressMethodMap[l]
}
enableClassExtend(ChartView), enableClassManagement(ChartView)
var progressMethodMap = {
    incrementalPrepareRender: {
      progress: function (e, t) {
        t.view.incrementalRender(e, t.model, t.ecModel, t.api, t.payload)
      }
    },
    render: {
      forceFirstProgress: !0,
      progress: function (e, t) {
        t.view.render(t.model, t.ecModel, t.api, t.payload)
      }
    }
  },
  ORIGIN_METHOD = '\0__throttleOriginMethod',
  RATE = '\0__throttleRate',
  THROTTLE_TYPE = '\0__throttleType'
function throttle(e, t, i) {
  var r,
    n,
    a,
    o,
    s,
    l = 0,
    h = 0,
    u = null
  function p() {
    ;(h = new Date().getTime()), (u = null), e.apply(a, o || [])
  }
  t = t || 0
  var c = function () {
    for (var e = [], c = 0; c < arguments.length; c++) e[c] = arguments[c]
    ;(r = new Date().getTime()), (a = this), (o = e)
    var d = s || t,
      f = s || i
    ;(s = null),
      (n = r - (f ? l : h) - d),
      clearTimeout(u),
      f ? (u = setTimeout(p, d)) : n >= 0 ? p() : (u = setTimeout(p, -n)),
      (l = r)
  }
  return (
    (c.clear = function () {
      u && (clearTimeout(u), (u = null))
    }),
    (c.debounceNextCall = function (e) {
      s = e
    }),
    c
  )
}
function createOrUpdate(e, t, i, r) {
  var n = e[t]
  if (n) {
    var a = n[ORIGIN_METHOD] || n,
      o = n[THROTTLE_TYPE]
    if (n[RATE] !== i || o !== r) {
      if (null == i || !r) return (e[t] = a)
      ;((n = e[t] = throttle(a, i, 'debounce' === r))[ORIGIN_METHOD] = a),
        (n[THROTTLE_TYPE] = r),
        (n[RATE] = i)
    }
    return n
  }
}
function clear$1(e, t) {
  var i = e[t]
  i && i[ORIGIN_METHOD] && (e[t] = i[ORIGIN_METHOD])
}
var inner$i = makeInner(),
  defaultStyleMappers = {
    itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, !0),
    lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, !0)
  },
  defaultColorKey = { lineStyle: 'stroke', itemStyle: 'fill' }
function getStyleMapper(e, t) {
  var i = e.visualStyleMapper || defaultStyleMappers[t]
  return i || (console.warn("Unkown style type '" + t + "'."), defaultStyleMappers.itemStyle)
}
function getDefaultColorKey(e, t) {
  var i = e.visualDrawType || defaultColorKey[t]
  return i || (console.warn("Unkown style type '" + t + "'."), 'fill')
}
var seriesStyleTask = {
    createOnAllSeries: !0,
    performRawSeries: !0,
    reset: function (e, t) {
      var i = e.getData(),
        r = e.visualStyleAccessPath || 'itemStyle',
        n = e.getModel(r),
        a = getStyleMapper(e, r)(n),
        o = n.getShallow('decal')
      o && (i.setVisual('decal', o), (o.dirty = !0))
      var s = getDefaultColorKey(e, r),
        l = a[s],
        h = isFunction$1(l) ? l : null,
        u = 'auto' === a.fill || 'auto' === a.stroke
      if (!a[s] || h || u) {
        var p = e.getColorFromPalette(e.name, null, t.getSeriesCount())
        a[s] || ((a[s] = p), i.setVisual('colorFromPalette', !0)),
          (a.fill = 'auto' === a.fill || 'function' == typeof a.fill ? p : a.fill),
          (a.stroke = 'auto' === a.stroke || 'function' == typeof a.stroke ? p : a.stroke)
      }
      if ((i.setVisual('style', a), i.setVisual('drawType', s), !t.isSeriesFiltered(e) && h))
        return (
          i.setVisual('colorFromPalette', !1),
          {
            dataEach: function (t, i) {
              var r = e.getDataParams(i),
                n = extend$3({}, a)
              ;(n[s] = h(r)), t.setItemVisual(i, 'style', n)
            }
          }
        )
    }
  },
  sharedModel = new Model(),
  dataStyleTask = {
    createOnAllSeries: !0,
    performRawSeries: !0,
    reset: function (e, t) {
      if (!e.ignoreStyleOnData && !t.isSeriesFiltered(e)) {
        var i = e.getData(),
          r = e.visualStyleAccessPath || 'itemStyle',
          n = getStyleMapper(e, r),
          a = i.getVisual('drawType')
        return {
          dataEach: i.hasItemOption
            ? function (e, t) {
                var i = e.getRawDataItem(t)
                if (i && i[r]) {
                  sharedModel.option = i[r]
                  var o = n(sharedModel)
                  extend$3(e.ensureUniqueItemVisual(t, 'style'), o),
                    sharedModel.option.decal &&
                      (e.setItemVisual(t, 'decal', sharedModel.option.decal),
                      (sharedModel.option.decal.dirty = !0)),
                    a in o && e.setItemVisual(t, 'colorFromPalette', !1)
                }
              }
            : null
        }
      }
    }
  },
  dataColorPaletteTask = {
    performRawSeries: !0,
    overallReset: function (e) {
      var t = createHashMap()
      e.eachSeries(function (e) {
        if (e.useColorPaletteOnData) {
          var i = t.get(e.type)
          i || ((i = {}), t.set(e.type, i)), (inner$i(e).scope = i)
        }
      }),
        e.eachSeries(function (t) {
          if (t.useColorPaletteOnData && !e.isSeriesFiltered(t)) {
            var i = t.getRawData(),
              r = {},
              n = t.getData(),
              a = inner$i(t).scope,
              o = t.visualStyleAccessPath || 'itemStyle',
              s = getDefaultColorKey(t, o)
            n.each(function (e) {
              var t = n.getRawIndex(e)
              r[t] = e
            }),
              i.each(function (e) {
                var o = r[e]
                if (n.getItemVisual(o, 'colorFromPalette')) {
                  var l = n.ensureUniqueItemVisual(o, 'style'),
                    h = i.getName(e) || e + '',
                    u = i.count()
                  l[s] = t.getColorFromPalette(h, a, u)
                }
              })
          }
        })
    }
  },
  PI$5 = Math.PI
function defaultLoading(e, t) {
  defaults$1((t = t || {}), {
    text: 'loading',
    textColor: '#000',
    fontSize: 12,
    fontWeight: 'normal',
    fontStyle: 'normal',
    fontFamily: 'sans-serif',
    maskColor: 'rgba(255, 255, 255, 0.8)',
    showSpinner: !0,
    color: '#5470c6',
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  })
  var i = new Group$3(),
    r = new Rect$2({ style: { fill: t.maskColor }, zlevel: t.zlevel, z: 1e4 })
  i.add(r)
  var n,
    a = new ZRText({
      style: {
        text: t.text,
        fill: t.textColor,
        fontSize: t.fontSize,
        fontWeight: t.fontWeight,
        fontStyle: t.fontStyle,
        fontFamily: t.fontFamily
      },
      zlevel: t.zlevel,
      z: 10001
    }),
    o = new Rect$2({
      style: { fill: 'none' },
      textContent: a,
      textConfig: { position: 'right', distance: 10 },
      zlevel: t.zlevel,
      z: 10001
    })
  return (
    i.add(o),
    t.showSpinner &&
      ((n = new Arc({
        shape: { startAngle: -PI$5 / 2, endAngle: -PI$5 / 2 + 0.1, r: t.spinnerRadius },
        style: { stroke: t.color, lineCap: 'round', lineWidth: t.lineWidth },
        zlevel: t.zlevel,
        z: 10001
      }))
        .animateShape(!0)
        .when(1e3, { endAngle: (3 * PI$5) / 2 })
        .start('circularInOut'),
      n
        .animateShape(!0)
        .when(1e3, { startAngle: (3 * PI$5) / 2 })
        .delay(300)
        .start('circularInOut'),
      i.add(n)),
    (i.resize = function () {
      var i = a.getBoundingRect().width,
        s = t.showSpinner ? t.spinnerRadius : 0,
        l =
          (e.getWidth() - 2 * s - (t.showSpinner && i ? 10 : 0) - i) / 2 -
          (t.showSpinner && i ? 0 : 5 + i / 2) +
          (t.showSpinner ? 0 : i / 2) +
          (i ? 0 : s),
        h = e.getHeight() / 2
      t.showSpinner && n.setShape({ cx: l, cy: h }),
        o.setShape({ x: l - s, y: h - s, width: 2 * s, height: 2 * s }),
        r.setShape({ x: 0, y: 0, width: e.getWidth(), height: e.getHeight() })
    }),
    i.resize(),
    i
  )
}
var Scheduler = (function () {
  function e(e, t, i, r) {
    ;(this._stageTaskMap = createHashMap()),
      (this.ecInstance = e),
      (this.api = t),
      (i = this._dataProcessorHandlers = i.slice()),
      (r = this._visualHandlers = r.slice()),
      (this._allHandlers = i.concat(r))
  }
  return (
    (e.prototype.restoreData = function (e, t) {
      e.restoreData(t),
        this._stageTaskMap.each(function (e) {
          var t = e.overallTask
          t && t.dirty()
        })
    }),
    (e.prototype.getPerformArgs = function (e, t) {
      if (e.__pipeline) {
        var i = this._pipelineMap.get(e.__pipeline.id),
          r = i.context,
          n =
            !t &&
            i.progressiveEnabled &&
            (!r || r.progressiveRender) &&
            e.__idxInPipeline > i.blockIndex
              ? i.step
              : null,
          a = r && r.modDataCount
        return { step: n, modBy: null != a ? Math.ceil(a / n) : null, modDataCount: a }
      }
    }),
    (e.prototype.getPipeline = function (e) {
      return this._pipelineMap.get(e)
    }),
    (e.prototype.updateStreamModes = function (e, t) {
      var i = this._pipelineMap.get(e.uid),
        r = e.getData().count(),
        n = i.progressiveEnabled && t.incrementalPrepareRender && r >= i.threshold,
        a = e.get('large') && r >= e.get('largeThreshold'),
        o = 'mod' === e.get('progressiveChunkMode') ? r : null
      e.pipelineContext = i.context = { progressiveRender: n, modDataCount: o, large: a }
    }),
    (e.prototype.restorePipelines = function (e) {
      var t = this,
        i = (t._pipelineMap = createHashMap())
      e.eachSeries(function (e) {
        var r = e.getProgressive(),
          n = e.uid
        i.set(n, {
          id: n,
          head: null,
          tail: null,
          threshold: e.getProgressiveThreshold(),
          progressiveEnabled: r && !(e.preventIncremental && e.preventIncremental()),
          blockIndex: -1,
          step: Math.round(r || 700),
          count: 0
        }),
          t._pipe(e, e.dataTask)
      })
    }),
    (e.prototype.prepareStageTasks = function () {
      var e = this._stageTaskMap,
        t = this.api.getModel(),
        i = this.api
      each$i(
        this._allHandlers,
        function (r) {
          var n = e.get(r.uid) || e.set(r.uid, {})
          assert$1(!(r.reset && r.overallReset), ''),
            r.reset && this._createSeriesStageTask(r, n, t, i),
            r.overallReset && this._createOverallStageTask(r, n, t, i)
        },
        this
      )
    }),
    (e.prototype.prepareView = function (e, t, i, r) {
      var n = e.renderTask,
        a = n.context
      ;(a.model = t),
        (a.ecModel = i),
        (a.api = r),
        (n.__block = !e.incrementalPrepareRender),
        this._pipe(t, n)
    }),
    (e.prototype.performDataProcessorTasks = function (e, t) {
      this._performStageTasks(this._dataProcessorHandlers, e, t, { block: !0 })
    }),
    (e.prototype.performVisualTasks = function (e, t, i) {
      this._performStageTasks(this._visualHandlers, e, t, i)
    }),
    (e.prototype._performStageTasks = function (e, t, i, r) {
      r = r || {}
      var n = !1,
        a = this
      function o(e, t) {
        return e.setDirty && (!e.dirtyMap || e.dirtyMap.get(t.__pipeline.id))
      }
      each$i(e, function (e, s) {
        if (!r.visualType || r.visualType === e.visualType) {
          var l = a._stageTaskMap.get(e.uid),
            h = l.seriesTaskMap,
            u = l.overallTask
          if (u) {
            var p,
              c = u.agentStubMap
            c.each(function (e) {
              o(r, e) && (e.dirty(), (p = !0))
            }),
              p && u.dirty(),
              a.updatePayload(u, i)
            var d = a.getPerformArgs(u, r.block)
            c.each(function (e) {
              e.perform(d)
            }),
              u.perform(d) && (n = !0)
          } else
            h &&
              h.each(function (s, l) {
                o(r, s) && s.dirty()
                var h = a.getPerformArgs(s, r.block)
                ;(h.skip = !e.performRawSeries && t.isSeriesFiltered(s.context.model)),
                  a.updatePayload(s, i),
                  s.perform(h) && (n = !0)
              })
        }
      }),
        (this.unfinished = n || this.unfinished)
    }),
    (e.prototype.performSeriesTasks = function (e) {
      var t
      e.eachSeries(function (e) {
        t = e.dataTask.perform() || t
      }),
        (this.unfinished = t || this.unfinished)
    }),
    (e.prototype.plan = function () {
      this._pipelineMap.each(function (e) {
        var t = e.tail
        do {
          if (t.__block) {
            e.blockIndex = t.__idxInPipeline
            break
          }
          t = t.getUpstream()
        } while (t)
      })
    }),
    (e.prototype.updatePayload = function (e, t) {
      'remain' !== t && (e.context.payload = t)
    }),
    (e.prototype._createSeriesStageTask = function (e, t, i, r) {
      var n = this,
        a = t.seriesTaskMap,
        o = (t.seriesTaskMap = createHashMap()),
        s = e.seriesType,
        l = e.getTargetSeries
      function h(t) {
        var s = t.uid,
          l = o.set(
            s,
            (a && a.get(s)) ||
              createTask({ plan: seriesTaskPlan, reset: seriesTaskReset, count: seriesTaskCount })
          )
        ;(l.context = {
          model: t,
          ecModel: i,
          api: r,
          useClearVisual: e.isVisual && !e.isLayout,
          plan: e.plan,
          reset: e.reset,
          scheduler: n
        }),
          n._pipe(t, l)
      }
      e.createOnAllSeries
        ? i.eachRawSeries(h)
        : s
        ? i.eachRawSeriesByType(s, h)
        : l && l(i, r).each(h)
    }),
    (e.prototype._createOverallStageTask = function (e, t, i, r) {
      var n = this,
        a = (t.overallTask = t.overallTask || createTask({ reset: overallTaskReset }))
      a.context = { ecModel: i, api: r, overallReset: e.overallReset, scheduler: n }
      var o = a.agentStubMap,
        s = (a.agentStubMap = createHashMap()),
        l = e.seriesType,
        h = e.getTargetSeries,
        u = !0,
        p = !1
      function c(e) {
        var t = e.uid,
          i = s.set(
            t,
            (o && o.get(t)) || ((p = !0), createTask({ reset: stubReset, onDirty: stubOnDirty }))
          )
        ;(i.context = { model: e, overallProgress: u }),
          (i.agent = a),
          (i.__block = u),
          n._pipe(e, i)
      }
      assert$1(!e.createOnAllSeries, ''),
        l
          ? i.eachRawSeriesByType(l, c)
          : h
          ? h(i, r).each(c)
          : ((u = !1), each$i(i.getSeries(), c)),
        p && a.dirty()
    }),
    (e.prototype._pipe = function (e, t) {
      var i = e.uid,
        r = this._pipelineMap.get(i)
      !r.head && (r.head = t),
        r.tail && r.tail.pipe(t),
        (r.tail = t),
        (t.__idxInPipeline = r.count++),
        (t.__pipeline = r)
    }),
    (e.wrapStageHandler = function (e, t) {
      return (
        isFunction$1(e) && (e = { overallReset: e, seriesType: detectSeriseType(e) }),
        (e.uid = getUID('stageHandler')),
        t && (e.visualType = t),
        e
      )
    }),
    e
  )
})()
function overallTaskReset(e) {
  e.overallReset(e.ecModel, e.api, e.payload)
}
function stubReset(e) {
  return e.overallProgress && stubProgress
}
function stubProgress() {
  this.agent.dirty(), this.getDownstream().dirty()
}
function stubOnDirty() {
  this.agent && this.agent.dirty()
}
function seriesTaskPlan(e) {
  return e.plan ? e.plan(e.model, e.ecModel, e.api, e.payload) : null
}
function seriesTaskReset(e) {
  e.useClearVisual && e.data.clearAllVisual()
  var t = (e.resetDefines = normalizeToArray(e.reset(e.model, e.ecModel, e.api, e.payload)))
  return t.length > 1
    ? map$1(t, function (e, t) {
        return makeSeriesTaskProgress(t)
      })
    : singleSeriesTaskProgress
}
var singleSeriesTaskProgress = makeSeriesTaskProgress(0)
function makeSeriesTaskProgress(e) {
  return function (t, i) {
    var r = i.data,
      n = i.resetDefines[e]
    if (n && n.dataEach) for (var a = t.start; a < t.end; a++) n.dataEach(r, a)
    else n && n.progress && n.progress(t, r)
  }
}
function seriesTaskCount(e) {
  return e.data.count()
}
function detectSeriseType(e) {
  seriesType = null
  try {
    e(ecModelMock, apiMock)
  } catch (t) {}
  return seriesType
}
var ecModelMock = {},
  apiMock = {},
  seriesType
function mockMethods(e, t) {
  for (var i in t.prototype) e[i] = noop$1
}
mockMethods(ecModelMock, GlobalModel),
  mockMethods(apiMock, ExtensionAPI),
  (ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType =
    function (e) {
      seriesType = e
    }),
  (ecModelMock.eachComponent = function (e) {
    'series' === e.mainType && e.subType && (seriesType = e.subType)
  })
var colorAll = [
    '#37A2DA',
    '#32C5E9',
    '#67E0E3',
    '#9FE6B8',
    '#FFDB5C',
    '#ff9f7f',
    '#fb7293',
    '#E062AE',
    '#E690D1',
    '#e7bcf3',
    '#9d96f5',
    '#8378EA',
    '#96BFFF'
  ],
  lightTheme = {
    color: colorAll,
    colorLayer: [
      ['#37A2DA', '#ffd85c', '#fd7b5f'],
      ['#37A2DA', '#67E0E3', '#FFDB5C', '#ff9f7f', '#E062AE', '#9d96f5'],
      [
        '#37A2DA',
        '#32C5E9',
        '#9FE6B8',
        '#FFDB5C',
        '#ff9f7f',
        '#fb7293',
        '#e7bcf3',
        '#8378EA',
        '#96BFFF'
      ],
      colorAll
    ]
  },
  contrastColor = '#B9B8CE',
  backgroundColor = '#100C2A',
  axisCommon = function () {
    return {
      axisLine: { lineStyle: { color: contrastColor } },
      splitLine: { lineStyle: { color: '#484753' } },
      splitArea: { areaStyle: { color: ['rgba(255,255,255,0.02)', 'rgba(255,255,255,0.05)'] } },
      minorSplitLine: { lineStyle: { color: '#20203B' } }
    }
  },
  colorPalette = [
    '#4992ff',
    '#7cffb2',
    '#fddd60',
    '#ff6e76',
    '#58d9f9',
    '#05c091',
    '#ff8a45',
    '#8d48e3',
    '#dd79ff'
  ],
  theme = {
    darkMode: !0,
    color: colorPalette,
    backgroundColor: backgroundColor,
    axisPointer: {
      lineStyle: { color: '#817f91' },
      crossStyle: { color: '#817f91' },
      label: { color: '#fff' }
    },
    legend: { textStyle: { color: contrastColor } },
    textStyle: { color: contrastColor },
    title: { textStyle: { color: '#EEF1FA' }, subtextStyle: { color: '#B9B8CE' } },
    toolbox: { iconStyle: { borderColor: contrastColor } },
    dataZoom: {
      borderColor: '#71708A',
      textStyle: { color: contrastColor },
      brushStyle: { color: 'rgba(135,163,206,0.3)' },
      handleStyle: { color: '#353450', borderColor: '#C5CBE3' },
      moveHandleStyle: { color: '#B0B6C3', opacity: 0.3 },
      fillerColor: 'rgba(135,163,206,0.2)',
      emphasis: {
        handleStyle: { borderColor: '#91B7F2', color: '#4D587D' },
        moveHandleStyle: { color: '#636D9A', opacity: 0.7 }
      },
      dataBackground: {
        lineStyle: { color: '#71708A', width: 1 },
        areaStyle: { color: '#71708A' }
      },
      selectedDataBackground: { lineStyle: { color: '#87A3CE' }, areaStyle: { color: '#87A3CE' } }
    },
    visualMap: { textStyle: { color: contrastColor } },
    timeline: {
      lineStyle: { color: contrastColor },
      label: { color: contrastColor },
      controlStyle: { color: contrastColor, borderColor: contrastColor }
    },
    calendar: {
      itemStyle: { color: backgroundColor },
      dayLabel: { color: contrastColor },
      monthLabel: { color: contrastColor },
      yearLabel: { color: contrastColor }
    },
    timeAxis: axisCommon(),
    logAxis: axisCommon(),
    valueAxis: axisCommon(),
    categoryAxis: axisCommon(),
    line: { symbol: 'circle' },
    graph: { color: colorPalette },
    gauge: {
      title: { color: contrastColor },
      axisLine: { lineStyle: { color: [[1, 'rgba(207,212,219,0.2)']] } },
      axisLabel: { color: contrastColor },
      detail: { color: '#EEF1FA' }
    },
    candlestick: {
      itemStyle: {
        color: '#f64e56',
        color0: '#54ea92',
        borderColor: '#f64e56',
        borderColor0: '#54ea92'
      }
    }
  }
theme.categoryAxis.splitLine.show = !1
var ECEventProcessor = (function () {
    function e() {}
    return (
      (e.prototype.normalizeQuery = function (e) {
        var t = {},
          i = {},
          r = {}
        if (isString(e)) {
          var n = parseClassType(e)
          ;(t.mainType = n.main || null), (t.subType = n.sub || null)
        } else {
          var a = ['Index', 'Name', 'Id'],
            o = { name: 1, dataIndex: 1, dataType: 1 }
          each$i(e, function (e, n) {
            for (var s = !1, l = 0; l < a.length; l++) {
              var h = a[l],
                u = n.lastIndexOf(h)
              if (u > 0 && u === n.length - h.length) {
                var p = n.slice(0, u)
                'data' !== p && ((t.mainType = p), (t[h.toLowerCase()] = e), (s = !0))
              }
            }
            o.hasOwnProperty(n) && ((i[n] = e), (s = !0)), s || (r[n] = e)
          })
        }
        return { cptQuery: t, dataQuery: i, otherQuery: r }
      }),
      (e.prototype.filter = function (e, t) {
        var i = this.eventInfo
        if (!i) return !0
        var r = i.targetEl,
          n = i.packedEvent,
          a = i.model,
          o = i.view
        if (!a || !o) return !0
        var s = t.cptQuery,
          l = t.dataQuery
        return (
          h(s, a, 'mainType') &&
          h(s, a, 'subType') &&
          h(s, a, 'index', 'componentIndex') &&
          h(s, a, 'name') &&
          h(s, a, 'id') &&
          h(l, n, 'name') &&
          h(l, n, 'dataIndex') &&
          h(l, n, 'dataType') &&
          (!o.filterForExposedEvent || o.filterForExposedEvent(e, t.otherQuery, r, n))
        )
        function h(e, t, i, r) {
          return null == e[i] || t[r || i] === e[i]
        }
      }),
      (e.prototype.afterTrigger = function () {
        this.eventInfo = null
      }),
      e
    )
  })(),
  seriesSymbolTask = {
    createOnAllSeries: !0,
    performRawSeries: !0,
    reset: function (e, t) {
      var i = e.getData()
      if ((e.legendIcon && i.setVisual('legendIcon', e.legendIcon), e.hasSymbolVisual)) {
        var r = e.get('symbol'),
          n = e.get('symbolSize'),
          a = e.get('symbolKeepAspect'),
          o = e.get('symbolRotate'),
          s = e.get('symbolOffset'),
          l = isFunction$1(r),
          h = isFunction$1(n),
          u = isFunction$1(o),
          p = isFunction$1(s),
          c = l || h || u || p,
          d = !l && r ? r : e.defaultSymbol,
          f = h ? null : n,
          m = u ? null : o,
          g = p ? null : s
        if (
          (i.setVisual({
            legendIcon: e.legendIcon || d,
            symbol: d,
            symbolSize: f,
            symbolKeepAspect: a,
            symbolRotate: m,
            symbolOffset: g
          }),
          !t.isSeriesFiltered(e))
        )
          return {
            dataEach: c
              ? function (t, i) {
                  var a = e.getRawValue(i),
                    c = e.getDataParams(i)
                  l && t.setItemVisual(i, 'symbol', r(a, c)),
                    h && t.setItemVisual(i, 'symbolSize', n(a, c)),
                    u && t.setItemVisual(i, 'symbolRotate', o(a, c)),
                    p && t.setItemVisual(i, 'symbolOffset', s(a, c))
                }
              : null
          }
      }
    }
  },
  dataSymbolTask = {
    createOnAllSeries: !0,
    performRawSeries: !0,
    reset: function (e, t) {
      if (e.hasSymbolVisual && !t.isSeriesFiltered(e))
        return {
          dataEach: e.getData().hasItemOption
            ? function (e, t) {
                var i = e.getItemModel(t),
                  r = i.getShallow('symbol', !0),
                  n = i.getShallow('symbolSize', !0),
                  a = i.getShallow('symbolRotate', !0),
                  o = i.getShallow('symbolOffset', !0),
                  s = i.getShallow('symbolKeepAspect', !0)
                null != r && e.setItemVisual(t, 'symbol', r),
                  null != n && e.setItemVisual(t, 'symbolSize', n),
                  null != a && e.setItemVisual(t, 'symbolRotate', a),
                  null != o && e.setItemVisual(t, 'symbolOffset', o),
                  null != s && e.setItemVisual(t, 'symbolKeepAspect', s)
              }
            : null
        }
    }
  }
function getItemVisualFromData(e, t, i) {
  switch (i) {
    case 'color':
      return e.getItemVisual(t, 'style')[e.getVisual('drawType')]
    case 'opacity':
      return e.getItemVisual(t, 'style').opacity
    case 'symbol':
    case 'symbolSize':
    case 'liftZ':
      return e.getItemVisual(t, i)
  }
}
function getVisualFromData(e, t) {
  switch (t) {
    case 'color':
      return e.getVisual('style')[e.getVisual('drawType')]
    case 'opacity':
      return e.getVisual('style').opacity
    case 'symbol':
    case 'symbolSize':
    case 'liftZ':
      return e.getVisual(t)
  }
}
function setItemVisualFromData(e, t, i, r) {
  switch (i) {
    case 'color':
      ;(e.ensureUniqueItemVisual(t, 'style')[e.getVisual('drawType')] = r),
        e.setItemVisual(t, 'colorFromPalette', !1)
      break
    case 'opacity':
      e.ensureUniqueItemVisual(t, 'style').opacity = r
      break
    case 'symbol':
    case 'symbolSize':
    case 'liftZ':
      e.setItemVisual(t, i, r)
  }
}
var PI2$4 = 2 * Math.PI,
  CMD$1 = PathProxy.CMD,
  DEFAULT_SEARCH_SPACE = ['top', 'right', 'bottom', 'left']
function getCandidateAnchor(e, t, i, r, n) {
  var a = i.width,
    o = i.height
  switch (e) {
    case 'top':
      r.set(i.x + a / 2, i.y - t), n.set(0, -1)
      break
    case 'bottom':
      r.set(i.x + a / 2, i.y + o + t), n.set(0, 1)
      break
    case 'left':
      r.set(i.x - t, i.y + o / 2), n.set(-1, 0)
      break
    case 'right':
      r.set(i.x + a + t, i.y + o / 2), n.set(1, 0)
  }
}
function projectPointToArc(e, t, i, r, n, a, o, s, l) {
  ;(o -= e), (s -= t)
  var h = Math.sqrt(o * o + s * s),
    u = (o /= h) * i + e,
    p = (s /= h) * i + t
  if (Math.abs(r - n) % PI2$4 < 1e-4) return (l[0] = u), (l[1] = p), h - i
  if (a) {
    var c = r
    ;(r = normalizeRadian$1(n)), (n = normalizeRadian$1(c))
  } else (r = normalizeRadian$1(r)), (n = normalizeRadian$1(n))
  r > n && (n += PI2$4)
  var d = Math.atan2(s, o)
  if ((d < 0 && (d += PI2$4), (d >= r && d <= n) || (d + PI2$4 >= r && d + PI2$4 <= n)))
    return (l[0] = u), (l[1] = p), h - i
  var f = i * Math.cos(r) + e,
    m = i * Math.sin(r) + t,
    g = i * Math.cos(n) + e,
    y = i * Math.sin(n) + t,
    v = (f - o) * (f - o) + (m - s) * (m - s),
    _ = (g - o) * (g - o) + (y - s) * (y - s)
  return v < _ ? ((l[0] = f), (l[1] = m), Math.sqrt(v)) : ((l[0] = g), (l[1] = y), Math.sqrt(_))
}
function projectPointToLine(e, t, i, r, n, a, o, s) {
  var l = n - e,
    h = a - t,
    u = i - e,
    p = r - t,
    c = Math.sqrt(u * u + p * p),
    d = (l * (u /= c) + h * (p /= c)) / c
  s && (d = Math.min(Math.max(d, 0), 1)), (d *= c)
  var f = (o[0] = e + d * u),
    m = (o[1] = t + d * p)
  return Math.sqrt((f - n) * (f - n) + (m - a) * (m - a))
}
function projectPointToRect(e, t, i, r, n, a, o) {
  i < 0 && ((e += i), (i = -i)), r < 0 && ((t += r), (r = -r))
  var s = e + i,
    l = t + r,
    h = (o[0] = Math.min(Math.max(n, e), s)),
    u = (o[1] = Math.min(Math.max(a, t), l))
  return Math.sqrt((h - n) * (h - n) + (u - a) * (u - a))
}
var tmpPt = []
function nearestPointOnRect(e, t, i) {
  var r = projectPointToRect(t.x, t.y, t.width, t.height, e.x, e.y, tmpPt)
  return i.set(tmpPt[0], tmpPt[1]), r
}
function nearestPointOnPath(e, t, i) {
  for (
    var r, n, a = 0, o = 0, s = 0, l = 0, h = 1 / 0, u = t.data, p = e.x, c = e.y, d = 0;
    d < u.length;

  ) {
    var f = u[d++]
    1 === d && ((s = a = u[d]), (l = o = u[d + 1]))
    var m = h
    switch (f) {
      case CMD$1.M:
        ;(a = s = u[d++]), (o = l = u[d++])
        break
      case CMD$1.L:
        ;(m = projectPointToLine(a, o, u[d], u[d + 1], p, c, tmpPt, !0)), (a = u[d++]), (o = u[d++])
        break
      case CMD$1.C:
        ;(m = cubicProjectPoint(a, o, u[d++], u[d++], u[d++], u[d++], u[d], u[d + 1], p, c, tmpPt)),
          (a = u[d++]),
          (o = u[d++])
        break
      case CMD$1.Q:
        ;(m = quadraticProjectPoint(a, o, u[d++], u[d++], u[d], u[d + 1], p, c, tmpPt)),
          (a = u[d++]),
          (o = u[d++])
        break
      case CMD$1.A:
        var g = u[d++],
          y = u[d++],
          v = u[d++],
          _ = u[d++],
          x = u[d++],
          S = u[d++]
        d += 1
        var b = !!(1 - u[d++])
        ;(r = Math.cos(x) * v + g),
          (n = Math.sin(x) * _ + y),
          d <= 1 && ((s = r), (l = n)),
          (m = projectPointToArc(g, y, _, x, x + S, b, ((p - g) * _) / v + g, c, tmpPt)),
          (a = Math.cos(x + S) * v + g),
          (o = Math.sin(x + S) * _ + y)
        break
      case CMD$1.R:
        m = projectPointToRect((s = a = u[d++]), (l = o = u[d++]), u[d++], u[d++], p, c, tmpPt)
        break
      case CMD$1.Z:
        ;(m = projectPointToLine(a, o, s, l, p, c, tmpPt, !0)), (a = s), (o = l)
    }
    m < h && ((h = m), i.set(tmpPt[0], tmpPt[1]))
  }
  return h
}
var pt0 = new Point(),
  pt1 = new Point(),
  pt2 = new Point(),
  dir = new Point(),
  dir2 = new Point()
function updateLabelLinePoints(e, t) {
  if (e) {
    var i = e.getTextGuideLine(),
      r = e.getTextContent()
    if (r && i) {
      var n = e.textGuideLineConfig || {},
        a = [
          [0, 0],
          [0, 0],
          [0, 0]
        ],
        o = n.candidates || DEFAULT_SEARCH_SPACE,
        s = r.getBoundingRect().clone()
      s.applyTransform(r.getComputedTransform())
      var l = 1 / 0,
        h = n.anchor,
        u = e.getComputedTransform(),
        p = u && invert([], u),
        c = t.get('length2') || 0
      h && pt2.copy(h)
      for (var d = 0; d < o.length; d++) {
        getCandidateAnchor(o[d], 0, s, pt0, dir),
          Point.scaleAndAdd(pt1, pt0, dir, c),
          pt1.transform(p)
        var f = e.getBoundingRect(),
          m = h
            ? h.distance(pt1)
            : e instanceof Path
            ? nearestPointOnPath(pt1, e.path, pt2)
            : nearestPointOnRect(pt1, f, pt2)
        m < l &&
          ((l = m),
          pt1.transform(u),
          pt2.transform(u),
          pt2.toArray(a[0]),
          pt1.toArray(a[1]),
          pt0.toArray(a[2]))
      }
      limitTurnAngle(a, t.get('minTurnAngle')), i.setShape({ points: a })
    }
  }
}
var tmpArr$1 = [],
  tmpProjPoint = new Point()
function limitTurnAngle(e, t) {
  if (t <= 180 && t > 0) {
    ;(t = (t / 180) * Math.PI),
      pt0.fromArray(e[0]),
      pt1.fromArray(e[1]),
      pt2.fromArray(e[2]),
      Point.sub(dir, pt0, pt1),
      Point.sub(dir2, pt2, pt1)
    var i = dir.len(),
      r = dir2.len()
    if (!(i < 0.001 || r < 0.001)) {
      dir.scale(1 / i), dir2.scale(1 / r)
      var n = dir.dot(dir2)
      if (Math.cos(t) < n) {
        var a = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr$1, !1)
        tmpProjPoint.fromArray(tmpArr$1), tmpProjPoint.scaleAndAdd(dir2, a / Math.tan(Math.PI - t))
        var o =
          pt2.x !== pt1.x
            ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x)
            : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y)
        if (isNaN(o)) return
        o < 0 ? Point.copy(tmpProjPoint, pt1) : o > 1 && Point.copy(tmpProjPoint, pt2),
          tmpProjPoint.toArray(e[1])
      }
    }
  }
}
function limitSurfaceAngle(e, t, i) {
  if (i <= 180 && i > 0) {
    ;(i = (i / 180) * Math.PI),
      pt0.fromArray(e[0]),
      pt1.fromArray(e[1]),
      pt2.fromArray(e[2]),
      Point.sub(dir, pt1, pt0),
      Point.sub(dir2, pt2, pt1)
    var r = dir.len(),
      n = dir2.len()
    if (!(r < 0.001 || n < 0.001))
      if ((dir.scale(1 / r), dir2.scale(1 / n), dir.dot(t) < Math.cos(i))) {
        var a = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr$1, !1)
        tmpProjPoint.fromArray(tmpArr$1)
        var o = Math.PI / 2,
          s = o + Math.acos(dir2.dot(t)) - i
        if (s >= o) Point.copy(tmpProjPoint, pt2)
        else {
          tmpProjPoint.scaleAndAdd(dir2, a / Math.tan(Math.PI / 2 - s))
          var l =
            pt2.x !== pt1.x
              ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x)
              : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y)
          if (isNaN(l)) return
          l < 0 ? Point.copy(tmpProjPoint, pt1) : l > 1 && Point.copy(tmpProjPoint, pt2)
        }
        tmpProjPoint.toArray(e[1])
      }
  }
}
function setLabelLineState(e, t, i, r) {
  var n = 'normal' === i,
    a = n ? e : e.ensureState(i)
  a.ignore = t
  var o = r.get('smooth')
  o && !0 === o && (o = 0.3), (a.shape = a.shape || {}), o > 0 && (a.shape.smooth = o)
  var s = r.getModel('lineStyle').getLineStyle()
  n ? e.useStyle(s) : (a.style = s)
}
function buildLabelLinePath(e, t) {
  var i = t.smooth,
    r = t.points
  if (r)
    if ((e.moveTo(r[0][0], r[0][1]), i > 0 && r.length >= 3)) {
      var n = dist$1(r[0], r[1]),
        a = dist$1(r[1], r[2])
      if (!n || !a) return e.lineTo(r[1][0], r[1][1]), void e.lineTo(r[2][0], r[2][1])
      var o = Math.min(n, a) * i,
        s = lerp([], r[1], r[0], o / n),
        l = lerp([], r[1], r[2], o / a),
        h = lerp([], s, l, 0.5)
      e.bezierCurveTo(s[0], s[1], s[0], s[1], h[0], h[1]),
        e.bezierCurveTo(l[0], l[1], l[0], l[1], r[2][0], r[2][1])
    } else for (var u = 1; u < r.length; u++) e.lineTo(r[u][0], r[u][1])
}
function setLabelLineStyle(e, t, i) {
  var r = e.getTextGuideLine(),
    n = e.getTextContent()
  if (n) {
    for (var a = t.normal, o = a.get('show'), s = n.ignore, l = 0; l < DISPLAY_STATES.length; l++) {
      var h = DISPLAY_STATES[l],
        u = t[h],
        p = 'normal' === h
      if (u) {
        var c = u.get('show')
        if ((p ? s : retrieve2(n.states[h] && n.states[h].ignore, s)) || !retrieve2(c, o)) {
          var d = p ? r : r && r.states.normal
          d && (d.ignore = !0)
          continue
        }
        r ||
          ((r = new Polyline$1()),
          e.setTextGuideLine(r),
          p || (!s && o) || setLabelLineState(r, !0, 'normal', t.normal),
          e.stateProxy && (r.stateProxy = e.stateProxy)),
          setLabelLineState(r, !1, h, u)
      }
    }
    if (r) {
      defaults$1(r.style, i), (r.style.fill = null)
      var f = a.get('showAbove')
      ;((e.textGuideLineConfig = e.textGuideLineConfig || {}).showAbove = f || !1),
        (r.buildPath = buildLabelLinePath)
    }
  } else r && e.removeTextGuideLine()
}
function getLabelLineStatesModels(e, t) {
  t = t || 'labelLine'
  for (var i = { normal: e.getModel(t) }, r = 0; r < SPECIAL_STATES.length; r++) {
    var n = SPECIAL_STATES[r]
    i[n] = e.getModel([n, t])
  }
  return i
}
function prepareLayoutList(e) {
  for (var t = [], i = 0; i < e.length; i++) {
    var r = e[i]
    if (!r.defaultAttr.ignore) {
      var n = r.label,
        a = n.getComputedTransform(),
        o = n.getBoundingRect(),
        s = !a || (a[1] < 1e-5 && a[2] < 1e-5),
        l = n.style.margin || 0,
        h = o.clone()
      h.applyTransform(a), (h.x -= l / 2), (h.y -= l / 2), (h.width += l), (h.height += l)
      var u = s ? new OrientedBoundingRect(o, a) : null
      t.push({
        label: n,
        labelLine: r.labelLine,
        rect: h,
        localRect: o,
        obb: u,
        priority: r.priority,
        defaultAttr: r.defaultAttr,
        layoutOption: r.computedLayoutOption,
        axisAligned: s,
        transform: a
      })
    }
  }
  return t
}
function shiftLayout(e, t, i, r, n, a) {
  var o = e.length
  if (!(o < 2)) {
    e.sort(function (e, i) {
      return e.rect[t] - i.rect[t]
    })
    for (var s, l = 0, h = !1, u = 0, p = 0; p < o; p++) {
      var c = e[p],
        d = c.rect
      ;(s = d[t] - l) < 0 && ((d[t] -= s), (c.label[t] -= s), (h = !0)),
        (u += Math.max(-s, 0)),
        (l = d[t] + d[i])
    }
    u > 0 && a && x(-u / o, 0, o)
    var f,
      m,
      g = e[0],
      y = e[o - 1]
    return (
      v(),
      f < 0 && S(-f, 0.8),
      m < 0 && S(m, 0.8),
      v(),
      _(f, m, 1),
      _(m, f, -1),
      v(),
      f < 0 && b(-f),
      m < 0 && b(m),
      h
    )
  }
  function v() {
    ;(f = g.rect[t] - r), (m = n - y.rect[t] - y.rect[i])
  }
  function _(e, t, i) {
    if (e < 0) {
      var r = Math.min(t, -e)
      if (r > 0) {
        x(r * i, 0, o)
        var n = r + e
        n < 0 && S(-n * i, 1)
      } else S(-e * i, 1)
    }
  }
  function x(i, r, n) {
    0 !== i && (h = !0)
    for (var a = r; a < n; a++) {
      var o = e[a]
      ;(o.rect[t] += i), (o.label[t] += i)
    }
  }
  function S(r, n) {
    for (var a = [], s = 0, l = 1; l < o; l++) {
      var h = e[l - 1].rect,
        u = Math.max(e[l].rect[t] - h[t] - h[i], 0)
      a.push(u), (s += u)
    }
    if (s) {
      var p = Math.min(Math.abs(r) / s, n)
      if (r > 0)
        for (l = 0; l < o - 1; l++) {
          x(a[l] * p, 0, l + 1)
        }
      else
        for (l = o - 1; l > 0; l--) {
          x(-(a[l - 1] * p), l, o)
        }
    }
  }
  function b(e) {
    var t = e < 0 ? -1 : 1
    e = Math.abs(e)
    for (var i = Math.ceil(e / (o - 1)), r = 0; r < o - 1; r++)
      if ((t > 0 ? x(i, 0, r + 1) : x(-i, o - r - 1, o), (e -= i) <= 0)) return
  }
}
function shiftLayoutOnX(e, t, i, r) {
  return shiftLayout(e, 'x', 'width', t, i, r)
}
function shiftLayoutOnY(e, t, i, r) {
  return shiftLayout(e, 'y', 'height', t, i, r)
}
function hideOverlap(e) {
  var t = []
  e.sort(function (e, t) {
    return t.priority - e.priority
  })
  var i = new BoundingRect(0, 0, 0, 0)
  function r(e) {
    if (!e.ignore) {
      var t = e.ensureState('emphasis')
      null == t.ignore && (t.ignore = !1)
    }
    e.ignore = !0
  }
  for (var n = 0; n < e.length; n++) {
    var a = e[n],
      o = a.axisAligned,
      s = a.localRect,
      l = a.transform,
      h = a.label,
      u = a.labelLine
    i.copy(a.rect), (i.width -= 0.1), (i.height -= 0.1), (i.x += 0.05), (i.y += 0.05)
    for (var p = a.obb, c = !1, d = 0; d < t.length; d++) {
      var f = t[d]
      if (i.intersect(f.rect)) {
        if (o && f.axisAligned) {
          c = !0
          break
        }
        if (
          (f.obb || (f.obb = new OrientedBoundingRect(f.localRect, f.transform)),
          p || (p = new OrientedBoundingRect(s, l)),
          p.intersect(f.obb))
        ) {
          c = !0
          break
        }
      }
    }
    c
      ? (r(h), u && r(u))
      : (h.attr('ignore', a.defaultAttr.ignore),
        u && u.attr('ignore', a.defaultAttr.labelGuideIgnore),
        t.push(a))
  }
}
function cloneArr(e) {
  if (e) {
    for (var t = [], i = 0; i < e.length; i++) t.push(e[i].slice())
    return t
  }
}
function prepareLayoutCallbackParams(e, t) {
  var i = e.label,
    r = t && t.getTextGuideLine()
  return {
    dataIndex: e.dataIndex,
    dataType: e.dataType,
    seriesIndex: e.seriesModel.seriesIndex,
    text: e.label.style.text,
    rect: e.hostRect,
    labelRect: e.rect,
    align: i.style.align,
    verticalAlign: i.style.verticalAlign,
    labelLinePoints: cloneArr(r && r.shape.points)
  }
}
var LABEL_OPTION_TO_STYLE_KEYS = ['align', 'verticalAlign', 'width', 'height', 'fontSize'],
  dummyTransformable = new Transformable(),
  labelLayoutInnerStore = makeInner(),
  labelLineAnimationStore = makeInner()
function extendWithKeys(e, t, i) {
  for (var r = 0; r < i.length; r++) {
    var n = i[r]
    null != t[n] && (e[n] = t[n])
  }
}
var LABEL_LAYOUT_PROPS = ['x', 'y', 'rotation'],
  LabelManager = (function () {
    function e() {
      ;(this._labelList = []), (this._chartViewList = [])
    }
    return (
      (e.prototype.clearLabels = function () {
        ;(this._labelList = []), (this._chartViewList = [])
      }),
      (e.prototype._addLabel = function (e, t, i, r, n) {
        var a = r.style,
          o = r.__hostTarget.textConfig || {},
          s = r.getComputedTransform(),
          l = r.getBoundingRect().plain()
        BoundingRect.applyTransform(l, l, s),
          s
            ? dummyTransformable.setLocalTransform(s)
            : ((dummyTransformable.x =
                dummyTransformable.y =
                dummyTransformable.rotation =
                dummyTransformable.originX =
                dummyTransformable.originY =
                  0),
              (dummyTransformable.scaleX = dummyTransformable.scaleY = 1))
        var h,
          u = r.__hostTarget
        if (u) {
          h = u.getBoundingRect().plain()
          var p = u.getComputedTransform()
          BoundingRect.applyTransform(h, h, p)
        }
        var c = h && u.getTextGuideLine()
        this._labelList.push({
          label: r,
          labelLine: c,
          seriesModel: i,
          dataIndex: e,
          dataType: t,
          layoutOption: n,
          computedLayoutOption: null,
          rect: l,
          hostRect: h,
          priority: h ? h.width * h.height : 0,
          defaultAttr: {
            ignore: r.ignore,
            labelGuideIgnore: c && c.ignore,
            x: dummyTransformable.x,
            y: dummyTransformable.y,
            scaleX: dummyTransformable.scaleX,
            scaleY: dummyTransformable.scaleY,
            rotation: dummyTransformable.rotation,
            style: {
              x: a.x,
              y: a.y,
              align: a.align,
              verticalAlign: a.verticalAlign,
              width: a.width,
              height: a.height,
              fontSize: a.fontSize
            },
            cursor: r.cursor,
            attachedPos: o.position,
            attachedRot: o.rotation
          }
        })
      }),
      (e.prototype.addLabelsOfSeries = function (e) {
        var t = this
        this._chartViewList.push(e)
        var i = e.__model,
          r = i.get('labelLayout')
        ;(isFunction$1(r) || keys(r).length) &&
          e.group.traverse(function (e) {
            if (e.ignore) return !0
            var n = e.getTextContent(),
              a = getECData(e)
            n && !n.disableLabelLayout && t._addLabel(a.dataIndex, a.dataType, i, n, r)
          })
      }),
      (e.prototype.updateLayoutConfig = function (e) {
        var t = e.getWidth(),
          i = e.getHeight()
        function r(e, t) {
          return function () {
            updateLabelLinePoints(e, t)
          }
        }
        for (var n = 0; n < this._labelList.length; n++) {
          var a = this._labelList[n],
            o = a.label,
            s = o.__hostTarget,
            l = a.defaultAttr,
            h = void 0
          ;(h =
            (h =
              'function' == typeof a.layoutOption
                ? a.layoutOption(prepareLayoutCallbackParams(a, s))
                : a.layoutOption) || {}),
            (a.computedLayoutOption = h)
          var u = Math.PI / 180
          s &&
            s.setTextConfig({
              local: !1,
              position: null != h.x || null != h.y ? null : l.attachedPos,
              rotation: null != h.rotate ? h.rotate * u : l.attachedRot,
              offset: [h.dx || 0, h.dy || 0]
            })
          var p = !1
          if (
            (null != h.x
              ? ((o.x = parsePercent$1(h.x, t)), o.setStyle('x', 0), (p = !0))
              : ((o.x = l.x), o.setStyle('x', l.style.x)),
            null != h.y
              ? ((o.y = parsePercent$1(h.y, i)), o.setStyle('y', 0), (p = !0))
              : ((o.y = l.y), o.setStyle('y', l.style.y)),
            h.labelLinePoints)
          ) {
            var c = s.getTextGuideLine()
            c && (c.setShape({ points: h.labelLinePoints }), (p = !1))
          }
          ;(labelLayoutInnerStore(o).needsUpdateLabelLine = p),
            (o.rotation = null != h.rotate ? h.rotate * u : l.rotation),
            (o.scaleX = l.scaleX),
            (o.scaleY = l.scaleY)
          for (var d = 0; d < LABEL_OPTION_TO_STYLE_KEYS.length; d++) {
            var f = LABEL_OPTION_TO_STYLE_KEYS[d]
            o.setStyle(f, null != h[f] ? h[f] : l.style[f])
          }
          if (h.draggable) {
            if (((o.draggable = !0), (o.cursor = 'move'), s)) {
              var m = a.seriesModel
              if (null != a.dataIndex)
                m = a.seriesModel.getData(a.dataType).getItemModel(a.dataIndex)
              o.on('drag', r(s, m.getModel('labelLine')))
            }
          } else o.off('drag'), (o.cursor = l.cursor)
        }
      }),
      (e.prototype.layout = function (e) {
        var t = e.getWidth(),
          i = e.getHeight(),
          r = prepareLayoutList(this._labelList),
          n = filter$1(r, function (e) {
            return 'shiftX' === e.layoutOption.moveOverlap
          }),
          a = filter$1(r, function (e) {
            return 'shiftY' === e.layoutOption.moveOverlap
          })
        shiftLayoutOnX(n, 0, t),
          shiftLayoutOnY(a, 0, i),
          hideOverlap(
            filter$1(r, function (e) {
              return e.layoutOption.hideOverlap
            })
          )
      }),
      (e.prototype.processLabelsOverall = function () {
        var e = this
        each$i(this._chartViewList, function (t) {
          var i = t.__model,
            r = t.ignoreLabelLineUpdate,
            n = i.isAnimationEnabled()
          t.group.traverse(function (t) {
            if (t.ignore) return !0
            var a = !r,
              o = t.getTextContent()
            !a && o && (a = labelLayoutInnerStore(o).needsUpdateLabelLine),
              a && e._updateLabelLine(t, i),
              n && e._animateLabels(t, i)
          })
        })
      }),
      (e.prototype._updateLabelLine = function (e, t) {
        var i = e.getTextContent(),
          r = getECData(e),
          n = r.dataIndex
        if (i && null != n) {
          var a = t.getData(r.dataType),
            o = a.getItemModel(n),
            s = {},
            l = a.getItemVisual(n, 'style'),
            h = a.getVisual('drawType')
          s.stroke = l[h]
          var u = o.getModel('labelLine')
          setLabelLineStyle(e, getLabelLineStatesModels(o), s), updateLabelLinePoints(e, u)
        }
      }),
      (e.prototype._animateLabels = function (e, t) {
        var i = e.getTextContent(),
          r = e.getTextGuideLine()
        if (i && !i.ignore && !i.invisible && !e.disableLabelAnimation && !isElementRemoved(e)) {
          var n = (d = labelLayoutInnerStore(i)).oldLayout,
            a = getECData(e),
            o = a.dataIndex,
            s = { x: i.x, y: i.y, rotation: i.rotation },
            l = t.getData(a.dataType)
          if (n) {
            i.attr(n)
            var h = e.prevStates
            h &&
              (indexOf$1(h, 'select') >= 0 && i.attr(d.oldLayoutSelect),
              indexOf$1(h, 'emphasis') >= 0 && i.attr(d.oldLayoutEmphasis)),
              updateProps$1(i, s, t, o)
          } else if ((i.attr(s), !labelInner(i).valueAnimation)) {
            var u = retrieve2(i.style.opacity, 1)
            ;(i.style.opacity = 0), initProps(i, { style: { opacity: u } }, t, o)
          }
          if (((d.oldLayout = s), i.states.select)) {
            var p = (d.oldLayoutSelect = {})
            extendWithKeys(p, s, LABEL_LAYOUT_PROPS),
              extendWithKeys(p, i.states.select, LABEL_LAYOUT_PROPS)
          }
          if (i.states.emphasis) {
            var c = (d.oldLayoutEmphasis = {})
            extendWithKeys(c, s, LABEL_LAYOUT_PROPS),
              extendWithKeys(c, i.states.emphasis, LABEL_LAYOUT_PROPS)
          }
          animateLabelValue(i, o, l, t, t)
        }
        if (r && !r.ignore && !r.invisible) {
          n = (d = labelLineAnimationStore(r)).oldLayout
          var d,
            f = { points: r.shape.points }
          n
            ? (r.attr({ shape: n }), updateProps$1(r, { shape: f }, t))
            : (r.setShape(f),
              (r.style.strokePercent = 0),
              initProps(r, { style: { strokePercent: 1 } }, t)),
            (d.oldLayout = f)
        }
      }),
      e
    )
  })()
function createLegacyDataSelectAction(e, t) {
  function i(t, i) {
    var r = []
    return (
      t.eachComponent({ mainType: 'series', subType: e, query: i }, function (e) {
        r.push(e.seriesIndex)
      }),
      r
    )
  }
  each$i(
    [
      [e + 'ToggleSelect', 'toggleSelect'],
      [e + 'Select', 'select'],
      [e + 'UnSelect', 'unselect']
    ],
    function (e) {
      t(e[0], function (t, r, n) {
        ;(t = extend$3({}, t)), n.dispatchAction(extend$3(t, { type: e[1], seriesIndex: i(r, t) }))
      })
    }
  )
}
function handleSeriesLegacySelectEvents(e, t, i, r, n) {
  var a = e + t
  i.isSilent(a) ||
    r.eachComponent({ mainType: 'series', subType: 'pie' }, function (e) {
      for (var t = e.seriesIndex, r = n.selected, o = 0; o < r.length; o++)
        if (r[o].seriesIndex === t) {
          var s = e.getData(),
            l = queryDataIndex(s, n.fromActionPayload)
          i.trigger(a, {
            type: a,
            seriesId: e.id,
            name: isArray$1(l) ? s.getName(l[0]) : s.getName(l),
            selected: extend$3({}, e.option.selectedMap)
          })
        }
    })
}
function handleLegacySelectEvents(e, t, i) {
  e.on('selectchanged', function (e) {
    var r = i.getModel()
    e.isFromClick
      ? (handleSeriesLegacySelectEvents('map', 'selectchanged', t, r, e),
        handleSeriesLegacySelectEvents('pie', 'selectchanged', t, r, e))
      : 'select' === e.fromAction
      ? (handleSeriesLegacySelectEvents('map', 'selected', t, r, e),
        handleSeriesLegacySelectEvents('pie', 'selected', t, r, e))
      : 'unselect' === e.fromAction &&
        (handleSeriesLegacySelectEvents('map', 'unselected', t, r, e),
        handleSeriesLegacySelectEvents('pie', 'unselected', t, r, e))
  })
}
function findEventDispatcher(e, t, i) {
  for (var r; e && (!t(e) || ((r = e), !i)); ) e = e.__hostTarget || e.parent
  return r
}
var wmUniqueIndex = Math.round(9 * Math.random()),
  WeakMap = (function () {
    function e() {
      this._id = '__ec_inner_' + wmUniqueIndex++
    }
    return (
      (e.prototype.get = function (e) {
        return this._guard(e)[this._id]
      }),
      (e.prototype.set = function (e, t) {
        var i = this._guard(e)
        return (
          'function' == typeof Object.defineProperty
            ? Object.defineProperty(i, this._id, { value: t, enumerable: !1, configurable: !0 })
            : (i[this._id] = t),
          this
        )
      }),
      (e.prototype.delete = function (e) {
        return !!this.has(e) && (delete this._guard(e)[this._id], !0)
      }),
      (e.prototype.has = function (e) {
        return !!this._guard(e)[this._id]
      }),
      (e.prototype._guard = function (e) {
        if (e !== Object(e)) throw TypeError('Value of WeakMap is not a non-null object.')
        return e
      }),
      e
    )
  })(),
  Triangle = Path.extend({
    type: 'triangle',
    shape: { cx: 0, cy: 0, width: 0, height: 0 },
    buildPath: function (e, t) {
      var i = t.cx,
        r = t.cy,
        n = t.width / 2,
        a = t.height / 2
      e.moveTo(i, r - a), e.lineTo(i + n, r + a), e.lineTo(i - n, r + a), e.closePath()
    }
  }),
  Diamond = Path.extend({
    type: 'diamond',
    shape: { cx: 0, cy: 0, width: 0, height: 0 },
    buildPath: function (e, t) {
      var i = t.cx,
        r = t.cy,
        n = t.width / 2,
        a = t.height / 2
      e.moveTo(i, r - a), e.lineTo(i + n, r), e.lineTo(i, r + a), e.lineTo(i - n, r), e.closePath()
    }
  }),
  Pin = Path.extend({
    type: 'pin',
    shape: { x: 0, y: 0, width: 0, height: 0 },
    buildPath: function (e, t) {
      var i = t.x,
        r = t.y,
        n = (t.width / 5) * 3,
        a = Math.max(n, t.height),
        o = n / 2,
        s = (o * o) / (a - o),
        l = r - a + o + s,
        h = Math.asin(s / o),
        u = Math.cos(h) * o,
        p = Math.sin(h),
        c = Math.cos(h),
        d = 0.6 * o,
        f = 0.7 * o
      e.moveTo(i - u, l + s),
        e.arc(i, l, o, Math.PI - h, 2 * Math.PI + h),
        e.bezierCurveTo(i + u - p * d, l + s + c * d, i, r - f, i, r),
        e.bezierCurveTo(i, r - f, i - u + p * d, l + s + c * d, i - u, l + s),
        e.closePath()
    }
  }),
  Arrow = Path.extend({
    type: 'arrow',
    shape: { x: 0, y: 0, width: 0, height: 0 },
    buildPath: function (e, t) {
      var i = t.height,
        r = t.width,
        n = t.x,
        a = t.y,
        o = (r / 3) * 2
      e.moveTo(n, a),
        e.lineTo(n + o, a + i),
        e.lineTo(n, a + (i / 4) * 3),
        e.lineTo(n - o, a + i),
        e.lineTo(n, a),
        e.closePath()
    }
  }),
  symbolCtors = {
    line: Line$1,
    rect: Rect$2,
    roundRect: Rect$2,
    square: Rect$2,
    circle: Circle,
    diamond: Diamond,
    pin: Pin,
    arrow: Arrow,
    triangle: Triangle
  },
  symbolShapeMakers = {
    line: function (e, t, i, r, n) {
      ;(n.x1 = e), (n.y1 = t + r / 2), (n.x2 = e + i), (n.y2 = t + r / 2)
    },
    rect: function (e, t, i, r, n) {
      ;(n.x = e), (n.y = t), (n.width = i), (n.height = r)
    },
    roundRect: function (e, t, i, r, n) {
      ;(n.x = e), (n.y = t), (n.width = i), (n.height = r), (n.r = Math.min(i, r) / 4)
    },
    square: function (e, t, i, r, n) {
      var a = Math.min(i, r)
      ;(n.x = e), (n.y = t), (n.width = a), (n.height = a)
    },
    circle: function (e, t, i, r, n) {
      ;(n.cx = e + i / 2), (n.cy = t + r / 2), (n.r = Math.min(i, r) / 2)
    },
    diamond: function (e, t, i, r, n) {
      ;(n.cx = e + i / 2), (n.cy = t + r / 2), (n.width = i), (n.height = r)
    },
    pin: function (e, t, i, r, n) {
      ;(n.x = e + i / 2), (n.y = t + r / 2), (n.width = i), (n.height = r)
    },
    arrow: function (e, t, i, r, n) {
      ;(n.x = e + i / 2), (n.y = t + r / 2), (n.width = i), (n.height = r)
    },
    triangle: function (e, t, i, r, n) {
      ;(n.cx = e + i / 2), (n.cy = t + r / 2), (n.width = i), (n.height = r)
    }
  },
  symbolBuildProxies = {}
each$i(symbolCtors, function (e, t) {
  symbolBuildProxies[t] = new e()
})
var SymbolClz = Path.extend({
  type: 'symbol',
  shape: { symbolType: '', x: 0, y: 0, width: 0, height: 0 },
  calculateTextPosition: function (e, t, i) {
    var r = calculateTextPosition(e, t, i),
      n = this.shape
    return n && 'pin' === n.symbolType && 'inside' === t.position && (r.y = i.y + 0.4 * i.height), r
  },
  buildPath: function (e, t, i) {
    var r = t.symbolType
    if ('none' !== r) {
      var n = symbolBuildProxies[r]
      n || (n = symbolBuildProxies[(r = 'rect')]),
        symbolShapeMakers[r](t.x, t.y, t.width, t.height, n.shape),
        n.buildPath(e, n.shape, i)
    }
  }
})
function symbolPathSetColor(e, t) {
  if ('image' !== this.type) {
    var i = this.style
    this.__isEmptyBrush
      ? ((i.stroke = e), (i.fill = t || '#fff'), (i.lineWidth = 2))
      : 'line' === this.shape.symbolType
      ? (i.stroke = e)
      : (i.fill = e),
      this.markRedraw()
  }
}
function createSymbol$1(e, t, i, r, n, a, o) {
  var s,
    l = 0 === e.indexOf('empty')
  return (
    l && (e = e.substr(5, 1).toLowerCase() + e.substr(6)),
    ((s =
      0 === e.indexOf('image://')
        ? makeImage(e.slice(8), new BoundingRect(t, i, r, n), o ? 'center' : 'cover')
        : 0 === e.indexOf('path://')
        ? makePath(e.slice(7), {}, new BoundingRect(t, i, r, n), o ? 'center' : 'cover')
        : new SymbolClz({
            shape: { symbolType: e, x: t, y: i, width: r, height: n }
          })).__isEmptyBrush = l),
    (s.setColor = symbolPathSetColor),
    a && s.setColor(a),
    s
  )
}
function createLinearGradient(e, t, i) {
  var r = null == t.x ? 0 : t.x,
    n = null == t.x2 ? 1 : t.x2,
    a = null == t.y ? 0 : t.y,
    o = null == t.y2 ? 0 : t.y2
  return (
    t.global ||
      ((r = r * i.width + i.x),
      (n = n * i.width + i.x),
      (a = a * i.height + i.y),
      (o = o * i.height + i.y)),
    (r = isNaN(r) ? 0 : r),
    (n = isNaN(n) ? 1 : n),
    (a = isNaN(a) ? 0 : a),
    (o = isNaN(o) ? 0 : o),
    e.createLinearGradient(r, a, n, o)
  )
}
function createRadialGradient(e, t, i) {
  var r = i.width,
    n = i.height,
    a = Math.min(r, n),
    o = null == t.x ? 0.5 : t.x,
    s = null == t.y ? 0.5 : t.y,
    l = null == t.r ? 0.5 : t.r
  return (
    t.global || ((o = o * r + i.x), (s = s * n + i.y), (l *= a)),
    e.createRadialGradient(o, s, 0, o, s, l)
  )
}
function getCanvasGradient(e, t, i) {
  for (
    var r = 'radial' === t.type ? createRadialGradient(e, t, i) : createLinearGradient(e, t, i),
      n = t.colorStops,
      a = 0;
    a < n.length;
    a++
  )
    r.addColorStop(n[a].offset, n[a].color)
  return r
}
function isClipPathChanged(e, t) {
  if (e === t || (!e && !t)) return !1
  if (!e || !t || e.length !== t.length) return !0
  for (var i = 0; i < e.length; i++) if (e[i] !== t[i]) return !0
  return !1
}
function normalizeLineDash(e, t) {
  return e && 'solid' !== e && t > 0
    ? ((t = t || 1),
      'dashed' === e
        ? [4 * t, 2 * t]
        : 'dotted' === e
        ? [t]
        : isNumber(e)
        ? [e]
        : isArray$1(e)
        ? e
        : null)
    : null
}
var pathProxyForDraw = new PathProxy(!0)
function styleHasStroke(e) {
  var t = e.stroke
  return !(null == t || 'none' === t || !(e.lineWidth > 0))
}
function styleHasFill(e) {
  var t = e.fill
  return null != t && 'none' !== t
}
function doFillPath(e, t) {
  if (null != t.fillOpacity && 1 !== t.fillOpacity) {
    var i = e.globalAlpha
    ;(e.globalAlpha = t.fillOpacity * t.opacity), e.fill(), (e.globalAlpha = i)
  } else e.fill()
}
function doStrokePath(e, t) {
  if (null != t.strokeOpacity && 1 !== t.strokeOpacity) {
    var i = e.globalAlpha
    ;(e.globalAlpha = t.strokeOpacity * t.opacity), e.stroke(), (e.globalAlpha = i)
  } else e.stroke()
}
function createCanvasPattern(e, t, i) {
  var r = createOrUpdateImage(t.image, t.__image, i)
  if (isImageReady(r)) {
    var n = e.createPattern(r, t.repeat || 'repeat')
    if ('function' == typeof DOMMatrix && n.setTransform) {
      var a = new DOMMatrix()
      a.rotateSelf(0, 0, ((t.rotation || 0) / Math.PI) * 180),
        a.scaleSelf(t.scaleX || 1, t.scaleY || 1),
        a.translateSelf(t.x || 0, t.y || 0),
        n.setTransform(a)
    }
    return n
  }
}
function brushPath(e, t, i, r) {
  var n = styleHasStroke(i),
    a = styleHasFill(i),
    o = i.strokePercent,
    s = o < 1,
    l = !t.path
  ;(t.silent && !s) || !l || t.createPathProxy()
  var h = t.path || pathProxyForDraw
  if (!r) {
    var u = i.fill,
      p = i.stroke,
      c = a && !!u.colorStops,
      d = n && !!p.colorStops,
      f = a && !!u.image,
      m = n && !!p.image,
      g = void 0,
      y = void 0,
      v = void 0,
      _ = void 0,
      x = void 0
    ;(c || d) && (x = t.getBoundingRect()),
      c &&
        ((g = t.__dirty ? getCanvasGradient(e, u, x) : t.__canvasFillGradient),
        (t.__canvasFillGradient = g)),
      d &&
        ((y = t.__dirty ? getCanvasGradient(e, p, x) : t.__canvasStrokeGradient),
        (t.__canvasStrokeGradient = y)),
      f &&
        ((v =
          t.__dirty || !t.__canvasFillPattern
            ? createCanvasPattern(e, u, t)
            : t.__canvasFillPattern),
        (t.__canvasFillPattern = v)),
      m &&
        ((_ =
          t.__dirty || !t.__canvasStrokePattern
            ? createCanvasPattern(e, p, t)
            : t.__canvasStrokePattern),
        (t.__canvasStrokePattern = v)),
      c ? (e.fillStyle = g) : f && (v ? (e.fillStyle = v) : (a = !1)),
      d ? (e.strokeStyle = y) : m && (_ ? (e.strokeStyle = _) : (n = !1))
  }
  var S = i.lineDash && i.lineWidth > 0 && normalizeLineDash(i.lineDash, i.lineWidth),
    b = i.lineDashOffset,
    T = !!e.setLineDash,
    A = t.getGlobalScale()
  if ((h.setScale(A[0], A[1], t.segmentIgnoreThreshold), S)) {
    var w = i.strokeNoScale && t.getLineScale ? t.getLineScale() : 1
    w &&
      1 !== w &&
      ((S = map$1(S, function (e) {
        return e / w
      })),
      (b /= w))
  }
  var M = !0
  ;(l || t.__dirty & SHAPE_CHANGED_BIT || (S && !T && n)) &&
    (h.setDPR(e.dpr),
    s ? h.setContext(null) : (h.setContext(e), (M = !1)),
    h.reset(),
    S && !T && (h.setLineDash(S), h.setLineDashOffset(b)),
    t.buildPath(h, t.shape, r),
    h.toStatic(),
    t.pathUpdated()),
    M && h.rebuildPath(e, s ? o : 1),
    S && T && (e.setLineDash(S), (e.lineDashOffset = b)),
    r ||
      (i.strokeFirst
        ? (n && doStrokePath(e, i), a && doFillPath(e, i))
        : (a && doFillPath(e, i), n && doStrokePath(e, i))),
    S && T && e.setLineDash([])
}
function brushImage(e, t, i) {
  var r = (t.__image = createOrUpdateImage(i.image, t.__image, t, t.onload))
  if (r && isImageReady(r)) {
    var n = i.x || 0,
      a = i.y || 0,
      o = t.getWidth(),
      s = t.getHeight(),
      l = r.width / r.height
    if (
      (null == o && null != s
        ? (o = s * l)
        : null == s && null != o
        ? (s = o / l)
        : null == o && null == s && ((o = r.width), (s = r.height)),
      i.sWidth && i.sHeight)
    ) {
      var h = i.sx || 0,
        u = i.sy || 0
      e.drawImage(r, h, u, i.sWidth, i.sHeight, n, a, o, s)
    } else if (i.sx && i.sy) {
      var p = o - (h = i.sx),
        c = s - (u = i.sy)
      e.drawImage(r, h, u, p, c, n, a, o, s)
    } else e.drawImage(r, n, a, o, s)
  }
}
function brushText(e, t, i) {
  var r = i.text
  if ((null != r && (r += ''), r)) {
    ;(e.font = i.font || DEFAULT_FONT),
      (e.textAlign = i.textAlign),
      (e.textBaseline = i.textBaseline)
    var n = void 0
    if (e.setLineDash) {
      var a = i.lineDash && i.lineWidth > 0 && normalizeLineDash(i.lineDash, i.lineWidth),
        o = i.lineDashOffset
      if (a) {
        var s = i.strokeNoScale && t.getLineScale ? t.getLineScale() : 1
        s &&
          1 !== s &&
          ((a = map$1(a, function (e) {
            return e / s
          })),
          (o /= s)),
          e.setLineDash(a),
          (e.lineDashOffset = o),
          (n = !0)
      }
    }
    i.strokeFirst
      ? (styleHasStroke(i) && e.strokeText(r, i.x, i.y), styleHasFill(i) && e.fillText(r, i.x, i.y))
      : (styleHasFill(i) && e.fillText(r, i.x, i.y),
        styleHasStroke(i) && e.strokeText(r, i.x, i.y)),
      n && e.setLineDash([])
  }
}
var SHADOW_NUMBER_PROPS = ['shadowBlur', 'shadowOffsetX', 'shadowOffsetY'],
  STROKE_PROPS = [
    ['lineCap', 'butt'],
    ['lineJoin', 'miter'],
    ['miterLimit', 10]
  ]
function bindCommonProps(e, t, i, r, n) {
  var a = !1
  if (!r && t === (i = i || {})) return !1
  if (r || t.opacity !== i.opacity) {
    a || (flushPathDrawn(e, n), (a = !0))
    var o = Math.max(Math.min(t.opacity, 1), 0)
    e.globalAlpha = isNaN(o) ? DEFAULT_COMMON_STYLE.opacity : o
  }
  ;(r || t.blend !== i.blend) &&
    (a || (flushPathDrawn(e, n), (a = !0)),
    (e.globalCompositeOperation = t.blend || DEFAULT_COMMON_STYLE.blend))
  for (var s = 0; s < SHADOW_NUMBER_PROPS.length; s++) {
    var l = SHADOW_NUMBER_PROPS[s]
    ;(r || t[l] !== i[l]) && (a || (flushPathDrawn(e, n), (a = !0)), (e[l] = e.dpr * (t[l] || 0)))
  }
  return (
    (r || t.shadowColor !== i.shadowColor) &&
      (a || (flushPathDrawn(e, n), (a = !0)),
      (e.shadowColor = t.shadowColor || DEFAULT_COMMON_STYLE.shadowColor)),
    a
  )
}
function bindPathAndTextCommonStyle(e, t, i, r, n) {
  var a = getStyle(t, n.inHover),
    o = r ? null : (i && getStyle(i, n.inHover)) || {}
  if (a === o) return !1
  var s = bindCommonProps(e, a, o, r, n)
  if (
    ((r || a.fill !== o.fill) && (s || (flushPathDrawn(e, n), (s = !0)), (e.fillStyle = a.fill)),
    (r || a.stroke !== o.stroke) &&
      (s || (flushPathDrawn(e, n), (s = !0)), (e.strokeStyle = a.stroke)),
    (r || a.opacity !== o.opacity) &&
      (s || (flushPathDrawn(e, n), (s = !0)), (e.globalAlpha = null == a.opacity ? 1 : a.opacity)),
    t.hasStroke())
  ) {
    var l = a.lineWidth / (a.strokeNoScale && t && t.getLineScale ? t.getLineScale() : 1)
    e.lineWidth !== l && (s || (flushPathDrawn(e, n), (s = !0)), (e.lineWidth = l))
  }
  for (var h = 0; h < STROKE_PROPS.length; h++) {
    var u = STROKE_PROPS[h],
      p = u[0]
    ;(r || a[p] !== o[p]) && (s || (flushPathDrawn(e, n), (s = !0)), (e[p] = a[p] || u[1]))
  }
  return s
}
function bindImageStyle(e, t, i, r, n) {
  return bindCommonProps(e, getStyle(t, n.inHover), i && getStyle(i, n.inHover), r, n)
}
function setContextTransform(e, t) {
  var i = t.transform,
    r = e.dpr || 1
  i
    ? e.setTransform(r * i[0], r * i[1], r * i[2], r * i[3], r * i[4], r * i[5])
    : e.setTransform(r, 0, 0, r, 0, 0)
}
function updateClipStatus(e, t, i) {
  for (var r = !1, n = 0; n < e.length; n++) {
    var a = e[n]
    ;(r = r || a.isZeroArea()),
      setContextTransform(t, a),
      t.beginPath(),
      a.buildPath(t, a.shape),
      t.clip()
  }
  i.allClipped = r
}
function isTransformChanged(e, t) {
  return e && t
    ? e[0] !== t[0] ||
        e[1] !== t[1] ||
        e[2] !== t[2] ||
        e[3] !== t[3] ||
        e[4] !== t[4] ||
        e[5] !== t[5]
    : !(!e && !t)
}
var DRAW_TYPE_PATH = 1,
  DRAW_TYPE_IMAGE = 2,
  DRAW_TYPE_TEXT = 3,
  DRAW_TYPE_INCREMENTAL = 4
function canPathBatch(e) {
  var t = styleHasFill(e),
    i = styleHasStroke(e)
  return !(
    e.lineDash ||
    !(+t ^ +i) ||
    (t && 'string' != typeof e.fill) ||
    (i && 'string' != typeof e.stroke) ||
    e.strokePercent < 1 ||
    e.strokeOpacity < 1 ||
    e.fillOpacity < 1
  )
}
function flushPathDrawn(e, t) {
  t.batchFill && e.fill(), t.batchStroke && e.stroke(), (t.batchFill = ''), (t.batchStroke = '')
}
function getStyle(e, t) {
  return (t && e.__hoverStyle) || e.style
}
function brushSingle(e, t) {
  brush(e, t, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0)
}
function brush(e, t, i, r) {
  var n = t.transform
  if (!t.shouldBePainted(i.viewWidth, i.viewHeight, !1, !1))
    return (t.__dirty &= ~REDARAW_BIT), void (t.__isRendered = !1)
  var a = t.__clipPaths,
    o = i.prevElClipPaths,
    s = !1,
    l = !1
  if (
    ((o && !isClipPathChanged(a, o)) ||
      (o &&
        o.length &&
        (flushPathDrawn(e, i),
        e.restore(),
        (l = s = !0),
        (i.prevElClipPaths = null),
        (i.allClipped = !1),
        (i.prevEl = null)),
      a && a.length && (flushPathDrawn(e, i), e.save(), updateClipStatus(a, e, i), (s = !0)),
      (i.prevElClipPaths = a)),
    i.allClipped)
  )
    t.__isRendered = !1
  else {
    t.beforeBrush && t.beforeBrush(), t.innerBeforeBrush()
    var h = i.prevEl
    h || (l = s = !0)
    var u = t instanceof Path && t.autoBatch && canPathBatch(t.style)
    s || isTransformChanged(n, h.transform)
      ? (flushPathDrawn(e, i), setContextTransform(e, t))
      : u || flushPathDrawn(e, i)
    var p = getStyle(t, i.inHover)
    t instanceof Path
      ? (i.lastDrawType !== DRAW_TYPE_PATH && ((l = !0), (i.lastDrawType = DRAW_TYPE_PATH)),
        bindPathAndTextCommonStyle(e, t, h, l, i),
        (u && (i.batchFill || i.batchStroke)) || e.beginPath(),
        brushPath(e, t, p, u),
        u && ((i.batchFill = p.fill || ''), (i.batchStroke = p.stroke || '')))
      : t instanceof TSpan
      ? (i.lastDrawType !== DRAW_TYPE_TEXT && ((l = !0), (i.lastDrawType = DRAW_TYPE_TEXT)),
        bindPathAndTextCommonStyle(e, t, h, l, i),
        brushText(e, t, p))
      : t instanceof ZRImage
      ? (i.lastDrawType !== DRAW_TYPE_IMAGE && ((l = !0), (i.lastDrawType = DRAW_TYPE_IMAGE)),
        bindImageStyle(e, t, h, l, i),
        brushImage(e, t, p))
      : t instanceof IncrementalDisplayable &&
        (i.lastDrawType !== DRAW_TYPE_INCREMENTAL &&
          ((l = !0), (i.lastDrawType = DRAW_TYPE_INCREMENTAL)),
        brushIncremental(e, t, i)),
      u && r && flushPathDrawn(e, i),
      t.innerAfterBrush(),
      t.afterBrush && t.afterBrush(),
      (i.prevEl = t),
      (t.__dirty = 0),
      (t.__isRendered = !0)
  }
}
function brushIncremental(e, t, i) {
  var r = t.getDisplayables(),
    n = t.getTemporalDisplayables()
  e.save()
  var a,
    o,
    s = {
      prevElClipPaths: null,
      prevEl: null,
      allClipped: !1,
      viewWidth: i.viewWidth,
      viewHeight: i.viewHeight,
      inHover: i.inHover
    }
  for (a = t.getCursor(), o = r.length; a < o; a++) {
    ;(u = r[a]).beforeBrush && u.beforeBrush(),
      u.innerBeforeBrush(),
      brush(e, u, s, a === o - 1),
      u.innerAfterBrush(),
      u.afterBrush && u.afterBrush(),
      (s.prevEl = u)
  }
  for (var l = 0, h = n.length; l < h; l++) {
    var u
    ;(u = n[l]).beforeBrush && u.beforeBrush(),
      u.innerBeforeBrush(),
      brush(e, u, s, l === h - 1),
      u.innerAfterBrush(),
      u.afterBrush && u.afterBrush(),
      (s.prevEl = u)
  }
  t.clearTemporalDisplayables(), (t.notClear = !0), e.restore()
}
var decalMap = new WeakMap(),
  decalCache = new LRU(100),
  decalKeys = [
    'symbol',
    'symbolSize',
    'symbolKeepAspect',
    'color',
    'backgroundColor',
    'dashArrayX',
    'dashArrayY',
    'maxTileWidth',
    'maxTileHeight'
  ],
  nodeParsers
function createOrUpdatePatternFromDecal(e, t) {
  if ('none' === e) return null
  var i = t.getDevicePixelRatio(),
    r = t.getZr(),
    n = 'svg' === r.painter.type
  e.dirty && decalMap.delete(e)
  var a = decalMap.get(e)
  if (a) return a
  var o = defaults$1(e, {
    symbol: 'rect',
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: 'rgba(0, 0, 0, 0.2)',
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  })
  'none' === o.backgroundColor && (o.backgroundColor = null)
  var s = { repeat: 'repeat' }
  return (
    (function (e) {
      for (var t, a = [i], s = !0, l = 0; l < decalKeys.length; ++l) {
        var h = o[decalKeys[l]],
          u = typeof h
        if (null != h && !isArray$1(h) && 'string' !== u && 'number' !== u && 'boolean' !== u) {
          s = !1
          break
        }
        a.push(h)
      }
      if (s) {
        t = a.join(',') + (n ? '-svg' : '')
        var p = decalCache.get(t)
        p && (n ? (e.svgElement = p) : (e.image = p))
      }
      var c,
        d = normalizeDashArrayX(o.dashArrayX),
        f = normalizeDashArrayY(o.dashArrayY),
        m = normalizeSymbolArray(o.symbol),
        g = getLineBlockLengthX(d),
        y = getLineBlockLengthY(f),
        v = !n && createCanvas(),
        _ = n && r.painter.createSVGElement('g'),
        x = (function () {
          for (var e = 1, t = 0, i = g.length; t < i; ++t) e = getLeastCommonMultiple(e, g[t])
          var r = 1
          for (t = 0, i = m.length; t < i; ++t) r = getLeastCommonMultiple(r, m[t].length)
          e *= r
          var n = y * g.length * m.length
          return {
            width: Math.max(1, Math.min(e, o.maxTileWidth)),
            height: Math.max(1, Math.min(n, o.maxTileHeight))
          }
        })()
      v && ((v.width = x.width * i), (v.height = x.height * i), (c = v.getContext('2d')))
      ;(function () {
        c &&
          (c.clearRect(0, 0, v.width, v.height),
          o.backgroundColor &&
            ((c.fillStyle = o.backgroundColor), c.fillRect(0, 0, v.width, v.height)))
        for (var e = 0, t = 0; t < f.length; ++t) e += f[t]
        if (e <= 0) return
        var a = -y,
          s = 0,
          l = 0,
          h = 0
        for (; a < x.height; ) {
          if (s % 2 == 0) {
            for (var u = (l / 2) % m.length, p = 0, g = 0, S = 0; p < 2 * x.width; ) {
              var b = 0
              for (t = 0; t < d[h].length; ++t) b += d[h][t]
              if (b <= 0) break
              if (g % 2 == 0) {
                var T = 0.5 * (1 - o.symbolSize),
                  A = p + d[h][g] * T,
                  w = a + f[s] * T,
                  M = d[h][g] * o.symbolSize,
                  C = f[s] * o.symbolSize,
                  P = (S / 2) % m[u].length
                E(A, w, M, C, m[u][P])
              }
              ;(p += d[h][g]), ++S, ++g === d[h].length && (g = 0)
            }
            ++h === d.length && (h = 0)
          }
          ;(a += f[s]), ++l, ++s === f.length && (s = 0)
        }
        function E(e, t, a, s, l) {
          var h = n ? 1 : i,
            u = createSymbol$1(l, e * h, t * h, a * h, s * h, o.color, o.symbolKeepAspect)
          n ? _.appendChild(r.painter.paintOne(u)) : brushSingle(c, u)
        }
      })(),
        s && decalCache.put(t, v || _)
      ;(e.image = v), (e.svgElement = _), (e.svgWidth = x.width), (e.svgHeight = x.height)
    })(s),
    (s.rotation = o.rotation),
    (s.scaleX = s.scaleY = n ? 1 : 1 / i),
    decalMap.set(e, s),
    (e.dirty = !1),
    s
  )
}
function normalizeSymbolArray(e) {
  if (!e || 0 === e.length) return [['rect']]
  if ('string' == typeof e) return [[e]]
  for (var t = !0, i = 0; i < e.length; ++i)
    if ('string' != typeof e[i]) {
      t = !1
      break
    }
  if (t) return normalizeSymbolArray([e])
  var r = []
  for (i = 0; i < e.length; ++i) 'string' == typeof e[i] ? r.push([e[i]]) : r.push(e[i])
  return r
}
function normalizeDashArrayX(e) {
  if (!e || 0 === e.length) return [[0, 0]]
  if ('number' == typeof e) return [[(n = Math.ceil(e)), n]]
  for (var t = !0, i = 0; i < e.length; ++i)
    if ('number' != typeof e[i]) {
      t = !1
      break
    }
  if (t) return normalizeDashArrayX([e])
  var r = []
  for (i = 0; i < e.length; ++i)
    if ('number' == typeof e[i]) {
      var n = Math.ceil(e[i])
      r.push([n, n])
    } else {
      ;(n = map$1(e[i], function (e) {
        return Math.ceil(e)
      })).length %
        2 ==
      1
        ? r.push(n.concat(n))
        : r.push(n)
    }
  return r
}
function normalizeDashArrayY(e) {
  if (!e || ('object' == typeof e && 0 === e.length)) return [0, 0]
  if ('number' == typeof e) {
    var t = Math.ceil(e)
    return [t, t]
  }
  var i = map$1(e, function (e) {
    return Math.ceil(e)
  })
  return e.length % 2 ? i.concat(i) : i
}
function getLineBlockLengthX(e) {
  return map$1(e, function (e) {
    return getLineBlockLengthY(e)
  })
}
function getLineBlockLengthY(e) {
  for (var t = 0, i = 0; i < e.length; ++i) t += e[i]
  return e.length % 2 == 1 ? 2 * t : t
}
function decalVisual(e, t) {
  e.eachRawSeries(function (i) {
    if (!e.isSeriesFiltered(i)) {
      var r = i.getData()
      r.hasItemVisual() &&
        r.each(function (e) {
          var i = r.getItemVisual(e, 'decal')
          i && (r.ensureUniqueItemVisual(e, 'style').decal = createOrUpdatePatternFromDecal(i, t))
        })
      var n = r.getVisual('decal')
      if (n) r.getVisual('style').decal = createOrUpdatePatternFromDecal(n, t)
    }
  })
}
function parseXML(e) {
  isString(e) && (e = new DOMParser().parseFromString(e, 'text/xml'))
  var t = e
  for (
    9 === t.nodeType && (t = t.firstChild);
    'svg' !== t.nodeName.toLowerCase() || 1 !== t.nodeType;

  )
    t = t.nextSibling
  return t
}
var INHERITABLE_STYLE_ATTRIBUTES_MAP = {
    fill: 'fill',
    stroke: 'stroke',
    'stroke-width': 'lineWidth',
    opacity: 'opacity',
    'fill-opacity': 'fillOpacity',
    'stroke-opacity': 'strokeOpacity',
    'stroke-dasharray': 'lineDash',
    'stroke-dashoffset': 'lineDashOffset',
    'stroke-linecap': 'lineCap',
    'stroke-linejoin': 'lineJoin',
    'stroke-miterlimit': 'miterLimit',
    'font-family': 'fontFamily',
    'font-size': 'fontSize',
    'font-style': 'fontStyle',
    'font-weight': 'fontWeight',
    'text-anchor': 'textAlign',
    visibility: 'visibility',
    display: 'display'
  },
  INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS = keys(INHERITABLE_STYLE_ATTRIBUTES_MAP),
  SELF_STYLE_ATTRIBUTES_MAP = { 'alignment-baseline': 'textBaseline', 'stop-color': 'stopColor' },
  SELF_STYLE_ATTRIBUTES_MAP_KEYS = keys(SELF_STYLE_ATTRIBUTES_MAP),
  SVGParser = (function () {
    function e() {
      ;(this._defs = {}), (this._root = null)
    }
    return (
      (e.prototype.parse = function (e, t) {
        t = t || {}
        var i = parseXML(e)
        if (!i) throw new Error('Illegal svg')
        this._defsUsePending = []
        var r = new Group$3()
        this._root = r
        var n = [],
          a = i.getAttribute('viewBox') || '',
          o = parseFloat(i.getAttribute('width') || t.width),
          s = parseFloat(i.getAttribute('height') || t.height)
        isNaN(o) && (o = null), isNaN(s) && (s = null), parseAttributes(i, r, null, !0, !1)
        for (var l, h, u = i.firstChild; u; )
          this._parseNode(u, r, n, null, !1, !1), (u = u.nextSibling)
        if ((applyDefs(this._defs, this._defsUsePending), (this._defsUsePending = []), a)) {
          var p = splitNumberSequence(a)
          p.length >= 4 &&
            (l = {
              x: parseFloat(p[0] || 0),
              y: parseFloat(p[1] || 0),
              width: parseFloat(p[2]),
              height: parseFloat(p[3])
            })
        }
        if (
          l &&
          null != o &&
          null != s &&
          ((h = makeViewBoxTransform(l, { x: 0, y: 0, width: o, height: s })), !t.ignoreViewBox)
        ) {
          var c = r
          ;(r = new Group$3()).add(c), (c.scaleX = c.scaleY = h.scale), (c.x = h.x), (c.y = h.y)
        }
        return (
          t.ignoreRootClip ||
            null == o ||
            null == s ||
            r.setClipPath(new Rect$2({ shape: { x: 0, y: 0, width: o, height: s } })),
          { root: r, width: o, height: s, viewBoxRect: l, viewBoxTransform: h, named: n }
        )
      }),
      (e.prototype._parseNode = function (e, t, i, r, n, a) {
        var o,
          s = e.nodeName.toLowerCase(),
          l = r
        if (('defs' === s && (n = !0), 'text' === s && (a = !0), 'defs' === s || 'switch' === s))
          o = t
        else {
          if (!n) {
            var h = nodeParsers[s]
            if (h && hasOwn(nodeParsers, s)) {
              o = h.call(this, e, t)
              var u = e.getAttribute('name')
              if (u) {
                var p = { name: u, namedFrom: null, svgNodeTagLower: s, el: o }
                i.push(p), 'g' === s && (l = p)
              } else r && i.push({ name: r.name, namedFrom: r, svgNodeTagLower: s, el: o })
              t.add(o)
            }
          }
          var c = paintServerParsers[s]
          if (c && hasOwn(paintServerParsers, s)) {
            var d = c.call(this, e),
              f = e.getAttribute('id')
            f && (this._defs[f] = d)
          }
        }
        if (o && o.isGroup)
          for (var m = e.firstChild; m; )
            1 === m.nodeType
              ? this._parseNode(m, o, i, l, n, a)
              : 3 === m.nodeType && a && this._parseText(m, o),
              (m = m.nextSibling)
      }),
      (e.prototype._parseText = function (e, t) {
        var i = new TSpan({
          style: { text: e.textContent },
          silent: !0,
          x: this._textX || 0,
          y: this._textY || 0
        })
        inheritStyle(t, i),
          parseAttributes(e, i, this._defsUsePending, !1, !1),
          applyTextAlignment(i, t)
        var r = i.style,
          n = r.fontSize
        n && n < 9 && ((r.fontSize = 9), (i.scaleX *= n / 9), (i.scaleY *= n / 9))
        var a =
          (r.fontSize || r.fontFamily) &&
          [r.fontStyle, r.fontWeight, (r.fontSize || 12) + 'px', r.fontFamily || 'sans-serif'].join(
            ' '
          )
        r.font = a
        var o = i.getBoundingRect()
        return (this._textX += o.width), t.add(i), i
      }),
      (e.internalField = void (nodeParsers = {
        g: function (e, t) {
          var i = new Group$3()
          return inheritStyle(t, i), parseAttributes(e, i, this._defsUsePending, !1, !1), i
        },
        rect: function (e, t) {
          var i = new Rect$2()
          return (
            inheritStyle(t, i),
            parseAttributes(e, i, this._defsUsePending, !1, !1),
            i.setShape({
              x: parseFloat(e.getAttribute('x') || '0'),
              y: parseFloat(e.getAttribute('y') || '0'),
              width: parseFloat(e.getAttribute('width') || '0'),
              height: parseFloat(e.getAttribute('height') || '0')
            }),
            (i.silent = !0),
            i
          )
        },
        circle: function (e, t) {
          var i = new Circle()
          return (
            inheritStyle(t, i),
            parseAttributes(e, i, this._defsUsePending, !1, !1),
            i.setShape({
              cx: parseFloat(e.getAttribute('cx') || '0'),
              cy: parseFloat(e.getAttribute('cy') || '0'),
              r: parseFloat(e.getAttribute('r') || '0')
            }),
            (i.silent = !0),
            i
          )
        },
        line: function (e, t) {
          var i = new Line$1()
          return (
            inheritStyle(t, i),
            parseAttributes(e, i, this._defsUsePending, !1, !1),
            i.setShape({
              x1: parseFloat(e.getAttribute('x1') || '0'),
              y1: parseFloat(e.getAttribute('y1') || '0'),
              x2: parseFloat(e.getAttribute('x2') || '0'),
              y2: parseFloat(e.getAttribute('y2') || '0')
            }),
            (i.silent = !0),
            i
          )
        },
        ellipse: function (e, t) {
          var i = new Ellipse()
          return (
            inheritStyle(t, i),
            parseAttributes(e, i, this._defsUsePending, !1, !1),
            i.setShape({
              cx: parseFloat(e.getAttribute('cx') || '0'),
              cy: parseFloat(e.getAttribute('cy') || '0'),
              rx: parseFloat(e.getAttribute('rx') || '0'),
              ry: parseFloat(e.getAttribute('ry') || '0')
            }),
            (i.silent = !0),
            i
          )
        },
        polygon: function (e, t) {
          var i,
            r = e.getAttribute('points')
          r && (i = parsePoints(r))
          var n = new Polygon({ shape: { points: i || [] }, silent: !0 })
          return inheritStyle(t, n), parseAttributes(e, n, this._defsUsePending, !1, !1), n
        },
        polyline: function (e, t) {
          var i,
            r = e.getAttribute('points')
          r && (i = parsePoints(r))
          var n = new Polyline$1({ shape: { points: i || [] }, silent: !0 })
          return inheritStyle(t, n), parseAttributes(e, n, this._defsUsePending, !1, !1), n
        },
        image: function (e, t) {
          var i = new ZRImage()
          return (
            inheritStyle(t, i),
            parseAttributes(e, i, this._defsUsePending, !1, !1),
            i.setStyle({
              image: e.getAttribute('xlink:href'),
              x: +e.getAttribute('x'),
              y: +e.getAttribute('y'),
              width: +e.getAttribute('width'),
              height: +e.getAttribute('height')
            }),
            (i.silent = !0),
            i
          )
        },
        text: function (e, t) {
          var i = e.getAttribute('x') || '0',
            r = e.getAttribute('y') || '0',
            n = e.getAttribute('dx') || '0',
            a = e.getAttribute('dy') || '0'
          ;(this._textX = parseFloat(i) + parseFloat(n)),
            (this._textY = parseFloat(r) + parseFloat(a))
          var o = new Group$3()
          return inheritStyle(t, o), parseAttributes(e, o, this._defsUsePending, !1, !0), o
        },
        tspan: function (e, t) {
          var i = e.getAttribute('x'),
            r = e.getAttribute('y')
          null != i && (this._textX = parseFloat(i)), null != r && (this._textY = parseFloat(r))
          var n = e.getAttribute('dx') || '0',
            a = e.getAttribute('dy') || '0',
            o = new Group$3()
          return (
            inheritStyle(t, o),
            parseAttributes(e, o, this._defsUsePending, !1, !0),
            (this._textX += parseFloat(n)),
            (this._textY += parseFloat(a)),
            o
          )
        },
        path: function (e, t) {
          var i = createFromString(e.getAttribute('d') || '')
          return (
            inheritStyle(t, i),
            parseAttributes(e, i, this._defsUsePending, !1, !1),
            (i.silent = !0),
            i
          )
        }
      })),
      e
    )
  })(),
  paintServerParsers = {
    lineargradient: function (e) {
      var t = parseInt(e.getAttribute('x1') || '0', 10),
        i = parseInt(e.getAttribute('y1') || '0', 10),
        r = parseInt(e.getAttribute('x2') || '10', 10),
        n = parseInt(e.getAttribute('y2') || '0', 10),
        a = new LinearGradient(t, i, r, n)
      return parsePaintServerUnit(e, a), parseGradientColorStops(e, a), a
    },
    radialgradient: function (e) {
      var t = parseInt(e.getAttribute('cx') || '0', 10),
        i = parseInt(e.getAttribute('cy') || '0', 10),
        r = parseInt(e.getAttribute('r') || '0', 10),
        n = new RadialGradient(t, i, r)
      return parsePaintServerUnit(e, n), parseGradientColorStops(e, n), n
    }
  }
function parsePaintServerUnit(e, t) {
  'userSpaceOnUse' === e.getAttribute('gradientUnits') && (t.global = !0)
}
function parseGradientColorStops(e, t) {
  for (var i = e.firstChild; i; ) {
    if (1 === i.nodeType && 'stop' === i.nodeName.toLocaleLowerCase()) {
      var r = i.getAttribute('offset'),
        n = void 0
      n = r && r.indexOf('%') > 0 ? parseInt(r, 10) / 100 : r ? parseFloat(r) : 0
      var a = {}
      parseInlineStyle(i, a, a)
      var o = a.stopColor || i.getAttribute('stop-color') || '#000000'
      t.colorStops.push({ offset: n, color: o })
    }
    i = i.nextSibling
  }
}
function inheritStyle(e, t) {
  e &&
    e.__inheritedStyle &&
    (t.__inheritedStyle || (t.__inheritedStyle = {}),
    defaults$1(t.__inheritedStyle, e.__inheritedStyle))
}
function parsePoints(e) {
  for (var t = splitNumberSequence(e), i = [], r = 0; r < t.length; r += 2) {
    var n = parseFloat(t[r]),
      a = parseFloat(t[r + 1])
    i.push([n, a])
  }
  return i
}
function parseAttributes(e, t, i, r, n) {
  var a = t,
    o = (a.__inheritedStyle = a.__inheritedStyle || {}),
    s = {}
  1 === e.nodeType &&
    (parseTransformAttribute(e, t), parseInlineStyle(e, o, s), r || parseAttributeStyle(e, o, s)),
    (a.style = a.style || {}),
    null != o.fill && (a.style.fill = getFillStrokeStyle(a, 'fill', o.fill, i)),
    null != o.stroke && (a.style.stroke = getFillStrokeStyle(a, 'stroke', o.stroke, i)),
    each$i(
      ['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'],
      function (e) {
        null != o[e] && (a.style[e] = parseFloat(o[e]))
      }
    ),
    each$i(
      [
        'lineDashOffset',
        'lineCap',
        'lineJoin',
        'fontWeight',
        'fontFamily',
        'fontStyle',
        'textAlign'
      ],
      function (e) {
        null != o[e] && (a.style[e] = o[e])
      }
    ),
    n && (a.__selfStyle = s),
    o.lineDash &&
      (a.style.lineDash = map$1(splitNumberSequence(o.lineDash), function (e) {
        return parseFloat(e)
      })),
    ('hidden' !== o.visibility && 'collapse' !== o.visibility) || (a.invisible = !0),
    'none' === o.display && (a.ignore = !0)
}
function applyTextAlignment(e, t) {
  var i = t.__selfStyle
  if (i) {
    var r = i.textBaseline,
      n = r
    r && 'auto' !== r
      ? 'baseline' === r
        ? (n = 'alphabetic')
        : 'before-edge' === r || 'text-before-edge' === r
        ? (n = 'top')
        : 'after-edge' === r || 'text-after-edge' === r
        ? (n = 'bottom')
        : ('central' !== r && 'mathematical' !== r) || (n = 'middle')
      : (n = 'alphabetic'),
      (e.style.textBaseline = n)
  }
  var a = t.__inheritedStyle
  if (a) {
    var o = a.textAlign,
      s = o
    o && ('middle' === o && (s = 'center'), (e.style.textAlign = s))
  }
}
var urlRegex = /^url\(\s*#(.*?)\)/
function getFillStrokeStyle(e, t, i, r) {
  var n = i && i.match(urlRegex)
  if (!n) return 'none' === i && (i = null), i
  var a = trim$1(n[1])
  r.push([e, t, a])
}
function applyDefs(e, t) {
  for (var i = 0; i < t.length; i++) {
    var r = t[i]
    r[0].style[r[1]] = e[r[2]]
  }
}
var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g
function splitNumberSequence(e) {
  return e.match(numberReg) || []
}
var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g,
  DEGREE_TO_ANGLE = Math.PI / 180
function parseTransformAttribute(e, t) {
  var i = e.getAttribute('transform')
  if (i) {
    i = i.replace(/,/g, ' ')
    var r = [],
      n = null
    i.replace(transformRegex, function (e, t, i) {
      return r.push(t, i), ''
    })
    for (var a = r.length - 1; a > 0; a -= 2) {
      var o = r[a],
        s = r[a - 1],
        l = splitNumberSequence(o)
      switch (((n = n || create$1()), s)) {
        case 'translate':
          translate$1(n, n, [parseFloat(l[0]), parseFloat(l[1] || '0')])
          break
        case 'scale':
          scale$1(n, n, [parseFloat(l[0]), parseFloat(l[1] || l[0])])
          break
        case 'rotate':
          rotate(n, n, -parseFloat(l[0]) * DEGREE_TO_ANGLE)
          break
        case 'skewX':
          mul(n, [1, 0, Math.tan(parseFloat(l[0]) * DEGREE_TO_ANGLE), 1, 0, 0], n)
          break
        case 'skewY':
          mul(n, [1, Math.tan(parseFloat(l[0]) * DEGREE_TO_ANGLE), 0, 1, 0, 0], n)
          break
        case 'matrix':
          ;(n[0] = parseFloat(l[0])),
            (n[1] = parseFloat(l[1])),
            (n[2] = parseFloat(l[2])),
            (n[3] = parseFloat(l[3])),
            (n[4] = parseFloat(l[4])),
            (n[5] = parseFloat(l[5]))
      }
    }
    t.setLocalTransform(n)
  }
}
var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g
function parseInlineStyle(e, t, i) {
  var r,
    n = e.getAttribute('style')
  if (n)
    for (styleRegex.lastIndex = 0; null != (r = styleRegex.exec(n)); ) {
      var a = r[1],
        o = hasOwn(INHERITABLE_STYLE_ATTRIBUTES_MAP, a) ? INHERITABLE_STYLE_ATTRIBUTES_MAP[a] : null
      o && (t[o] = r[2])
      var s = hasOwn(SELF_STYLE_ATTRIBUTES_MAP, a) ? SELF_STYLE_ATTRIBUTES_MAP[a] : null
      s && (i[s] = r[2])
    }
}
function parseAttributeStyle(e, t, i) {
  for (var r = 0; r < INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS.length; r++) {
    var n = INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS[r]
    null != (a = e.getAttribute(n)) && (t[INHERITABLE_STYLE_ATTRIBUTES_MAP[n]] = a)
  }
  for (r = 0; r < SELF_STYLE_ATTRIBUTES_MAP_KEYS.length; r++) {
    var a
    n = SELF_STYLE_ATTRIBUTES_MAP_KEYS[r]
    null != (a = e.getAttribute(n)) && (i[SELF_STYLE_ATTRIBUTES_MAP[n]] = a)
  }
}
function makeViewBoxTransform(e, t) {
  var i = t.width / e.width,
    r = t.height / e.height,
    n = Math.min(i, r)
  return {
    scale: n,
    x: -(e.x + e.width / 2) * n + (t.x + t.width / 2),
    y: -(e.y + e.height / 2) * n + (t.y + t.height / 2)
  }
}
function parseSVG(e, t) {
  return new SVGParser().parse(e, t)
}
var EPSILON$1 = 1e-8
function isAroundEqual(e, t) {
  return Math.abs(e - t) < EPSILON$1
}
function contain$1(e, t, i) {
  var r = 0,
    n = e[0]
  if (!n) return !1
  for (var a = 1; a < e.length; a++) {
    var o = e[a]
    ;(r += windingLine(n[0], n[1], o[0], o[1], t, i)), (n = o)
  }
  var s = e[0]
  return (
    (isAroundEqual(n[0], s[0]) && isAroundEqual(n[1], s[1])) ||
      (r += windingLine(n[0], n[1], s[0], s[1], t, i)),
    0 !== r
  )
}
var TMP_TRANSFORM = [],
  Region = (function () {
    function e(e) {
      this.name = e
    }
    return (e.prototype.getCenter = function () {}), e
  })(),
  GeoJSONRegion = (function (e) {
    function t(t, i, r) {
      var n = e.call(this, t) || this
      if (((n.type = 'geoJSON'), (n.geometries = i), r)) r = [r[0], r[1]]
      else {
        var a = n.getBoundingRect()
        r = [a.x + a.width / 2, a.y + a.height / 2]
      }
      return (n._center = r), n
    }
    return (
      __extends(t, e),
      (t.prototype.getBoundingRect = function () {
        var e = this._rect
        if (e) return e
        for (
          var t = Number.MAX_VALUE,
            i = [t, t],
            r = [-t, -t],
            n = [],
            a = [],
            o = this.geometries,
            s = 0;
          s < o.length;
          s++
        ) {
          if ('polygon' === o[s].type)
            fromPoints(o[s].exterior, n, a), min$1(i, i, n), max$1(r, r, a)
        }
        return (
          0 === s && (i[0] = i[1] = r[0] = r[1] = 0),
          (this._rect = new BoundingRect(i[0], i[1], r[0] - i[0], r[1] - i[1]))
        )
      }),
      (t.prototype.contain = function (e) {
        var t = this.getBoundingRect(),
          i = this.geometries
        if (!t.contain(e[0], e[1])) return !1
        e: for (var r = 0, n = i.length; r < n; r++)
          if ('polygon' === i[r].type) {
            var a = i[r].exterior,
              o = i[r].interiors
            if (contain$1(a, e[0], e[1])) {
              for (var s = 0; s < (o ? o.length : 0); s++)
                if (contain$1(o[s], e[0], e[1])) continue e
              return !0
            }
          }
        return !1
      }),
      (t.prototype.transformTo = function (e, t, i, r) {
        var n = this.getBoundingRect(),
          a = n.width / n.height
        i ? r || (r = i / a) : (i = a * r)
        for (
          var o = new BoundingRect(e, t, i, r),
            s = n.calculateTransform(o),
            l = this.geometries,
            h = 0;
          h < l.length;
          h++
        )
          if ('polygon' === l[h].type) {
            for (var u = l[h].exterior, p = l[h].interiors, c = 0; c < u.length; c++)
              applyTransform$1(u[c], u[c], s)
            for (var d = 0; d < (p ? p.length : 0); d++)
              for (c = 0; c < p[d].length; c++) applyTransform$1(p[d][c], p[d][c], s)
          }
        ;(n = this._rect).copy(o), (this._center = [n.x + n.width / 2, n.y + n.height / 2])
      }),
      (t.prototype.cloneShallow = function (e) {
        null == e && (e = this.name)
        var i = new t(e, this.geometries, this._center)
        return (i._rect = this._rect), (i.transformTo = null), i
      }),
      (t.prototype.getCenter = function () {
        return this._center
      }),
      (t.prototype.setCenter = function (e) {
        this._center = e
      }),
      t
    )
  })(Region),
  GeoSVGRegion = (function (e) {
    function t(t, i) {
      var r = e.call(this, t) || this
      return (r.type = 'geoSVG'), (r._elOnlyForCalculate = i), r
    }
    return (
      __extends(t, e),
      (t.prototype.getCenter = function () {
        var e = this._center
        return e || (e = this._center = this._calculateCenter()), e
      }),
      (t.prototype._calculateCenter = function () {
        for (
          var e = this._elOnlyForCalculate,
            t = e.getBoundingRect(),
            i = [t.x + t.width / 2, t.y + t.height / 2],
            r = identity(TMP_TRANSFORM),
            n = e;
          n && !n.isGeoSVGGraphicRoot;

        )
          mul(r, n.getLocalTransform(), r), (n = n.parent)
        return invert(r, r), applyTransform$1(i, i, r), i
      }),
      t
    )
  })(Region),
  REGION_AVAILABLE_SVG_TAG_MAP = createHashMap([
    'rect',
    'circle',
    'line',
    'ellipse',
    'polygon',
    'polyline',
    'path',
    'text',
    'tspan',
    'g'
  ]),
  GeoSVGResource = (function () {
    function e(e, t) {
      ;(this.type = 'geoSVG'),
        (this._usedGraphicMap = createHashMap()),
        (this._freedGraphics = []),
        (this._mapName = e),
        (this._parsedXML = parseXML(t))
    }
    return (
      (e.prototype.load = function () {
        var e = this._firstGraphic
        if (!e) {
          ;(e = this._firstGraphic = this._buildGraphic(this._parsedXML)),
            this._freedGraphics.push(e),
            (this._boundingRect = this._firstGraphic.boundingRect.clone())
          var t = createRegions(e.named),
            i = t.regions,
            r = t.regionsMap
          ;(this._regions = i), (this._regionsMap = r)
        }
        return {
          boundingRect: this._boundingRect,
          regions: this._regions,
          regionsMap: this._regionsMap
        }
      }),
      (e.prototype._buildGraphic = function (e) {
        var t, i
        try {
          assert$1(
            null !=
              (i = (t = (e && parseSVG(e, { ignoreViewBox: !0, ignoreRootClip: !0 })) || {}).root)
          )
        } catch (m) {
          throw new Error('Invalid svg format\n' + m.message)
        }
        var r = new Group$3()
        r.add(i), (r.isGeoSVGGraphicRoot = !0)
        var n = t.width,
          a = t.height,
          o = t.viewBoxRect,
          s = this._boundingRect
        if (!s) {
          var l = void 0,
            h = void 0,
            u = void 0,
            p = void 0
          if (
            (null != n ? ((l = 0), (u = n)) : o && ((l = o.x), (u = o.width)),
            null != a ? ((h = 0), (p = a)) : o && ((h = o.y), (p = o.height)),
            null == l || null == h)
          ) {
            var c = i.getBoundingRect()
            null == l && ((l = c.x), (u = c.width)), null == h && ((h = c.y), (p = c.height))
          }
          s = this._boundingRect = new BoundingRect(l, h, u, p)
        }
        if (o) {
          var d = makeViewBoxTransform(o, s)
          ;(i.scaleX = i.scaleY = d.scale), (i.x = d.x), (i.y = d.y)
        }
        r.setClipPath(new Rect$2({ shape: s.plain() }))
        var f = []
        return (
          each$i(t.named, function (e) {
            null != REGION_AVAILABLE_SVG_TAG_MAP.get(e.svgNodeTagLower) &&
              (f.push(e), setSilent(e.el))
          }),
          { root: r, boundingRect: s, named: f }
        )
      }),
      (e.prototype.useGraphic = function (e) {
        var t = this._usedGraphicMap,
          i = t.get(e)
        return (
          i ||
          ((i = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML)), t.set(e, i), i)
        )
      }),
      (e.prototype.freeGraphic = function (e) {
        var t = this._usedGraphicMap,
          i = t.get(e)
        i && (t.removeKey(e), this._freedGraphics.push(i))
      }),
      e
    )
  })()
function setSilent(e) {
  ;(e.silent = !1),
    e.isGroup &&
      e.traverse(function (e) {
        e.silent = !1
      })
}
function createRegions(e) {
  var t = [],
    i = createHashMap()
  return (
    each$i(e, function (e) {
      if (null == e.namedFrom) {
        var r = new GeoSVGRegion(e.name, e.el)
        t.push(r), i.set(e.name, r)
      }
    }),
    { regions: t, regionsMap: i }
  )
}
function decode(e) {
  if (!e.UTF8Encoding) return e
  var t = e,
    i = t.UTF8Scale
  null == i && (i = 1024)
  for (var r = t.features, n = 0; n < r.length; n++) {
    var a = r[n].geometry
    if ('Polygon' === a.type)
      for (var o = a.coordinates, s = 0; s < o.length; s++)
        o[s] = decodePolygon(o[s], a.encodeOffsets[s], i)
    else if ('MultiPolygon' === a.type)
      for (o = a.coordinates, s = 0; s < o.length; s++)
        for (var l = o[s], h = 0; h < l.length; h++)
          l[h] = decodePolygon(l[h], a.encodeOffsets[s][h], i)
  }
  return (t.UTF8Encoding = !1), t
}
function decodePolygon(e, t, i) {
  for (var r = [], n = t[0], a = t[1], o = 0; o < e.length; o += 2) {
    var s = e.charCodeAt(o) - 64,
      l = e.charCodeAt(o + 1) - 64
    ;(s = (s >> 1) ^ -(1 & s)),
      (l = (l >> 1) ^ -(1 & l)),
      (n = s += n),
      (a = l += a),
      r.push([s / i, l / i])
  }
  return r
}
function parseGeoJSON(e, t) {
  return map$1(
    filter$1((e = decode(e)).features, function (e) {
      return e.geometry && e.properties && e.geometry.coordinates.length > 0
    }),
    function (e) {
      var i = e.properties,
        r = e.geometry,
        n = []
      if ('Polygon' === r.type) {
        var a = r.coordinates
        n.push({ type: 'polygon', exterior: a[0], interiors: a.slice(1) })
      }
      'MultiPolygon' === r.type &&
        each$i((a = r.coordinates), function (e) {
          e[0] && n.push({ type: 'polygon', exterior: e[0], interiors: e.slice(1) })
        })
      var o = new GeoJSONRegion(i[t || 'name'], n, i.cp)
      return (o.properties = i), o
    }
  )
}
for (
  var geoCoord = [126, 25],
    nanhaiName = '',
    points$1 = [
      [
        [0, 3.5],
        [7, 11.2],
        [15, 11.9],
        [30, 7],
        [42, 0.7],
        [52, 0.7],
        [56, 7.7],
        [59, 0.7],
        [64, 0.7],
        [64, 0],
        [5, 0],
        [0, 3.5]
      ],
      [
        [13, 16.1],
        [19, 14.7],
        [16, 21.7],
        [11, 23.1],
        [13, 16.1]
      ],
      [
        [12, 32.2],
        [14, 38.5],
        [15, 38.5],
        [13, 32.2],
        [12, 32.2]
      ],
      [
        [16, 47.6],
        [12, 53.2],
        [13, 53.2],
        [18, 47.6],
        [16, 47.6]
      ],
      [
        [6, 64.4],
        [8, 70],
        [9, 70],
        [8, 64.4],
        [6, 64.4]
      ],
      [
        [23, 82.6],
        [29, 79.8],
        [30, 79.8],
        [25, 82.6],
        [23, 82.6]
      ],
      [
        [37, 70.7],
        [43, 62.3],
        [44, 62.3],
        [39, 70.7],
        [37, 70.7]
      ],
      [
        [48, 51.1],
        [51, 45.5],
        [53, 45.5],
        [50, 51.1],
        [48, 51.1]
      ],
      [
        [51, 35],
        [51, 28.7],
        [53, 28.7],
        [53, 35],
        [51, 35]
      ],
      [
        [52, 22.4],
        [55, 17.5],
        [56, 17.5],
        [53, 22.4],
        [52, 22.4]
      ],
      [
        [58, 12.6],
        [62, 7],
        [63, 7],
        [60, 12.6],
        [58, 12.6]
      ],
      [
        [0, 3.5],
        [0, 93.1],
        [64, 93.1],
        [64, 0],
        [63, 0],
        [63, 92.4],
        [1, 92.4],
        [1, 3.5],
        [0, 3.5]
      ]
    ],
    i = 0;
  i < points$1.length;
  i++
)
  for (var k = 0; k < points$1[i].length; k++)
    (points$1[i][k][0] /= 10.5),
      (points$1[i][k][1] /= -14),
      (points$1[i][k][0] += geoCoord[0]),
      (points$1[i][k][1] += geoCoord[1])
function fixNanhai(e, t) {
  if ('china' === e) {
    for (var i = 0; i < t.length; i++) if (t[i].name === nanhaiName) return
    t.push(
      new GeoJSONRegion(
        nanhaiName,
        map$1(points$1, function (e) {
          return { type: 'polygon', exterior: e }
        }),
        geoCoord
      )
    )
  }
}
var coordsOffsetMap = {
  : [32, 80],
  : [0, -10],
  : [10, 5],
  : [-10, 10],
  : [5, 5]
}
function fixTextCoords(e, t) {
  if ('china' === e) {
    var i = coordsOffsetMap[t.name]
    if (i) {
      var r = t.getCenter()
      ;(r[0] += i[0] / 10.5), (r[1] += -i[1] / 14), t.setCenter(r)
    }
  }
}
var geoCoordMap = {
  Russia: [100, 60],
  'United States': [-99, 38],
  'United States of America': [-99, 38]
}
function fixGeoCoords(e, t) {
  if ('world' === e) {
    var i = geoCoordMap[t.name]
    if (i) {
      var r = [i[0], i[1]]
      t.setCenter(r)
    }
  }
}
var points = [
  [
    [123.45165252685547, 25.73527164402261],
    [123.49731445312499, 25.73527164402261],
    [123.49731445312499, 25.750734064600884],
    [123.45165252685547, 25.750734064600884],
    [123.45165252685547, 25.73527164402261]
  ]
]
function fixDiaoyuIsland(e, t) {
  'china' === e && '' === t.name && t.geometries.push({ type: 'polygon', exterior: points[0] })
}
var DEFAULT_NAME_PROPERTY = 'name',
  GeoJSONResource = (function () {
    function e(e, t, i) {
      ;(this.type = 'geoJSON'),
        (this._parsedMap = createHashMap()),
        (this._mapName = e),
        (this._specialAreas = i),
        (this._geoJSON = parseInput(t))
    }
    return (
      (e.prototype.load = function (e, t) {
        t = t || DEFAULT_NAME_PROPERTY
        var i = this._parsedMap.get(t)
        if (!i) {
          var r = this._parseToRegions(t)
          i = this._parsedMap.set(t, { regions: r, boundingRect: calculateBoundingRect(r) })
        }
        var n = createHashMap(),
          a = []
        return (
          each$i(i.regions, function (t) {
            var i = t.name
            e && e.hasOwnProperty(i) && (t = t.cloneShallow((i = e[i]))), a.push(t), n.set(i, t)
          }),
          {
            regions: a,
            boundingRect: i.boundingRect || new BoundingRect(0, 0, 0, 0),
            regionsMap: n
          }
        )
      }),
      (e.prototype._parseToRegions = function (e) {
        var t,
          i = this._mapName,
          r = this._geoJSON
        try {
          t = r ? parseGeoJSON(r, e) : []
        } catch (n) {
          throw new Error('Invalid geoJson format\n' + n.message)
        }
        return (
          fixNanhai(i, t),
          each$i(
            t,
            function (e) {
              var t = e.name
              fixTextCoords(i, e), fixGeoCoords(i, e), fixDiaoyuIsland(i, e)
              var r = this._specialAreas && this._specialAreas[t]
              r && e.transformTo(r.left, r.top, r.width, r.height)
            },
            this
          ),
          t
        )
      }),
      (e.prototype.getMapForUser = function () {
        return { geoJson: this._geoJSON, geoJSON: this._geoJSON, specialAreas: this._specialAreas }
      }),
      e
    )
  })()
function calculateBoundingRect(e) {
  for (var t, i = 0; i < e.length; i++) {
    var r = e[i].getBoundingRect()
    ;(t = t || r.clone()).union(r)
  }
  return t
}
function parseInput(e) {
  return isString(e)
    ? 'undefined' != typeof JSON && JSON.parse
      ? JSON.parse(e)
      : new Function('return (' + e + ');')()
    : e
}
var storage = createHashMap(),
  geoSourceManager = {
    registerMap: function (e, t, i) {
      if (t.svg) {
        var r = new GeoSVGResource(e, t.svg)
        storage.set(e, r)
      } else {
        var n = t.geoJson || t.geoJSON
        n && !t.features ? (i = t.specialAreas) : (n = t)
        r = new GeoJSONResource(e, n, i)
        storage.set(e, r)
      }
    },
    getGeoResource: function (e) {
      return storage.get(e)
    },
    getMapForUser: function (e) {
      var t = storage.get(e)
      return t && 'geoJSON' === t.type && t.getMapForUser()
    },
    load: function (e, t, i) {
      var r = storage.get(e)
      if (r) return r.load(t, i)
    }
  },
  assert = assert$1,
  each$f = each$i,
  isFunction = isFunction$1,
  isObject$5 = isObject$7,
  indexOf = indexOf$1,
  hasWindow = 'undefined' != typeof window,
  TEST_FRAME_REMAIN_TIME = 1,
  PRIORITY_PROCESSOR_SERIES_FILTER = 800,
  PRIORITY_PROCESSOR_DATASTACK = 900,
  PRIORITY_PROCESSOR_FILTER = 1e3,
  PRIORITY_PROCESSOR_DEFAULT = 2e3,
  PRIORITY_PROCESSOR_STATISTIC = 5e3,
  PRIORITY_VISUAL_LAYOUT = 1e3,
  PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100,
  PRIORITY_VISUAL_GLOBAL = 2e3,
  PRIORITY_VISUAL_CHART = 3e3,
  PRIORITY_VISUAL_COMPONENT = 4e3,
  PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500,
  PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600,
  PRIORITY_VISUAL_BRUSH = 5e3,
  PRIORITY_VISUAL_ARIA = 6e3,
  PRIORITY_VISUAL_DECAL = 7e3,
  PRIORITY = {
    PROCESSOR: {
      FILTER: PRIORITY_PROCESSOR_FILTER,
      SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
      STATISTIC: PRIORITY_PROCESSOR_STATISTIC
    },
    VISUAL: {
      LAYOUT: PRIORITY_VISUAL_LAYOUT,
      PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
      GLOBAL: PRIORITY_VISUAL_GLOBAL,
      CHART: PRIORITY_VISUAL_CHART,
      POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
      COMPONENT: PRIORITY_VISUAL_COMPONENT,
      BRUSH: PRIORITY_VISUAL_BRUSH,
      CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
      ARIA: PRIORITY_VISUAL_ARIA,
      DECAL: PRIORITY_VISUAL_DECAL
    }
  },
  IN_MAIN_PROCESS_KEY = '__flagInMainProcess',
  OPTION_UPDATED_KEY = '__optionUpdated',
  STATUS_NEEDS_UPDATE_KEY = '__needsUpdateStatus',
  ACTION_REG = /^[a-zA-Z0-9_]+$/,
  CONNECT_STATUS_KEY = '__connectUpdateStatus',
  CONNECT_STATUS_PENDING = 0,
  CONNECT_STATUS_UPDATING = 1,
  CONNECT_STATUS_UPDATED = 2
function createRegisterEventWithLowercaseECharts(e) {
  return function () {
    for (var t = [], i = 0; i < arguments.length; i++) t[i] = arguments[i]
    if (!this.isDisposed()) return toLowercaseNameAndCallEventful(this, e, t)
    disposedWarning(this.id)
  }
}
function createRegisterEventWithLowercaseMessageCenter(e) {
  return function () {
    for (var t = [], i = 0; i < arguments.length; i++) t[i] = arguments[i]
    return toLowercaseNameAndCallEventful(this, e, t)
  }
}
function toLowercaseNameAndCallEventful(e, t, i) {
  return (i[0] = i[0] && i[0].toLowerCase()), Eventful.prototype[t].apply(e, i)
}
var MessageCenter = (function (e) {
    function t() {
      return (null !== e && e.apply(this, arguments)) || this
    }
    return __extends(t, e), t
  })(Eventful),
  messageCenterProto = MessageCenter.prototype,
  prepare,
  prepareView,
  updateDirectly,
  updateMethods,
  doConvertPixel,
  updateStreamModes,
  doDispatchAction,
  flushPendingActions,
  triggerUpdatedEvent,
  bindRenderedEvent,
  bindMouseEvent,
  clearColorPalette,
  render,
  renderComponents,
  renderSeries,
  performPostUpdateFuncs,
  createExtensionAPI,
  enableConnect,
  setTransitionOpt,
  markStatusToUpdate,
  applyChangedStates
;(messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter('on')),
  (messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter('off'))
var ECharts = (function (e) {
    function t(t, i, r) {
      var n = e.call(this, new ECEventProcessor()) || this
      ;(n._chartsViews = []),
        (n._chartsMap = {}),
        (n._componentsViews = []),
        (n._componentsMap = {}),
        (n._pendingActions = []),
        (r = r || {}),
        'string' == typeof i && (i = themeStorage[i]),
        (n._dom = t)
      var a = (n._zr = init$2(t, {
        renderer: r.renderer || 'canvas',
        devicePixelRatio: r.devicePixelRatio,
        width: r.width,
        height: r.height,
        useDirtyRect: null != r.useDirtyRect && r.useDirtyRect
      }))
      ;(n._throttledZrFlush = throttle(bind$2(a.flush, a), 17)),
        (i = clone$3(i)) && globalBackwardCompat(i, !0),
        (n._theme = i),
        (n._locale = createLocaleObject(r.locale || SYSTEM_LANG)),
        (n._coordSysMgr = new CoordinateSystemManager())
      var o = (n._api = createExtensionAPI(n))
      function s(e, t) {
        return e.__prio - t.__prio
      }
      return (
        sort$2(visualFuncs, s),
        sort$2(dataProcessorFuncs, s),
        (n._scheduler = new Scheduler(n, o, dataProcessorFuncs, visualFuncs)),
        (n._messageCenter = new MessageCenter()),
        (n._labelManager = new LabelManager()),
        n._initEvents(),
        (n.resize = bind$2(n.resize, n)),
        a.animation.on('frame', n._onframe, n),
        bindRenderedEvent(a, n),
        bindMouseEvent(a, n),
        setAsPrimitive(n),
        n
      )
    }
    return (
      __extends(t, e),
      (t.prototype._onframe = function () {
        if (!this._disposed) {
          applyChangedStates(this)
          var e = this._scheduler
          if (this[OPTION_UPDATED_KEY]) {
            var t = this[OPTION_UPDATED_KEY].silent
            ;(this[IN_MAIN_PROCESS_KEY] = !0),
              prepare(this),
              updateMethods.update.call(this),
              this._zr.flush(),
              (this[IN_MAIN_PROCESS_KEY] = !1),
              (this[OPTION_UPDATED_KEY] = !1),
              flushPendingActions.call(this, t),
              triggerUpdatedEvent.call(this, t)
          } else if (e.unfinished) {
            var i = TEST_FRAME_REMAIN_TIME,
              r = this._model,
              n = this._api
            e.unfinished = !1
            do {
              var a = +new Date()
              e.performSeriesTasks(r),
                e.performDataProcessorTasks(r),
                updateStreamModes(this, r),
                e.performVisualTasks(r),
                renderSeries(this, this._model, n, 'remain'),
                (i -= +new Date() - a)
            } while (i > 0 && e.unfinished)
            e.unfinished || this._zr.flush()
          }
        }
      }),
      (t.prototype.getDom = function () {
        return this._dom
      }),
      (t.prototype.getId = function () {
        return this.id
      }),
      (t.prototype.getZr = function () {
        return this._zr
      }),
      (t.prototype.setOption = function (e, t, i) {
        if (this._disposed) disposedWarning(this.id)
        else {
          var r, n, a
          if (
            (isObject$5(t) &&
              ((i = t.lazyUpdate),
              (r = t.silent),
              (n = t.replaceMerge),
              (a = t.transition),
              (t = t.notMerge)),
            (this[IN_MAIN_PROCESS_KEY] = !0),
            !this._model || t)
          ) {
            var o = new OptionManager(this._api),
              s = this._theme,
              l = (this._model = new GlobalModel())
            ;(l.scheduler = this._scheduler), l.init(null, null, null, s, this._locale, o)
          }
          this._model.setOption(e, { replaceMerge: n }, optionPreprocessorFuncs),
            setTransitionOpt(this, a),
            i
              ? ((this[OPTION_UPDATED_KEY] = { silent: r }),
                (this[IN_MAIN_PROCESS_KEY] = !1),
                this.getZr().wakeUp())
              : (prepare(this),
                updateMethods.update.call(this),
                this._zr.flush(),
                (this[OPTION_UPDATED_KEY] = !1),
                (this[IN_MAIN_PROCESS_KEY] = !1),
                flushPendingActions.call(this, r),
                triggerUpdatedEvent.call(this, r))
        }
      }),
      (t.prototype.setTheme = function () {
        console.error('ECharts#setTheme() is DEPRECATED in ECharts 3.0')
      }),
      (t.prototype.getModel = function () {
        return this._model
      }),
      (t.prototype.getOption = function () {
        return this._model && this._model.getOption()
      }),
      (t.prototype.getWidth = function () {
        return this._zr.getWidth()
      }),
      (t.prototype.getHeight = function () {
        return this._zr.getHeight()
      }),
      (t.prototype.getDevicePixelRatio = function () {
        return this._zr.painter.dpr || (hasWindow && window.devicePixelRatio) || 1
      }),
      (t.prototype.getRenderedCanvas = function (e) {
        if (env.canvasSupported)
          return (
            (e = e || {}),
            this._zr.painter.getRenderedCanvas({
              backgroundColor: e.backgroundColor || this._model.get('backgroundColor'),
              pixelRatio: e.pixelRatio || this.getDevicePixelRatio()
            })
          )
      }),
      (t.prototype.getSvgDataURL = function () {
        if (env.svgSupported) {
          var e = this._zr
          return (
            each$i(e.storage.getDisplayList(), function (e) {
              e.stopAnimation(null, !0)
            }),
            e.painter.toDataURL()
          )
        }
      }),
      (t.prototype.getDataURL = function (e) {
        if (!this._disposed) {
          var t = (e = e || {}).excludeComponents,
            i = this._model,
            r = [],
            n = this
          each$f(t, function (e) {
            i.eachComponent({ mainType: e }, function (e) {
              var t = n._componentsMap[e.__viewId]
              t.group.ignore || (r.push(t), (t.group.ignore = !0))
            })
          })
          var a =
            'svg' === this._zr.painter.getType()
              ? this.getSvgDataURL()
              : this.getRenderedCanvas(e).toDataURL('image/' + ((e && e.type) || 'png'))
          return (
            each$f(r, function (e) {
              e.group.ignore = !1
            }),
            a
          )
        }
        disposedWarning(this.id)
      }),
      (t.prototype.getConnectedDataURL = function (e) {
        if (this._disposed) disposedWarning(this.id)
        else if (env.canvasSupported) {
          var t = 'svg' === e.type,
            i = this.group,
            r = Math.min,
            n = Math.max,
            a = 1 / 0
          if (connectedGroups[i]) {
            var o = a,
              s = a,
              l = -1 / 0,
              h = -1 / 0,
              u = [],
              p = (e && e.pixelRatio) || this.getDevicePixelRatio()
            each$i(instances, function (a, p) {
              if (a.group === i) {
                var c = t
                    ? a.getZr().painter.getSvgDom().innerHTML
                    : a.getRenderedCanvas(clone$3(e)),
                  d = a.getDom().getBoundingClientRect()
                ;(o = r(d.left, o)),
                  (s = r(d.top, s)),
                  (l = n(d.right, l)),
                  (h = n(d.bottom, h)),
                  u.push({ dom: c, left: d.left, top: d.top })
              }
            })
            var c = (l *= p) - (o *= p),
              d = (h *= p) - (s *= p),
              f = createCanvas(),
              m = init$2(f, { renderer: t ? 'svg' : 'canvas' })
            if ((m.resize({ width: c, height: d }), t)) {
              var g = ''
              return (
                each$f(u, function (e) {
                  var t = e.left - o,
                    i = e.top - s
                  g += '<g transform="translate(' + t + ',' + i + ')">' + e.dom + '</g>'
                }),
                (m.painter.getSvgRoot().innerHTML = g),
                e.connectedBackgroundColor &&
                  m.painter.setBackgroundColor(e.connectedBackgroundColor),
                m.refreshImmediately(),
                m.painter.toDataURL()
              )
            }
            return (
              e.connectedBackgroundColor &&
                m.add(
                  new Rect$2({
                    shape: { x: 0, y: 0, width: c, height: d },
                    style: { fill: e.connectedBackgroundColor }
                  })
                ),
              each$f(u, function (e) {
                var t = new ZRImage({
                  style: { x: e.left * p - o, y: e.top * p - s, image: e.dom }
                })
                m.add(t)
              }),
              m.refreshImmediately(),
              f.toDataURL('image/' + ((e && e.type) || 'png'))
            )
          }
          return this.getDataURL(e)
        }
      }),
      (t.prototype.convertToPixel = function (e, t) {
        return doConvertPixel(this, 'convertToPixel', e, t)
      }),
      (t.prototype.convertFromPixel = function (e, t) {
        return doConvertPixel(this, 'convertFromPixel', e, t)
      }),
      (t.prototype.containPixel = function (e, t) {
        var i
        if (!this._disposed)
          return (
            each$i(
              parseFinder$1(this._model, e),
              function (e, r) {
                r.indexOf('Models') >= 0 &&
                  each$i(
                    e,
                    function (e) {
                      var n = e.coordinateSystem
                      if (n && n.containPoint) i = i || !!n.containPoint(t)
                      else if ('seriesModels' === r) {
                        var a = this._chartsMap[e.__viewId]
                        a && a.containPoint && (i = i || a.containPoint(t, e))
                      }
                    },
                    this
                  )
              },
              this
            ),
            !!i
          )
        disposedWarning(this.id)
      }),
      (t.prototype.getVisual = function (e, t) {
        var i = parseFinder$1(this._model, e, { defaultMainType: 'series' }),
          r = i.seriesModel.getData(),
          n = i.hasOwnProperty('dataIndexInside')
            ? i.dataIndexInside
            : i.hasOwnProperty('dataIndex')
            ? r.indexOfRawIndex(i.dataIndex)
            : null
        return null != n ? getItemVisualFromData(r, n, t) : getVisualFromData(r, t)
      }),
      (t.prototype.getViewOfComponentModel = function (e) {
        return this._componentsMap[e.__viewId]
      }),
      (t.prototype.getViewOfSeriesModel = function (e) {
        return this._chartsMap[e.__viewId]
      }),
      (t.prototype._initEvents = function () {
        var e = this
        each$f(MOUSE_EVENT_NAMES, function (t) {
          var i = function (i) {
            var r,
              n = e.getModel(),
              a = i.target
            if (
              ('globalout' === t
                ? (r = {})
                : a &&
                  findEventDispatcher(
                    a,
                    function (e) {
                      var t = getECData(e)
                      if (t && null != t.dataIndex) {
                        var i = t.dataModel || n.getSeriesByIndex(t.seriesIndex)
                        return (r = (i && i.getDataParams(t.dataIndex, t.dataType)) || {}), !0
                      }
                      if (t.eventData) return (r = extend$3({}, t.eventData)), !0
                    },
                    !0
                  ),
              r)
            ) {
              var o = r.componentType,
                s = r.componentIndex
              ;('markLine' !== o && 'markPoint' !== o && 'markArea' !== o) ||
                ((o = 'series'), (s = r.seriesIndex))
              var l = o && null != s && n.getComponent(o, s),
                h = l && e['series' === l.mainType ? '_chartsMap' : '_componentsMap'][l.__viewId]
              ;(r.event = i),
                (r.type = t),
                (e._$eventProcessor.eventInfo = { targetEl: a, packedEvent: r, model: l, view: h }),
                e.trigger(t, r)
            }
          }
          ;(i.zrEventfulCallAtLast = !0), e._zr.on(t, i, e)
        }),
          each$f(eventActionMap, function (t, i) {
            e._messageCenter.on(
              i,
              function (e) {
                this.trigger(i, e)
              },
              e
            )
          }),
          each$f(['selectchanged'], function (t) {
            e._messageCenter.on(
              t,
              function (e) {
                this.trigger(t, e)
              },
              e
            )
          }),
          handleLegacySelectEvents(this._messageCenter, this, this._api)
      }),
      (t.prototype.isDisposed = function () {
        return this._disposed
      }),
      (t.prototype.clear = function () {
        this._disposed ? disposedWarning(this.id) : this.setOption({ series: [] }, !0)
      }),
      (t.prototype.dispose = function () {
        if (this._disposed) disposedWarning(this.id)
        else {
          ;(this._disposed = !0), setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, '')
          var e = this._api,
            t = this._model
          each$f(this._componentsViews, function (i) {
            i.dispose(t, e)
          }),
            each$f(this._chartsViews, function (i) {
              i.dispose(t, e)
            }),
            this._zr.dispose(),
            delete instances[this.id]
        }
      }),
      (t.prototype.resize = function (e) {
        if (this._disposed) disposedWarning(this.id)
        else {
          this._zr.resize(e)
          var t = this._model
          if ((this._loadingFX && this._loadingFX.resize(), t)) {
            var i = t.resetOption('media'),
              r = e && e.silent
            this[OPTION_UPDATED_KEY] &&
              (null == r && (r = this[OPTION_UPDATED_KEY].silent),
              (i = !0),
              (this[OPTION_UPDATED_KEY] = !1)),
              (this[IN_MAIN_PROCESS_KEY] = !0),
              i && prepare(this),
              updateMethods.update.call(this, {
                type: 'resize',
                animation: extend$3({ duration: 0 }, e && e.animation)
              }),
              (this[IN_MAIN_PROCESS_KEY] = !1),
              flushPendingActions.call(this, r),
              triggerUpdatedEvent.call(this, r)
          }
        }
      }),
      (t.prototype.showLoading = function (e, t) {
        if (this._disposed) disposedWarning(this.id)
        else if (
          (isObject$5(e) && ((t = e), (e = '')),
          (e = e || 'default'),
          this.hideLoading(),
          loadingEffects[e])
        ) {
          var i = loadingEffects[e](this._api, t),
            r = this._zr
          ;(this._loadingFX = i), r.add(i)
        }
      }),
      (t.prototype.hideLoading = function () {
        this._disposed
          ? disposedWarning(this.id)
          : (this._loadingFX && this._zr.remove(this._loadingFX), (this._loadingFX = null))
      }),
      (t.prototype.makeActionFromEvent = function (e) {
        var t = extend$3({}, e)
        return (t.type = eventActionMap[e.type]), t
      }),
      (t.prototype.dispatchAction = function (e, t) {
        if (this._disposed) disposedWarning(this.id)
        else if ((isObject$5(t) || (t = { silent: !!t }), actions[e.type] && this._model))
          if (this[IN_MAIN_PROCESS_KEY]) this._pendingActions.push(e)
          else {
            var i = t.silent
            doDispatchAction.call(this, e, i)
            var r = t.flush
            r ? this._zr.flush() : !1 !== r && env.browser.weChat && this._throttledZrFlush(),
              flushPendingActions.call(this, i),
              triggerUpdatedEvent.call(this, i)
          }
      }),
      (t.prototype.updateLabelLayout = function () {
        var e = this._labelManager
        e.updateLayoutConfig(this._api), e.layout(this._api), e.processLabelsOverall()
      }),
      (t.prototype.appendData = function (e) {
        if (this._disposed) disposedWarning(this.id)
        else {
          var t = e.seriesIndex
          this.getModel().getSeriesByIndex(t).appendData(e),
            (this._scheduler.unfinished = !0),
            this.getZr().wakeUp()
        }
      }),
      (t.internalField = (function () {
        function e(e) {
          for (var t = [], i = e.currentStates, r = 0; r < i.length; r++) {
            var n = i[r]
            'emphasis' !== n && 'blur' !== n && 'select' !== n && t.push(n)
          }
          e.selected && e.states.select && t.push('select'),
            e.hoverState === HOVER_STATE_EMPHASIS && e.states.emphasis
              ? t.push('emphasis')
              : e.hoverState === HOVER_STATE_BLUR && e.states.blur && t.push('blur'),
            e.useStates(t)
        }
        function t(e, t) {
          e.preventAutoZ || i(t.group, e.get('z') || 0, e.get('zlevel') || 0, -1 / 0)
        }
        function i(e, t, r, n) {
          var a = e.getTextContent(),
            o = e.getTextGuideLine()
          if (e.isGroup)
            for (var s = e.childrenRef(), l = 0; l < s.length; l++)
              n = Math.max(i(s[l], t, r, n), n)
          else (e.z = t), (e.zlevel = r), (n = Math.max(e.z2, n))
          if ((a && ((a.z = t), (a.zlevel = r), isFinite(n) && (a.z2 = n + 2)), o)) {
            var h = e.textGuideLineConfig
            ;(o.z = t), (o.zlevel = r), isFinite(n) && (o.z2 = n + (h && h.showAbove ? 1 : -1))
          }
          return n
        }
        function r(e, t) {
          t.group.traverse(function (e) {
            if (!isElementRemoved(e)) {
              var t = e.getTextContent(),
                i = e.getTextGuideLine()
              e.stateTransition && (e.stateTransition = null),
                t && t.stateTransition && (t.stateTransition = null),
                i && i.stateTransition && (i.stateTransition = null),
                e.hasState()
                  ? ((e.prevStates = e.currentStates), e.clearStates())
                  : e.prevStates && (e.prevStates = null)
            }
          })
        }
        function n(t, i) {
          var r = t.getModel('stateAnimation'),
            n = t.isAnimationEnabled(),
            a = r.get('duration'),
            o = a > 0 ? { duration: a, delay: r.get('delay'), easing: r.get('easing') } : null
          i.group.traverse(function (t) {
            if (t.states && t.states.emphasis) {
              if (isElementRemoved(t)) return
              if ((t instanceof Path && savePathStates(t), t.__dirty)) {
                var i = t.prevStates
                i && t.useStates(i)
              }
              if (n) {
                t.stateTransition = o
                var r = t.getTextContent(),
                  a = t.getTextGuideLine()
                r && (r.stateTransition = o), a && (a.stateTransition = o)
              }
              t.__dirty && e(t)
            }
          })
        }
        ;(prepare = function (e) {
          var t = e._scheduler
          t.restorePipelines(e._model),
            t.prepareStageTasks(),
            prepareView(e, !0),
            prepareView(e, !1),
            t.plan()
        }),
          (prepareView = function (e, t) {
            for (
              var i = e._model,
                r = e._scheduler,
                n = t ? e._componentsViews : e._chartsViews,
                a = t ? e._componentsMap : e._chartsMap,
                o = e._zr,
                s = e._api,
                l = 0;
              l < n.length;
              l++
            )
              n[l].__alive = !1
            function h(e) {
              var l = e.__requireNewView
              e.__requireNewView = !1
              var h = '_ec_' + e.id + '_' + e.type,
                u = !l && a[h]
              if (!u) {
                var p = parseClassType(e.type)
                ;(u = new (
                  t ? ComponentView.getClass(p.main, p.sub) : ChartView.getClass(p.sub)
                )()).init(i, s),
                  (a[h] = u),
                  n.push(u),
                  o.add(u.group)
              }
              ;(e.__viewId = u.__id = h),
                (u.__alive = !0),
                (u.__model = e),
                (u.group.__ecComponentInfo = { mainType: e.mainType, index: e.componentIndex }),
                !t && r.prepareView(u, e, i, s)
            }
            t
              ? i.eachComponent(function (e, t) {
                  'series' !== e && h(t)
                })
              : i.eachSeries(h)
            for (l = 0; l < n.length; ) {
              var u = n[l]
              u.__alive
                ? l++
                : (!t && u.renderTask.dispose(),
                  o.remove(u.group),
                  u.dispose(i, s),
                  n.splice(l, 1),
                  a[u.__id] === u && delete a[u.__id],
                  (u.__id = u.group.__ecComponentInfo = null))
            }
          }),
          (updateDirectly = function (e, t, i, r, n) {
            var a = e._model
            if ((a.setUpdatePayload(i), r)) {
              var o = {}
              ;(o[r + 'Id'] = i[r + 'Id']),
                (o[r + 'Index'] = i[r + 'Index']),
                (o[r + 'Name'] = i[r + 'Name'])
              var s = { mainType: r, query: o }
              n && (s.subType = n)
              var l,
                h = i.excludeSeriesId
              null != h &&
                ((l = createHashMap()),
                each$f(normalizeToArray(h), function (e) {
                  var t = convertOptionIdName(e, null)
                  null != t && l.set(t, !0)
                })),
                isHighDownPayload(i) && allLeaveBlur(e._api),
                a &&
                  a.eachComponent(
                    s,
                    function (t) {
                      if (!l || null == l.get(t.id)) {
                        if (isHighDownPayload(i))
                          if (t instanceof SeriesModel)
                            i.type !== HIGHLIGHT_ACTION_TYPE ||
                              i.notBlur ||
                              blurSeriesFromHighlightPayload(t, i, e._api)
                          else {
                            var n = findComponentHighDownDispatchers(
                                t.mainType,
                                t.componentIndex,
                                i.name,
                                e._api
                              ),
                              a = n.focusSelf,
                              o = n.dispatchers
                            i.type === HIGHLIGHT_ACTION_TYPE &&
                              a &&
                              !i.notBlur &&
                              blurComponent(t.mainType, t.componentIndex, e._api),
                              o &&
                                each$f(o, function (e) {
                                  i.type === HIGHLIGHT_ACTION_TYPE
                                    ? enterEmphasis(e)
                                    : leaveEmphasis(e)
                                })
                          }
                        else
                          isSelectChangePayload(i) &&
                            t instanceof SeriesModel &&
                            (toggleSelectionFromPayload(t, i, e._api),
                            updateSeriesElementSelection(t),
                            markStatusToUpdate(e))
                        u(e['series' === r ? '_chartsMap' : '_componentsMap'][t.__viewId])
                      }
                    },
                    e
                  )
            } else each$f([].concat(e._componentsViews).concat(e._chartsViews), u)
            function u(r) {
              r && r.__alive && r[t] && r[t](r.__model, a, e._api, i)
            }
          }),
          (updateMethods = {
            prepareAndUpdate: function (e) {
              prepare(this), updateMethods.update.call(this, e)
            },
            update: function (e) {
              var t = this._model,
                i = this._api,
                r = this._zr,
                n = this._coordSysMgr,
                a = this._scheduler
              if (t) {
                t.setUpdatePayload(e),
                  a.restoreData(t, e),
                  a.performSeriesTasks(t),
                  n.create(t, i),
                  a.performDataProcessorTasks(t, e),
                  updateStreamModes(this, t),
                  n.update(t, i),
                  clearColorPalette(t),
                  a.performVisualTasks(t, e),
                  render(this, t, i, e)
                var o = t.get('backgroundColor') || 'transparent',
                  s = t.get('darkMode')
                if (env.canvasSupported)
                  r.setBackgroundColor(o), null != s && 'auto' !== s && r.setDarkMode(s)
                else {
                  var l = parse(o)
                  ;(o = stringify(l, 'rgb')), 0 === l[3] && (o = 'transparent')
                }
                performPostUpdateFuncs(t, i)
              }
            },
            updateTransform: function (e) {
              var t = this,
                i = this._model,
                r = this._api
              if (i) {
                i.setUpdatePayload(e)
                var n = []
                i.eachComponent(function (a, o) {
                  if ('series' !== a) {
                    var s = t.getViewOfComponentModel(o)
                    if (s && s.__alive)
                      if (s.updateTransform) {
                        var l = s.updateTransform(o, i, r, e)
                        l && l.update && n.push(s)
                      } else n.push(s)
                  }
                })
                var a = createHashMap()
                i.eachSeries(function (n) {
                  var o = t._chartsMap[n.__viewId]
                  if (o.updateTransform) {
                    var s = o.updateTransform(n, i, r, e)
                    s && s.update && a.set(n.uid, 1)
                  } else a.set(n.uid, 1)
                }),
                  clearColorPalette(i),
                  this._scheduler.performVisualTasks(i, e, { setDirty: !0, dirtyMap: a }),
                  renderSeries(this, i, r, e, a),
                  performPostUpdateFuncs(i, this._api)
              }
            },
            updateView: function (e) {
              var t = this._model
              t &&
                (t.setUpdatePayload(e),
                ChartView.markUpdateMethod(e, 'updateView'),
                clearColorPalette(t),
                this._scheduler.performVisualTasks(t, e, { setDirty: !0 }),
                render(this, this._model, this._api, e),
                performPostUpdateFuncs(t, this._api))
            },
            updateVisual: function (e) {
              var t = this,
                i = this._model
              i &&
                (i.setUpdatePayload(e),
                i.eachSeries(function (e) {
                  e.getData().clearAllVisual()
                }),
                ChartView.markUpdateMethod(e, 'updateVisual'),
                clearColorPalette(i),
                this._scheduler.performVisualTasks(i, e, { visualType: 'visual', setDirty: !0 }),
                i.eachComponent(function (r, n) {
                  if ('series' !== r) {
                    var a = t.getViewOfComponentModel(n)
                    a && a.__alive && a.updateVisual(n, i, t._api, e)
                  }
                }),
                i.eachSeries(function (r) {
                  t._chartsMap[r.__viewId].updateVisual(r, i, t._api, e)
                }),
                performPostUpdateFuncs(i, this._api))
            },
            updateLayout: function (e) {
              updateMethods.update.call(this, e)
            }
          }),
          (doConvertPixel = function (e, t, i, r) {
            if (e._disposed) disposedWarning(e.id)
            else
              for (
                var n,
                  a = e._model,
                  o = e._coordSysMgr.getCoordinateSystems(),
                  s = parseFinder$1(a, i),
                  l = 0;
                l < o.length;
                l++
              ) {
                var h = o[l]
                if (h[t] && null != (n = h[t](a, s, r))) return n
              }
          }),
          (updateStreamModes = function (e, t) {
            var i = e._chartsMap,
              r = e._scheduler
            t.eachSeries(function (e) {
              r.updateStreamModes(e, i[e.__viewId])
            })
          }),
          (doDispatchAction = function (e, t) {
            var i = this,
              r = this.getModel(),
              n = e.type,
              a = e.escapeConnect,
              o = actions[n],
              s = o.actionInfo,
              l = (s.update || 'update').split(':'),
              h = l.pop(),
              u = null != l[0] && parseClassType(l[0])
            this[IN_MAIN_PROCESS_KEY] = !0
            var p = [e],
              c = !1
            e.batch &&
              ((c = !0),
              (p = map$1(e.batch, function (t) {
                return ((t = defaults$1(extend$3({}, t), e)).batch = null), t
              })))
            var d,
              f = [],
              m = isSelectChangePayload(e),
              g = isHighDownPayload(e)
            if (
              (each$f(p, function (t) {
                if (
                  (((d = (d = o.action(t, i._model, i._api)) || extend$3({}, t)).type =
                    s.event || d.type),
                  f.push(d),
                  g)
                ) {
                  var r = preParseFinder(e),
                    n = r.queryOptionMap,
                    a = r.mainTypeSpecified ? n.keys()[0] : 'series'
                  updateDirectly(i, h, t, a), markStatusToUpdate(i)
                } else m ? (updateDirectly(i, h, t, 'series'), markStatusToUpdate(i)) : u && updateDirectly(i, h, t, u.main, u.sub)
              }),
              'none' === h ||
                g ||
                m ||
                u ||
                (this[OPTION_UPDATED_KEY]
                  ? (prepare(this),
                    updateMethods.update.call(this, e),
                    (this[OPTION_UPDATED_KEY] = !1))
                  : updateMethods[h].call(this, e)),
              (d = c ? { type: s.event || n, escapeConnect: a, batch: f } : f[0]),
              (this[IN_MAIN_PROCESS_KEY] = !1),
              !t)
            ) {
              var y = this._messageCenter
              if ((y.trigger(d.type, d), m)) {
                var v = {
                  type: 'selectchanged',
                  escapeConnect: a,
                  selected: getAllSelectedIndices(r),
                  isFromClick: e.isFromClick || !1,
                  fromAction: e.type,
                  fromActionPayload: e
                }
                y.trigger(v.type, v)
              }
            }
          }),
          (flushPendingActions = function (e) {
            for (var t = this._pendingActions; t.length; ) {
              var i = t.shift()
              doDispatchAction.call(this, i, e)
            }
          }),
          (triggerUpdatedEvent = function (e) {
            !e && this.trigger('updated')
          }),
          (bindRenderedEvent = function (e, t) {
            e.on('rendered', function (i) {
              t.trigger('rendered', i),
                !e.animation.isFinished() ||
                  t[OPTION_UPDATED_KEY] ||
                  t._scheduler.unfinished ||
                  t._pendingActions.length ||
                  t.trigger('finished')
            })
          }),
          (bindMouseEvent = function (e, t) {
            e.on('mouseover', function (e) {
              var i = findEventDispatcher(e.target, isHighDownDispatcher)
              i && (handleGlobalMouseOverForHighDown(i, e, t._api), markStatusToUpdate(t))
            })
              .on('mouseout', function (e) {
                var i = findEventDispatcher(e.target, isHighDownDispatcher)
                i && (handleGlboalMouseOutForHighDown(i, e, t._api), markStatusToUpdate(t))
              })
              .on('click', function (e) {
                var i = findEventDispatcher(
                  e.target,
                  function (e) {
                    return null != getECData(e).dataIndex
                  },
                  !0
                )
                if (i) {
                  var r = i.selected ? 'unselect' : 'select',
                    n = getECData(i)
                  t._api.dispatchAction({
                    type: r,
                    dataType: n.dataType,
                    dataIndexInside: n.dataIndex,
                    seriesIndex: n.seriesIndex,
                    isFromClick: !0
                  })
                }
              })
          }),
          (clearColorPalette = function (e) {
            e.clearColorPalette(),
              e.eachSeries(function (e) {
                e.clearColorPalette()
              })
          }),
          (render = function (e, t, i, r) {
            renderComponents(e, t, i, r),
              each$f(e._chartsViews, function (e) {
                e.__alive = !1
              }),
              renderSeries(e, t, i, r),
              each$f(e._chartsViews, function (e) {
                e.__alive || e.remove(t, i)
              })
          }),
          (renderComponents = function (e, i, a, o, s) {
            each$f(s || e._componentsViews, function (e) {
              var s = e.__model
              r(s, e), e.render(s, i, a, o), t(s, e), n(s, e)
            })
          }),
          (renderSeries = function (e, i, a, o, s) {
            var l = e._scheduler,
              h = e._labelManager
            h.clearLabels()
            var u = !1
            i.eachSeries(function (t) {
              var i = e._chartsMap[t.__viewId]
              i.__alive = !0
              var n = i.renderTask
              l.updatePayload(n, o),
                r(t, i),
                s && s.get(t.uid) && n.dirty(),
                n.perform(l.getPerformArgs(n)) && (u = !0),
                (t.__transientTransitionOpt = null),
                (i.group.silent = !!t.get('silent')),
                (function (e, t) {
                  var i = e.get('blendMode') || null
                  t.group.traverse(function (e) {
                    e.isGroup || (e.style.blend = i),
                      e.eachPendingDisplayable &&
                        e.eachPendingDisplayable(function (e) {
                          e.style.blend = i
                        })
                  })
                })(t, i),
                updateSeriesElementSelection(t),
                h.addLabelsOfSeries(i)
            }),
              (l.unfinished = u || l.unfinished),
              h.updateLayoutConfig(a),
              h.layout(a),
              h.processLabelsOverall(),
              i.eachSeries(function (i) {
                var r = e._chartsMap[i.__viewId]
                t(i, r), n(i, r)
              }),
              (function (e, t) {
                var i = e._zr.storage,
                  r = 0
                i.traverse(function (e) {
                  e.isGroup || r++
                }),
                  r > t.get('hoverLayerThreshold') &&
                    !env.node &&
                    !env.worker &&
                    t.eachSeries(function (t) {
                      if (!t.preventUsingHoverLayer) {
                        var i = e._chartsMap[t.__viewId]
                        i.__alive &&
                          i.group.traverse(function (e) {
                            e.states.emphasis && (e.states.emphasis.hoverLayer = !0)
                          })
                      }
                    })
              })(e, i)
          }),
          (performPostUpdateFuncs = function (e, t) {
            each$f(postUpdateFuncs, function (i) {
              i(e, t)
            })
          }),
          (markStatusToUpdate = function (e) {
            ;(e[STATUS_NEEDS_UPDATE_KEY] = !0), e.getZr().wakeUp()
          }),
          (applyChangedStates = function (t) {
            t[STATUS_NEEDS_UPDATE_KEY] &&
              (t.getZr().storage.traverse(function (t) {
                isElementRemoved(t) || e(t)
              }),
              (t[STATUS_NEEDS_UPDATE_KEY] = !1))
          }),
          (createExtensionAPI = function (e) {
            return new ((function (t) {
              function i() {
                return (null !== t && t.apply(this, arguments)) || this
              }
              return (
                __extends(i, t),
                (i.prototype.getCoordinateSystems = function () {
                  return e._coordSysMgr.getCoordinateSystems()
                }),
                (i.prototype.getComponentByElement = function (t) {
                  for (; t; ) {
                    var i = t.__ecComponentInfo
                    if (null != i) return e._model.getComponent(i.mainType, i.index)
                    t = t.parent
                  }
                }),
                (i.prototype.enterEmphasis = function (t, i) {
                  enterEmphasis(t, i), markStatusToUpdate(e)
                }),
                (i.prototype.leaveEmphasis = function (t, i) {
                  leaveEmphasis(t, i), markStatusToUpdate(e)
                }),
                (i.prototype.enterBlur = function (t) {
                  enterBlur(t), markStatusToUpdate(e)
                }),
                (i.prototype.leaveBlur = function (t) {
                  leaveBlur(t), markStatusToUpdate(e)
                }),
                (i.prototype.enterSelect = function (t) {
                  enterSelect(t), markStatusToUpdate(e)
                }),
                (i.prototype.leaveSelect = function (t) {
                  leaveSelect(t), markStatusToUpdate(e)
                }),
                (i.prototype.getModel = function () {
                  return e.getModel()
                }),
                (i.prototype.getViewOfComponentModel = function (t) {
                  return e.getViewOfComponentModel(t)
                }),
                (i.prototype.getViewOfSeriesModel = function (t) {
                  return e.getViewOfSeriesModel(t)
                }),
                i
              )
            })(ExtensionAPI))(e)
          }),
          (enableConnect = function (e) {
            function t(e, t) {
              for (var i = 0; i < e.length; i++) {
                e[i][CONNECT_STATUS_KEY] = t
              }
            }
            each$f(eventActionMap, function (i, r) {
              e._messageCenter.on(r, function (i) {
                if (connectedGroups[e.group] && e[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
                  if (i && i.escapeConnect) return
                  var r = e.makeActionFromEvent(i),
                    n = []
                  each$f(instances, function (t) {
                    t !== e && t.group === e.group && n.push(t)
                  }),
                    t(n, CONNECT_STATUS_PENDING),
                    each$f(n, function (e) {
                      e[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING && e.dispatchAction(r)
                    }),
                    t(n, CONNECT_STATUS_UPDATED)
                }
              })
            })
          }),
          (setTransitionOpt = function (e, t) {
            var i = e._model
            each$i(normalizeToArray(t), function (e) {
              var t,
                r = e.from,
                n = e.to
              null == n && throwError(t)
              var a = { includeMainTypes: ['series'], enableAll: !1, enableNone: !1 },
                o = r ? parseFinder$1(i, r, a) : null,
                s = parseFinder$1(i, n, a).seriesModel
              null == s && (t = ''),
                o && o.seriesModel !== s && (t = ''),
                null != t && throwError(t),
                (s.__transientTransitionOpt = {
                  from: r ? r.dimension : null,
                  to: n.dimension,
                  dividingMethod: e.dividingMethod
                })
            })
          })
      })()),
      t
    )
  })(Eventful),
  echartsProto = ECharts.prototype
;(echartsProto.on = createRegisterEventWithLowercaseECharts('on')),
  (echartsProto.off = createRegisterEventWithLowercaseECharts('off')),
  (echartsProto.one = function (e, t, i) {
    var r = this
    this.on.call(
      this,
      e,
      function i() {
        for (var n = [], a = 0; a < arguments.length; a++) n[a] = arguments[a]
        t && t.apply && t.apply(this, n), r.off(e, i)
      },
      i
    )
  })
var MOUSE_EVENT_NAMES = [
  'click',
  'dblclick',
  'mouseover',
  'mouseout',
  'mousemove',
  'mousedown',
  'mouseup',
  'globalout',
  'contextmenu'
]
function disposedWarning(e) {}
var actions = {},
  eventActionMap = {},
  dataProcessorFuncs = [],
  optionPreprocessorFuncs = [],
  postInitFuncs = [],
  postUpdateFuncs = [],
  visualFuncs = [],
  themeStorage = {},
  loadingEffects = {},
  instances = {},
  connectedGroups = {},
  idBase = +new Date() - 0,
  DOM_ATTRIBUTE_KEY = '_echarts_instance_'
function init$1(e, t, i) {
  var r = getInstanceByDom(e)
  if (r) return r
  var n = new ECharts(e, t, i)
  return (
    (n.id = 'ec_' + idBase++),
    (instances[n.id] = n),
    setAttribute(e, DOM_ATTRIBUTE_KEY, n.id),
    enableConnect(n),
    each$f(postInitFuncs, function (e) {
      e(n)
    }),
    n
  )
}
function getInstanceByDom(e) {
  return instances[getAttribute(e, DOM_ATTRIBUTE_KEY)]
}
function registerTheme(e, t) {
  themeStorage[e] = t
}
function registerPreprocessor(e) {
  indexOf(optionPreprocessorFuncs, e) < 0 && optionPreprocessorFuncs.push(e)
}
function registerProcessor(e, t) {
  normalizeRegister(dataProcessorFuncs, e, t, PRIORITY_PROCESSOR_DEFAULT)
}
function registerPostInit(e) {
  indexOf(postInitFuncs, e) < 0 && e && postInitFuncs.push(e)
}
function registerPostUpdate(e) {
  indexOf(postUpdateFuncs, e) < 0 && e && postUpdateFuncs.push(e)
}
function registerAction(e, t, i) {
  'function' == typeof t && ((i = t), (t = ''))
  var r = isObject$5(e) ? e.type : [e, (e = { event: t })][0]
  ;(e.event = (e.event || r).toLowerCase()),
    (t = e.event),
    eventActionMap[t] ||
      (assert(ACTION_REG.test(r) && ACTION_REG.test(t)),
      actions[r] || (actions[r] = { action: i, actionInfo: e }),
      (eventActionMap[t] = r))
}
function registerCoordinateSystem(e, t) {
  CoordinateSystemManager.register(e, t)
}
function registerLayout(e, t) {
  normalizeRegister(visualFuncs, e, t, PRIORITY_VISUAL_LAYOUT, 'layout')
}
function registerVisual(e, t) {
  normalizeRegister(visualFuncs, e, t, PRIORITY_VISUAL_CHART, 'visual')
}
var registeredTasks = []
function normalizeRegister(e, t, i, r, n) {
  if (
    ((isFunction(t) || isObject$5(t)) && ((i = t), (t = r)), !(indexOf(registeredTasks, i) >= 0))
  ) {
    registeredTasks.push(i)
    var a = Scheduler.wrapStageHandler(i, n)
    ;(a.__prio = t), (a.__raw = i), e.push(a)
  }
}
function registerLoading(e, t) {
  loadingEffects[e] = t
}
function registerMap(e, t, i) {
  geoSourceManager.registerMap(e, t, i)
}
var registerTransform = registerExternalTransform
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask),
  registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask),
  registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask),
  registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask),
  registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask),
  registerVisual(PRIORITY_VISUAL_DECAL, decalVisual),
  registerPreprocessor(globalBackwardCompat),
  registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack),
  registerLoading('default', defaultLoading),
  registerAction(
    { type: HIGHLIGHT_ACTION_TYPE, event: HIGHLIGHT_ACTION_TYPE, update: HIGHLIGHT_ACTION_TYPE },
    noop$1
  ),
  registerAction(
    { type: DOWNPLAY_ACTION_TYPE, event: DOWNPLAY_ACTION_TYPE, update: DOWNPLAY_ACTION_TYPE },
    noop$1
  ),
  registerAction(
    { type: SELECT_ACTION_TYPE, event: SELECT_ACTION_TYPE, update: SELECT_ACTION_TYPE },
    noop$1
  ),
  registerAction(
    { type: UNSELECT_ACTION_TYPE, event: UNSELECT_ACTION_TYPE, update: UNSELECT_ACTION_TYPE },
    noop$1
  ),
  registerAction(
    {
      type: TOGGLE_SELECT_ACTION_TYPE,
      event: TOGGLE_SELECT_ACTION_TYPE,
      update: TOGGLE_SELECT_ACTION_TYPE
    },
    noop$1
  ),
  registerTheme('light', lightTheme),
  registerTheme('dark', theme)
var extensions = [],
  extensionRegisters = {
    registerPreprocessor: registerPreprocessor,
    registerProcessor: registerProcessor,
    registerPostInit: registerPostInit,
    registerPostUpdate: registerPostUpdate,
    registerAction: registerAction,
    registerCoordinateSystem: registerCoordinateSystem,
    registerLayout: registerLayout,
    registerVisual: registerVisual,
    registerTransform: registerTransform,
    registerLoading: registerLoading,
    registerMap: registerMap,
    PRIORITY: PRIORITY,
    ComponentModel: ComponentModel,
    ComponentView: ComponentView,
    SeriesModel: SeriesModel,
    ChartView: ChartView,
    registerComponentModel: function (e) {
      ComponentModel.registerClass(e)
    },
    registerComponentView: function (e) {
      ComponentView.registerClass(e)
    },
    registerSeriesModel: function (e) {
      SeriesModel.registerClass(e)
    },
    registerChartView: function (e) {
      ChartView.registerClass(e)
    },
    registerSubTypeDefaulter: function (e, t) {
      ComponentModel.registerSubTypeDefaulter(e, t)
    },
    registerPainter: function (e, t) {
      registerPainter(e, t)
    }
  }
function use(e) {
  isArray$1(e)
    ? each$i(e, function (e) {
        use(e)
      })
    : indexOf$1(extensions, e) >= 0 ||
      (extensions.push(e), isFunction$1(e) && (e = { install: e }), e.install(extensionRegisters))
}
function dataIndexMapValueLength(e) {
  return null == e ? 0 : e.length || 1
}
function defaultKeyGetter(e) {
  return e
}
var DataDiffer = (function () {
  function e(e, t, i, r, n, a) {
    ;(this._old = e),
      (this._new = t),
      (this._oldKeyGetter = i || defaultKeyGetter),
      (this._newKeyGetter = r || defaultKeyGetter),
      (this.context = n),
      (this._diffModeMultiple = 'multiple' === a)
  }
  return (
    (e.prototype.add = function (e) {
      return (this._add = e), this
    }),
    (e.prototype.update = function (e) {
      return (this._update = e), this
    }),
    (e.prototype.updateManyToOne = function (e) {
      return (this._updateManyToOne = e), this
    }),
    (e.prototype.updateOneToMany = function (e) {
      return (this._updateOneToMany = e), this
    }),
    (e.prototype.remove = function (e) {
      return (this._remove = e), this
    }),
    (e.prototype.execute = function () {
      this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']()
    }),
    (e.prototype._executeOneToOne = function () {
      var e = this._old,
        t = this._new,
        i = {},
        r = new Array(e.length),
        n = new Array(t.length)
      this._initIndexMap(e, null, r, '_oldKeyGetter'), this._initIndexMap(t, i, n, '_newKeyGetter')
      for (var a = 0; a < e.length; a++) {
        var o = r[a],
          s = i[o],
          l = dataIndexMapValueLength(s)
        if (l > 1) {
          var h = s.shift()
          1 === s.length && (i[o] = s[0]), this._update && this._update(h, a)
        } else
          1 === l
            ? ((i[o] = null), this._update && this._update(s, a))
            : this._remove && this._remove(a)
      }
      this._performRestAdd(n, i)
    }),
    (e.prototype._executeMultiple = function () {
      var e = this._old,
        t = this._new,
        i = {},
        r = {},
        n = [],
        a = []
      this._initIndexMap(e, i, n, '_oldKeyGetter'), this._initIndexMap(t, r, a, '_newKeyGetter')
      for (var o = 0; o < n.length; o++) {
        var s = n[o],
          l = i[s],
          h = r[s],
          u = dataIndexMapValueLength(l),
          p = dataIndexMapValueLength(h)
        if (u > 1 && 1 === p) this._updateManyToOne && this._updateManyToOne(h, l), (r[s] = null)
        else if (1 === u && p > 1)
          this._updateOneToMany && this._updateOneToMany(h, l), (r[s] = null)
        else if (1 === u && 1 === p) this._update && this._update(h, l), (r[s] = null)
        else if (u > 1) for (var c = 0; c < u; c++) this._remove && this._remove(l[c])
        else this._remove && this._remove(l)
      }
      this._performRestAdd(a, r)
    }),
    (e.prototype._performRestAdd = function (e, t) {
      for (var i = 0; i < e.length; i++) {
        var r = e[i],
          n = t[r],
          a = dataIndexMapValueLength(n)
        if (a > 1) for (var o = 0; o < a; o++) this._add && this._add(n[o])
        else 1 === a && this._add && this._add(n)
        t[r] = null
      }
    }),
    (e.prototype._initIndexMap = function (e, t, i, r) {
      for (var n = this._diffModeMultiple, a = 0; a < e.length; a++) {
        var o = '_ec_' + this[r](e[a], a)
        if ((n || (i[a] = o), t)) {
          var s = t[o],
            l = dataIndexMapValueLength(s)
          0 === l ? ((t[o] = a), n && i.push(o)) : 1 === l ? (t[o] = [s, a]) : s.push(a)
        }
      }
    }),
    e
  )
})()
function summarizeDimensions(e) {
  var t = {},
    i = (t.encode = {}),
    r = createHashMap(),
    n = [],
    a = [],
    o = (t.userOutput = { dimensionNames: e.dimensions.slice(), encode: {} })
  each$i(e.dimensions, function (t) {
    var s = e.getDimensionInfo(t),
      l = s.coordDim
    if (l) {
      var h = s.coordDimIndex
      ;(getOrCreateEncodeArr(i, l)[h] = t),
        s.isExtraCoord ||
          (r.set(l, 1),
          mayLabelDimType(s.type) && (n[0] = t),
          (getOrCreateEncodeArr(o.encode, l)[h] = s.index)),
        s.defaultTooltip && a.push(t)
    }
    VISUAL_DIMENSIONS.each(function (e, t) {
      var r = getOrCreateEncodeArr(i, t),
        n = s.otherDims[t]
      null != n && !1 !== n && (r[n] = s.name)
    })
  })
  var s = [],
    l = {}
  r.each(function (e, t) {
    var r = i[t]
    ;(l[t] = r[0]), (s = s.concat(r))
  }),
    (t.dataDimsOnCoord = s),
    (t.encodeFirstDimNotExtra = l)
  var h = i.label
  h && h.length && (n = h.slice())
  var u = i.tooltip
  return (
    u && u.length ? (a = u.slice()) : a.length || (a = n.slice()),
    (i.defaultedLabel = n),
    (i.defaultedTooltip = a),
    t
  )
}
function getOrCreateEncodeArr(e, t) {
  return e.hasOwnProperty(t) || (e[t] = []), e[t]
}
function getDimensionTypeByAxis(e) {
  return 'category' === e ? 'ordinal' : 'time' === e ? 'time' : 'float'
}
function mayLabelDimType(e) {
  return !('ordinal' === e || 'time' === e)
}
var DataDimensionInfo = function (e) {
    ;(this.otherDims = {}), null != e && extend$3(this, e)
  },
  mathFloor$2 = Math.floor,
  isObject$4 = isObject$7,
  map = map$1,
  UNDEFINED = 'undefined',
  INDEX_NOT_FOUND = -1,
  ID_PREFIX = 'e\0\0',
  dataCtors = {
    float: typeof Float64Array === UNDEFINED ? Array : Float64Array,
    int: typeof Int32Array === UNDEFINED ? Array : Int32Array,
    ordinal: Array,
    number: Array,
    time: Array
  },
  CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array,
  CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array,
  CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array,
  TRANSFERABLE_PROPERTIES = [
    'hasItemOption',
    '_nameList',
    '_idList',
    '_invertedIndicesMap',
    '_rawData',
    '_dimValueGetter',
    '_count',
    '_rawCount',
    '_nameDimIdx',
    '_idDimIdx',
    '_nameRepeatCount'
  ],
  CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'],
  defaultDimValueGetters,
  prepareInvertedIndex,
  getIndicesCtor,
  prepareStorage,
  getRawIndexWithoutIndices,
  getRawIndexWithIndices,
  getId,
  getIdNameFromStore,
  makeIdFromName,
  normalizeDimensions,
  cloneListForMapAndSample,
  getInitialExtent,
  setItemDataAndSeriesIndex,
  transferProperties,
  List = (function () {
    function e(e, t) {
      ;(this.type = 'list'),
        (this._count = 0),
        (this._rawCount = 0),
        (this._storage = {}),
        (this._storageArr = []),
        (this._nameList = []),
        (this._idList = []),
        (this._visual = {}),
        (this._layout = {}),
        (this._itemVisuals = []),
        (this._itemLayouts = []),
        (this._graphicEls = []),
        (this._rawExtent = {}),
        (this._extent = {}),
        (this._approximateExtent = {}),
        (this._calculationInfo = {}),
        (this.hasItemOption = !0),
        (this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map']),
        (this.CHANGABLE_METHODS = ['filterSelf', 'selectRange']),
        (this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample']),
        (this.getRawIndex = getRawIndexWithoutIndices),
        (e = e || ['x', 'y'])
      for (var i = {}, r = [], n = {}, a = 0; a < e.length; a++) {
        var o = e[a],
          s = isString(o)
            ? new DataDimensionInfo({ name: o })
            : o instanceof DataDimensionInfo
            ? o
            : new DataDimensionInfo(o),
          l = s.name
        ;(s.type = s.type || 'float'), s.coordDim || ((s.coordDim = l), (s.coordDimIndex = 0))
        var h = (s.otherDims = s.otherDims || {})
        r.push(l),
          (i[l] = s),
          (s.index = a),
          s.createInvertedIndices && (n[l] = []),
          0 === h.itemName && ((this._nameDimIdx = a), (this._nameOrdinalMeta = s.ordinalMeta)),
          0 === h.itemId && ((this._idDimIdx = a), (this._idOrdinalMeta = s.ordinalMeta))
      }
      ;(this.dimensions = r),
        (this._dimensionInfos = i),
        (this.hostModel = t),
        (this._dimensionsSummary = summarizeDimensions(this)),
        (this._invertedIndicesMap = n),
        (this.userOutput = this._dimensionsSummary.userOutput)
    }
    return (
      (e.prototype.getDimension = function (e) {
        return (
          ('number' != typeof e && (isNaN(e) || this._dimensionInfos.hasOwnProperty(e))) ||
            (e = this.dimensions[e]),
          e
        )
      }),
      (e.prototype.getDimensionInfo = function (e) {
        return this._dimensionInfos[this.getDimension(e)]
      }),
      (e.prototype.getDimensionsOnCoord = function () {
        return this._dimensionsSummary.dataDimsOnCoord.slice()
      }),
      (e.prototype.mapDimension = function (e, t) {
        var i = this._dimensionsSummary
        if (null == t) return i.encodeFirstDimNotExtra[e]
        var r = i.encode[e]
        return r ? r[t] : null
      }),
      (e.prototype.mapDimensionsAll = function (e) {
        return (this._dimensionsSummary.encode[e] || []).slice()
      }),
      (e.prototype.initData = function (e, t, i) {
        var r =
          isSourceInstance(e) || isArrayLike(e)
            ? new DefaultDataProvider(e, this.dimensions.length)
            : e
        this._rawData = r
        var n = r.getSource().sourceFormat
        ;(this._storage = {}),
          (this._indices = null),
          (this._dontMakeIdFromName =
            null != this._idDimIdx || n === SOURCE_FORMAT_TYPED_ARRAY || !!r.fillStorage),
          (this._nameList = (t || []).slice()),
          (this._idList = []),
          (this._nameRepeatCount = {}),
          i || (this.hasItemOption = !1),
          (this.defaultDimValueGetter = defaultDimValueGetters[n]),
          (this._dimValueGetter = i = i || this.defaultDimValueGetter),
          (this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows),
          (this._rawExtent = {}),
          this._initDataFromProvider(0, r.count()),
          r.pure && (this.hasItemOption = !1)
      }),
      (e.prototype.getProvider = function () {
        return this._rawData
      }),
      (e.prototype.appendData = function (e) {
        var t = this._rawData,
          i = this.count()
        t.appendData(e)
        var r = t.count()
        t.persistent || (r += i), this._initDataFromProvider(i, r, !0)
      }),
      (e.prototype.appendValues = function (e, t) {
        for (
          var i = this._storage,
            r = this.dimensions,
            n = r.length,
            a = this._rawExtent,
            o = this.count(),
            s = o + Math.max(e.length, t ? t.length : 0),
            l = 0;
          l < n;
          l++
        ) {
          var h = r[l]
          a[h] || (a[h] = getInitialExtent()), prepareStorage(i, this._dimensionInfos[h], s, !0)
        }
        for (
          var u = map(r, function (e) {
              return a[e]
            }),
            p = (this._storageArr = map(r, function (e) {
              return i[e]
            })),
            c = [],
            d = o;
          d < s;
          d++
        ) {
          for (var f = d - o, m = 0; m < n; m++) {
            h = r[m]
            var g = this._dimValueGetterArrayRows(e[f] || c, h, f, m)
            p[m][d] = g
            var y = u[m]
            g < y[0] && (y[0] = g), g > y[1] && (y[1] = g)
          }
          t && ((this._nameList[d] = t[f]), this._dontMakeIdFromName || makeIdFromName(this, d))
        }
        ;(this._rawCount = this._count = s), (this._extent = {}), prepareInvertedIndex(this)
      }),
      (e.prototype._initDataFromProvider = function (e, t, i) {
        if (!(e >= t)) {
          for (
            var r = this._rawData,
              n = this._storage,
              a = this.dimensions,
              o = a.length,
              s = this._dimensionInfos,
              l = this._nameList,
              h = this._idList,
              u = this._rawExtent,
              p = r.getSource().sourceFormat === SOURCE_FORMAT_ORIGINAL,
              c = 0;
            c < o;
            c++
          ) {
            var d = a[c]
            u[d] || (u[d] = getInitialExtent()), prepareStorage(n, s[d], t, i)
          }
          var f = (this._storageArr = map(a, function (e) {
              return n[e]
            })),
            m = map(a, function (e) {
              return u[e]
            })
          if (r.fillStorage) r.fillStorage(e, t, f, m)
          else
            for (var g = [], y = e; y < t; y++) {
              g = r.getItem(y, g)
              for (var v = 0; v < o; v++) {
                d = a[v]
                var _ = f[v],
                  x = this._dimValueGetter(g, d, y, v)
                _[y] = x
                var S = m[v]
                x < S[0] && (S[0] = x), x > S[1] && (S[1] = x)
              }
              if (p && !r.pure && g) {
                var b = g.name
                null == l[y] && null != b && (l[y] = convertOptionIdName(b, null))
                var T = g.id
                null == h[y] && null != T && (h[y] = convertOptionIdName(T, null))
              }
              this._dontMakeIdFromName || makeIdFromName(this, y)
            }
          !r.persistent && r.clean && r.clean(),
            (this._rawCount = this._count = t),
            (this._extent = {}),
            prepareInvertedIndex(this)
        }
      }),
      (e.prototype.count = function () {
        return this._count
      }),
      (e.prototype.getIndices = function () {
        var e,
          t = this._indices
        if (t) {
          var i = t.constructor,
            r = this._count
          if (i === Array) {
            e = new i(r)
            for (var n = 0; n < r; n++) e[n] = t[n]
          } else e = new i(t.buffer, 0, r)
        } else {
          e = new (i = getIndicesCtor(this))(this.count())
          for (n = 0; n < e.length; n++) e[n] = n
        }
        return e
      }),
      (e.prototype.getByDimIdx = function (e, t) {
        if (!(t >= 0 && t < this._count)) return NaN
        var i = this._storageArr[e]
        return i ? i[this.getRawIndex(t)] : NaN
      }),
      (e.prototype.get = function (e, t) {
        if (!(t >= 0 && t < this._count)) return NaN
        var i = this._storage[e]
        return i ? i[this.getRawIndex(t)] : NaN
      }),
      (e.prototype.getByRawIndex = function (e, t) {
        if (!(t >= 0 && t < this._rawCount)) return NaN
        var i = this._storage[e]
        return i ? i[t] : NaN
      }),
      (e.prototype.getValues = function (e, t) {
        var i = []
        isArray$1(e) || ((t = e), (e = this.dimensions))
        for (var r = 0, n = e.length; r < n; r++) i.push(this.get(e[r], t))
        return i
      }),
      (e.prototype.hasValue = function (e) {
        for (var t = this._dimensionsSummary.dataDimsOnCoord, i = 0, r = t.length; i < r; i++)
          if (isNaN(this.get(t[i], e))) return !1
        return !0
      }),
      (e.prototype.getDataExtent = function (e) {
        e = this.getDimension(e)
        var t = this._storage[e],
          i = getInitialExtent()
        if (!t) return i
        var r,
          n = this.count()
        if (!this._indices) return this._rawExtent[e].slice()
        if ((r = this._extent[e])) return r.slice()
        for (var a = (r = i)[0], o = r[1], s = 0; s < n; s++) {
          var l = t[this.getRawIndex(s)]
          l < a && (a = l), l > o && (o = l)
        }
        return (r = [a, o]), (this._extent[e] = r), r
      }),
      (e.prototype.getApproximateExtent = function (e) {
        return (e = this.getDimension(e)), this._approximateExtent[e] || this.getDataExtent(e)
      }),
      (e.prototype.setApproximateExtent = function (e, t) {
        ;(t = this.getDimension(t)), (this._approximateExtent[t] = e.slice())
      }),
      (e.prototype.getCalculationInfo = function (e) {
        return this._calculationInfo[e]
      }),
      (e.prototype.setCalculationInfo = function (e, t) {
        isObject$4(e) ? extend$3(this._calculationInfo, e) : (this._calculationInfo[e] = t)
      }),
      (e.prototype.getSum = function (e) {
        var t = 0
        if (this._storage[e])
          for (var i = 0, r = this.count(); i < r; i++) {
            var n = this.get(e, i)
            isNaN(n) || (t += n)
          }
        return t
      }),
      (e.prototype.getMedian = function (e) {
        var t = []
        this.each(e, function (e) {
          isNaN(e) || t.push(e)
        })
        var i = t.sort(function (e, t) {
            return e - t
          }),
          r = this.count()
        return 0 === r ? 0 : r % 2 == 1 ? i[(r - 1) / 2] : (i[r / 2] + i[r / 2 - 1]) / 2
      }),
      (e.prototype.rawIndexOf = function (e, t) {
        var i = (e && this._invertedIndicesMap[e])[t]
        return null == i || isNaN(i) ? INDEX_NOT_FOUND : i
      }),
      (e.prototype.indexOfName = function (e) {
        for (var t = 0, i = this.count(); t < i; t++) if (this.getName(t) === e) return t
        return -1
      }),
      (e.prototype.indexOfRawIndex = function (e) {
        if (e >= this._rawCount || e < 0) return -1
        if (!this._indices) return e
        var t = this._indices,
          i = t[e]
        if (null != i && i < this._count && i === e) return e
        for (var r = 0, n = this._count - 1; r <= n; ) {
          var a = ((r + n) / 2) | 0
          if (t[a] < e) r = a + 1
          else {
            if (!(t[a] > e)) return a
            n = a - 1
          }
        }
        return -1
      }),
      (e.prototype.indicesOfNearest = function (e, t, i) {
        var r = this._storage[e],
          n = []
        if (!r) return n
        null == i && (i = 1 / 0)
        for (var a = 1 / 0, o = -1, s = 0, l = 0, h = this.count(); l < h; l++) {
          var u = t - r[this.getRawIndex(l)],
            p = Math.abs(u)
          p <= i &&
            ((p < a || (p === a && u >= 0 && o < 0)) && ((a = p), (o = u), (s = 0)),
            u === o && (n[s++] = l))
        }
        return (n.length = s), n
      }),
      (e.prototype.getRawDataItem = function (e) {
        if (this._rawData.persistent) return this._rawData.getItem(this.getRawIndex(e))
        for (var t = [], i = 0; i < this.dimensions.length; i++) {
          var r = this.dimensions[i]
          t.push(this.get(r, e))
        }
        return t
      }),
      (e.prototype.getName = function (e) {
        var t = this.getRawIndex(e),
          i = this._nameList[t]
        return (
          null == i &&
            null != this._nameDimIdx &&
            (i = getIdNameFromStore(this, this._nameDimIdx, this._nameOrdinalMeta, t)),
          null == i && (i = ''),
          i
        )
      }),
      (e.prototype.getId = function (e) {
        return getId(this, this.getRawIndex(e))
      }),
      (e.prototype.each = function (e, t, i, r) {
        var n = this
        if (this._count) {
          'function' == typeof e && ((r = i), (i = t), (t = e), (e = []))
          for (
            var a = i || r || this,
              o = map(normalizeDimensions(e), this.getDimension, this),
              s = o.length,
              l = map(o, function (e) {
                return n._dimensionInfos[e].index
              }),
              h = this._storageArr,
              u = 0,
              p = this.count();
            u < p;
            u++
          ) {
            var c = this.getRawIndex(u)
            switch (s) {
              case 0:
                t.call(a, u)
                break
              case 1:
                t.call(a, h[l[0]][c], u)
                break
              case 2:
                t.call(a, h[l[0]][c], h[l[1]][c], u)
                break
              default:
                for (var d = 0, f = []; d < s; d++) f[d] = h[l[d]][c]
                ;(f[d] = u), t.apply(a, f)
            }
          }
        }
      }),
      (e.prototype.filterSelf = function (e, t, i, r) {
        var n = this
        if (this._count) {
          'function' == typeof e && ((r = i), (i = t), (t = e), (e = []))
          for (
            var a = i || r || this,
              o = map(normalizeDimensions(e), this.getDimension, this),
              s = this.count(),
              l = new (getIndicesCtor(this))(s),
              h = [],
              u = o.length,
              p = 0,
              c = map(o, function (e) {
                return n._dimensionInfos[e].index
              }),
              d = c[0],
              f = this._storageArr,
              m = 0;
            m < s;
            m++
          ) {
            var g = void 0,
              y = this.getRawIndex(m)
            if (0 === u) g = t.call(a, m)
            else if (1 === u) {
              var v = f[d][y]
              g = t.call(a, v, m)
            } else {
              for (var _ = 0; _ < u; _++) h[_] = f[c[_]][y]
              ;(h[_] = m), (g = t.apply(a, h))
            }
            g && (l[p++] = y)
          }
          return (
            p < s && (this._indices = l),
            (this._count = p),
            (this._extent = {}),
            (this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices),
            this
          )
        }
      }),
      (e.prototype.selectRange = function (e) {
        var t = this,
          i = this._count
        if (i) {
          var r = []
          for (var n in e) e.hasOwnProperty(n) && r.push(n)
          var a = r.length
          if (a) {
            var o = this.count(),
              s = new (getIndicesCtor(this))(o),
              l = 0,
              h = r[0],
              u = map(r, function (e) {
                return t._dimensionInfos[e].index
              }),
              p = e[h][0],
              c = e[h][1],
              d = this._storageArr,
              f = !1
            if (!this._indices) {
              var m = 0
              if (1 === a) {
                for (var g = d[u[0]], y = 0; y < i; y++) {
                  ;(((S = g[y]) >= p && S <= c) || isNaN(S)) && (s[l++] = m), m++
                }
                f = !0
              } else if (2 === a) {
                g = d[u[0]]
                var v = d[u[1]],
                  _ = e[r[1]][0],
                  x = e[r[1]][1]
                for (y = 0; y < i; y++) {
                  var S = g[y],
                    b = v[y]
                  ;((S >= p && S <= c) || isNaN(S)) &&
                    ((b >= _ && b <= x) || isNaN(b)) &&
                    (s[l++] = m),
                    m++
                }
                f = !0
              }
            }
            if (!f)
              if (1 === a)
                for (y = 0; y < o; y++) {
                  var T = this.getRawIndex(y)
                  ;(((S = d[u[0]][T]) >= p && S <= c) || isNaN(S)) && (s[l++] = T)
                }
              else
                for (y = 0; y < o; y++) {
                  for (var A = !0, w = ((T = this.getRawIndex(y)), 0); w < a; w++) {
                    var M = r[w]
                    ;((S = d[u[w]][T]) < e[M][0] || S > e[M][1]) && (A = !1)
                  }
                  A && (s[l++] = this.getRawIndex(y))
                }
            return (
              l < o && (this._indices = s),
              (this._count = l),
              (this._extent = {}),
              (this.getRawIndex = this._indices
                ? getRawIndexWithIndices
                : getRawIndexWithoutIndices),
              this
            )
          }
        }
      }),
      (e.prototype.mapArray = function (e, t, i, r) {
        'function' == typeof e && ((r = i), (i = t), (t = e), (e = [])), (i = i || r || this)
        var n = []
        return (
          this.each(
            e,
            function () {
              n.push(t && t.apply(this, arguments))
            },
            i
          ),
          n
        )
      }),
      (e.prototype.map = function (e, t, i, r) {
        var n = i || r || this,
          a = map(normalizeDimensions(e), this.getDimension, this),
          o = cloneListForMapAndSample(this, a),
          s = o._storage
        ;(o._indices = this._indices),
          (o.getRawIndex = o._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices)
        for (
          var l = [], h = a.length, u = this.count(), p = [], c = o._rawExtent, d = 0;
          d < u;
          d++
        ) {
          for (var f = 0; f < h; f++) p[f] = this.get(a[f], d)
          p[h] = d
          var m = t && t.apply(n, p)
          if (null != m) {
            'object' != typeof m && ((l[0] = m), (m = l))
            for (var g = this.getRawIndex(d), y = 0; y < m.length; y++) {
              var v = a[y],
                _ = m[y],
                x = c[v],
                S = s[v]
              S && (S[g] = _), _ < x[0] && (x[0] = _), _ > x[1] && (x[1] = _)
            }
          }
        }
        return o
      }),
      (e.prototype.downSample = function (e, t, i, r) {
        for (
          var n = cloneListForMapAndSample(this, [e]),
            a = n._storage,
            o = [],
            s = mathFloor$2(1 / t),
            l = a[e],
            h = this.count(),
            u = n._rawExtent[e],
            p = new (getIndicesCtor(this))(h),
            c = 0,
            d = 0;
          d < h;
          d += s
        ) {
          s > h - d && ((s = h - d), (o.length = s))
          for (var f = 0; f < s; f++) {
            var m = this.getRawIndex(d + f)
            o[f] = l[m]
          }
          var g = i(o),
            y = this.getRawIndex(Math.min(d + r(o, g) || 0, h - 1))
          ;(l[y] = g), g < u[0] && (u[0] = g), g > u[1] && (u[1] = g), (p[c++] = y)
        }
        return (n._count = c), (n._indices = p), (n.getRawIndex = getRawIndexWithIndices), n
      }),
      (e.prototype.lttbDownSample = function (e, t) {
        var i,
          r,
          n,
          a = cloneListForMapAndSample(this, []),
          o = a._storage[e],
          s = this.count(),
          l = new (getIndicesCtor(this))(s),
          h = 0,
          u = mathFloor$2(1 / t),
          p = this.getRawIndex(0)
        l[h++] = p
        for (var c = 1; c < s - 1; c += u) {
          for (
            var d = Math.min(c + u, s - 1),
              f = Math.min(c + 2 * u, s),
              m = (f + d) / 2,
              g = 0,
              y = d;
            y < f;
            y++
          ) {
            var v = o[(T = this.getRawIndex(y))]
            isNaN(v) || (g += v)
          }
          g /= f - d
          var _ = c,
            x = Math.min(c + u, s),
            S = c - 1,
            b = o[p]
          ;(i = -1), (n = _)
          for (y = _; y < x; y++) {
            var T
            v = o[(T = this.getRawIndex(y))]
            isNaN(v) ||
              ((r = Math.abs((S - m) * (v - b) - (S - y) * (g - b))) > i && ((i = r), (n = T)))
          }
          ;(l[h++] = n), (p = n)
        }
        return (
          (l[h++] = this.getRawIndex(s - 1)),
          (a._count = h),
          (a._indices = l),
          (a.getRawIndex = getRawIndexWithIndices),
          a
        )
      }),
      (e.prototype.getItemModel = function (e) {
        var t = this.hostModel,
          i = this.getRawDataItem(e)
        return new Model(i, t, t && t.ecModel)
      }),
      (e.prototype.diff = function (e) {
        var t = this
        return new DataDiffer(
          e ? e.getIndices() : [],
          this.getIndices(),
          function (t) {
            return getId(e, t)
          },
          function (e) {
            return getId(t, e)
          }
        )
      }),
      (e.prototype.getVisual = function (e) {
        var t = this._visual
        return t && t[e]
      }),
      (e.prototype.setVisual = function (e, t) {
        ;(this._visual = this._visual || {}),
          isObject$4(e) ? extend$3(this._visual, e) : (this._visual[e] = t)
      }),
      (e.prototype.getItemVisual = function (e, t) {
        var i = this._itemVisuals[e],
          r = i && i[t]
        return null == r ? this.getVisual(t) : r
      }),
      (e.prototype.hasItemVisual = function () {
        return this._itemVisuals.length > 0
      }),
      (e.prototype.ensureUniqueItemVisual = function (e, t) {
        var i = this._itemVisuals,
          r = i[e]
        r || (r = i[e] = {})
        var n = r[t]
        return (
          null == n &&
            (isArray$1((n = this.getVisual(t)))
              ? (n = n.slice())
              : isObject$4(n) && (n = extend$3({}, n)),
            (r[t] = n)),
          n
        )
      }),
      (e.prototype.setItemVisual = function (e, t, i) {
        var r = this._itemVisuals[e] || {}
        ;(this._itemVisuals[e] = r), isObject$4(t) ? extend$3(r, t) : (r[t] = i)
      }),
      (e.prototype.clearAllVisual = function () {
        ;(this._visual = {}), (this._itemVisuals = [])
      }),
      (e.prototype.setLayout = function (e, t) {
        if (isObject$4(e)) for (var i in e) e.hasOwnProperty(i) && this.setLayout(i, e[i])
        else this._layout[e] = t
      }),
      (e.prototype.getLayout = function (e) {
        return this._layout[e]
      }),
      (e.prototype.getItemLayout = function (e) {
        return this._itemLayouts[e]
      }),
      (e.prototype.setItemLayout = function (e, t, i) {
        this._itemLayouts[e] = i ? extend$3(this._itemLayouts[e] || {}, t) : t
      }),
      (e.prototype.clearItemLayouts = function () {
        this._itemLayouts.length = 0
      }),
      (e.prototype.setItemGraphicEl = function (e, t) {
        var i = this.hostModel
        if (t) {
          var r = getECData(t)
          ;(r.dataIndex = e),
            (r.dataType = this.dataType),
            (r.seriesIndex = i && i.seriesIndex),
            'group' === t.type && t.traverse(setItemDataAndSeriesIndex, t)
        }
        this._graphicEls[e] = t
      }),
      (e.prototype.getItemGraphicEl = function (e) {
        return this._graphicEls[e]
      }),
      (e.prototype.eachItemGraphicEl = function (e, t) {
        each$i(this._graphicEls, function (i, r) {
          i && e && e.call(t, i, r)
        })
      }),
      (e.prototype.cloneShallow = function (t) {
        t || (t = new e(map(this.dimensions, this.getDimensionInfo, this), this.hostModel))
        if (
          ((t._storage = this._storage),
          (t._storageArr = this._storageArr),
          transferProperties(t, this),
          this._indices)
        ) {
          var i = this._indices.constructor
          if (i === Array) {
            var r = this._indices.length
            t._indices = new i(r)
            for (var n = 0; n < r; n++) t._indices[n] = this._indices[n]
          } else t._indices = new i(this._indices)
        } else t._indices = null
        return (t.getRawIndex = t._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices), t
      }),
      (e.prototype.wrapMethod = function (e, t) {
        var i = this[e]
        'function' == typeof i &&
          ((this.__wrappedMethods = this.__wrappedMethods || []),
          this.__wrappedMethods.push(e),
          (this[e] = function () {
            var e = i.apply(this, arguments)
            return t.apply(this, [e].concat(slice(arguments)))
          }))
      }),
      (e.internalField = (function () {
        function t(e, t, i, r) {
          return parseDataValue(e[r], this._dimensionInfos[t])
        }
        ;(defaultDimValueGetters = {
          arrayRows: t,
          objectRows: function (e, t, i, r) {
            return parseDataValue(e[t], this._dimensionInfos[t])
          },
          keyedColumns: t,
          original: function (e, t, i, r) {
            var n = e && (null == e.value ? e : e.value)
            return (
              !this._rawData.pure && isDataItemOption(e) && (this.hasItemOption = !0),
              parseDataValue(n instanceof Array ? n[r] : n, this._dimensionInfos[t])
            )
          },
          typedArray: function (e, t, i, r) {
            return e[r]
          }
        }),
          (prepareInvertedIndex = function (e) {
            var t = e._invertedIndicesMap
            each$i(t, function (i, r) {
              var n = e._dimensionInfos[r].ordinalMeta
              if (n) {
                i = t[r] = new CtorInt32Array(n.categories.length)
                for (var a = 0; a < i.length; a++) i[a] = INDEX_NOT_FOUND
                for (a = 0; a < e._count; a++) i[e.get(r, a)] = a
              }
            })
          }),
          (getIdNameFromStore = function (e, t, i, r) {
            var n,
              a = e._storageArr[t]
            return (
              a && ((n = a[r]), i && i.categories.length && (n = i.categories[n])),
              convertOptionIdName(n, null)
            )
          }),
          (getIndicesCtor = function (e) {
            return e._rawCount > 65535 ? CtorUint32Array : CtorUint16Array
          }),
          (prepareStorage = function (e, t, i, r) {
            var n = dataCtors[t.type],
              a = t.name
            if (r) {
              var o = e[a],
                s = o && o.length
              if (s !== i) {
                for (var l = new n(i), h = 0; h < s; h++) l[h] = o[h]
                e[a] = l
              }
            } else e[a] = new n(i)
          }),
          (getRawIndexWithoutIndices = function (e) {
            return e
          }),
          (getRawIndexWithIndices = function (e) {
            return e < this._count && e >= 0 ? this._indices[e] : -1
          }),
          (getId = function (e, t) {
            var i = e._idList[t]
            return (
              null == i &&
                null != e._idDimIdx &&
                (i = getIdNameFromStore(e, e._idDimIdx, e._idOrdinalMeta, t)),
              null == i && (i = ID_PREFIX + t),
              i
            )
          }),
          (normalizeDimensions = function (e) {
            return isArray$1(e) || (e = null != e ? [e] : []), e
          }),
          (cloneListForMapAndSample = function (t, i) {
            var r = t.dimensions,
              n = new e(map(r, t.getDimensionInfo, t), t.hostModel)
            transferProperties(n, t)
            for (
              var a, o, s = (n._storage = {}), l = t._storage, h = (n._storageArr = []), u = 0;
              u < r.length;
              u++
            ) {
              var p = r[u]
              l[p] &&
                (indexOf$1(i, p) >= 0
                  ? ((s[p] =
                      ((a = l[p]),
                      (o = void 0),
                      (o = a.constructor) === Array ? a.slice() : new o(a))),
                    (n._rawExtent[p] = getInitialExtent()),
                    (n._extent[p] = null))
                  : (s[p] = l[p]),
                h.push(s[p]))
            }
            return n
          }),
          (getInitialExtent = function () {
            return [1 / 0, -1 / 0]
          }),
          (setItemDataAndSeriesIndex = function (e) {
            var t = getECData(e),
              i = getECData(this)
            ;(t.seriesIndex = i.seriesIndex), (t.dataIndex = i.dataIndex), (t.dataType = i.dataType)
          }),
          (transferProperties = function (e, t) {
            each$i(TRANSFERABLE_PROPERTIES.concat(t.__wrappedMethods || []), function (i) {
              t.hasOwnProperty(i) && (e[i] = t[i])
            }),
              (e.__wrappedMethods = t.__wrappedMethods),
              each$i(CLONE_PROPERTIES, function (i) {
                e[i] = clone$3(t[i])
              }),
              (e._calculationInfo = extend$3({}, t._calculationInfo))
          }),
          (makeIdFromName = function (e, t) {
            var i = e._nameList,
              r = e._idList,
              n = e._nameDimIdx,
              a = e._idDimIdx,
              o = i[t],
              s = r[t]
            if (
              (null == o &&
                null != n &&
                (i[t] = o = getIdNameFromStore(e, n, e._nameOrdinalMeta, t)),
              null == s && null != a && (r[t] = s = getIdNameFromStore(e, a, e._idOrdinalMeta, t)),
              null == s && null != o)
            ) {
              var l = e._nameRepeatCount,
                h = (l[o] = (l[o] || 0) + 1)
              ;(s = o), h > 1 && (s += '__ec__' + h), (r[t] = s)
            }
          })
      })()),
      e
    )
  })()
function completeDimensions(e, t, i) {
  isSourceInstance(t) || (t = createSourceFromSeriesDataOption(t)),
    (i = i || {}),
    (e = (e || []).slice())
  for (
    var r = (i.dimsDef || []).slice(),
      n = createHashMap(),
      a = createHashMap(),
      o = [],
      s = getDimCount(t, e, r, i.dimCount),
      l = 0;
    l < s;
    l++
  ) {
    var h = r[l],
      u = (r[l] = extend$3({}, isObject$7(h) ? h : { name: h })),
      p = u.name,
      c = (o[l] = new DataDimensionInfo())
    null != p && null == n.get(p) && ((c.name = c.displayName = p), n.set(p, l)),
      null != u.type && (c.type = u.type),
      null != u.displayName && (c.displayName = u.displayName)
  }
  var d = i.encodeDef
  !d && i.encodeDefaulter && (d = i.encodeDefaulter(t, s))
  var f = createHashMap(d)
  f.each(function (e, t) {
    var i = normalizeToArray(e).slice()
    if (1 === i.length && !isString(i[0]) && i[0] < 0) f.set(t, !1)
    else {
      var r = f.set(t, [])
      each$i(i, function (e, i) {
        var a = isString(e) ? n.get(e) : e
        null != a && a < s && ((r[i] = a), g(o[a], t, i))
      })
    }
  })
  var m = 0
  function g(e, t, i) {
    null != VISUAL_DIMENSIONS.get(t)
      ? (e.otherDims[t] = i)
      : ((e.coordDim = t), (e.coordDimIndex = i), a.set(t, !0))
  }
  each$i(e, function (e) {
    var t, i, r, n
    if (isString(e)) (t = e), (n = {})
    else {
      t = (n = e).name
      var a = n.ordinalMeta
      ;(n.ordinalMeta = null),
        ((n = clone$3(n)).ordinalMeta = a),
        (i = n.dimsDef),
        (r = n.otherDims),
        (n.name = n.coordDim = n.coordDimIndex = n.dimsDef = n.otherDims = null)
    }
    var s = f.get(t)
    if (!1 !== s) {
      if (!(s = normalizeToArray(s)).length)
        for (var l = 0; l < ((i && i.length) || 1); l++) {
          for (; m < o.length && null != o[m].coordDim; ) m++
          m < o.length && s.push(m++)
        }
      each$i(s, function (e, a) {
        var s = o[e]
        if ((g(defaults$1(s, n), t, a), null == s.name && i)) {
          var l = i[a]
          !isObject$7(l) && (l = { name: l }),
            (s.name = s.displayName = l.name),
            (s.defaultTooltip = l.defaultTooltip)
        }
        r && defaults$1(s.otherDims, r)
      })
    }
  })
  var y = i.generateCoord,
    v = i.generateCoordCount,
    _ = null != v
  v = y ? v || 1 : 0
  for (var x = y || 'value', S = 0; S < s; S++) {
    null == (c = o[S] = o[S] || new DataDimensionInfo()).coordDim &&
      ((c.coordDim = genName(x, a, _)),
      (c.coordDimIndex = 0),
      (!y || v <= 0) && (c.isExtraCoord = !0),
      v--),
      null == c.name && (c.name = genName(c.coordDim, n, !1)),
      null != c.type ||
        (guessOrdinal(t, S) !== BE_ORDINAL.Must &&
          (!c.isExtraCoord || (null == c.otherDims.itemName && null == c.otherDims.seriesName))) ||
        (c.type = 'ordinal')
  }
  return o
}
function getDimCount(e, t, i, r) {
  var n = Math.max(e.dimensionsDetectedCount || 1, t.length, i.length, r || 0)
  return (
    each$i(t, function (e) {
      var t
      isObject$7(e) && (t = e.dimsDef) && (n = Math.max(n, t.length))
    }),
    n
  )
}
function genName(e, t, i) {
  if (i || null != t.get(e)) {
    for (var r = 0; null != t.get(e + r); ) r++
    e += r
  }
  return t.set(e, !0), e
}
function createDimensions(e, t) {
  return completeDimensions((t = t || {}).coordDimensions || [], e, {
    dimsDef: t.dimensionsDefine || e.dimensionsDefine,
    encodeDef: t.encodeDefine || e.encodeDefine,
    dimCount: t.dimensionsCount,
    encodeDefaulter: t.encodeDefaulter,
    generateCoord: t.generateCoord,
    generateCoordCount: t.generateCoordCount
  })
}
var CoordSysInfo = function (e) {
  ;(this.coordSysDims = []),
    (this.axisMap = createHashMap()),
    (this.categoryAxisMap = createHashMap()),
    (this.coordSysName = e)
}
function getCoordSysInfoBySeries(e) {
  var t = e.get('coordinateSystem'),
    i = new CoordSysInfo(t),
    r = fetchers[t]
  if (r) return r(e, i, i.axisMap, i.categoryAxisMap), i
}
var fetchers = {
  cartesian2d: function (e, t, i, r) {
    var n = e.getReferringComponents('xAxis', SINGLE_REFERRING).models[0],
      a = e.getReferringComponents('yAxis', SINGLE_REFERRING).models[0]
    ;(t.coordSysDims = ['x', 'y']),
      i.set('x', n),
      i.set('y', a),
      isCategory(n) && (r.set('x', n), (t.firstCategoryDimIndex = 0)),
      isCategory(a) &&
        (r.set('y', a), null == t.firstCategoryDimIndex && (t.firstCategoryDimIndex = 1))
  },
  singleAxis: function (e, t, i, r) {
    var n = e.getReferringComponents('singleAxis', SINGLE_REFERRING).models[0]
    ;(t.coordSysDims = ['single']),
      i.set('single', n),
      isCategory(n) && (r.set('single', n), (t.firstCategoryDimIndex = 0))
  },
  polar: function (e, t, i, r) {
    var n = e.getReferringComponents('polar', SINGLE_REFERRING).models[0],
      a = n.findAxisModel('radiusAxis'),
      o = n.findAxisModel('angleAxis')
    ;(t.coordSysDims = ['radius', 'angle']),
      i.set('radius', a),
      i.set('angle', o),
      isCategory(a) && (r.set('radius', a), (t.firstCategoryDimIndex = 0)),
      isCategory(o) &&
        (r.set('angle', o), null == t.firstCategoryDimIndex && (t.firstCategoryDimIndex = 1))
  },
  geo: function (e, t, i, r) {
    t.coordSysDims = ['lng', 'lat']
  },
  parallel: function (e, t, i, r) {
    var n = e.ecModel,
      a = n.getComponent('parallel', e.get('parallelIndex')),
      o = (t.coordSysDims = a.dimensions.slice())
    each$i(a.parallelAxisIndex, function (e, a) {
      var s = n.getComponent('parallelAxis', e),
        l = o[a]
      i.set(l, s),
        isCategory(s) &&
          (r.set(l, s), null == t.firstCategoryDimIndex && (t.firstCategoryDimIndex = a))
    })
  }
}
function isCategory(e) {
  return 'category' === e.get('type')
}
function enableDataStack(e, t, i) {
  var r,
    n,
    a,
    o,
    s = (i = i || {}).byIndex,
    l = i.stackedCoordDimension,
    h = !(!e || !e.get('stack'))
  if (
    (each$i(t, function (e, i) {
      isString(e) && (t[i] = e = { name: e }),
        h &&
          !e.isExtraCoord &&
          (s || r || !e.ordinalMeta || (r = e),
          n || 'ordinal' === e.type || 'time' === e.type || (l && l !== e.coordDim) || (n = e))
    }),
    !n || s || r || (s = !0),
    n)
  ) {
    ;(a = '__\0ecstackresult'), (o = '__\0ecstackedover'), r && (r.createInvertedIndices = !0)
    var u = n.coordDim,
      p = n.type,
      c = 0
    each$i(t, function (e) {
      e.coordDim === u && c++
    }),
      t.push({
        name: a,
        coordDim: u,
        coordDimIndex: c,
        type: p,
        isExtraCoord: !0,
        isCalculationCoord: !0
      }),
      c++,
      t.push({
        name: o,
        coordDim: o,
        coordDimIndex: c,
        type: p,
        isExtraCoord: !0,
        isCalculationCoord: !0
      })
  }
  return {
    stackedDimension: n && n.name,
    stackedByDimension: r && r.name,
    isStackedByIndex: s,
    stackedOverDimension: o,
    stackResultDimension: a
  }
}
function isDimensionStacked(e, t) {
  return !!t && t === e.getCalculationInfo('stackedDimension')
}
function getStackedDimension(e, t) {
  return isDimensionStacked(e, t) ? e.getCalculationInfo('stackResultDimension') : t
}
function createListFromArray(e, t, i) {
  ;(i = i || {}), isSourceInstance(e) || (e = createSourceFromSeriesDataOption(e))
  var r,
    n = t.get('coordinateSystem'),
    a = CoordinateSystemManager.get(n),
    o = getCoordSysInfoBySeries(t)
  o &&
    o.coordSysDims &&
    (r = map$1(o.coordSysDims, function (e) {
      var t = { name: e },
        i = o.axisMap.get(e)
      if (i) {
        var r = i.get('type')
        t.type = getDimensionTypeByAxis(r)
      }
      return t
    })),
    r ||
      (r = (a && (a.getDimensionsInfo ? a.getDimensionsInfo() : a.dimensions.slice())) || [
        'x',
        'y'
      ])
  var s,
    l,
    h = i.useEncodeDefaulter,
    u = createDimensions(e, {
      coordDimensions: r,
      generateCoord: i.generateCoord,
      encodeDefaulter: isFunction$1(h)
        ? h
        : h
        ? curry$1(makeSeriesEncodeForAxisCoordSys, r, t)
        : null
    })
  o &&
    each$i(u, function (e, t) {
      var r = e.coordDim,
        n = o.categoryAxisMap.get(r)
      n &&
        (null == s && (s = t),
        (e.ordinalMeta = n.getOrdinalMeta()),
        i.createInvertedIndices && (e.createInvertedIndices = !0)),
        null != e.otherDims.itemName && (l = !0)
    }),
    l || null == s || (u[s].otherDims.itemName = 0)
  var p = enableDataStack(t, u),
    c = new List(u, t)
  c.setCalculationInfo(p)
  var d =
    null != s && isNeedCompleteOrdinalData(e)
      ? function (e, t, i, r) {
          return r === s ? i : this.defaultDimValueGetter(e, t, i, r)
        }
      : null
  return (c.hasItemOption = !1), c.initData(e, null, d), c
}
function isNeedCompleteOrdinalData(e) {
  if (e.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    var t = firstDataNotNull(e.data || [])
    return null != t && !isArray$1(getDataItemValue(t))
  }
}
function firstDataNotNull(e) {
  for (var t = 0; t < e.length && null == e[t]; ) t++
  return e[t]
}
var Scale = (function () {
  function e(e) {
    ;(this._setting = e || {}), (this._extent = [1 / 0, -1 / 0])
  }
  return (
    (e.prototype.getSetting = function (e) {
      return this._setting[e]
    }),
    (e.prototype.unionExtent = function (e) {
      var t = this._extent
      e[0] < t[0] && (t[0] = e[0]), e[1] > t[1] && (t[1] = e[1])
    }),
    (e.prototype.unionExtentFromData = function (e, t) {
      this.unionExtent(e.getApproximateExtent(t))
    }),
    (e.prototype.getExtent = function () {
      return this._extent.slice()
    }),
    (e.prototype.setExtent = function (e, t) {
      var i = this._extent
      isNaN(e) || (i[0] = e), isNaN(t) || (i[1] = t)
    }),
    (e.prototype.isInExtentRange = function (e) {
      return this._extent[0] <= e && this._extent[1] >= e
    }),
    (e.prototype.isBlank = function () {
      return this._isBlank
    }),
    (e.prototype.setBlank = function (e) {
      this._isBlank = e
    }),
    e
  )
})()
enableClassManagement(Scale)
var OrdinalMeta = (function () {
  function e(e) {
    ;(this.categories = e.categories || []),
      (this._needCollect = e.needCollect),
      (this._deduplication = e.deduplication)
  }
  return (
    (e.createByAxisModel = function (t) {
      var i = t.option,
        r = i.data,
        n = r && map$1(r, getName)
      return new e({ categories: n, needCollect: !n, deduplication: !1 !== i.dedplication })
    }),
    (e.prototype.getOrdinal = function (e) {
      return this._getOrCreateMap().get(e)
    }),
    (e.prototype.parseAndCollect = function (e) {
      var t,
        i = this._needCollect
      if ('string' != typeof e && !i) return e
      if (i && !this._deduplication)
        return (t = this.categories.length), (this.categories[t] = e), t
      var r = this._getOrCreateMap()
      return (
        null == (t = r.get(e)) &&
          (i ? ((t = this.categories.length), (this.categories[t] = e), r.set(e, t)) : (t = NaN)),
        t
      )
    }),
    (e.prototype._getOrCreateMap = function () {
      return this._map || (this._map = createHashMap(this.categories))
    }),
    e
  )
})()
function getName(e) {
  return isObject$7(e) && null != e.value ? e.value : e + ''
}
var roundNumber$1 = round$2
function intervalScaleNiceTicks(e, t, i, r) {
  var n = {},
    a = e[1] - e[0],
    o = (n.interval = nice(a / t, !0))
  null != i && o < i && (o = n.interval = i), null != r && o > r && (o = n.interval = r)
  var s = (n.intervalPrecision = getIntervalPrecision(o))
  return (
    fixExtent(
      (n.niceTickExtent = [
        roundNumber$1(Math.ceil(e[0] / o) * o, s),
        roundNumber$1(Math.floor(e[1] / o) * o, s)
      ]),
      e
    ),
    n
  )
}
function getIntervalPrecision(e) {
  return getPrecision(e) + 2
}
function clamp(e, t, i) {
  e[t] = Math.max(Math.min(e[t], i[1]), i[0])
}
function fixExtent(e, t) {
  !isFinite(e[0]) && (e[0] = t[0]),
    !isFinite(e[1]) && (e[1] = t[1]),
    clamp(e, 0, t),
    clamp(e, 1, t),
    e[0] > e[1] && (e[0] = e[1])
}
function contain(e, t) {
  return e >= t[0] && e <= t[1]
}
function normalize$2(e, t) {
  return t[1] === t[0] ? 0.5 : (e - t[0]) / (t[1] - t[0])
}
function scale(e, t) {
  return e * (t[1] - t[0]) + t[0]
}
var OrdinalScale = (function (e) {
  function t(t) {
    var i = e.call(this, t) || this
    i.type = 'ordinal'
    var r = i.getSetting('ordinalMeta')
    return (
      r || (r = new OrdinalMeta({})),
      isArray$1(r) &&
        (r = new OrdinalMeta({
          categories: map$1(r, function (e) {
            return isObject$7(e) ? e.value : e
          })
        })),
      (i._ordinalMeta = r),
      (i._extent = i.getSetting('extent') || [0, r.categories.length - 1]),
      i
    )
  }
  return (
    __extends(t, e),
    (t.prototype.parse = function (e) {
      return 'string' == typeof e ? this._ordinalMeta.getOrdinal(e) : Math.round(e)
    }),
    (t.prototype.contain = function (e) {
      return contain((e = this.parse(e)), this._extent) && null != this._ordinalMeta.categories[e]
    }),
    (t.prototype.normalize = function (e) {
      return normalize$2((e = this._getTickNumber(this.parse(e))), this._extent)
    }),
    (t.prototype.scale = function (e) {
      return (e = Math.round(scale(e, this._extent))), this.getRawOrdinalNumber(e)
    }),
    (t.prototype.getTicks = function () {
      for (var e = [], t = this._extent, i = t[0]; i <= t[1]; ) e.push({ value: i }), i++
      return e
    }),
    (t.prototype.getMinorTicks = function (e) {}),
    (t.prototype.setSortInfo = function (e) {
      if (null != e) {
        for (
          var t = e.ordinalNumbers,
            i = (this._ordinalNumbersByTick = []),
            r = (this._ticksByOrdinalNumber = []),
            n = 0,
            a = this._ordinalMeta.categories.length,
            o = Math.min(a, t.length);
          n < o;
          ++n
        ) {
          var s = t[n]
          ;(i[n] = s), (r[s] = n)
        }
        for (var l = 0; n < a; ++n) {
          for (; null != r[l]; ) l++
          i.push(l), (r[l] = n)
        }
      } else this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null
    }),
    (t.prototype._getTickNumber = function (e) {
      var t = this._ticksByOrdinalNumber
      return t && e >= 0 && e < t.length ? t[e] : e
    }),
    (t.prototype.getRawOrdinalNumber = function (e) {
      var t = this._ordinalNumbersByTick
      return t && e >= 0 && e < t.length ? t[e] : e
    }),
    (t.prototype.getLabel = function (e) {
      if (!this.isBlank()) {
        var t = this.getRawOrdinalNumber(e.value),
          i = this._ordinalMeta.categories[t]
        return null == i ? '' : i + ''
      }
    }),
    (t.prototype.count = function () {
      return this._extent[1] - this._extent[0] + 1
    }),
    (t.prototype.unionExtentFromData = function (e, t) {
      this.unionExtent(e.getApproximateExtent(t))
    }),
    (t.prototype.isInExtentRange = function (e) {
      return (e = this._getTickNumber(e)), this._extent[0] <= e && this._extent[1] >= e
    }),
    (t.prototype.getOrdinalMeta = function () {
      return this._ordinalMeta
    }),
    (t.prototype.niceTicks = function () {}),
    (t.prototype.niceExtent = function () {}),
    (t.type = 'ordinal'),
    t
  )
})(Scale)
Scale.registerClass(OrdinalScale)
var roundNumber = round$2,
  IntervalScale = (function (e) {
    function t() {
      var t = (null !== e && e.apply(this, arguments)) || this
      return (t.type = 'interval'), (t._interval = 0), (t._intervalPrecision = 2), t
    }
    return (
      __extends(t, e),
      (t.prototype.parse = function (e) {
        return e
      }),
      (t.prototype.contain = function (e) {
        return contain(e, this._extent)
      }),
      (t.prototype.normalize = function (e) {
        return normalize$2(e, this._extent)
      }),
      (t.prototype.scale = function (e) {
        return scale(e, this._extent)
      }),
      (t.prototype.setExtent = function (e, t) {
        var i = this._extent
        isNaN(e) || (i[0] = parseFloat(e)), isNaN(t) || (i[1] = parseFloat(t))
      }),
      (t.prototype.unionExtent = function (e) {
        var t = this._extent
        e[0] < t[0] && (t[0] = e[0]), e[1] > t[1] && (t[1] = e[1]), this.setExtent(t[0], t[1])
      }),
      (t.prototype.getInterval = function () {
        return this._interval
      }),
      (t.prototype.setInterval = function (e) {
        ;(this._interval = e),
          (this._niceExtent = this._extent.slice()),
          (this._intervalPrecision = getIntervalPrecision(e))
      }),
      (t.prototype.getTicks = function (e) {
        var t = this._interval,
          i = this._extent,
          r = this._niceExtent,
          n = this._intervalPrecision,
          a = []
        if (!t) return a
        i[0] < r[0] && (e ? a.push({ value: roundNumber(r[0] - t, n) }) : a.push({ value: i[0] }))
        for (
          var o = r[0];
          o <= r[1] &&
          (a.push({ value: o }), (o = roundNumber(o + t, n)) !== a[a.length - 1].value);

        )
          if (a.length > 1e4) return []
        var s = a.length ? a[a.length - 1].value : r[1]
        return (
          i[1] > s && (e ? a.push({ value: roundNumber(s + t, n) }) : a.push({ value: i[1] })), a
        )
      }),
      (t.prototype.getMinorTicks = function (e) {
        for (var t = this.getTicks(!0), i = [], r = this.getExtent(), n = 1; n < t.length; n++) {
          for (
            var a = t[n], o = t[n - 1], s = 0, l = [], h = (a.value - o.value) / e;
            s < e - 1;

          ) {
            var u = roundNumber(o.value + (s + 1) * h)
            u > r[0] && u < r[1] && l.push(u), s++
          }
          i.push(l)
        }
        return i
      }),
      (t.prototype.getLabel = function (e, t) {
        if (null == e) return ''
        var i = t && t.precision
        return (
          null == i
            ? (i = getPrecision(e.value) || 0)
            : 'auto' === i && (i = this._intervalPrecision),
          addCommas(roundNumber(e.value, i, !0))
        )
      }),
      (t.prototype.niceTicks = function (e, t, i) {
        e = e || 5
        var r = this._extent,
          n = r[1] - r[0]
        if (isFinite(n)) {
          n < 0 && ((n = -n), r.reverse())
          var a = intervalScaleNiceTicks(r, e, t, i)
          ;(this._intervalPrecision = a.intervalPrecision),
            (this._interval = a.interval),
            (this._niceExtent = a.niceTickExtent)
        }
      }),
      (t.prototype.niceExtent = function (e) {
        var t = this._extent
        if (t[0] === t[1])
          if (0 !== t[0]) {
            var i = t[0]
            e.fixMax || (t[1] += i / 2), (t[0] -= i / 2)
          } else t[1] = 1
        var r = t[1] - t[0]
        isFinite(r) || ((t[0] = 0), (t[1] = 1)),
          this.niceTicks(e.splitNumber, e.minInterval, e.maxInterval)
        var n = this._interval
        e.fixMin || (t[0] = roundNumber(Math.floor(t[0] / n) * n)),
          e.fixMax || (t[1] = roundNumber(Math.ceil(t[1] / n) * n))
      }),
      (t.type = 'interval'),
      t
    )
  })(Scale)
Scale.registerClass(IntervalScale)
var STACK_PREFIX = '__ec_stack_',
  LARGE_BAR_MIN_WIDTH = 0.5,
  LargeArr$1 = 'undefined' != typeof Float32Array ? Float32Array : Array
function getSeriesStackId$1(e) {
  return e.get('stack') || STACK_PREFIX + e.seriesIndex
}
function getAxisKey$1(e) {
  return e.dim + e.index
}
function getLayoutOnAxis(e) {
  var t = [],
    i = e.axis,
    r = 'axis0'
  if ('category' === i.type) {
    for (var n = i.getBandWidth(), a = 0; a < e.count; a++)
      t.push(defaults$1({ bandWidth: n, axisKey: r, stackId: STACK_PREFIX + a }, e))
    var o = doCalBarWidthAndOffset(t),
      s = []
    for (a = 0; a < e.count; a++) {
      var l = o.axis0[STACK_PREFIX + a]
      ;(l.offsetCenter = l.offset + l.width / 2), s.push(l)
    }
    return s
  }
}
function prepareLayoutBarSeries(e, t) {
  var i = []
  return (
    t.eachSeriesByType(e, function (e) {
      isOnCartesian(e) && !isInLargeMode(e) && i.push(e)
    }),
    i
  )
}
function getValueAxesMinGaps(e) {
  var t = {}
  each$i(e, function (e) {
    var i = e.coordinateSystem.getBaseAxis()
    if ('time' === i.type || 'value' === i.type)
      for (
        var r = e.getData(),
          n = i.dim + '_' + i.index,
          a = r.mapDimension(i.dim),
          o = 0,
          s = r.count();
        o < s;
        ++o
      ) {
        var l = r.get(a, o)
        t[n] ? t[n].push(l) : (t[n] = [l])
      }
  })
  var i = {}
  for (var r in t)
    if (t.hasOwnProperty(r)) {
      var n = t[r]
      if (n) {
        n.sort(function (e, t) {
          return e - t
        })
        for (var a = null, o = 1; o < n.length; ++o) {
          var s = n[o] - n[o - 1]
          s > 0 && (a = null === a ? s : Math.min(a, s))
        }
        i[r] = a
      }
    }
  return i
}
function makeColumnLayout(e) {
  var t = getValueAxesMinGaps(e),
    i = []
  return (
    each$i(e, function (e) {
      var r,
        n = e.coordinateSystem.getBaseAxis(),
        a = n.getExtent()
      if ('category' === n.type) r = n.getBandWidth()
      else if ('value' === n.type || 'time' === n.type) {
        var o = n.dim + '_' + n.index,
          s = t[o],
          l = Math.abs(a[1] - a[0]),
          h = n.scale.getExtent(),
          u = Math.abs(h[1] - h[0])
        r = s ? (l / u) * s : l
      } else {
        var p = e.getData()
        r = Math.abs(a[1] - a[0]) / p.count()
      }
      var c = parsePercent$1(e.get('barWidth'), r),
        d = parsePercent$1(e.get('barMaxWidth'), r),
        f = parsePercent$1(e.get('barMinWidth') || 1, r),
        m = e.get('barGap'),
        g = e.get('barCategoryGap')
      i.push({
        bandWidth: r,
        barWidth: c,
        barMaxWidth: d,
        barMinWidth: f,
        barGap: m,
        barCategoryGap: g,
        axisKey: getAxisKey$1(n),
        stackId: getSeriesStackId$1(e)
      })
    }),
    doCalBarWidthAndOffset(i)
  )
}
function doCalBarWidthAndOffset(e) {
  var t = {}
  each$i(e, function (e, i) {
    var r = e.axisKey,
      n = e.bandWidth,
      a = t[r] || {
        bandWidth: n,
        remainedWidth: n,
        autoWidthCount: 0,
        categoryGap: null,
        gap: '20%',
        stacks: {}
      },
      o = a.stacks
    t[r] = a
    var s = e.stackId
    o[s] || a.autoWidthCount++, (o[s] = o[s] || { width: 0, maxWidth: 0 })
    var l = e.barWidth
    l &&
      !o[s].width &&
      ((o[s].width = l), (l = Math.min(a.remainedWidth, l)), (a.remainedWidth -= l))
    var h = e.barMaxWidth
    h && (o[s].maxWidth = h)
    var u = e.barMinWidth
    u && (o[s].minWidth = u)
    var p = e.barGap
    null != p && (a.gap = p)
    var c = e.barCategoryGap
    null != c && (a.categoryGap = c)
  })
  var i = {}
  return (
    each$i(t, function (e, t) {
      i[t] = {}
      var r = e.stacks,
        n = e.bandWidth,
        a = e.categoryGap
      if (null == a) {
        var o = keys(r).length
        a = Math.max(35 - 4 * o, 15) + '%'
      }
      var s = parsePercent$1(a, n),
        l = parsePercent$1(e.gap, 1),
        h = e.remainedWidth,
        u = e.autoWidthCount,
        p = (h - s) / (u + (u - 1) * l)
      ;(p = Math.max(p, 0)),
        each$i(r, function (e) {
          var t = e.maxWidth,
            i = e.minWidth
          if (e.width) {
            r = e.width
            t && (r = Math.min(r, t)),
              i && (r = Math.max(r, i)),
              (e.width = r),
              (h -= r + l * r),
              u--
          } else {
            var r = p
            t && t < r && (r = Math.min(t, h)),
              i && i > r && (r = i),
              r !== p && ((e.width = r), (h -= r + l * r), u--)
          }
        }),
        (p = (h - s) / (u + (u - 1) * l)),
        (p = Math.max(p, 0))
      var c,
        d = 0
      each$i(r, function (e, t) {
        e.width || (e.width = p), (c = e), (d += e.width * (1 + l))
      }),
        c && (d -= c.width * l)
      var f = -d / 2
      each$i(r, function (e, r) {
        ;(i[t][r] = i[t][r] || { bandWidth: n, offset: f, width: e.width }),
          (f += e.width * (1 + l))
      })
    }),
    i
  )
}
function retrieveColumnLayout(e, t, i) {
  if (e && t) {
    var r = e[getAxisKey$1(t)]
    return null != r && null != i ? r[getSeriesStackId$1(i)] : r
  }
}
function layout$3(e, t) {
  var i = prepareLayoutBarSeries(e, t),
    r = makeColumnLayout(i),
    n = {}
  each$i(i, function (e) {
    var t = e.getData(),
      i = e.coordinateSystem,
      a = i.getBaseAxis(),
      o = getSeriesStackId$1(e),
      s = r[getAxisKey$1(a)][o],
      l = s.offset,
      h = s.width,
      u = i.getOtherAxis(a),
      p = e.get('barMinHeight') || 0
    ;(n[o] = n[o] || []), t.setLayout({ bandWidth: s.bandWidth, offset: l, size: h })
    for (
      var c = t.mapDimension(u.dim),
        d = t.mapDimension(a.dim),
        f = isDimensionStacked(t, c),
        m = u.isHorizontal(),
        g = getValueAxisStart(a, u),
        y = 0,
        v = t.count();
      y < v;
      y++
    ) {
      var _ = t.get(c, y),
        x = t.get(d, y),
        S = _ >= 0 ? 'p' : 'n',
        b = g
      f && (n[o][x] || (n[o][x] = { p: g, n: g }), (b = n[o][x][S]))
      var T,
        A = void 0,
        w = void 0,
        M = void 0,
        C = void 0
      if (m)
        (A = b),
          (w = (T = i.dataToPoint([_, x]))[1] + l),
          (M = T[0] - g),
          (C = h),
          Math.abs(M) < p && (M = (M < 0 ? -1 : 1) * p),
          isNaN(M) || (f && (n[o][x][S] += M))
      else
        (A = (T = i.dataToPoint([x, _]))[0] + l),
          (w = b),
          (M = h),
          (C = T[1] - g),
          Math.abs(C) < p && (C = (C <= 0 ? -1 : 1) * p),
          isNaN(C) || (f && (n[o][x][S] += C))
      t.setItemLayout(y, { x: A, y: w, width: M, height: C })
    }
  })
}
var largeLayout = {
  seriesType: 'bar',
  plan: createRenderPlanner(),
  reset: function (e) {
    if (isOnCartesian(e) && isInLargeMode(e)) {
      var t = e.getData(),
        i = e.coordinateSystem,
        r = i.master.getRect(),
        n = i.getBaseAxis(),
        a = i.getOtherAxis(n),
        o = t.mapDimension(a.dim),
        s = t.mapDimension(n.dim),
        l = a.isHorizontal(),
        h = l ? 0 : 1,
        u = retrieveColumnLayout(makeColumnLayout([e]), n, e).width
      return (
        u > LARGE_BAR_MIN_WIDTH || (u = LARGE_BAR_MIN_WIDTH),
        {
          progress: function (e, t) {
            for (
              var p,
                c = e.count,
                d = new LargeArr$1(2 * c),
                f = new LargeArr$1(2 * c),
                m = new LargeArr$1(c),
                g = [],
                y = [],
                v = 0,
                _ = 0;
              null != (p = e.next());

            )
              (y[h] = t.get(o, p)),
                (y[1 - h] = t.get(s, p)),
                (g = i.dataToPoint(y, null)),
                (f[v] = l ? r.x + r.width : g[0]),
                (d[v++] = g[0]),
                (f[v] = l ? g[1] : r.y + r.height),
                (d[v++] = g[1]),
                (m[_++] = p)
            t.setLayout({
              largePoints: d,
              largeDataIndices: m,
              largeBackgroundPoints: f,
              barWidth: u,
              valueAxisStart: getValueAxisStart(n, a),
              backgroundStart: l ? r.x : r.y,
              valueAxisHorizontal: l
            })
          }
        }
      )
    }
  }
}
function isOnCartesian(e) {
  return e.coordinateSystem && 'cartesian2d' === e.coordinateSystem.type
}
function isInLargeMode(e) {
  return e.pipelineContext && e.pipelineContext.large
}
function getValueAxisStart(e, t, i) {
  return t.toGlobalCoord(t.dataToCoord('log' === t.type ? 1 : 0))
}
var bisect = function (e, t, i, r) {
    for (; i < r; ) {
      var n = (i + r) >>> 1
      e[n][1] < t ? (i = n + 1) : (r = n)
    }
    return i
  },
  TimeScale = (function (e) {
    function t(t) {
      var i = e.call(this, t) || this
      return (i.type = 'time'), i
    }
    return (
      __extends(t, e),
      (t.prototype.getLabel = function (e) {
        var t = this.getSetting('useUTC')
        return format(
          e.value,
          fullLeveledFormatter[
            getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))
          ] || fullLeveledFormatter.second,
          t,
          this.getSetting('locale')
        )
      }),
      (t.prototype.getFormattedLabel = function (e, t, i) {
        var r = this.getSetting('useUTC')
        return leveledFormat(e, t, i, this.getSetting('locale'), r)
      }),
      (t.prototype.getTicks = function (e) {
        var t = this._interval,
          i = this._extent,
          r = []
        if (!t) return r
        r.push({ value: i[0], level: 0 })
        var n = this.getSetting('useUTC'),
          a = getIntervalTicks(this._minLevelUnit, this._approxInterval, n, i)
        return (r = r.concat(a)).push({ value: i[1], level: 0 }), r
      }),
      (t.prototype.niceExtent = function (e) {
        var t = this._extent
        if (
          (t[0] === t[1] && ((t[0] -= ONE_DAY), (t[1] += ONE_DAY)),
          t[1] === -1 / 0 && t[0] === 1 / 0)
        ) {
          var i = new Date()
          ;(t[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate())), (t[0] = t[1] - ONE_DAY)
        }
        this.niceTicks(e.splitNumber, e.minInterval, e.maxInterval)
      }),
      (t.prototype.niceTicks = function (e, t, i) {
        e = e || 10
        var r = this._extent,
          n = r[1] - r[0]
        ;(this._approxInterval = n / e),
          null != t && this._approxInterval < t && (this._approxInterval = t),
          null != i && this._approxInterval > i && (this._approxInterval = i)
        var a = scaleIntervals.length,
          o = Math.min(bisect(scaleIntervals, this._approxInterval, 0, a), a - 1)
        ;(this._interval = scaleIntervals[o][1]),
          (this._minLevelUnit = scaleIntervals[Math.max(o - 1, 0)][0])
      }),
      (t.prototype.parse = function (e) {
        return 'number' == typeof e ? e : +parseDate(e)
      }),
      (t.prototype.contain = function (e) {
        return contain(this.parse(e), this._extent)
      }),
      (t.prototype.normalize = function (e) {
        return normalize$2(this.parse(e), this._extent)
      }),
      (t.prototype.scale = function (e) {
        return scale(e, this._extent)
      }),
      (t.type = 'time'),
      t
    )
  })(IntervalScale),
  scaleIntervals = [
    ['second', ONE_SECOND],
    ['minute', ONE_MINUTE],
    ['hour', ONE_HOUR],
    ['quarter-day', 6 * ONE_HOUR],
    ['half-day', 12 * ONE_HOUR],
    ['day', 1.2 * ONE_DAY],
    ['half-week', 3.5 * ONE_DAY],
    ['week', 7 * ONE_DAY],
    ['month', 31 * ONE_DAY],
    ['quarter', 95 * ONE_DAY],
    ['half-year', ONE_YEAR / 2],
    ['year', ONE_YEAR]
  ]
function isUnitValueSame(e, t, i, r) {
  var n = parseDate(t),
    a = parseDate(i),
    o = function (e) {
      return getUnitValue(n, e, r) === getUnitValue(a, e, r)
    },
    s = function () {
      return o('year')
    },
    l = function () {
      return s() && o('month')
    },
    h = function () {
      return l() && o('day')
    },
    u = function () {
      return h() && o('hour')
    },
    p = function () {
      return u() && o('minute')
    },
    c = function () {
      return p() && o('second')
    }
  switch (e) {
    case 'year':
      return s()
    case 'month':
      return l()
    case 'day':
      return h()
    case 'hour':
      return u()
    case 'minute':
      return p()
    case 'second':
      return c()
    case 'millisecond':
      return c() && o('millisecond')
  }
}
function getDateInterval(e, t) {
  return (e /= ONE_DAY) > 16 ? 16 : e > 7.5 ? 7 : e > 3.5 ? 4 : e > 1.5 ? 2 : 1
}
function getMonthInterval(e) {
  return (e /= 30 * ONE_DAY) > 6 ? 6 : e > 3 ? 3 : e > 2 ? 2 : 1
}
function getHourInterval(e) {
  return (e /= ONE_HOUR) > 12 ? 12 : e > 6 ? 6 : e > 3.5 ? 4 : e > 2 ? 2 : 1
}
function getMinutesAndSecondsInterval(e, t) {
  return (e /= t ? ONE_MINUTE : ONE_SECOND) > 30
    ? 30
    : e > 20
    ? 20
    : e > 15
    ? 15
    : e > 10
    ? 10
    : e > 5
    ? 5
    : e > 2
    ? 2
    : 1
}
function getMillisecondsInterval(e) {
  return nice(e, !0)
}
function getFirstTimestampOfUnit(e, t, i) {
  var r = new Date(e)
  switch (getPrimaryTimeUnit(t)) {
    case 'year':
    case 'month':
      r[monthSetterName(i)](0)
    case 'day':
      r[dateSetterName(i)](1)
    case 'hour':
      r[hoursSetterName(i)](0)
    case 'minute':
      r[minutesSetterName(i)](0)
    case 'second':
      r[secondsSetterName(i)](0), r[millisecondsSetterName(i)](0)
  }
  return r.getTime()
}
function getIntervalTicks(e, t, i, r) {
  var n = timeUnits,
    a = 0
  function o(e, t, i, n, a, o, s) {
    for (var l = new Date(t), h = t, u = l[n](); h < i && h <= r[1]; )
      s.push({ value: h }), (u += e), l[a](u), (h = l.getTime())
    s.push({ value: h, notAdd: !0 })
  }
  function s(e, n, a) {
    var s = [],
      l = !n.length
    if (!isUnitValueSame(getPrimaryTimeUnit(e), r[0], r[1], i)) {
      l && (n = [{ value: getFirstTimestampOfUnit(new Date(r[0]), e, i) }, { value: r[1] }])
      for (var h = 0; h < n.length - 1; h++) {
        var u = n[h].value,
          p = n[h + 1].value
        if (u !== p) {
          var c = void 0,
            d = void 0,
            f = void 0
          switch (e) {
            case 'year':
              ;(c = Math.max(1, Math.round(t / ONE_DAY / 365))),
                (d = fullYearGetterName(i)),
                (f = fullYearSetterName(i))
              break
            case 'half-year':
            case 'quarter':
            case 'month':
              ;(c = getMonthInterval(t)), (d = monthGetterName(i)), (f = monthSetterName(i))
              break
            case 'week':
            case 'half-week':
            case 'day':
              ;(c = getDateInterval(t)), (d = dateGetterName(i)), (f = dateSetterName(i)), !0
              break
            case 'half-day':
            case 'quarter-day':
            case 'hour':
              ;(c = getHourInterval(t)), (d = hoursGetterName(i)), (f = hoursSetterName(i))
              break
            case 'minute':
              ;(c = getMinutesAndSecondsInterval(t, !0)),
                (d = minutesGetterName(i)),
                (f = minutesSetterName(i))
              break
            case 'second':
              ;(c = getMinutesAndSecondsInterval(t, !1)),
                (d = secondsGetterName(i)),
                (f = secondsSetterName(i))
              break
            case 'millisecond':
              ;(c = getMillisecondsInterval(t)),
                (d = millisecondsGetterName(i)),
                (f = millisecondsSetterName(i))
          }
          o(c, u, p, d, f, 0, s),
            'year' === e && a.length > 1 && 0 === h && a.unshift({ value: a[0].value - c })
        }
      }
      for (h = 0; h < s.length; h++) a.push(s[h])
      return s
    }
  }
  for (var l = [], h = [], u = 0, p = 0, c = 0; c < n.length && a++ < 1e4; ++c) {
    var d = getPrimaryTimeUnit(n[c])
    if (isPrimaryTimeUnit(n[c]))
      if (
        (s(n[c], l[l.length - 1] || [], h), d !== (n[c + 1] ? getPrimaryTimeUnit(n[c + 1]) : null))
      ) {
        if (h.length) {
          ;(p = u),
            h.sort(function (e, t) {
              return e.value - t.value
            })
          for (var f = [], m = 0; m < h.length; ++m) {
            var g = h[m].value
            ;(0 !== m && h[m - 1].value === g) || (f.push(h[m]), g >= r[0] && g <= r[1] && u++)
          }
          var y = (r[1] - r[0]) / t
          if (u > 1.5 * y && p > y / 1.5) break
          if ((l.push(f), u > y || e === n[c])) break
        }
        h = []
      }
  }
  var v = filter$1(
      map$1(l, function (e) {
        return filter$1(e, function (e) {
          return e.value >= r[0] && e.value <= r[1] && !e.notAdd
        })
      }),
      function (e) {
        return e.length > 0
      }
    ),
    _ = [],
    x = v.length - 1
  for (c = 0; c < v.length; ++c)
    for (var S = v[c], b = 0; b < S.length; ++b) _.push({ value: S[b].value, level: x - c })
  _.sort(function (e, t) {
    return e.value - t.value
  })
  var T = []
  for (c = 0; c < _.length; ++c) (0 !== c && _[c].value === _[c - 1].value) || T.push(_[c])
  return T
}
Scale.registerClass(TimeScale)
var scaleProto = Scale.prototype,
  intervalScaleProto = IntervalScale.prototype,
  roundingErrorFix = round$2,
  mathFloor$1 = Math.floor,
  mathCeil$1 = Math.ceil,
  mathPow$1 = Math.pow,
  mathLog = Math.log,
  LogScale = (function (e) {
    function t() {
      var t = (null !== e && e.apply(this, arguments)) || this
      return (
        (t.type = 'log'),
        (t.base = 10),
        (t._originalScale = new IntervalScale()),
        (t._interval = 0),
        t
      )
    }
    return (
      __extends(t, e),
      (t.prototype.getTicks = function (e) {
        var t = this._originalScale,
          i = this._extent,
          r = t.getExtent()
        return map$1(
          intervalScaleProto.getTicks.call(this, e),
          function (e) {
            var t = e.value,
              n = round$2(mathPow$1(this.base, t))
            return (
              (n = t === i[0] && this._fixMin ? fixRoundingError(n, r[0]) : n),
              { value: (n = t === i[1] && this._fixMax ? fixRoundingError(n, r[1]) : n) }
            )
          },
          this
        )
      }),
      (t.prototype.setExtent = function (e, t) {
        var i = this.base
        ;(e = mathLog(e) / mathLog(i)),
          (t = mathLog(t) / mathLog(i)),
          intervalScaleProto.setExtent.call(this, e, t)
      }),
      (t.prototype.getExtent = function () {
        var e = this.base,
          t = scaleProto.getExtent.call(this)
        ;(t[0] = mathPow$1(e, t[0])), (t[1] = mathPow$1(e, t[1]))
        var i = this._originalScale.getExtent()
        return (
          this._fixMin && (t[0] = fixRoundingError(t[0], i[0])),
          this._fixMax && (t[1] = fixRoundingError(t[1], i[1])),
          t
        )
      }),
      (t.prototype.unionExtent = function (e) {
        this._originalScale.unionExtent(e)
        var t = this.base
        ;(e[0] = mathLog(e[0]) / mathLog(t)),
          (e[1] = mathLog(e[1]) / mathLog(t)),
          scaleProto.unionExtent.call(this, e)
      }),
      (t.prototype.unionExtentFromData = function (e, t) {
        this.unionExtent(e.getApproximateExtent(t))
      }),
      (t.prototype.niceTicks = function (e) {
        e = e || 10
        var t = this._extent,
          i = t[1] - t[0]
        if (!(i === 1 / 0 || i <= 0)) {
          var r = quantity(i)
          for ((e / i) * r <= 0.5 && (r *= 10); !isNaN(r) && Math.abs(r) < 1 && Math.abs(r) > 0; )
            r *= 10
          var n = [round$2(mathCeil$1(t[0] / r) * r), round$2(mathFloor$1(t[1] / r) * r)]
          ;(this._interval = r), (this._niceExtent = n)
        }
      }),
      (t.prototype.niceExtent = function (e) {
        intervalScaleProto.niceExtent.call(this, e),
          (this._fixMin = e.fixMin),
          (this._fixMax = e.fixMax)
      }),
      (t.prototype.parse = function (e) {
        return e
      }),
      (t.prototype.contain = function (e) {
        return contain((e = mathLog(e) / mathLog(this.base)), this._extent)
      }),
      (t.prototype.normalize = function (e) {
        return normalize$2((e = mathLog(e) / mathLog(this.base)), this._extent)
      }),
      (t.prototype.scale = function (e) {
        return (e = scale(e, this._extent)), mathPow$1(this.base, e)
      }),
      (t.type = 'log'),
      t
    )
  })(Scale),
  proto = LogScale.prototype
function fixRoundingError(e, t) {
  return roundingErrorFix(e, getPrecision(t))
}
;(proto.getMinorTicks = intervalScaleProto.getMinorTicks),
  (proto.getLabel = intervalScaleProto.getLabel),
  Scale.registerClass(LogScale)
var ScaleRawExtentInfo = (function () {
    function e(e, t, i) {
      this._prepareParams(e, t, i)
    }
    return (
      (e.prototype._prepareParams = function (e, t, i) {
        i[1] < i[0] && (i = [NaN, NaN]), (this._dataMin = i[0]), (this._dataMax = i[1])
        var r = (this._isOrdinal = 'ordinal' === e.type)
        this._needCrossZero = t.getNeedCrossZero && t.getNeedCrossZero()
        var n = (this._modelMinRaw = t.get('min', !0))
        isFunction$1(n)
          ? (this._modelMinNum = parseAxisModelMinMax(e, n({ min: i[0], max: i[1] })))
          : 'dataMin' !== n && (this._modelMinNum = parseAxisModelMinMax(e, n))
        var a = (this._modelMaxRaw = t.get('max', !0))
        if (
          (isFunction$1(a)
            ? (this._modelMaxNum = parseAxisModelMinMax(e, a({ min: i[0], max: i[1] })))
            : 'dataMax' !== a && (this._modelMaxNum = parseAxisModelMinMax(e, a)),
          r)
        )
          this._axisDataLen = t.getCategories().length
        else {
          var o = t.get('boundaryGap'),
            s = isArray$1(o) ? o : [o || 0, o || 0]
          'boolean' == typeof s[0] || 'boolean' == typeof s[1]
            ? (this._boundaryGapInner = [0, 0])
            : (this._boundaryGapInner = [parsePercent$2(s[0], 1), parsePercent$2(s[1], 1)])
        }
      }),
      (e.prototype.calculate = function () {
        var e = this._isOrdinal,
          t = this._dataMin,
          i = this._dataMax,
          r = this._axisDataLen,
          n = this._boundaryGapInner,
          a = e ? null : i - t || Math.abs(t),
          o = 'dataMin' === this._modelMinRaw ? t : this._modelMinNum,
          s = 'dataMax' === this._modelMaxRaw ? i : this._modelMaxNum,
          l = null != o,
          h = null != s
        null == o && (o = e ? (r ? 0 : NaN) : t - n[0] * a),
          null == s && (s = e ? (r ? r - 1 : NaN) : i + n[1] * a),
          (null == o || !isFinite(o)) && (o = NaN),
          (null == s || !isFinite(s)) && (s = NaN),
          o > s && ((o = NaN), (s = NaN))
        var u = eqNaN(o) || eqNaN(s) || (e && !r)
        this._needCrossZero && (o > 0 && s > 0 && !l && (o = 0), o < 0 && s < 0 && !h && (s = 0))
        var p = this._determinedMin,
          c = this._determinedMax
        return (
          null != p && ((o = p), (l = !0)),
          null != c && ((s = c), (h = !0)),
          { min: o, max: s, minFixed: l, maxFixed: h, isBlank: u }
        )
      }),
      (e.prototype.modifyDataMinMax = function (e, t) {
        this[DATA_MIN_MAX_ATTR[e]] = t
      }),
      (e.prototype.setDeterminedMinMax = function (e, t) {
        this[DETERMINED_MIN_MAX_ATTR[e]] = t
      }),
      (e.prototype.freeze = function () {
        this.frozen = !0
      }),
      e
    )
  })(),
  DETERMINED_MIN_MAX_ATTR = { min: '_determinedMin', max: '_determinedMax' },
  DATA_MIN_MAX_ATTR = { min: '_dataMin', max: '_dataMax' }
function ensureScaleRawExtentInfo(e, t, i) {
  var r = e.rawExtentInfo
  return r || ((r = new ScaleRawExtentInfo(e, t, i)), (e.rawExtentInfo = r), r)
}
function parseAxisModelMinMax(e, t) {
  return null == t ? null : eqNaN(t) ? NaN : e.parse(t)
}
function getScaleExtent(e, t) {
  var i = e.type,
    r = ensureScaleRawExtentInfo(e, t, e.getExtent()).calculate()
  e.setBlank(r.isBlank)
  var n = r.min,
    a = r.max,
    o = t.ecModel
  if (o && 'time' === i) {
    var s = prepareLayoutBarSeries('bar', o),
      l = !1
    if (
      (each$i(s, function (e) {
        l = l || e.getBaseAxis() === t.axis
      }),
      l)
    ) {
      var h = makeColumnLayout(s),
        u = adjustScaleForOverflow(n, a, t, h)
      ;(n = u.min), (a = u.max)
    }
  }
  return { extent: [n, a], fixMin: r.minFixed, fixMax: r.maxFixed }
}
function adjustScaleForOverflow(e, t, i, r) {
  var n = i.axis.getExtent(),
    a = n[1] - n[0],
    o = retrieveColumnLayout(r, i.axis)
  if (void 0 === o) return { min: e, max: t }
  var s = 1 / 0
  each$i(o, function (e) {
    s = Math.min(e.offset, s)
  })
  var l = -1 / 0
  each$i(o, function (e) {
    l = Math.max(e.offset + e.width, l)
  }),
    (s = Math.abs(s)),
    (l = Math.abs(l))
  var h = s + l,
    u = t - e,
    p = u / (1 - (s + l) / a) - u
  return { min: (e -= p * (s / h)), max: (t += p * (l / h)) }
}
function niceScaleExtent(e, t) {
  var i = getScaleExtent(e, t),
    r = i.extent,
    n = t.get('splitNumber')
  e instanceof LogScale && (e.base = t.get('logBase'))
  var a = e.type
  e.setExtent(r[0], r[1]),
    e.niceExtent({
      splitNumber: n,
      fixMin: i.fixMin,
      fixMax: i.fixMax,
      minInterval: 'interval' === a || 'time' === a ? t.get('minInterval') : null,
      maxInterval: 'interval' === a || 'time' === a ? t.get('maxInterval') : null
    })
  var o = t.get('interval')
  null != o && e.setInterval && e.setInterval(o)
}
function createScaleByModel$1(e, t) {
  if ((t = t || e.get('type')))
    switch (t) {
      case 'category':
        return new OrdinalScale({
          ordinalMeta: e.getOrdinalMeta ? e.getOrdinalMeta() : e.getCategories(),
          extent: [1 / 0, -1 / 0]
        })
      case 'time':
        return new TimeScale({
          locale: e.ecModel.getLocaleModel(),
          useUTC: e.ecModel.get('useUTC')
        })
      default:
        return new (Scale.getClass(t) || IntervalScale)()
    }
}
function ifAxisCrossZero(e) {
  var t = e.scale.getExtent(),
    i = t[0],
    r = t[1]
  return !((i > 0 && r > 0) || (i < 0 && r < 0))
}
function makeLabelFormatter(e) {
  var t,
    i,
    r = e.getLabelModel().get('formatter'),
    n = 'category' === e.type ? e.scale.getExtent()[0] : null
  return 'time' === e.scale.type
    ? ((i = r),
      function (t, r) {
        return e.scale.getFormattedLabel(t, r, i)
      })
    : 'string' == typeof r
    ? (function (t) {
        return function (i) {
          var r = e.scale.getLabel(i)
          return t.replace('{value}', null != r ? r : '')
        }
      })(r)
    : 'function' == typeof r
    ? ((t = r),
      function (i, r) {
        return (
          null != n && (r = i.value - n),
          t(getAxisRawValue(e, i), r, null != i.level ? { level: i.level } : null)
        )
      })
    : function (t) {
        return e.scale.getLabel(t)
      }
}
function getAxisRawValue(e, t) {
  return 'category' === e.type ? e.scale.getLabel(t) : t.value
}
function estimateLabelUnionRect(e) {
  var t = e.model,
    i = e.scale
  if (t.get(['axisLabel', 'show']) && !i.isBlank()) {
    var r,
      n,
      a = i.getExtent()
    n = i instanceof OrdinalScale ? i.count() : (r = i.getTicks()).length
    var o,
      s = e.getLabelModel(),
      l = makeLabelFormatter(e),
      h = 1
    n > 40 && (h = Math.ceil(n / 40))
    for (var u = 0; u < n; u += h) {
      var p = l(r ? r[u] : { value: a[0] + u }, u),
        c = rotateTextRect(s.getTextRect(p), s.get('rotate') || 0)
      o ? o.union(c) : (o = c)
    }
    return o
  }
}
function rotateTextRect(e, t) {
  var i = (t * Math.PI) / 180,
    r = e.width,
    n = e.height,
    a = r * Math.abs(Math.cos(i)) + Math.abs(n * Math.sin(i)),
    o = r * Math.abs(Math.sin(i)) + Math.abs(n * Math.cos(i))
  return new BoundingRect(e.x, e.y, a, o)
}
function getOptionCategoryInterval(e) {
  var t = e.get('interval')
  return null == t ? 'auto' : t
}
function shouldShowAllLabels(e) {
  return 'category' === e.type && 0 === getOptionCategoryInterval(e.getLabelModel())
}
function getDataDimensionsOnAxis(e, t) {
  var i = {}
  return (
    each$i(e.mapDimensionsAll(t), function (t) {
      i[getStackedDimension(e, t)] = !0
    }),
    keys(i)
  )
}
function unionAxisExtentFromData(e, t, i) {
  t &&
    each$i(getDataDimensionsOnAxis(t, i), function (i) {
      var r = t.getApproximateExtent(i)
      r[0] < e[0] && (e[0] = r[0]), r[1] > e[1] && (e[1] = r[1])
    })
}
var AxisModelCommonMixin = (function () {
    function e() {}
    return (
      (e.prototype.getNeedCrossZero = function () {
        return !this.option.scale
      }),
      (e.prototype.getCoordSysModel = function () {}),
      e
    )
  })(),
  inner$h = makeInner()
function createAxisLabels(e) {
  return 'category' === e.type ? makeCategoryLabels(e) : makeRealNumberLabels(e)
}
function createAxisTicks(e, t) {
  return 'category' === e.type
    ? makeCategoryTicks(e, t)
    : {
        ticks: map$1(e.scale.getTicks(), function (e) {
          return e.value
        })
      }
}
function makeCategoryLabels(e) {
  var t = e.getLabelModel(),
    i = makeCategoryLabelsActually(e, t)
  return !t.get('show') || e.scale.isBlank()
    ? { labels: [], labelCategoryInterval: i.labelCategoryInterval }
    : i
}
function makeCategoryLabelsActually(e, t) {
  var i,
    r = getListCache(e, 'labels'),
    n = getOptionCategoryInterval(t),
    a = listCacheGet(r, n)
  return (
    a ||
    listCacheSet(r, n, {
      labels: isFunction$1(n)
        ? makeLabelsByCustomizedCategoryInterval(e, n)
        : makeLabelsByNumericCategoryInterval(
            e,
            (i = 'auto' === n ? makeAutoCategoryInterval(e) : n)
          ),
      labelCategoryInterval: i
    })
  )
}
function makeCategoryTicks(e, t) {
  var i,
    r,
    n = getListCache(e, 'ticks'),
    a = getOptionCategoryInterval(t),
    o = listCacheGet(n, a)
  if (o) return o
  if (((t.get('show') && !e.scale.isBlank()) || (i = []), isFunction$1(a)))
    i = makeLabelsByCustomizedCategoryInterval(e, a, !0)
  else if ('auto' === a) {
    var s = makeCategoryLabelsActually(e, e.getLabelModel())
    ;(r = s.labelCategoryInterval),
      (i = map$1(s.labels, function (e) {
        return e.tickValue
      }))
  } else i = makeLabelsByNumericCategoryInterval(e, (r = a), !0)
  return listCacheSet(n, a, { ticks: i, tickCategoryInterval: r })
}
function makeRealNumberLabels(e) {
  var t = e.scale.getTicks(),
    i = makeLabelFormatter(e)
  return {
    labels: map$1(t, function (t, r) {
      return { formattedLabel: i(t, r), rawLabel: e.scale.getLabel(t), tickValue: t.value }
    })
  }
}
function getListCache(e, t) {
  return inner$h(e)[t] || (inner$h(e)[t] = [])
}
function listCacheGet(e, t) {
  for (var i = 0; i < e.length; i++) if (e[i].key === t) return e[i].value
}
function listCacheSet(e, t, i) {
  return e.push({ key: t, value: i }), i
}
function makeAutoCategoryInterval(e) {
  var t = inner$h(e).autoInterval
  return null != t ? t : (inner$h(e).autoInterval = e.calculateCategoryInterval())
}
function calculateCategoryInterval(e) {
  var t = fetchAutoCategoryIntervalCalculationParams(e),
    i = makeLabelFormatter(e),
    r = ((t.axisRotate - t.labelRotate) / 180) * Math.PI,
    n = e.scale,
    a = n.getExtent(),
    o = n.count()
  if (a[1] - a[0] < 1) return 0
  var s = 1
  o > 40 && (s = Math.max(1, Math.floor(o / 40)))
  for (
    var l = a[0],
      h = e.dataToCoord(l + 1) - e.dataToCoord(l),
      u = Math.abs(h * Math.cos(r)),
      p = Math.abs(h * Math.sin(r)),
      c = 0,
      d = 0;
    l <= a[1];
    l += s
  ) {
    var f,
      m,
      g = getBoundingRect(i({ value: l }), t.font, 'center', 'top')
    ;(f = 1.3 * g.width), (m = 1.3 * g.height), (c = Math.max(c, f, 7)), (d = Math.max(d, m, 7))
  }
  var y = c / u,
    v = d / p
  isNaN(y) && (y = 1 / 0), isNaN(v) && (v = 1 / 0)
  var _ = Math.max(0, Math.floor(Math.min(y, v))),
    x = inner$h(e.model),
    S = e.getExtent(),
    b = x.lastAutoInterval,
    T = x.lastTickCount
  return (
    null != b &&
    null != T &&
    Math.abs(b - _) <= 1 &&
    Math.abs(T - o) <= 1 &&
    b > _ &&
    x.axisExtent0 === S[0] &&
    x.axisExtent1 === S[1]
      ? (_ = b)
      : ((x.lastTickCount = o),
        (x.lastAutoInterval = _),
        (x.axisExtent0 = S[0]),
        (x.axisExtent1 = S[1])),
    _
  )
}
function fetchAutoCategoryIntervalCalculationParams(e) {
  var t = e.getLabelModel()
  return {
    axisRotate: e.getRotate ? e.getRotate() : e.isHorizontal && !e.isHorizontal() ? 90 : 0,
    labelRotate: t.get('rotate') || 0,
    font: t.getFont()
  }
}
function makeLabelsByNumericCategoryInterval(e, t, i) {
  var r = makeLabelFormatter(e),
    n = e.scale,
    a = n.getExtent(),
    o = e.getLabelModel(),
    s = [],
    l = Math.max((t || 0) + 1, 1),
    h = a[0],
    u = n.count()
  0 !== h && l > 1 && u / l > 2 && (h = Math.round(Math.ceil(h / l) * l))
  var p = shouldShowAllLabels(e),
    c = o.get('showMinLabel') || p,
    d = o.get('showMaxLabel') || p
  c && h !== a[0] && m(a[0])
  for (var f = h; f <= a[1]; f += l) m(f)
  function m(e) {
    var t = { value: e }
    s.push(i ? e : { formattedLabel: r(t), rawLabel: n.getLabel(t), tickValue: e })
  }
  return d && f - l !== a[1] && m(a[1]), s
}
function makeLabelsByCustomizedCategoryInterval(e, t, i) {
  var r = e.scale,
    n = makeLabelFormatter(e),
    a = []
  return (
    each$i(r.getTicks(), function (e) {
      var o = r.getLabel(e),
        s = e.value
      t(e.value, o) && a.push(i ? s : { formattedLabel: n(e), rawLabel: o, tickValue: s })
    }),
    a
  )
}
var NORMALIZED_EXTENT = [0, 1],
  Axis = (function () {
    function e(e, t, i) {
      ;(this.onBand = !1),
        (this.inverse = !1),
        (this.dim = e),
        (this.scale = t),
        (this._extent = i || [0, 0])
    }
    return (
      (e.prototype.contain = function (e) {
        var t = this._extent,
          i = Math.min(t[0], t[1]),
          r = Math.max(t[0], t[1])
        return e >= i && e <= r
      }),
      (e.prototype.containData = function (e) {
        return this.scale.contain(e)
      }),
      (e.prototype.getExtent = function () {
        return this._extent.slice()
      }),
      (e.prototype.getPixelPrecision = function (e) {
        return getPixelPrecision(e || this.scale.getExtent(), this._extent)
      }),
      (e.prototype.setExtent = function (e, t) {
        var i = this._extent
        ;(i[0] = e), (i[1] = t)
      }),
      (e.prototype.dataToCoord = function (e, t) {
        var i = this._extent,
          r = this.scale
        return (
          (e = r.normalize(e)),
          this.onBand && 'ordinal' === r.type && fixExtentWithBands((i = i.slice()), r.count()),
          linearMap$2(e, NORMALIZED_EXTENT, i, t)
        )
      }),
      (e.prototype.coordToData = function (e, t) {
        var i = this._extent,
          r = this.scale
        this.onBand && 'ordinal' === r.type && fixExtentWithBands((i = i.slice()), r.count())
        var n = linearMap$2(e, i, NORMALIZED_EXTENT, t)
        return this.scale.scale(n)
      }),
      (e.prototype.pointToData = function (e, t) {}),
      (e.prototype.getTicksCoords = function (e) {
        var t = (e = e || {}).tickModel || this.getTickModel(),
          i = map$1(
            createAxisTicks(this, t).ticks,
            function (e) {
              return {
                coord: this.dataToCoord(
                  'ordinal' === this.scale.type ? this.scale.getRawOrdinalNumber(e) : e
                ),
                tickValue: e
              }
            },
            this
          )
        return fixOnBandTicksCoords(this, i, t.get('alignWithLabel'), e.clamp), i
      }),
      (e.prototype.getMinorTicksCoords = function () {
        if ('ordinal' === this.scale.type) return []
        var e = this.model.getModel('minorTick').get('splitNumber')
        return (
          (e > 0 && e < 100) || (e = 5),
          map$1(
            this.scale.getMinorTicks(e),
            function (e) {
              return map$1(
                e,
                function (e) {
                  return { coord: this.dataToCoord(e), tickValue: e }
                },
                this
              )
            },
            this
          )
        )
      }),
      (e.prototype.getViewLabels = function () {
        return createAxisLabels(this).labels
      }),
      (e.prototype.getLabelModel = function () {
        return this.model.getModel('axisLabel')
      }),
      (e.prototype.getTickModel = function () {
        return this.model.getModel('axisTick')
      }),
      (e.prototype.getBandWidth = function () {
        var e = this._extent,
          t = this.scale.getExtent(),
          i = t[1] - t[0] + (this.onBand ? 1 : 0)
        0 === i && (i = 1)
        var r = Math.abs(e[1] - e[0])
        return Math.abs(r) / i
      }),
      (e.prototype.calculateCategoryInterval = function () {
        return calculateCategoryInterval(this)
      }),
      e
    )
  })()
function fixExtentWithBands(e, t) {
  var i = (e[1] - e[0]) / t / 2
  ;(e[0] += i), (e[1] -= i)
}
function fixOnBandTicksCoords(e, t, i, r) {
  var n = t.length
  if (e.onBand && !i && n) {
    var a,
      o,
      s = e.getExtent()
    if (1 === n) (t[0].coord = s[0]), (a = t[1] = { coord: s[0] })
    else {
      var l = t[n - 1].tickValue - t[0].tickValue,
        h = (t[n - 1].coord - t[0].coord) / l
      each$i(t, function (e) {
        e.coord -= h / 2
      }),
        (o = 1 + e.scale.getExtent()[1] - t[n - 1].tickValue),
        (a = { coord: t[n - 1].coord + h * o }),
        t.push(a)
    }
    var u = s[0] > s[1]
    p(t[0].coord, s[0]) && (r ? (t[0].coord = s[0]) : t.shift()),
      r && p(s[0], t[0].coord) && t.unshift({ coord: s[0] }),
      p(s[1], a.coord) && (r ? (a.coord = s[1]) : t.pop()),
      r && p(a.coord, s[1]) && t.push({ coord: s[1] })
  }
  function p(e, t) {
    return (e = round$2(e)), (t = round$2(t)), u ? e > t : e < t
  }
}
function createElement(e) {
  return document.createElementNS('http://www.w3.org/2000/svg', e)
}
function diff(e, t, i) {
  i ||
    (i = function (e, t) {
      return e === t
    }),
    (e = e.slice())
  var r = (t = t.slice()).length,
    n = e.length,
    a = 1,
    o = r + n,
    s = [{ newPos: -1, components: [] }],
    l = extractCommon(s[0], t, e, 0, i)
  if (s[0].newPos + 1 >= r && l + 1 >= n) {
    for (var h = [], u = 0; u < t.length; u++) h.push(u)
    return [{ indices: h, count: t.length, added: !1, removed: !1 }]
  }
  function p() {
    for (var o = -1 * a; o <= a; o += 2) {
      var l,
        h = s[o - 1],
        u = s[o + 1],
        p = (u ? u.newPos : 0) - o
      h && (s[o - 1] = void 0)
      var c = h && h.newPos + 1 < r,
        d = u && 0 <= p && p < n
      if (c || d) {
        if (
          (!c || (d && h.newPos < u.newPos)
            ? pushComponent((l = clonePath(u)).components, !1, !0)
            : ((l = h).newPos++, pushComponent(l.components, !0, !1)),
          (p = extractCommon(l, t, e, o, i)),
          l.newPos + 1 >= r && p + 1 >= n)
        )
          return buildValues(l.components)
        s[o] = l
      } else s[o] = void 0
    }
    a++
  }
  for (; a <= o; ) {
    var c = p()
    if (c) return c
  }
}
function extractCommon(e, t, i, r, n) {
  for (
    var a = t.length, o = i.length, s = e.newPos, l = s - r, h = 0;
    s + 1 < a && l + 1 < o && n(t[s + 1], i[l + 1]);

  )
    s++, l++, h++
  return (
    h && e.components.push({ count: h, added: !1, removed: !1, indices: [] }), (e.newPos = s), l
  )
}
function pushComponent(e, t, i) {
  var r = e[e.length - 1]
  r && r.added === t && r.removed === i
    ? (e[e.length - 1] = { count: r.count + 1, added: t, removed: i, indices: [] })
    : e.push({ count: 1, added: t, removed: i, indices: [] })
}
function buildValues(e) {
  for (var t = 0, i = e.length, r = 0, n = 0; t < i; t++) {
    var a = e[t]
    if (a.removed) {
      for (s = n; s < n + a.count; s++) a.indices.push(s)
      n += a.count
    } else {
      for (var o = [], s = r; s < r + a.count; s++) o.push(s)
      ;(a.indices = o), (r += a.count), a.added || (n += a.count)
    }
  }
  return e
}
function clonePath(e) {
  return { newPos: e.newPos, components: e.components.slice(0) }
}
function arrayDiff(e, t, i) {
  return diff(e, t, i)
}
var NONE = 'none',
  mathRound = Math.round,
  mathSin = Math.sin,
  mathCos = Math.cos,
  PI$4 = Math.PI,
  PI2$3 = 2 * Math.PI,
  degree = 180 / PI$4,
  EPSILON = 1e-4
function round3(e) {
  return mathRound(1e3 * e) / 1e3
}
function round4(e) {
  return mathRound(1e4 * e) / 1e4
}
function isAroundZero(e) {
  return e < EPSILON && e > -EPSILON
}
function pathHasFill(e) {
  var t = e.fill
  return null != t && t !== NONE
}
function pathHasStroke(e) {
  var t = e.stroke
  return null != t && t !== NONE
}
function setTransform(e, t) {
  t &&
    attr$1(
      e,
      'transform',
      'matrix(' +
        round3(t[0]) +
        ',' +
        round3(t[1]) +
        ',' +
        round3(t[2]) +
        ',' +
        round3(t[3]) +
        ',' +
        round4(t[4]) +
        ',' +
        round4(t[5]) +
        ')'
    )
}
function attr$1(e, t, i) {
  ;(!i || ('linear' !== i.type && 'radial' !== i.type)) && e.setAttribute(t, i)
}
function attrXLink(e, t, i) {
  e.setAttributeNS('http://www.w3.org/1999/xlink', t, i)
}
function attrXML(e, t, i) {
  e.setAttributeNS('http://www.w3.org/XML/1998/namespace', t, i)
}
function bindStyle(e, t, i) {
  var r = null == t.opacity ? 1 : t.opacity
  if (i instanceof ZRImage) e.style.opacity = r + ''
  else {
    if (pathHasFill(t)) {
      var n = t.fill
      attr$1(e, 'fill', (n = 'transparent' === n ? NONE : n)),
        attr$1(e, 'fill-opacity', (null != t.fillOpacity ? t.fillOpacity * r : r) + '')
    } else attr$1(e, 'fill', NONE)
    if (pathHasStroke(t)) {
      var a = t.stroke
      attr$1(e, 'stroke', (a = 'transparent' === a ? NONE : a))
      var o = t.lineWidth,
        s = t.strokeNoScale ? i.getLineScale() : 1
      attr$1(e, 'stroke-width', (s ? o / s : 0) + ''),
        attr$1(e, 'paint-order', t.strokeFirst ? 'stroke' : 'fill'),
        attr$1(e, 'stroke-opacity', (null != t.strokeOpacity ? t.strokeOpacity * r : r) + '')
      var l = t.lineDash && o > 0 && normalizeLineDash(t.lineDash, o)
      if (l) {
        var h = t.lineDashOffset
        s &&
          1 !== s &&
          ((l = map$1(l, function (e) {
            return e / s
          })),
          h && (h = mathRound((h /= s)))),
          attr$1(e, 'stroke-dasharray', l.join(',')),
          attr$1(e, 'stroke-dashoffset', (h || 0) + '')
      } else attr$1(e, 'stroke-dasharray', '')
      t.lineCap && attr$1(e, 'stroke-linecap', t.lineCap),
        t.lineJoin && attr$1(e, 'stroke-linejoin', t.lineJoin),
        t.miterLimit && attr$1(e, 'stroke-miterlimit', t.miterLimit + '')
    } else attr$1(e, 'stroke', NONE)
  }
}
var SVGPathRebuilder = (function () {
    function e() {}
    return (
      (e.prototype.reset = function () {
        ;(this._d = []), (this._str = '')
      }),
      (e.prototype.moveTo = function (e, t) {
        this._add('M', e, t)
      }),
      (e.prototype.lineTo = function (e, t) {
        this._add('L', e, t)
      }),
      (e.prototype.bezierCurveTo = function (e, t, i, r, n, a) {
        this._add('C', e, t, i, r, n, a)
      }),
      (e.prototype.quadraticCurveTo = function (e, t, i, r) {
        this._add('Q', e, t, i, r)
      }),
      (e.prototype.arc = function (e, t, i, r, n, a) {
        this.ellipse(e, t, i, i, 0, r, n, a)
      }),
      (e.prototype.ellipse = function (e, t, i, r, n, a, o, s) {
        var l = 0 === this._d.length,
          h = o - a,
          u = !s,
          p = Math.abs(h),
          c = isAroundZero(p - PI2$3) || (u ? h >= PI2$3 : -h >= PI2$3),
          d = h > 0 ? h % PI2$3 : (h % PI2$3) + PI2$3,
          f = !1
        f = !!c || (!isAroundZero(p) && d >= PI$4 == !!u)
        var m = round4(e + i * mathCos(a)),
          g = round4(t + r * mathSin(a))
        c && ((h = u ? PI2$3 - 1e-4 : 1e-4 - PI2$3), (f = !0), l && this._d.push('M', m, g))
        var y = round4(e + i * mathCos(a + h)),
          v = round4(t + r * mathSin(a + h))
        if (
          isNaN(m) ||
          isNaN(g) ||
          isNaN(i) ||
          isNaN(r) ||
          isNaN(n) ||
          isNaN(degree) ||
          isNaN(y) ||
          isNaN(v)
        )
          return ''
        this._d.push('A', round4(i), round4(r), mathRound(n * degree), +f, +u, y, v)
      }),
      (e.prototype.rect = function (e, t, i, r) {
        this._add('M', e, t),
          this._add('L', e + i, t),
          this._add('L', e + i, t + r),
          this._add('L', e, t + r),
          this._add('L', e, t)
      }),
      (e.prototype.closePath = function () {
        this._d.length > 0 && this._add('Z')
      }),
      (e.prototype._add = function (e, t, i, r, n, a, o, s, l) {
        this._d.push(e)
        for (var h = 1; h < arguments.length; h++) {
          var u = arguments[h]
          if (isNaN(u)) return void (this._invalid = !0)
          this._d.push(round4(u))
        }
      }),
      (e.prototype.generateStr = function () {
        ;(this._str = this._invalid ? '' : this._d.join(' ')), (this._d = [])
      }),
      (e.prototype.getStr = function () {
        return this._str
      }),
      e
    )
  })(),
  svgPath = {
    brush: function (e) {
      var t = e.style,
        i = e.__svgEl
      i || ((i = createElement('path')), (e.__svgEl = i)), e.path || e.createPathProxy()
      var r = e.path
      e.shapeChanged() && (r.beginPath(), e.buildPath(r, e.shape), e.pathUpdated())
      var n = r.getVersion(),
        a = e,
        o = a.__svgPathBuilder
      ;(a.__svgPathVersion !== n || !o || e.style.strokePercent < 1) &&
        (o || (o = a.__svgPathBuilder = new SVGPathRebuilder()),
        o.reset(),
        r.rebuildPath(o, e.style.strokePercent),
        o.generateStr(),
        (a.__svgPathVersion = n)),
        attr$1(i, 'd', o.getStr()),
        bindStyle(i, t, e),
        setTransform(i, e.transform)
    }
  },
  svgImage = {
    brush: function (e) {
      var t = e.style,
        i = t.image
      if (
        (i instanceof HTMLImageElement
          ? (i = i.src)
          : i instanceof HTMLCanvasElement && (i = i.toDataURL()),
        i)
      ) {
        var r = t.x || 0,
          n = t.y || 0,
          a = t.width,
          o = t.height,
          s = e.__svgEl
        s || ((s = createElement('image')), (e.__svgEl = s)),
          i !== e.__imageSrc && (attrXLink(s, 'href', i), (e.__imageSrc = i)),
          attr$1(s, 'width', a + ''),
          attr$1(s, 'height', o + ''),
          attr$1(s, 'x', r + ''),
          attr$1(s, 'y', n + ''),
          bindStyle(s, t, e),
          setTransform(s, e.transform)
      }
    }
  },
  TEXT_ALIGN_TO_ANCHOR = { left: 'start', right: 'end', center: 'middle', middle: 'middle' }
function adjustTextY(e, t, i) {
  return 'top' === i ? (e += t / 2) : 'bottom' === i && (e -= t / 2), e
}
var svgText = {
    brush: function (e) {
      var t = e.style,
        i = t.text
      if ((null != i && (i += ''), i && !isNaN(t.x) && !isNaN(t.y))) {
        var r = e.__svgEl
        r || (attrXML((r = createElement('text')), 'xml:space', 'preserve'), (e.__svgEl = r))
        var n = t.font || DEFAULT_FONT
        ;(r.style.font = n), (r.textContent = i), bindStyle(r, t, e), setTransform(r, e.transform)
        var a = t.x || 0,
          o = adjustTextY(t.y || 0, getLineHeight(n), t.textBaseline),
          s = TEXT_ALIGN_TO_ANCHOR[t.textAlign] || t.textAlign
        attr$1(r, 'dominant-baseline', 'central'),
          attr$1(r, 'text-anchor', s),
          attr$1(r, 'x', a + ''),
          attr$1(r, 'y', o + '')
      }
    }
  },
  MARK_UNUSED = '0',
  MARK_USED = '1',
  Definable = (function () {
    function e(e, t, i, r, n) {
      ;(this.nextId = 0),
        (this._domName = '_dom'),
        (this.createElement = createElement),
        (this._zrId = e),
        (this._svgRoot = t),
        (this._tagNames = 'string' == typeof i ? [i] : i),
        (this._markLabel = r),
        n && (this._domName = n)
    }
    return (
      (e.prototype.getDefs = function (e) {
        var t = this._svgRoot,
          i = this._svgRoot.getElementsByTagName('defs')
        if (0 === i.length) {
          if (e) {
            var r = t.insertBefore(this.createElement('defs'), t.firstChild)
            return (
              r.contains ||
                (r.contains = function (e) {
                  var t = r.children
                  if (!t) return !1
                  for (var i = t.length - 1; i >= 0; --i) if (t[i] === e) return !0
                  return !1
                }),
              r
            )
          }
          return null
        }
        return i[0]
      }),
      (e.prototype.doUpdate = function (e, t) {
        if (e) {
          var i = this.getDefs(!1)
          if (e[this._domName] && i.contains(e[this._domName])) 'function' == typeof t && t(e)
          else {
            var r = this.add(e)
            r && (e[this._domName] = r)
          }
        }
      }),
      (e.prototype.add = function (e) {
        return null
      }),
      (e.prototype.addDom = function (e) {
        var t = this.getDefs(!0)
        e.parentNode !== t && t.appendChild(e)
      }),
      (e.prototype.removeDom = function (e) {
        var t = this.getDefs(!1)
        t && e[this._domName] && (t.removeChild(e[this._domName]), (e[this._domName] = null))
      }),
      (e.prototype.getDoms = function () {
        var e = this.getDefs(!1)
        if (!e) return []
        var t = []
        return (
          each$i(this._tagNames, function (i) {
            for (var r = e.getElementsByTagName(i), n = 0; n < r.length; n++) t.push(r[n])
          }),
          t
        )
      }),
      (e.prototype.markAllUnused = function () {
        var e = this.getDoms(),
          t = this
        each$i(e, function (e) {
          e[t._markLabel] = MARK_UNUSED
        })
      }),
      (e.prototype.markDomUsed = function (e) {
        e && (e[this._markLabel] = MARK_USED)
      }),
      (e.prototype.markDomUnused = function (e) {
        e && (e[this._markLabel] = MARK_UNUSED)
      }),
      (e.prototype.isDomUnused = function (e) {
        return e && e[this._markLabel] !== MARK_USED
      }),
      (e.prototype.removeUnused = function () {
        var e = this,
          t = this.getDefs(!1)
        t &&
          each$i(this.getDoms(), function (i) {
            e.isDomUnused(i) && t.removeChild(i)
          })
      }),
      (e.prototype.getSvgProxy = function (e) {
        return e instanceof Path
          ? svgPath
          : e instanceof ZRImage
          ? svgImage
          : e instanceof TSpan
          ? svgText
          : svgPath
      }),
      (e.prototype.getSvgElement = function (e) {
        return e.__svgEl
      }),
      e
    )
  })()
function isLinearGradient(e) {
  return 'linear' === e.type
}
function isRadialGradient(e) {
  return 'radial' === e.type
}
function isGradient(e) {
  return e && ('linear' === e.type || 'radial' === e.type)
}
var GradientManager = (function (e) {
  function t(t, i) {
    return e.call(this, t, i, ['linearGradient', 'radialGradient'], '__gradient_in_use__') || this
  }
  return (
    __extends(t, e),
    (t.prototype.addWithoutUpdate = function (e, t) {
      if (t && t.style) {
        var i = this
        each$i(['fill', 'stroke'], function (r) {
          var n = t.style[r]
          if (isGradient(n)) {
            var a = n,
              o = i.getDefs(!0),
              s = void 0
            a.__dom ? ((s = a.__dom), o.contains(a.__dom) || i.addDom(s)) : (s = i.add(a)),
              i.markUsed(t)
            var l = s.getAttribute('id')
            e.setAttribute(r, 'url(#' + l + ')')
          }
        })
      }
    }),
    (t.prototype.add = function (e) {
      var t
      if (isLinearGradient(e)) t = this.createElement('linearGradient')
      else {
        if (!isRadialGradient(e)) return logError('Illegal gradient type.'), null
        t = this.createElement('radialGradient')
      }
      return (
        (e.id = e.id || this.nextId++),
        t.setAttribute('id', 'zr' + this._zrId + '-gradient-' + e.id),
        this.updateDom(e, t),
        this.addDom(t),
        t
      )
    }),
    (t.prototype.update = function (e) {
      if (isGradient(e)) {
        var t = this
        this.doUpdate(e, function () {
          var i = e.__dom
          if (i) {
            var r = i.tagName,
              n = e.type
            ;('linear' === n && 'linearGradient' === r) ||
            ('radial' === n && 'radialGradient' === r)
              ? t.updateDom(e, e.__dom)
              : (t.removeDom(e), t.add(e))
          }
        })
      }
    }),
    (t.prototype.updateDom = function (e, t) {
      if (isLinearGradient(e))
        t.setAttribute('x1', e.x + ''),
          t.setAttribute('y1', e.y + ''),
          t.setAttribute('x2', e.x2 + ''),
          t.setAttribute('y2', e.y2 + '')
      else {
        if (!isRadialGradient(e)) return void logError('Illegal gradient type.')
        t.setAttribute('cx', e.x + ''),
          t.setAttribute('cy', e.y + ''),
          t.setAttribute('r', e.r + '')
      }
      e.global
        ? t.setAttribute('gradientUnits', 'userSpaceOnUse')
        : t.setAttribute('gradientUnits', 'objectBoundingBox'),
        (t.innerHTML = '')
      for (var i = e.colorStops, r = 0, n = i.length; r < n; ++r) {
        var a = this.createElement('stop')
        a.setAttribute('offset', 100 * i[r].offset + '%')
        var o = i[r].color
        if (o.indexOf('rgba') > -1) {
          var s = parse(o)[3],
            l = toHex(o)
          a.setAttribute('stop-color', '#' + l), a.setAttribute('stop-opacity', s + '')
        } else a.setAttribute('stop-color', i[r].color)
        t.appendChild(a)
      }
      e.__dom = t
    }),
    (t.prototype.markUsed = function (t) {
      if (t.style) {
        var i = t.style.fill
        i && i.__dom && e.prototype.markDomUsed.call(this, i.__dom),
          (i = t.style.stroke) && i.__dom && e.prototype.markDomUsed.call(this, i.__dom)
      }
    }),
    t
  )
})(Definable)
function isPattern(e) {
  return e && (!!e.image || !!e.svgElement)
}
var patternDomMap = new WeakMap(),
  PatternManager = (function (e) {
    function t(t, i) {
      return e.call(this, t, i, ['pattern'], '__pattern_in_use__') || this
    }
    return (
      __extends(t, e),
      (t.prototype.addWithoutUpdate = function (e, t) {
        if (t && t.style) {
          var i = this
          each$i(['fill', 'stroke'], function (r) {
            var n = t.style[r]
            if (isPattern(n)) {
              var a = i.getDefs(!0),
                o = patternDomMap.get(n)
              o ? a.contains(o) || i.addDom(o) : (o = i.add(n)), i.markUsed(t)
              var s = o.getAttribute('id')
              e.setAttribute(r, 'url(#' + s + ')')
            }
          })
        }
      }),
      (t.prototype.add = function (e) {
        if (isPattern(e)) {
          var t = this.createElement('pattern')
          return (
            (e.id = null == e.id ? this.nextId++ : e.id),
            t.setAttribute('id', 'zr' + this._zrId + '-pattern-' + e.id),
            t.setAttribute('x', '0'),
            t.setAttribute('y', '0'),
            t.setAttribute('patternUnits', 'userSpaceOnUse'),
            this.updateDom(e, t),
            this.addDom(t),
            t
          )
        }
      }),
      (t.prototype.update = function (e) {
        if (isPattern(e)) {
          var t = this
          this.doUpdate(e, function () {
            var i = patternDomMap.get(e)
            t.updateDom(e, i)
          })
        }
      }),
      (t.prototype.updateDom = function (e, t) {
        var i = e.svgElement
        if (i instanceof SVGElement)
          i.parentNode !== t &&
            ((t.innerHTML = ''),
            t.appendChild(i),
            t.setAttribute('width', e.svgWidth + ''),
            t.setAttribute('height', e.svgHeight + ''))
        else {
          var r = void 0,
            n = t.getElementsByTagName('image')
          if (n.length) {
            if (!e.image) return void t.removeChild(n[0])
            r = n[0]
          } else e.image && (r = this.createElement('image'))
          if (r) {
            var a = void 0,
              o = e.image
            if (
              ('string' == typeof o
                ? (a = o)
                : o instanceof HTMLImageElement
                ? (a = o.src)
                : o instanceof HTMLCanvasElement && (a = o.toDataURL()),
              a)
            ) {
              r.setAttribute('href', a), r.setAttribute('x', '0'), r.setAttribute('y', '0')
              var s = createOrUpdateImage(a, r, { dirty: function () {} }, function (e) {
                t.setAttribute('width', e.width + ''), t.setAttribute('height', e.height + '')
              })
              s &&
                s.width &&
                s.height &&
                (t.setAttribute('width', s.width + ''), t.setAttribute('height', s.height + '')),
                t.appendChild(r)
            }
          }
        }
        var l =
          'translate(' +
          (e.x || 0) +
          ', ' +
          (e.y || 0) +
          ') rotate(' +
          ((e.rotation || 0) / Math.PI) * 180 +
          ') scale(' +
          (e.scaleX || 1) +
          ', ' +
          (e.scaleY || 1) +
          ')'
        t.setAttribute('patternTransform', l), patternDomMap.set(e, t)
      }),
      (t.prototype.markUsed = function (t) {
        t.style &&
          (isPattern(t.style.fill) &&
            e.prototype.markDomUsed.call(this, patternDomMap.get(t.style.fill)),
          isPattern(t.style.stroke) &&
            e.prototype.markDomUsed.call(this, patternDomMap.get(t.style.stroke)))
      }),
      t
    )
  })(Definable)
function generateClipPathsKey(e) {
  var t = []
  if (e)
    for (var i = 0; i < e.length; i++) {
      var r = e[i]
      t.push(r.id)
    }
  return t.join(',')
}
function hasClipPath(e) {
  var t = e.__clipPaths
  return t && t.length > 0
}
var ClippathManager = (function (e) {
    function t(t, i) {
      var r = e.call(this, t, i, 'clipPath', '__clippath_in_use__') || this
      return (r._refGroups = {}), (r._keyDuplicateCount = {}), r
    }
    return (
      __extends(t, e),
      (t.prototype.markAllUnused = function () {
        for (var t in (e.prototype.markAllUnused.call(this), this._refGroups))
          this.markDomUnused(this._refGroups[t])
        this._keyDuplicateCount = {}
      }),
      (t.prototype._getClipPathGroup = function (e, t) {
        if (hasClipPath(e)) {
          var i = e.__clipPaths,
            r = this._keyDuplicateCount,
            n = generateClipPathsKey(i)
          return (
            isClipPathChanged(i, t && t.__clipPaths) &&
              ((r[n] = r[n] || 0), r[n] && (n += '-' + r[n]), r[n]++),
            this._refGroups[n] || (this._refGroups[n] = this.createElement('g'))
          )
        }
      }),
      (t.prototype.update = function (e, t) {
        var i = this._getClipPathGroup(e, t)
        return i && (this.markDomUsed(i), this.updateDom(i, e.__clipPaths)), i
      }),
      (t.prototype.updateDom = function (e, t) {
        if (t && t.length > 0) {
          var i = this.getDefs(!0),
            r = t[0],
            n = void 0,
            a = void 0
          r._dom
            ? ((a = r._dom.getAttribute('id')), (n = r._dom), i.contains(n) || i.appendChild(n))
            : ((a = 'zr' + this._zrId + '-clip-' + this.nextId),
              ++this.nextId,
              (n = this.createElement('clipPath')).setAttribute('id', a),
              i.appendChild(n),
              (r._dom = n)),
            this.getSvgProxy(r).brush(r)
          var o = this.getSvgElement(r)
          ;(n.innerHTML = ''),
            n.appendChild(o),
            e.setAttribute('clip-path', 'url(#' + a + ')'),
            t.length > 1 && this.updateDom(n, t.slice(1))
        } else e && e.setAttribute('clip-path', 'none')
      }),
      (t.prototype.markUsed = function (t) {
        var i = this
        t.__clipPaths &&
          each$i(t.__clipPaths, function (t) {
            t._dom && e.prototype.markDomUsed.call(i, t._dom)
          })
      }),
      (t.prototype.removeUnused = function () {
        e.prototype.removeUnused.call(this)
        var t = {}
        for (var i in this._refGroups) {
          var r = this._refGroups[i]
          this.isDomUnused(r) ? r.parentNode && r.parentNode.removeChild(r) : (t[i] = r)
        }
        this._refGroups = t
      }),
      t
    )
  })(Definable),
  ShadowManager = (function (e) {
    function t(t, i) {
      var r = e.call(this, t, i, ['filter'], '__filter_in_use__', '_shadowDom') || this
      return (r._shadowDomMap = {}), (r._shadowDomPool = []), r
    }
    return (
      __extends(t, e),
      (t.prototype._getFromPool = function () {
        var e = this._shadowDomPool.pop()
        if (!e) {
          ;(e = this.createElement('filter')).setAttribute(
            'id',
            'zr' + this._zrId + '-shadow-' + this.nextId++
          )
          var t = this.createElement('feDropShadow')
          e.appendChild(t), this.addDom(e)
        }
        return e
      }),
      (t.prototype.update = function (e, t) {
        if (hasShadow(t.style)) {
          var i = getShadowKey(t),
            r = (t._shadowDom = this._shadowDomMap[i])
          r || ((r = this._getFromPool()), (this._shadowDomMap[i] = r)), this.updateDom(e, t, r)
        } else this.remove(e, t)
      }),
      (t.prototype.remove = function (e, t) {
        null != t._shadowDom && ((t._shadowDom = null), (e.style.filter = ''))
      }),
      (t.prototype.updateDom = function (e, t, i) {
        var r = i.children[0],
          n = t.style,
          a = t.getGlobalScale(),
          o = a[0],
          s = a[1]
        if (o && s) {
          var l = n.shadowOffsetX || 0,
            h = n.shadowOffsetY || 0,
            u = n.shadowBlur,
            p = n.shadowColor
          r.setAttribute('dx', l / o + ''),
            r.setAttribute('dy', h / s + ''),
            r.setAttribute('flood-color', p)
          var c = u / 2 / o + ' ' + u / 2 / s
          r.setAttribute('stdDeviation', c),
            i.setAttribute('x', '-100%'),
            i.setAttribute('y', '-100%'),
            i.setAttribute('width', '300%'),
            i.setAttribute('height', '300%'),
            (t._shadowDom = i)
          var d = i.getAttribute('id')
          e.style.filter = 'url(#' + d + ')'
        }
      }),
      (t.prototype.removeUnused = function () {
        if (this.getDefs(!1)) {
          var e = this._shadowDomPool
          for (var t in this._shadowDomMap) {
            var i = this._shadowDomMap[t]
            e.push(i)
          }
          this._shadowDomMap = {}
        }
      }),
      t
    )
  })(Definable)
function hasShadow(e) {
  return e && (e.shadowBlur || e.shadowOffsetX || e.shadowOffsetY)
}
function getShadowKey(e) {
  var t = e.style,
    i = e.getGlobalScale()
  return [
    t.shadowColor,
    (t.shadowBlur || 0).toFixed(2),
    (t.shadowOffsetX || 0).toFixed(2),
    (t.shadowOffsetY || 0).toFixed(2),
    i[0],
    i[1]
  ].join(',')
}
function parseInt10$1(e) {
  return parseInt(e, 10)
}
function getSvgProxy(e) {
  return e instanceof Path
    ? svgPath
    : e instanceof ZRImage
    ? svgImage
    : e instanceof TSpan
    ? svgText
    : svgPath
}
function checkParentAvailable(e, t) {
  return t && e && t.parentNode !== e
}
function insertAfter(e, t, i) {
  if (checkParentAvailable(e, t) && i) {
    var r = i.nextSibling
    r ? e.insertBefore(t, r) : e.appendChild(t)
  }
}
function prepend$1(e, t) {
  if (checkParentAvailable(e, t)) {
    var i = e.firstChild
    i ? e.insertBefore(t, i) : e.appendChild(t)
  }
}
function remove$1(e, t) {
  t && e && t.parentNode === e && e.removeChild(t)
}
function removeFromMyParent(e) {
  e && e.parentNode && e.parentNode.removeChild(e)
}
function getSvgElement(e) {
  return e.__svgEl
}
var SVGPainter = (function () {
  function e(e, t, i, r) {
    ;(this.type = 'svg'),
      (this.refreshHover = createMethodNotSupport('refreshHover')),
      (this.pathToImage = createMethodNotSupport('pathToImage')),
      (this.configLayer = createMethodNotSupport('configLayer')),
      (this.root = e),
      (this.storage = t),
      (this._opts = i = extend$3({}, i || {}))
    var n = createElement('svg')
    n.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns', 'http://www.w3.org/2000/svg'),
      n.setAttributeNS(
        'http://www.w3.org/2000/xmlns/',
        'xmlns:xlink',
        'http://www.w3.org/1999/xlink'
      ),
      n.setAttribute('version', '1.1'),
      n.setAttribute('baseProfile', 'full'),
      (n.style.cssText = 'user-select:none;position:absolute;left:0;top:0;')
    var a = createElement('g')
    n.appendChild(a)
    var o = createElement('g')
    n.appendChild(o),
      (this._gradientManager = new GradientManager(r, o)),
      (this._patternManager = new PatternManager(r, o)),
      (this._clipPathManager = new ClippathManager(r, o)),
      (this._shadowManager = new ShadowManager(r, o))
    var s = document.createElement('div')
    ;(s.style.cssText = 'overflow:hidden;position:relative'),
      (this._svgDom = n),
      (this._svgRoot = o),
      (this._backgroundRoot = a),
      (this._viewport = s),
      e.appendChild(s),
      s.appendChild(n),
      this.resize(i.width, i.height),
      (this._visibleList = [])
  }
  return (
    (e.prototype.getType = function () {
      return 'svg'
    }),
    (e.prototype.getViewportRoot = function () {
      return this._viewport
    }),
    (e.prototype.getSvgDom = function () {
      return this._svgDom
    }),
    (e.prototype.getSvgRoot = function () {
      return this._svgRoot
    }),
    (e.prototype.getViewportRootOffset = function () {
      var e = this.getViewportRoot()
      if (e) return { offsetLeft: e.offsetLeft || 0, offsetTop: e.offsetTop || 0 }
    }),
    (e.prototype.refresh = function () {
      var e = this.storage.getDisplayList(!0)
      this._paintList(e)
    }),
    (e.prototype.setBackgroundColor = function (e) {
      this._backgroundRoot &&
        this._backgroundNode &&
        this._backgroundRoot.removeChild(this._backgroundNode)
      var t = createElement('rect')
      t.setAttribute('width', this.getWidth()),
        t.setAttribute('height', this.getHeight()),
        t.setAttribute('x', 0),
        t.setAttribute('y', 0),
        t.setAttribute('id', 0),
        (t.style.fill = e),
        this._backgroundRoot.appendChild(t),
        (this._backgroundNode = t)
    }),
    (e.prototype.createSVGElement = function (e) {
      return createElement(e)
    }),
    (e.prototype.paintOne = function (e) {
      var t = getSvgProxy(e)
      return t && t.brush(e), getSvgElement(e)
    }),
    (e.prototype._paintList = function (e) {
      var t = this._gradientManager,
        i = this._patternManager,
        r = this._clipPathManager,
        n = this._shadowManager
      t.markAllUnused(), i.markAllUnused(), r.markAllUnused(), n.markAllUnused()
      for (var a = this._svgRoot, o = this._visibleList, s = e.length, l = [], h = 0; h < s; h++) {
        var u = getSvgProxy((_ = e[h])),
          p = getSvgElement(_)
        _.invisible ||
          ((!_.__dirty && p) ||
            (u && u.brush(_),
            (p = getSvgElement(_)) &&
              _.style &&
              (t.update(_.style.fill),
              t.update(_.style.stroke),
              i.update(_.style.fill),
              i.update(_.style.stroke),
              n.update(p, _)),
            (_.__dirty = 0)),
          p && l.push(_))
      }
      var c,
        d,
        f,
        m,
        g = arrayDiff(o, l)
      for (h = 0; h < g.length; h++) {
        if ((v = g[h]).removed)
          for (var y = 0; y < v.count; y++) {
            p = getSvgElement((_ = o[v.indices[y]]))
            hasClipPath(_) ? removeFromMyParent(p) : remove$1(a, p)
          }
      }
      for (h = 0; h < g.length; h++) {
        var v
        if (!(v = g[h]).removed)
          for (y = 0; y < v.count; y++) {
            var _ = l[v.indices[y]],
              x = r.update(_, f)
            x !== m &&
              ((c = d),
              x && (c ? insertAfter(a, x, c) : prepend$1(a, x), (d = x), (c = null)),
              (m = x))
            p = getSvgElement(_)
            c ? insertAfter(m || a, p, c) : prepend$1(m || a, p),
              (c = p || c),
              m || (d = c),
              t.markUsed(_),
              t.addWithoutUpdate(p, _),
              i.markUsed(_),
              i.addWithoutUpdate(p, _),
              r.markUsed(_),
              (f = _)
          }
      }
      t.removeUnused(),
        i.removeUnused(),
        r.removeUnused(),
        n.removeUnused(),
        (this._visibleList = l)
    }),
    (e.prototype.resize = function (e, t) {
      var i = this._viewport
      i.style.display = 'none'
      var r = this._opts
      if (
        (null != e && (r.width = e),
        null != t && (r.height = t),
        (e = this._getSize(0)),
        (t = this._getSize(1)),
        (i.style.display = ''),
        this._width !== e || this._height !== t)
      ) {
        ;(this._width = e), (this._height = t)
        var n = i.style
        ;(n.width = e + 'px'), (n.height = t + 'px')
        var a = this._svgDom
        a.setAttribute('width', e + ''), a.setAttribute('height', t + '')
      }
      this._backgroundNode &&
        (this._backgroundNode.setAttribute('width', e),
        this._backgroundNode.setAttribute('height', t))
    }),
    (e.prototype.getWidth = function () {
      return this._width
    }),
    (e.prototype.getHeight = function () {
      return this._height
    }),
    (e.prototype._getSize = function (e) {
      var t = this._opts,
        i = ['width', 'height'][e],
        r = ['clientWidth', 'clientHeight'][e],
        n = ['paddingLeft', 'paddingTop'][e],
        a = ['paddingRight', 'paddingBottom'][e]
      if (null != t[i] && 'auto' !== t[i]) return parseFloat(t[i])
      var o = this.root,
        s = document.defaultView.getComputedStyle(o)
      return (
        ((o[r] || parseInt10$1(s[i]) || parseInt10$1(o.style[i])) -
          (parseInt10$1(s[n]) || 0) -
          (parseInt10$1(s[a]) || 0)) |
        0
      )
    }),
    (e.prototype.dispose = function () {
      ;(this.root.innerHTML = ''),
        (this._svgRoot =
          this._backgroundRoot =
          this._svgDom =
          this._backgroundNode =
          this._viewport =
          this.storage =
            null)
    }),
    (e.prototype.clear = function () {
      var e = this._viewport
      e && e.parentNode && e.parentNode.removeChild(e)
    }),
    (e.prototype.toDataURL = function () {
      this.refresh()
      var e = this._svgDom,
        t = e.outerHTML || (e.parentNode && e.parentNode).innerHTML
      return 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(t.replace(/></g, '>\n\r<'))
    }),
    e
  )
})()
function createMethodNotSupport(e) {
  return function () {
    logError('In SVG mode painter not support method "' + e + '"')
  }
}
function install$S(e) {
  e.registerPainter('svg', SVGPainter)
}
function returnFalse() {
  return !1
}
function createDom(e, t, i) {
  var r = createCanvas(),
    n = t.getWidth(),
    a = t.getHeight(),
    o = r.style
  return (
    o &&
      ((o.position = 'absolute'),
      (o.left = '0'),
      (o.top = '0'),
      (o.width = n + 'px'),
      (o.height = a + 'px'),
      r.setAttribute('data-zr-dom-id', e)),
    (r.width = n * i),
    (r.height = a * i),
    r
  )
}
var Layer = (function (e) {
    function t(t, i, r) {
      var n,
        a = e.call(this) || this
      ;(a.motionBlur = !1),
        (a.lastFrameAlpha = 0.7),
        (a.dpr = 1),
        (a.virtual = !1),
        (a.config = {}),
        (a.incremental = !1),
        (a.zlevel = 0),
        (a.maxRepaintRectCount = 5),
        (a.__dirty = !0),
        (a.__firstTimePaint = !0),
        (a.__used = !1),
        (a.__drawIndex = 0),
        (a.__startIndex = 0),
        (a.__endIndex = 0),
        (a.__prevStartIndex = null),
        (a.__prevEndIndex = null),
        (r = r || devicePixelRatio),
        'string' == typeof t ? (n = createDom(t, i, r)) : isObject$7(t) && (t = (n = t).id),
        (a.id = t),
        (a.dom = n)
      var o = n.style
      return (
        o &&
          ((n.onselectstart = returnFalse),
          (o.webkitUserSelect = 'none'),
          (o.userSelect = 'none'),
          (o.webkitTapHighlightColor = 'rgba(0,0,0,0)'),
          (o['-webkit-touch-callout'] = 'none'),
          (o.padding = '0'),
          (o.margin = '0'),
          (o.borderWidth = '0')),
        (a.domBack = null),
        (a.ctxBack = null),
        (a.painter = i),
        (a.config = null),
        (a.dpr = r),
        a
      )
    }
    return (
      __extends(t, e),
      (t.prototype.getElementCount = function () {
        return this.__endIndex - this.__startIndex
      }),
      (t.prototype.afterBrush = function () {
        ;(this.__prevStartIndex = this.__startIndex), (this.__prevEndIndex = this.__endIndex)
      }),
      (t.prototype.initContext = function () {
        ;(this.ctx = this.dom.getContext('2d')), (this.ctx.dpr = this.dpr)
      }),
      (t.prototype.setUnpainted = function () {
        this.__firstTimePaint = !0
      }),
      (t.prototype.createBackBuffer = function () {
        var e = this.dpr
        ;(this.domBack = createDom('back-' + this.id, this.painter, e)),
          (this.ctxBack = this.domBack.getContext('2d')),
          1 !== e && this.ctxBack.scale(e, e)
      }),
      (t.prototype.createRepaintRects = function (e, t, i, r) {
        if (this.__firstTimePaint) return (this.__firstTimePaint = !1), null
        var n,
          a = [],
          o = this.maxRepaintRectCount,
          s = !1,
          l = new BoundingRect(0, 0, 0, 0)
        function h(e) {
          if (e.isFinite() && !e.isZero())
            if (0 === a.length) {
              ;(t = new BoundingRect(0, 0, 0, 0)).copy(e), a.push(t)
            } else {
              for (var t, i = !1, r = 1 / 0, n = 0, h = 0; h < a.length; ++h) {
                var u = a[h]
                if (u.intersect(e)) {
                  var p = new BoundingRect(0, 0, 0, 0)
                  p.copy(u), p.union(e), (a[h] = p), (i = !0)
                  break
                }
                if (s) {
                  l.copy(e), l.union(u)
                  var c = e.width * e.height,
                    d = u.width * u.height,
                    f = l.width * l.height - c - d
                  f < r && ((r = f), (n = h))
                }
              }
              if ((s && (a[n].union(e), (i = !0)), !i))
                (t = new BoundingRect(0, 0, 0, 0)).copy(e), a.push(t)
              s || (s = a.length >= o)
            }
        }
        for (var u = this.__startIndex; u < this.__endIndex; ++u) {
          if ((d = e[u])) {
            var p = d.shouldBePainted(i, r, !0, !0)
            ;(f =
              d.__isRendered && (d.__dirty & REDARAW_BIT || !p) ? d.getPrevPaintRect() : null) &&
              h(f)
            var c = p && (d.__dirty & REDARAW_BIT || !d.__isRendered) ? d.getPaintRect() : null
            c && h(c)
          }
        }
        for (u = this.__prevStartIndex; u < this.__prevEndIndex; ++u) {
          var d, f
          p = (d = t[u]).shouldBePainted(i, r, !0, !0)
          if (d && (!p || !d.__zr) && d.__isRendered) (f = d.getPrevPaintRect()) && h(f)
        }
        do {
          n = !1
          for (u = 0; u < a.length; )
            if (a[u].isZero()) a.splice(u, 1)
            else {
              for (var m = u + 1; m < a.length; )
                a[u].intersect(a[m]) ? ((n = !0), a[u].union(a[m]), a.splice(m, 1)) : m++
              u++
            }
        } while (n)
        return (this._paintRects = a), a
      }),
      (t.prototype.debugGetPaintRects = function () {
        return (this._paintRects || []).slice()
      }),
      (t.prototype.resize = function (e, t) {
        var i = this.dpr,
          r = this.dom,
          n = r.style,
          a = this.domBack
        n && ((n.width = e + 'px'), (n.height = t + 'px')),
          (r.width = e * i),
          (r.height = t * i),
          a && ((a.width = e * i), (a.height = t * i), 1 !== i && this.ctxBack.scale(i, i))
      }),
      (t.prototype.clear = function (e, t, i) {
        var r = this.dom,
          n = this.ctx,
          a = r.width,
          o = r.height
        t = t || this.clearColor
        var s = this.motionBlur && !e,
          l = this.lastFrameAlpha,
          h = this.dpr,
          u = this
        s &&
          (this.domBack || this.createBackBuffer(),
          (this.ctxBack.globalCompositeOperation = 'copy'),
          this.ctxBack.drawImage(r, 0, 0, a / h, o / h))
        var p = this.domBack
        function c(e, i, r, a) {
          if ((n.clearRect(e, i, r, a), t && 'transparent' !== t)) {
            var o = void 0
            isGradientObject(t)
              ? ((o =
                  t.__canvasGradient ||
                  getCanvasGradient(n, t, { x: 0, y: 0, width: r, height: a })),
                (t.__canvasGradient = o))
              : isImagePatternObject(t) &&
                (o = createCanvasPattern(n, t, {
                  dirty: function () {
                    u.setUnpainted(), u.__painter.refresh()
                  }
                })),
              n.save(),
              (n.fillStyle = o || t),
              n.fillRect(e, i, r, a),
              n.restore()
          }
          s && (n.save(), (n.globalAlpha = l), n.drawImage(p, e, i, r, a), n.restore())
        }
        !i || s
          ? c(0, 0, a, o)
          : i.length &&
            each$i(i, function (e) {
              c(e.x * h, e.y * h, e.width * h, e.height * h)
            })
      }),
      t
    )
  })(Eventful),
  HOVER_LAYER_ZLEVEL = 1e5,
  CANVAS_ZLEVEL = 314159,
  EL_AFTER_INCREMENTAL_INC = 0.01,
  INCREMENTAL_INC = 0.001
function parseInt10(e) {
  return parseInt(e, 10)
}
function isLayerValid(e) {
  return (
    !!e && (!!e.__builtin__ || ('function' == typeof e.resize && 'function' == typeof e.refresh))
  )
}
function createRoot(e, t) {
  var i = document.createElement('div')
  return (
    (i.style.cssText =
      [
        'position:relative',
        'width:' + e + 'px',
        'height:' + t + 'px',
        'padding:0',
        'margin:0',
        'border-width:0'
      ].join(';') + ';'),
    i
  )
}
var CanvasPainter = (function () {
  function e(e, t, i, r) {
    ;(this.type = 'canvas'),
      (this._zlevelList = []),
      (this._prevDisplayList = []),
      (this._layers = {}),
      (this._layerConfig = {}),
      (this._needsManuallyCompositing = !1),
      (this.type = 'canvas')
    var n = !e.nodeName || 'CANVAS' === e.nodeName.toUpperCase()
    ;(this._opts = i = extend$3({}, i || {})),
      (this.dpr = i.devicePixelRatio || devicePixelRatio),
      (this._singleCanvas = n),
      (this.root = e)
    var a = e.style
    a &&
      ((a.webkitTapHighlightColor = 'transparent'),
      (a.webkitUserSelect = 'none'),
      (a.userSelect = 'none'),
      (a['-webkit-touch-callout'] = 'none'),
      (e.innerHTML = '')),
      (this.storage = t)
    var o = this._zlevelList
    this._prevDisplayList = []
    var s = this._layers
    if (n) {
      var l = e,
        h = l.width,
        u = l.height
      null != i.width && (h = i.width),
        null != i.height && (u = i.height),
        (this.dpr = i.devicePixelRatio || 1),
        (l.width = h * this.dpr),
        (l.height = u * this.dpr),
        (this._width = h),
        (this._height = u)
      var p = new Layer(l, this, this.dpr)
      ;(p.__builtin__ = !0),
        p.initContext(),
        (s[CANVAS_ZLEVEL] = p),
        (p.zlevel = CANVAS_ZLEVEL),
        o.push(CANVAS_ZLEVEL),
        (this._domRoot = e)
    } else {
      ;(this._width = this._getSize(0)), (this._height = this._getSize(1))
      var c = (this._domRoot = createRoot(this._width, this._height))
      e.appendChild(c)
    }
  }
  return (
    (e.prototype.getType = function () {
      return 'canvas'
    }),
    (e.prototype.isSingleCanvas = function () {
      return this._singleCanvas
    }),
    (e.prototype.getViewportRoot = function () {
      return this._domRoot
    }),
    (e.prototype.getViewportRootOffset = function () {
      var e = this.getViewportRoot()
      if (e) return { offsetLeft: e.offsetLeft || 0, offsetTop: e.offsetTop || 0 }
    }),
    (e.prototype.refresh = function (e) {
      var t = this.storage.getDisplayList(!0),
        i = this._prevDisplayList,
        r = this._zlevelList
      ;(this._redrawId = Math.random()), this._paintList(t, i, e, this._redrawId)
      for (var n = 0; n < r.length; n++) {
        var a = r[n],
          o = this._layers[a]
        if (!o.__builtin__ && o.refresh) {
          var s = 0 === n ? this._backgroundColor : null
          o.refresh(s)
        }
      }
      return this._opts.useDirtyRect && (this._prevDisplayList = t.slice()), this
    }),
    (e.prototype.refreshHover = function () {
      this._paintHoverList(this.storage.getDisplayList(!1))
    }),
    (e.prototype._paintHoverList = function (e) {
      var t = e.length,
        i = this._hoverlayer
      if ((i && i.clear(), t)) {
        for (
          var r, n = { inHover: !0, viewWidth: this._width, viewHeight: this._height }, a = 0;
          a < t;
          a++
        ) {
          var o = e[a]
          o.__inHover &&
            (i || (i = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL)),
            r || (r = i.ctx).save(),
            brush(r, o, n, a === t - 1))
        }
        r && r.restore()
      }
    }),
    (e.prototype.getHoverLayer = function () {
      return this.getLayer(HOVER_LAYER_ZLEVEL)
    }),
    (e.prototype.paintOne = function (e, t) {
      brushSingle(e, t)
    }),
    (e.prototype._paintList = function (e, t, i, r) {
      if (this._redrawId === r) {
        ;(i = i || !1), this._updateLayerStatus(e)
        var n = this._doPaintList(e, t, i),
          a = n.finished,
          o = n.needsRefreshHover
        if (
          (this._needsManuallyCompositing && this._compositeManually(),
          o && this._paintHoverList(e),
          a)
        )
          this.eachLayer(function (e) {
            e.afterBrush && e.afterBrush()
          })
        else {
          var s = this
          requestAnimationFrame$1(function () {
            s._paintList(e, t, i, r)
          })
        }
      }
    }),
    (e.prototype._compositeManually = function () {
      var e = this.getLayer(CANVAS_ZLEVEL).ctx,
        t = this._domRoot.width,
        i = this._domRoot.height
      e.clearRect(0, 0, t, i),
        this.eachBuiltinLayer(function (r) {
          r.virtual && e.drawImage(r.dom, 0, 0, t, i)
        })
    }),
    (e.prototype._doPaintList = function (e, t, i) {
      for (
        var r = this, n = [], a = this._opts.useDirtyRect, o = 0;
        o < this._zlevelList.length;
        o++
      ) {
        var s = this._zlevelList[o],
          l = this._layers[s]
        l.__builtin__ && l !== this._hoverlayer && (l.__dirty || i) && n.push(l)
      }
      for (
        var h = !0,
          u = !1,
          p = function (o) {
            var s,
              l = n[o],
              p = l.ctx,
              d = a && l.createRepaintRects(e, t, c._width, c._height),
              f = i ? l.__startIndex : l.__drawIndex,
              m = !i && l.incremental && Date.now,
              g = m && Date.now(),
              y = l.zlevel === c._zlevelList[0] ? c._backgroundColor : null
            if (l.__startIndex === l.__endIndex) l.clear(!1, y, d)
            else if (f === l.__startIndex) {
              var v = e[f]
              ;(v.incremental && v.notClear && !i) || l.clear(!1, y, d)
            }
            ;-1 === f &&
              (console.error('For some unknown reason. drawIndex is -1'), (f = l.__startIndex))
            var _ = function (t) {
              var i = {
                inHover: !1,
                allClipped: !1,
                prevEl: null,
                viewWidth: r._width,
                viewHeight: r._height
              }
              for (s = f; s < l.__endIndex; s++) {
                var n = e[s]
                if (
                  (n.__inHover && (u = !0), r._doPaintEl(n, l, a, t, i, s === l.__endIndex - 1), m)
                )
                  if (Date.now() - g > 15) break
              }
              i.prevElClipPaths && p.restore()
            }
            if (d)
              if (0 === d.length) s = l.__endIndex
              else
                for (var x = c.dpr, S = 0; S < d.length; ++S) {
                  var b = d[S]
                  p.save(),
                    p.beginPath(),
                    p.rect(b.x * x, b.y * x, b.width * x, b.height * x),
                    p.clip(),
                    _(b),
                    p.restore()
                }
            else p.save(), _(), p.restore()
            ;(l.__drawIndex = s), l.__drawIndex < l.__endIndex && (h = !1)
          },
          c = this,
          d = 0;
        d < n.length;
        d++
      )
        p(d)
      return (
        env.wxa &&
          each$i(this._layers, function (e) {
            e && e.ctx && e.ctx.draw && e.ctx.draw()
          }),
        { finished: h, needsRefreshHover: u }
      )
    }),
    (e.prototype._doPaintEl = function (e, t, i, r, n, a) {
      var o = t.ctx
      if (i) {
        var s = e.getPaintRect()
        ;(!r || (s && s.intersect(r))) && (brush(o, e, n, a), e.setPrevPaintRect(s))
      } else brush(o, e, n, a)
    }),
    (e.prototype.getLayer = function (e, t) {
      this._singleCanvas && !this._needsManuallyCompositing && (e = CANVAS_ZLEVEL)
      var i = this._layers[e]
      return (
        i ||
          (((i = new Layer('zr_' + e, this, this.dpr)).zlevel = e),
          (i.__builtin__ = !0),
          this._layerConfig[e]
            ? merge(i, this._layerConfig[e], !0)
            : this._layerConfig[e - EL_AFTER_INCREMENTAL_INC] &&
              merge(i, this._layerConfig[e - EL_AFTER_INCREMENTAL_INC], !0),
          t && (i.virtual = t),
          this.insertLayer(e, i),
          i.initContext()),
        i
      )
    }),
    (e.prototype.insertLayer = function (e, t) {
      var i = this._layers,
        r = this._zlevelList,
        n = r.length,
        a = this._domRoot,
        o = null,
        s = -1
      if (i[e]) logError('ZLevel ' + e + ' has been used already')
      else if (isLayerValid(t)) {
        if (n > 0 && e > r[0]) {
          for (s = 0; s < n - 1 && !(r[s] < e && r[s + 1] > e); s++);
          o = i[r[s]]
        }
        if ((r.splice(s + 1, 0, e), (i[e] = t), !t.virtual))
          if (o) {
            var l = o.dom
            l.nextSibling ? a.insertBefore(t.dom, l.nextSibling) : a.appendChild(t.dom)
          } else a.firstChild ? a.insertBefore(t.dom, a.firstChild) : a.appendChild(t.dom)
        t.__painter = this
      } else logError('Layer of zlevel ' + e + ' is not valid')
    }),
    (e.prototype.eachLayer = function (e, t) {
      for (var i = this._zlevelList, r = 0; r < i.length; r++) {
        var n = i[r]
        e.call(t, this._layers[n], n)
      }
    }),
    (e.prototype.eachBuiltinLayer = function (e, t) {
      for (var i = this._zlevelList, r = 0; r < i.length; r++) {
        var n = i[r],
          a = this._layers[n]
        a.__builtin__ && e.call(t, a, n)
      }
    }),
    (e.prototype.eachOtherLayer = function (e, t) {
      for (var i = this._zlevelList, r = 0; r < i.length; r++) {
        var n = i[r],
          a = this._layers[n]
        a.__builtin__ || e.call(t, a, n)
      }
    }),
    (e.prototype.getLayers = function () {
      return this._layers
    }),
    (e.prototype._updateLayerStatus = function (e) {
      function t(e) {
        a && (a.__endIndex !== e && (a.__dirty = !0), (a.__endIndex = e))
      }
      if (
        (this.eachBuiltinLayer(function (e, t) {
          e.__dirty = e.__used = !1
        }),
        this._singleCanvas)
      )
        for (var i = 1; i < e.length; i++) {
          if ((s = e[i]).zlevel !== e[i - 1].zlevel || s.incremental) {
            this._needsManuallyCompositing = !0
            break
          }
        }
      var r,
        n,
        a = null,
        o = 0
      for (n = 0; n < e.length; n++) {
        var s,
          l = (s = e[n]).zlevel,
          h = void 0
        r !== l && ((r = l), (o = 0)),
          s.incremental
            ? (((h = this.getLayer(
                l + INCREMENTAL_INC,
                this._needsManuallyCompositing
              )).incremental = !0),
              (o = 1))
            : (h = this.getLayer(
                l + (o > 0 ? EL_AFTER_INCREMENTAL_INC : 0),
                this._needsManuallyCompositing
              )),
          h.__builtin__ || logError('ZLevel ' + l + ' has been used by unkown layer ' + h.id),
          h !== a &&
            ((h.__used = !0),
            h.__startIndex !== n && (h.__dirty = !0),
            (h.__startIndex = n),
            h.incremental ? (h.__drawIndex = -1) : (h.__drawIndex = n),
            t(n),
            (a = h)),
          s.__dirty & REDARAW_BIT &&
            !s.__inHover &&
            ((h.__dirty = !0), h.incremental && h.__drawIndex < 0 && (h.__drawIndex = n))
      }
      t(n),
        this.eachBuiltinLayer(function (e, t) {
          !e.__used &&
            e.getElementCount() > 0 &&
            ((e.__dirty = !0), (e.__startIndex = e.__endIndex = e.__drawIndex = 0)),
            e.__dirty && e.__drawIndex < 0 && (e.__drawIndex = e.__startIndex)
        })
    }),
    (e.prototype.clear = function () {
      return this.eachBuiltinLayer(this._clearLayer), this
    }),
    (e.prototype._clearLayer = function (e) {
      e.clear()
    }),
    (e.prototype.setBackgroundColor = function (e) {
      ;(this._backgroundColor = e),
        each$i(this._layers, function (e) {
          e.setUnpainted()
        })
    }),
    (e.prototype.configLayer = function (e, t) {
      if (t) {
        var i = this._layerConfig
        i[e] ? merge(i[e], t, !0) : (i[e] = t)
        for (var r = 0; r < this._zlevelList.length; r++) {
          var n = this._zlevelList[r]
          if (n === e || n === e + EL_AFTER_INCREMENTAL_INC) merge(this._layers[n], i[e], !0)
        }
      }
    }),
    (e.prototype.delLayer = function (e) {
      var t = this._layers,
        i = this._zlevelList,
        r = t[e]
      r && (r.dom.parentNode.removeChild(r.dom), delete t[e], i.splice(indexOf$1(i, e), 1))
    }),
    (e.prototype.resize = function (e, t) {
      if (this._domRoot.style) {
        var i = this._domRoot
        i.style.display = 'none'
        var r = this._opts
        if (
          (null != e && (r.width = e),
          null != t && (r.height = t),
          (e = this._getSize(0)),
          (t = this._getSize(1)),
          (i.style.display = ''),
          this._width !== e || t !== this._height)
        ) {
          for (var n in ((i.style.width = e + 'px'), (i.style.height = t + 'px'), this._layers))
            this._layers.hasOwnProperty(n) && this._layers[n].resize(e, t)
          this.refresh(!0)
        }
        ;(this._width = e), (this._height = t)
      } else {
        if (null == e || null == t) return
        ;(this._width = e), (this._height = t), this.getLayer(CANVAS_ZLEVEL).resize(e, t)
      }
      return this
    }),
    (e.prototype.clearLayer = function (e) {
      var t = this._layers[e]
      t && t.clear()
    }),
    (e.prototype.dispose = function () {
      ;(this.root.innerHTML = ''), (this.root = this.storage = this._domRoot = this._layers = null)
    }),
    (e.prototype.getRenderedCanvas = function (e) {
      if (((e = e || {}), this._singleCanvas && !this._compositeManually))
        return this._layers[CANVAS_ZLEVEL].dom
      var t = new Layer('image', this, e.pixelRatio || this.dpr)
      t.initContext(), t.clear(!1, e.backgroundColor || this._backgroundColor)
      var i = t.ctx
      if (e.pixelRatio <= this.dpr) {
        this.refresh()
        var r = t.dom.width,
          n = t.dom.height
        this.eachLayer(function (e) {
          e.__builtin__
            ? i.drawImage(e.dom, 0, 0, r, n)
            : e.renderToCanvas && (i.save(), e.renderToCanvas(i), i.restore())
        })
      } else
        for (
          var a = { inHover: !1, viewWidth: this._width, viewHeight: this._height },
            o = this.storage.getDisplayList(!0),
            s = 0,
            l = o.length;
          s < l;
          s++
        ) {
          var h = o[s]
          brush(i, h, a, s === l - 1)
        }
      return t.dom
    }),
    (e.prototype.getWidth = function () {
      return this._width
    }),
    (e.prototype.getHeight = function () {
      return this._height
    }),
    (e.prototype._getSize = function (e) {
      var t = this._opts,
        i = ['width', 'height'][e],
        r = ['clientWidth', 'clientHeight'][e],
        n = ['paddingLeft', 'paddingTop'][e],
        a = ['paddingRight', 'paddingBottom'][e]
      if (null != t[i] && 'auto' !== t[i]) return parseFloat(t[i])
      var o = this.root,
        s = document.defaultView.getComputedStyle(o)
      return (
        ((o[r] || parseInt10(s[i]) || parseInt10(o.style[i])) -
          (parseInt10(s[n]) || 0) -
          (parseInt10(s[a]) || 0)) |
        0
      )
    }),
    (e.prototype.pathToImage = function (e, t) {
      t = t || this.dpr
      var i = document.createElement('canvas'),
        r = i.getContext('2d'),
        n = e.getBoundingRect(),
        a = e.style,
        o = a.shadowBlur * t,
        s = a.shadowOffsetX * t,
        l = a.shadowOffsetY * t,
        h = e.hasStroke() ? a.lineWidth : 0,
        u = Math.max(h / 2, -s + o),
        p = Math.max(h / 2, s + o),
        c = Math.max(h / 2, -l + o),
        d = Math.max(h / 2, l + o),
        f = n.width + u + p,
        m = n.height + c + d
      ;(i.width = f * t), (i.height = m * t), r.scale(t, t), r.clearRect(0, 0, f, m), (r.dpr = t)
      var g = {
        x: e.x,
        y: e.y,
        scaleX: e.scaleX,
        scaleY: e.scaleY,
        rotation: e.rotation,
        originX: e.originX,
        originY: e.originY
      }
      ;(e.x = u - n.x),
        (e.y = c - n.y),
        (e.rotation = 0),
        (e.scaleX = 1),
        (e.scaleY = 1),
        e.updateTransform(),
        e && brush(r, e, { inHover: !1, viewWidth: this._width, viewHeight: this._height }, !0)
      var y = new ZRImage({ style: { x: 0, y: 0, image: i } })
      return extend$3(e, g), y
    }),
    e
  )
})()
function install$R(e) {
  e.registerPainter('canvas', CanvasPainter)
}
var LineSeriesModel = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), (i.hasSymbolVisual = !0), i
  }
  return (
    __extends(t, e),
    (t.prototype.getInitialData = function (e) {
      return createListFromArray(this.getSource(), this, { useEncodeDefaulter: !0 })
    }),
    (t.prototype.getLegendIcon = function (e) {
      var t = new Group$3(),
        i = createSymbol$1('line', 0, e.itemHeight / 2, e.itemWidth, 0, e.lineStyle.stroke, !1)
      t.add(i), i.setStyle(e.lineStyle)
      var r = this.getData().getVisual('symbol'),
        n = this.getData().getVisual('symbolRotate'),
        a = 'none' === r ? 'circle' : r,
        o = 0.8 * e.itemHeight,
        s = createSymbol$1(a, (e.itemWidth - o) / 2, (e.itemHeight - o) / 2, o, o, e.itemStyle.fill)
      t.add(s), s.setStyle(e.itemStyle)
      var l = 'inherit' === e.iconRotate ? n : e.iconRotate || 0
      return (
        (s.rotation = (l * Math.PI) / 180),
        s.setOrigin([e.itemWidth / 2, e.itemHeight / 2]),
        a.indexOf('empty') > -1 &&
          ((s.style.stroke = s.style.fill), (s.style.fill = '#fff'), (s.style.lineWidth = 2)),
        t
      )
    }),
    (t.type = 'series.line'),
    (t.dependencies = ['grid', 'polar']),
    (t.defaultOption = {
      zlevel: 0,
      z: 3,
      coordinateSystem: 'cartesian2d',
      legendHoverLink: !0,
      clip: !0,
      label: { position: 'top' },
      endLabel: { show: !1, valueAnimation: !0, distance: 8 },
      lineStyle: { width: 2, type: 'solid' },
      emphasis: { scale: !0, lineStyle: { width: 'bolder' } },
      step: !1,
      smooth: !1,
      smoothMonotone: null,
      symbol: 'emptyCircle',
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: !0,
      showAllSymbol: 'auto',
      connectNulls: !1,
      sampling: 'none',
      animationEasing: 'linear',
      progressive: 0,
      hoverLayerThreshold: 1 / 0
    }),
    t
  )
})(SeriesModel)
function getDefaultLabel(e, t) {
  var i = e.mapDimensionsAll('defaultedLabel'),
    r = i.length
  if (1 === r) {
    var n = retrieveRawValue(e, t, i[0])
    return null != n ? n + '' : null
  }
  if (r) {
    for (var a = [], o = 0; o < i.length; o++) a.push(retrieveRawValue(e, t, i[o]))
    return a.join(' ')
  }
}
function getDefaultInterpolatedLabel(e, t) {
  var i = e.mapDimensionsAll('defaultedLabel')
  if (!isArray$1(t)) return t + ''
  for (var r = [], n = 0; n < i.length; n++) {
    var a = e.getDimensionInfo(i[n])
    a && r.push(t[a.index])
  }
  return r.join(' ')
}
var Symbol$1 = (function (e) {
  function t(t, i, r, n) {
    var a = e.call(this) || this
    return a.updateData(t, i, r, n), a
  }
  return (
    __extends(t, e),
    (t.prototype._createSymbol = function (e, t, i, r, n) {
      this.removeAll()
      var a = createSymbol$1(e, -1, -1, 2, 2, null, n)
      a.attr({ z2: 100, culling: !0, scaleX: r[0] / 2, scaleY: r[1] / 2 }),
        (a.drift = driftSymbol),
        (this._symbolType = e),
        this.add(a)
    }),
    (t.prototype.stopSymbolAnimation = function (e) {
      this.childAt(0).stopAnimation(null, e)
    }),
    (t.prototype.getSymbolPath = function () {
      return this.childAt(0)
    }),
    (t.prototype.highlight = function () {
      enterEmphasis(this.childAt(0))
    }),
    (t.prototype.downplay = function () {
      leaveEmphasis(this.childAt(0))
    }),
    (t.prototype.setZ = function (e, t) {
      var i = this.childAt(0)
      ;(i.zlevel = e), (i.z = t)
    }),
    (t.prototype.setDraggable = function (e) {
      var t = this.childAt(0)
      ;(t.draggable = e), (t.cursor = e ? 'move' : t.cursor)
    }),
    (t.prototype.updateData = function (e, i, r, n) {
      this.silent = !1
      var a = e.getItemVisual(i, 'symbol') || 'circle',
        o = e.hostModel,
        s = t.getSymbolSize(e, i),
        l = a !== this._symbolType,
        h = n && n.disableAnimation
      if (l) {
        var u = e.getItemVisual(i, 'symbolKeepAspect')
        this._createSymbol(a, e, i, s, u)
      } else {
        ;(c = this.childAt(0)).silent = !1
        var p = { scaleX: s[0] / 2, scaleY: s[1] / 2 }
        h ? c.attr(p) : updateProps$1(c, p, o, i)
      }
      if ((this._updateCommon(e, i, s, r, n), l)) {
        var c = this.childAt(0)
        if (!h) {
          p = { scaleX: this._sizeX, scaleY: this._sizeY, style: { opacity: c.style.opacity } }
          ;(c.scaleX = c.scaleY = 0), (c.style.opacity = 0), initProps(c, p, o, i)
        }
      }
      h && this.childAt(0).stopAnimation('remove'), (this._seriesModel = o)
    }),
    (t.prototype._updateCommon = function (e, t, i, r, n) {
      var a,
        o,
        s,
        l,
        h,
        u,
        p,
        c,
        d = this.childAt(0),
        f = e.hostModel
      if (
        (r &&
          ((a = r.emphasisItemStyle),
          (o = r.blurItemStyle),
          (s = r.selectItemStyle),
          (l = r.focus),
          (h = r.blurScope),
          (u = r.labelStatesModels),
          (p = r.hoverScale),
          (c = r.cursorStyle)),
        !r || e.hasItemOption)
      ) {
        var m = r && r.itemModel ? r.itemModel : e.getItemModel(t),
          g = m.getModel('emphasis')
        ;(a = g.getModel('itemStyle').getItemStyle()),
          (s = m.getModel(['select', 'itemStyle']).getItemStyle()),
          (o = m.getModel(['blur', 'itemStyle']).getItemStyle()),
          (l = g.get('focus')),
          (h = g.get('blurScope')),
          (u = getLabelStatesModels(m)),
          (p = g.getShallow('scale')),
          (c = m.getShallow('cursor'))
      }
      var y = e.getItemVisual(t, 'symbolRotate')
      d.attr('rotation', ((y || 0) * Math.PI) / 180 || 0)
      var v = e.getItemVisual(t, 'symbolOffset') || 0
      v &&
        (isArray$1(v) || (v = [v, v]),
        (d.x = parsePercent$1(v[0], i[0])),
        (d.y = parsePercent$1(retrieve2(v[1], v[0]) || 0, i[1]))),
        c && d.attr('cursor', c)
      var _ = e.getItemVisual(t, 'style'),
        x = _.fill
      if (d instanceof ZRImage) {
        var S = d.style
        d.useStyle(
          extend$3({ image: S.image, x: S.x, y: S.y, width: S.width, height: S.height }, _)
        )
      } else
        d.__isEmptyBrush ? d.useStyle(extend$3({}, _)) : d.useStyle(_),
          (d.style.decal = null),
          d.setColor(x, n && n.symbolInnerColor),
          (d.style.strokeNoScale = !0)
      var b = e.getItemVisual(t, 'liftZ'),
        T = this._z2
      null != b
        ? null == T && ((this._z2 = d.z2), (d.z2 += b))
        : null != T && ((d.z2 = T), (this._z2 = null))
      var A = n && n.useNameLabel
      setLabelStyle(d, u, {
        labelFetcher: f,
        labelDataIndex: t,
        defaultText: function (t) {
          return A ? e.getName(t) : getDefaultLabel(e, t)
        },
        inheritColor: x,
        defaultOpacity: _.opacity
      }),
        (this._sizeX = i[0] / 2),
        (this._sizeY = i[1] / 2)
      var w = d.ensureState('emphasis')
      if (
        ((w.style = a), (d.ensureState('select').style = s), (d.ensureState('blur').style = o), p)
      ) {
        var M = Math.max(1.1, 3 / this._sizeY)
        ;(w.scaleX = this._sizeX * M), (w.scaleY = this._sizeY * M)
      }
      this.setSymbolScale(1), enableHoverEmphasis(this, l, h)
    }),
    (t.prototype.setSymbolScale = function (e) {
      this.scaleX = this.scaleY = e
    }),
    (t.prototype.fadeOut = function (e, t) {
      var i = this.childAt(0),
        r = this._seriesModel,
        n = getECData(this).dataIndex,
        a = t && t.animation
      if (((this.silent = i.silent = !0), t && t.fadeLabel)) {
        var o = i.getTextContent()
        o &&
          removeElement(o, { style: { opacity: 0 } }, r, {
            dataIndex: n,
            removeOpt: a,
            cb: function () {
              i.removeTextContent()
            }
          })
      } else i.removeTextContent()
      removeElement(i, { style: { opacity: 0 }, scaleX: 0, scaleY: 0 }, r, {
        dataIndex: n,
        cb: e,
        removeOpt: a
      })
    }),
    (t.getSymbolSize = function (e, t) {
      var i = e.getItemVisual(t, 'symbolSize')
      return isArray$1(i) ? i.slice() : [+i, +i]
    }),
    t
  )
})(Group$3)
function driftSymbol(e, t) {
  this.parent.drift(e, t)
}
function symbolNeedsDraw$1(e, t, i, r) {
  return (
    t &&
    !isNaN(t[0]) &&
    !isNaN(t[1]) &&
    !(r.isIgnore && r.isIgnore(i)) &&
    !(r.clipShape && !r.clipShape.contain(t[0], t[1])) &&
    'none' !== e.getItemVisual(i, 'symbol')
  )
}
function normalizeUpdateOpt(e) {
  return null == e || isObject$7(e) || (e = { isIgnore: e }), e || {}
}
function makeSeriesScope$2(e) {
  var t = e.hostModel,
    i = t.getModel('emphasis')
  return {
    emphasisItemStyle: i.getModel('itemStyle').getItemStyle(),
    blurItemStyle: t.getModel(['blur', 'itemStyle']).getItemStyle(),
    selectItemStyle: t.getModel(['select', 'itemStyle']).getItemStyle(),
    focus: i.get('focus'),
    blurScope: i.get('blurScope'),
    hoverScale: i.get('scale'),
    labelStatesModels: getLabelStatesModels(t),
    cursorStyle: t.get('cursor')
  }
}
var SymbolDraw = (function () {
  function e(e) {
    ;(this.group = new Group$3()), (this._SymbolCtor = e || Symbol$1)
  }
  return (
    (e.prototype.updateData = function (e, t) {
      t = normalizeUpdateOpt(t)
      var i = this.group,
        r = e.hostModel,
        n = this._data,
        a = this._SymbolCtor,
        o = t.disableAnimation,
        s = makeSeriesScope$2(e),
        l = { disableAnimation: o },
        h =
          t.getSymbolPoint ||
          function (t) {
            return e.getItemLayout(t)
          }
      n || i.removeAll(),
        e
          .diff(n)
          .add(function (r) {
            var n = h(r)
            if (symbolNeedsDraw$1(e, n, r, t)) {
              var o = new a(e, r, s, l)
              o.setPosition(n), e.setItemGraphicEl(r, o), i.add(o)
            }
          })
          .update(function (u, p) {
            var c = n.getItemGraphicEl(p),
              d = h(u)
            if (symbolNeedsDraw$1(e, d, u, t)) {
              if (c) {
                c.updateData(e, u, s, l)
                var f = { x: d[0], y: d[1] }
                o ? c.attr(f) : updateProps$1(c, f, r)
              } else (c = new a(e, u)).setPosition(d)
              i.add(c), e.setItemGraphicEl(u, c)
            } else i.remove(c)
          })
          .remove(function (e) {
            var t = n.getItemGraphicEl(e)
            t &&
              t.fadeOut(function () {
                i.remove(t)
              })
          })
          .execute(),
        (this._getSymbolPoint = h),
        (this._data = e)
    }),
    (e.prototype.isPersistent = function () {
      return !0
    }),
    (e.prototype.updateLayout = function () {
      var e = this,
        t = this._data
      t &&
        t.eachItemGraphicEl(function (t, i) {
          var r = e._getSymbolPoint(i)
          t.setPosition(r), t.markRedraw()
        })
    }),
    (e.prototype.incrementalPrepareUpdate = function (e) {
      ;(this._seriesScope = makeSeriesScope$2(e)), (this._data = null), this.group.removeAll()
    }),
    (e.prototype.incrementalUpdate = function (e, t, i) {
      function r(e) {
        e.isGroup || ((e.incremental = !0), (e.ensureState('emphasis').hoverLayer = !0))
      }
      i = normalizeUpdateOpt(i)
      for (var n = e.start; n < e.end; n++) {
        var a = t.getItemLayout(n)
        if (symbolNeedsDraw$1(t, a, n, i)) {
          var o = new this._SymbolCtor(t, n, this._seriesScope)
          o.traverse(r), o.setPosition(a), this.group.add(o), t.setItemGraphicEl(n, o)
        }
      }
    }),
    (e.prototype.remove = function (e) {
      var t = this.group,
        i = this._data
      i && e
        ? i.eachItemGraphicEl(function (e) {
            e.fadeOut(function () {
              t.remove(e)
            })
          })
        : t.removeAll()
    }),
    e
  )
})()
function prepareDataCoordInfo(e, t, i) {
  var r = e.getBaseAxis(),
    n = e.getOtherAxis(r),
    a = getValueStart(n, i),
    o = r.dim,
    s = n.dim,
    l = t.mapDimension(s),
    h = t.mapDimension(o),
    u = 'x' === s || 'radius' === s ? 1 : 0,
    p = map$1(e.dimensions, function (e) {
      return t.mapDimension(e)
    }),
    c = !1,
    d = t.getCalculationInfo('stackResultDimension')
  return (
    isDimensionStacked(t, p[0]) && ((c = !0), (p[0] = d)),
    isDimensionStacked(t, p[1]) && ((c = !0), (p[1] = d)),
    {
      dataDimsForPoint: p,
      valueStart: a,
      valueAxisDim: s,
      baseAxisDim: o,
      stacked: !!c,
      valueDim: l,
      baseDim: h,
      baseDataOffset: u,
      stackedOverDimension: t.getCalculationInfo('stackedOverDimension')
    }
  )
}
function getValueStart(e, t) {
  var i = 0,
    r = e.scale.getExtent()
  return (
    'start' === t
      ? (i = r[0])
      : 'end' === t
      ? (i = r[1])
      : r[0] > 0
      ? (i = r[0])
      : r[1] < 0 && (i = r[1]),
    i
  )
}
function getStackedOnPoint(e, t, i, r) {
  var n = NaN
  e.stacked && (n = i.get(i.getCalculationInfo('stackedOverDimension'), r)),
    isNaN(n) && (n = e.valueStart)
  var a = e.baseDataOffset,
    o = []
  return (o[a] = i.get(e.baseDim, r)), (o[1 - a] = n), t.dataToPoint(o)
}
var supportFloat32Array = 'undefined' != typeof Float32Array,
  Float32ArrayCtor = supportFloat32Array ? Float32Array : Array
function createFloat32Array(e) {
  return isArray$1(e) ? (supportFloat32Array ? new Float32Array(e) : e) : new Float32ArrayCtor(e)
}
function diffData(e, t) {
  var i = []
  return (
    t
      .diff(e)
      .add(function (e) {
        i.push({ cmd: '+', idx: e })
      })
      .update(function (e, t) {
        i.push({ cmd: '=', idx: t, idx1: e })
      })
      .remove(function (e) {
        i.push({ cmd: '-', idx: e })
      })
      .execute(),
    i
  )
}
function lineAnimationDiff(e, t, i, r, n, a, o, s) {
  for (
    var l = diffData(e, t),
      h = [],
      u = [],
      p = [],
      c = [],
      d = [],
      f = [],
      m = [],
      g = prepareDataCoordInfo(n, t, o),
      y = e.getLayout('points') || [],
      v = t.getLayout('points') || [],
      _ = 0;
    _ < l.length;
    _++
  ) {
    var x = l[_],
      S = !0,
      b = void 0,
      T = void 0
    switch (x.cmd) {
      case '=':
        ;(b = 2 * x.idx), (T = 2 * x.idx1)
        var A = y[b],
          w = y[b + 1],
          M = v[T],
          C = v[T + 1]
        ;(isNaN(A) || isNaN(w)) && ((A = M), (w = C)),
          h.push(A, w),
          u.push(M, C),
          p.push(i[b], i[b + 1]),
          c.push(r[T], r[T + 1]),
          m.push(t.getRawIndex(x.idx1))
        break
      case '+':
        var P = x.idx,
          E = g.dataDimsForPoint,
          I = n.dataToPoint([t.get(E[0], P), t.get(E[1], P)])
        ;(T = 2 * P), h.push(I[0], I[1]), u.push(v[T], v[T + 1])
        var D = getStackedOnPoint(g, n, t, P)
        p.push(D[0], D[1]), c.push(r[T], r[T + 1]), m.push(t.getRawIndex(P))
        break
      case '-':
        S = !1
    }
    S && (d.push(x), f.push(f.length))
  }
  f.sort(function (e, t) {
    return m[e] - m[t]
  })
  var L = h.length,
    R = createFloat32Array(L),
    O = createFloat32Array(L),
    k = createFloat32Array(L),
    $ = createFloat32Array(L),
    N = []
  for (_ = 0; _ < f.length; _++) {
    var F = f[_],
      B = 2 * _,
      V = 2 * F
    ;(R[B] = h[V]),
      (R[B + 1] = h[V + 1]),
      (O[B] = u[V]),
      (O[B + 1] = u[V + 1]),
      (k[B] = p[V]),
      (k[B + 1] = p[V + 1]),
      ($[B] = c[V]),
      ($[B + 1] = c[V + 1]),
      (N[_] = d[F])
  }
  return { current: R, next: O, stackedOnCurrent: k, stackedOnNext: $, status: N }
}
var mathMin$5 = Math.min,
  mathMax$5 = Math.max
function isPointNull$1(e, t) {
  return isNaN(e) || isNaN(t)
}
function drawSegment(e, t, i, r, n, a, o, s, l) {
  for (var h, u, p, c, d, f, m = i, g = 0; g < r; g++) {
    var y = t[2 * m],
      v = t[2 * m + 1]
    if (m >= n || m < 0) break
    if (isPointNull$1(y, v)) {
      if (l) {
        m += a
        continue
      }
      break
    }
    if (m === i) e[a > 0 ? 'moveTo' : 'lineTo'](y, v), (p = y), (c = v)
    else {
      var _ = y - h,
        x = v - u
      if (_ * _ + x * x < 0.5) {
        m += a
        continue
      }
      if (o > 0) {
        var S = m + a,
          b = t[2 * S],
          T = t[2 * S + 1],
          A = g + 1
        if (l) for (; isPointNull$1(b, T) && A < r; ) A++, (b = t[2 * (S += a)]), (T = t[2 * S + 1])
        var w = 0.5,
          M = 0,
          C = 0,
          P = void 0,
          E = void 0
        if (A >= r || isPointNull$1(b, T)) (d = y), (f = v)
        else {
          ;(M = b - h), (C = T - u)
          var I = y - h,
            D = b - y,
            L = v - u,
            R = T - v,
            O = void 0,
            k = void 0
          'x' === s
            ? ((O = Math.abs(I)),
              (k = Math.abs(D)),
              (d = y - O * o),
              (f = v),
              (P = y + O * o),
              (E = v))
            : 'y' === s
            ? ((O = Math.abs(L)),
              (k = Math.abs(R)),
              (d = y),
              (f = v - O * o),
              (P = y),
              (E = v + O * o))
            : ((O = Math.sqrt(I * I + L * L)),
              (d = y - M * o * (1 - (w = (k = Math.sqrt(D * D + R * R)) / (k + O)))),
              (f = v - C * o * (1 - w)),
              (E = v + C * o * w),
              (P = mathMin$5((P = y + M * o * w), mathMax$5(b, y))),
              (E = mathMin$5(E, mathMax$5(T, v))),
              (P = mathMax$5(P, mathMin$5(b, y))),
              (f = v - ((C = (E = mathMax$5(E, mathMin$5(T, v))) - v) * O) / k),
              (d = mathMin$5((d = y - ((M = P - y) * O) / k), mathMax$5(h, y))),
              (f = mathMin$5(f, mathMax$5(u, v))),
              (P = y + ((M = y - (d = mathMax$5(d, mathMin$5(h, y)))) * k) / O),
              (E = v + ((C = v - (f = mathMax$5(f, mathMin$5(u, v)))) * k) / O))
        }
        e.bezierCurveTo(p, c, d, f, y, v), (p = P), (c = E)
      } else e.lineTo(y, v)
    }
    ;(h = y), (u = v), (m += a)
  }
  return g
}
var ECPolylineShape = function () {
    ;(this.smooth = 0), (this.smoothConstraint = !0)
  },
  ECPolyline = (function (e) {
    function t(t) {
      var i = e.call(this, t) || this
      return (i.type = 'ec-polyline'), i
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultStyle = function () {
        return { stroke: '#000', fill: null }
      }),
      (t.prototype.getDefaultShape = function () {
        return new ECPolylineShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        var i = t.points,
          r = 0,
          n = i.length / 2
        if (t.connectNulls) {
          for (; n > 0 && isPointNull$1(i[2 * n - 2], i[2 * n - 1]); n--);
          for (; r < n && isPointNull$1(i[2 * r], i[2 * r + 1]); r++);
        }
        for (; r < n; )
          r += drawSegment(e, i, r, n, n, 1, t.smooth, t.smoothMonotone, t.connectNulls) + 1
      }),
      (t.prototype.getPointOn = function (e, t) {
        this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape))
        for (
          var i, r, n = this.path.data, a = PathProxy.CMD, o = 'x' === t, s = [], l = 0;
          l < n.length;

        ) {
          var h = void 0,
            u = void 0,
            p = void 0,
            c = void 0,
            d = void 0,
            f = void 0,
            m = void 0
          switch (n[l++]) {
            case a.M:
              ;(i = n[l++]), (r = n[l++])
              break
            case a.L:
              if (
                ((h = n[l++]),
                (u = n[l++]),
                (m = o ? (e - i) / (h - i) : (e - r) / (u - r)) <= 1 && m >= 0)
              ) {
                var g = o ? (u - r) * m + r : (h - i) * m + i
                return o ? [e, g] : [g, e]
              }
              ;(i = h), (r = u)
              break
            case a.C:
              ;(h = n[l++]), (u = n[l++]), (p = n[l++]), (c = n[l++]), (d = n[l++]), (f = n[l++])
              var y = o ? cubicRootAt(i, h, p, d, e, s) : cubicRootAt(r, u, c, f, e, s)
              if (y > 0)
                for (var v = 0; v < y; v++) {
                  var _ = s[v]
                  if (_ <= 1 && _ >= 0) {
                    g = o ? cubicAt(r, u, c, f, _) : cubicAt(i, h, p, d, _)
                    return o ? [e, g] : [g, e]
                  }
                }
              ;(i = d), (r = f)
          }
        }
      }),
      t
    )
  })(Path),
  ECPolygonShape = (function (e) {
    function t() {
      return (null !== e && e.apply(this, arguments)) || this
    }
    return __extends(t, e), t
  })(ECPolylineShape),
  ECPolygon = (function (e) {
    function t(t) {
      var i = e.call(this, t) || this
      return (i.type = 'ec-polygon'), i
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultShape = function () {
        return new ECPolygonShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        var i = t.points,
          r = t.stackedOnPoints,
          n = 0,
          a = i.length / 2,
          o = t.smoothMonotone
        if (t.connectNulls) {
          for (; a > 0 && isPointNull$1(i[2 * a - 2], i[2 * a - 1]); a--);
          for (; n < a && isPointNull$1(i[2 * n], i[2 * n + 1]); n++);
        }
        for (; n < a; ) {
          var s = drawSegment(e, i, n, a, a, 1, t.smooth, o, t.connectNulls)
          drawSegment(e, r, n + s - 1, s, a, -1, t.stackedOnSmooth, o, t.connectNulls),
            (n += s + 1),
            e.closePath()
        }
      }),
      t
    )
  })(Path)
function createGridClipPath(e, t, i, r, n) {
  var a = e.getArea(),
    o = a.x,
    s = a.y,
    l = a.width,
    h = a.height,
    u = i.get(['lineStyle', 'width']) || 2
  ;(o -= u / 2), (s -= u / 2), (l += u), (h += u), (o = Math.floor(o)), (l = Math.round(l))
  var p = new Rect$2({ shape: { x: o, y: s, width: l, height: h } })
  if (t) {
    var c = e.getBaseAxis(),
      d = c.isHorizontal(),
      f = c.inverse
    d
      ? (f && (p.shape.x += l), (p.shape.width = 0))
      : (f || (p.shape.y += h), (p.shape.height = 0)),
      initProps(
        p,
        { shape: { width: l, height: h, x: o, y: s } },
        i,
        null,
        r,
        'function' == typeof n
          ? function (e) {
              n(e, p)
            }
          : null
      )
  }
  return p
}
function createPolarClipPath(e, t, i) {
  var r = e.getArea(),
    n = round$2(r.r0, 1),
    a = round$2(r.r, 1),
    o = new Sector({
      shape: {
        cx: round$2(e.cx, 1),
        cy: round$2(e.cy, 1),
        r0: n,
        r: a,
        startAngle: r.startAngle,
        endAngle: r.endAngle,
        clockwise: r.clockwise
      }
    })
  t &&
    ('angle' === e.getBaseAxis().dim ? (o.shape.endAngle = r.startAngle) : (o.shape.r = n),
    initProps(o, { shape: { endAngle: r.endAngle, r: a } }, i))
  return o
}
function createClipPath(e, t, i, r, n) {
  return e
    ? 'polar' === e.type
      ? createPolarClipPath(e, t, i)
      : 'cartesian2d' === e.type
      ? createGridClipPath(e, t, i, r, n)
      : null
    : null
}
function isCoordinateSystemType(e, t) {
  return e.type === t
}
function isPointsSame(e, t) {
  if (e.length === t.length) {
    for (var i = 0; i < e.length; i++) if (e[i] !== t[i]) return
    return !0
  }
}
function bboxFromPoints(e) {
  for (var t = 1 / 0, i = 1 / 0, r = -1 / 0, n = -1 / 0, a = 0; a < e.length; ) {
    var o = e[a++],
      s = e[a++]
    isNaN(o) || ((t = Math.min(o, t)), (r = Math.max(o, r))),
      isNaN(s) || ((i = Math.min(s, i)), (n = Math.max(s, n)))
  }
  return [
    [t, i],
    [r, n]
  ]
}
function getBoundingDiff(e, t) {
  var i = bboxFromPoints(e),
    r = i[0],
    n = i[1],
    a = bboxFromPoints(t),
    o = a[0],
    s = a[1]
  return Math.max(
    Math.abs(r[0] - o[0]),
    Math.abs(r[1] - o[1]),
    Math.abs(n[0] - s[0]),
    Math.abs(n[1] - s[1])
  )
}
function getSmooth(e) {
  return 'number' == typeof e ? e : e ? 0.5 : 0
}
function getStackedOnPoints(e, t, i) {
  if (!i.valueDim) return []
  for (var r = t.count(), n = createFloat32Array(2 * r), a = 0; a < r; a++) {
    var o = getStackedOnPoint(i, e, t, a)
    ;(n[2 * a] = o[0]), (n[2 * a + 1] = o[1])
  }
  return n
}
function turnPointsIntoStep(e, t, i) {
  for (
    var r = t.getBaseAxis(),
      n = 'x' === r.dim || 'radius' === r.dim ? 0 : 1,
      a = [],
      o = 0,
      s = [],
      l = [],
      h = [];
    o < e.length - 2;
    o += 2
  )
    switch (
      ((h[0] = e[o + 2]),
      (h[1] = e[o + 3]),
      (l[0] = e[o]),
      (l[1] = e[o + 1]),
      a.push(l[0], l[1]),
      i)
    ) {
      case 'end':
        ;(s[n] = h[n]), (s[1 - n] = l[1 - n]), a.push(s[0], s[1])
        break
      case 'middle':
        var u = (l[n] + h[n]) / 2,
          p = []
        ;(s[n] = p[n] = u),
          (s[1 - n] = l[1 - n]),
          (p[1 - n] = h[1 - n]),
          a.push(s[0], s[1]),
          a.push(p[0], p[1])
        break
      default:
        ;(s[n] = l[n]), (s[1 - n] = h[1 - n]), a.push(s[0], s[1])
    }
  return a.push(e[o++], e[o++]), a
}
function getVisualGradient(e, t) {
  var i = e.getVisual('visualMeta')
  if (i && i.length && e.count() && 'cartesian2d' === t.type) {
    for (var r, n, a = i.length - 1; a >= 0; a--) {
      var o = i[a].dimension,
        s = e.dimensions[o],
        l = e.getDimensionInfo(s)
      if ('x' === (r = l && l.coordDim) || 'y' === r) {
        n = i[a]
        break
      }
    }
    if (n) {
      var h = t.getAxis(r),
        u = map$1(n.stops, function (e) {
          return { offset: 0, coord: h.toGlobalCoord(h.dataToCoord(e.value, !0)), color: e.color }
        }),
        p = u.length,
        c = n.outerColors.slice()
      p && u[0].coord > u[p - 1].coord && (u.reverse(), c.reverse())
      var d = u[0].coord - 10,
        f = u[p - 1].coord + 10,
        m = f - d
      if (m < 0.001) return 'transparent'
      each$i(u, function (e) {
        e.offset = (e.coord - d) / m
      }),
        u.push({ offset: p ? u[p - 1].offset : 0.5, color: c[1] || 'transparent' }),
        u.unshift({ offset: p ? u[0].offset : 0.5, color: c[0] || 'transparent' })
      var g = new LinearGradient(0, 0, 0, 0, u, !0)
      return (g[r] = d), (g[r + '2'] = f), g
    }
  }
}
function getIsIgnoreFunc(e, t, i) {
  var r = e.get('showAllSymbol'),
    n = 'auto' === r
  if (!r || n) {
    var a = i.getAxesByScale('ordinal')[0]
    if (a && (!n || !canShowAllSymbolForCategory(a, t))) {
      var o = t.mapDimension(a.dim),
        s = {}
      return (
        each$i(a.getViewLabels(), function (e) {
          var t = a.scale.getRawOrdinalNumber(e.tickValue)
          s[t] = 1
        }),
        function (e) {
          return !s.hasOwnProperty(t.get(o, e))
        }
      )
    }
  }
}
function canShowAllSymbolForCategory(e, t) {
  var i = e.getExtent(),
    r = Math.abs(i[1] - i[0]) / e.scale.count()
  isNaN(r) && (r = 0)
  for (var n = t.count(), a = Math.max(1, Math.round(n / 5)), o = 0; o < n; o += a)
    if (1.5 * Symbol$1.getSymbolSize(t, o)[e.isHorizontal() ? 1 : 0] > r) return !1
  return !0
}
function isPointNull(e, t) {
  return isNaN(e) || isNaN(t)
}
function getLastIndexNotNull(e) {
  for (var t = e.length / 2; t > 0 && isPointNull(e[2 * t - 2], e[2 * t - 1]); t--);
  return t - 1
}
function getPointAtIndex(e, t) {
  return [e[2 * t], e[2 * t + 1]]
}
function getIndexRange(e, t, i) {
  for (var r, n, a = e.length / 2, o = 'x' === i ? 0 : 1, s = 0, l = -1, h = 0; h < a; h++)
    if (((n = e[2 * h + o]), !isNaN(n) && !isNaN(e[2 * h + 1 - o])))
      if (0 !== h) {
        if ((r <= t && n >= t) || (r >= t && n <= t)) {
          l = h
          break
        }
        ;(s = h), (r = n)
      } else r = n
  return { range: [s, l], t: (t - r) / (n - r) }
}
function createLineClipPath(e, t, i, r) {
  if (isCoordinateSystemType(t, 'cartesian2d')) {
    var n = r.getModel('endLabel'),
      a = n.get('show'),
      o = n.get('valueAnimation'),
      s = r.getData(),
      l = { lastFrameIndex: 0 },
      h = a
        ? function (i, r) {
            e._endLabelOnDuring(i, r, s, l, o, n, t)
          }
        : null,
      u = t.getBaseAxis().isHorizontal(),
      p = createGridClipPath(
        t,
        i,
        r,
        function () {
          var t = e._endLabel
          t && i && null != l.originalX && t.attr({ x: l.originalX, y: l.originalY })
        },
        h
      )
    if (!r.get('clip', !0)) {
      var c = p.shape,
        d = Math.max(c.width, c.height)
      u ? ((c.y -= d), (c.height += 2 * d)) : ((c.x -= d), (c.width += 2 * d))
    }
    return h && h(1, p), p
  }
  return createPolarClipPath(t, i, r)
}
function getEndLabelStateSpecified(e, t) {
  var i = t.getBaseAxis(),
    r = i.isHorizontal(),
    n = i.inverse,
    a = r ? (n ? 'right' : 'left') : 'center',
    o = r ? 'middle' : n ? 'top' : 'bottom'
  return { normal: { align: e.get('align') || a, verticalAlign: e.get('verticalAlign') || o } }
}
var LineView = (function (e) {
  function t() {
    return (null !== e && e.apply(this, arguments)) || this
  }
  return (
    __extends(t, e),
    (t.prototype.init = function () {
      var e = new Group$3(),
        t = new SymbolDraw()
      this.group.add(t.group), (this._symbolDraw = t), (this._lineGroup = e)
    }),
    (t.prototype.render = function (e, t, i) {
      var r = this,
        n = e.coordinateSystem,
        a = this.group,
        o = e.getData(),
        s = e.getModel('lineStyle'),
        l = e.getModel('areaStyle'),
        h = o.getLayout('points') || [],
        u = 'polar' === n.type,
        p = this._coordSys,
        c = this._symbolDraw,
        d = this._polyline,
        f = this._polygon,
        m = this._lineGroup,
        g = e.get('animation'),
        y = !l.isEmpty(),
        v = l.get('origin'),
        _ = prepareDataCoordInfo(n, o, v),
        x = y && getStackedOnPoints(n, o, _),
        S = e.get('showSymbol'),
        b = S && !u && getIsIgnoreFunc(e, o, n),
        T = this._data
      T &&
        T.eachItemGraphicEl(function (e, t) {
          e.__temp && (a.remove(e), T.setItemGraphicEl(t, null))
        }),
        S || c.remove(),
        a.add(m)
      var A,
        w = !u && e.get('step')
      n &&
        n.getArea &&
        e.get('clip', !0) &&
        (null != (A = n.getArea()).width
          ? ((A.x -= 0.1), (A.y -= 0.1), (A.width += 0.2), (A.height += 0.2))
          : A.r0 && ((A.r0 -= 0.5), (A.r += 0.5))),
        (this._clipShapeForSymbol = A)
      var M = getVisualGradient(o, n) || o.getVisual('style')[o.getVisual('drawType')]
      d && p.type === n.type && w === this._step
        ? (y && !f
            ? (f = this._newPolygon(h, x))
            : f && !y && (m.remove(f), (f = this._polygon = null)),
          u || this._initOrUpdateEndLabel(e, n, convertToColorString(M)),
          m.setClipPath(createLineClipPath(this, n, !1, e)),
          S &&
            c.updateData(o, {
              isIgnore: b,
              clipShape: A,
              disableAnimation: !0,
              getSymbolPoint: function (e) {
                return [h[2 * e], h[2 * e + 1]]
              }
            }),
          (isPointsSame(this._stackedOnPoints, x) && isPointsSame(this._points, h)) ||
            (g
              ? this._doUpdateAnimation(o, x, n, i, w, v)
              : (w && ((h = turnPointsIntoStep(h, n, w)), x && (x = turnPointsIntoStep(x, n, w))),
                d.setShape({ points: h }),
                f && f.setShape({ points: h, stackedOnPoints: x }))))
        : (S &&
            c.updateData(o, {
              isIgnore: b,
              clipShape: A,
              disableAnimation: !0,
              getSymbolPoint: function (e) {
                return [h[2 * e], h[2 * e + 1]]
              }
            }),
          g && this._initSymbolLabelAnimation(o, n, A),
          w && ((h = turnPointsIntoStep(h, n, w)), x && (x = turnPointsIntoStep(x, n, w))),
          (d = this._newPolyline(h)),
          y && (f = this._newPolygon(h, x)),
          u || this._initOrUpdateEndLabel(e, n, convertToColorString(M)),
          m.setClipPath(createLineClipPath(this, n, !0, e)))
      var C = e.get(['emphasis', 'focus']),
        P = e.get(['emphasis', 'blurScope'])
      ;(d.useStyle(defaults$1(s.getLineStyle(), { fill: 'none', stroke: M, lineJoin: 'bevel' })),
      setStatesStylesFromModel(d, e, 'lineStyle'),
      d.style.lineWidth > 0 && 'bolder' === e.get(['emphasis', 'lineStyle', 'width'])) &&
        (d.getState('emphasis').style.lineWidth = +d.style.lineWidth + 1)
      ;(getECData(d).seriesIndex = e.seriesIndex), enableHoverEmphasis(d, C, P)
      var E = getSmooth(e.get('smooth')),
        I = e.get('smoothMonotone'),
        D = e.get('connectNulls')
      if ((d.setShape({ smooth: E, smoothMonotone: I, connectNulls: D }), f)) {
        var L = o.getCalculationInfo('stackedOnSeries'),
          R = 0
        f.useStyle(
          defaults$1(l.getAreaStyle(), {
            fill: M,
            opacity: 0.7,
            lineJoin: 'bevel',
            decal: o.getVisual('style').decal
          })
        ),
          L && (R = getSmooth(L.get('smooth'))),
          f.setShape({ smooth: E, stackedOnSmooth: R, smoothMonotone: I, connectNulls: D }),
          setStatesStylesFromModel(f, e, 'areaStyle'),
          (getECData(f).seriesIndex = e.seriesIndex),
          enableHoverEmphasis(f, C, P)
      }
      var O = function (e) {
        r._changePolyState(e)
      }
      o.eachItemGraphicEl(function (e) {
        e && (e.onHoverStateChange = O)
      }),
        (this._polyline.onHoverStateChange = O),
        (this._data = o),
        (this._coordSys = n),
        (this._stackedOnPoints = x),
        (this._points = h),
        (this._step = w),
        (this._valueOrigin = v)
    }),
    (t.prototype.dispose = function () {}),
    (t.prototype.highlight = function (e, t, i, r) {
      var n = e.getData(),
        a = queryDataIndex(n, r)
      if ((this._changePolyState('emphasis'), !(a instanceof Array) && null != a && a >= 0)) {
        var o = n.getLayout('points'),
          s = n.getItemGraphicEl(a)
        if (!s) {
          var l = o[2 * a],
            h = o[2 * a + 1]
          if (isNaN(l) || isNaN(h)) return
          if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(l, h)) return
          var u = e.get('zlevel'),
            p = e.get('z')
          ;((s = new Symbol$1(n, a)).x = l), (s.y = h), s.setZ(u, p)
          var c = s.getSymbolPath().getTextContent()
          c && ((c.zlevel = u), (c.z = p), (c.z2 = this._polyline.z2 + 1)),
            (s.__temp = !0),
            n.setItemGraphicEl(a, s),
            s.stopSymbolAnimation(!0),
            this.group.add(s)
        }
        s.highlight()
      } else ChartView.prototype.highlight.call(this, e, t, i, r)
    }),
    (t.prototype.downplay = function (e, t, i, r) {
      var n = e.getData(),
        a = queryDataIndex(n, r)
      if ((this._changePolyState('normal'), null != a && a >= 0)) {
        var o = n.getItemGraphicEl(a)
        o && (o.__temp ? (n.setItemGraphicEl(a, null), this.group.remove(o)) : o.downplay())
      } else ChartView.prototype.downplay.call(this, e, t, i, r)
    }),
    (t.prototype._changePolyState = function (e) {
      var t = this._polygon
      setStatesFlag(this._polyline, e), t && setStatesFlag(t, e)
    }),
    (t.prototype._newPolyline = function (e) {
      var t = this._polyline
      return (
        t && this._lineGroup.remove(t),
        (t = new ECPolyline({ shape: { points: e }, segmentIgnoreThreshold: 2, z2: 10 })),
        this._lineGroup.add(t),
        (this._polyline = t),
        t
      )
    }),
    (t.prototype._newPolygon = function (e, t) {
      var i = this._polygon
      return (
        i && this._lineGroup.remove(i),
        (i = new ECPolygon({
          shape: { points: e, stackedOnPoints: t },
          segmentIgnoreThreshold: 2
        })),
        this._lineGroup.add(i),
        (this._polygon = i),
        i
      )
    }),
    (t.prototype._initSymbolLabelAnimation = function (e, t, i) {
      var r,
        n,
        a = t.getBaseAxis(),
        o = a.inverse
      'cartesian2d' === t.type
        ? ((r = a.isHorizontal()), (n = !1))
        : 'polar' === t.type && ((r = 'angle' === a.dim), (n = !0))
      var s = e.hostModel,
        l = s.get('animationDuration')
      'function' == typeof l && (l = l(null))
      var h = s.get('animationDelay') || 0,
        u = 'function' == typeof h ? h(null) : h
      e.eachItemGraphicEl(function (e, a) {
        var s = e
        if (s) {
          var p = [e.x, e.y],
            c = void 0,
            d = void 0,
            f = void 0
          if (i)
            if (n) {
              var m = i,
                g = t.pointToCoord(p)
              r
                ? ((c = m.startAngle), (d = m.endAngle), (f = (-g[1] / 180) * Math.PI))
                : ((c = m.r0), (d = m.r), (f = g[0]))
            } else {
              var y = i
              r
                ? ((c = y.x), (d = y.x + y.width), (f = e.x))
                : ((c = y.y + y.height), (d = y.y), (f = e.y))
            }
          var v = d === c ? 0 : (f - c) / (d - c)
          o && (v = 1 - v)
          var _ = 'function' == typeof h ? h(a) : l * v + u,
            x = s.getSymbolPath(),
            S = x.getTextContent()
          s.attr({ scaleX: 0, scaleY: 0 }),
            s.animateTo({ scaleX: 1, scaleY: 1 }, { duration: 200, delay: _ }),
            S && S.animateFrom({ style: { opacity: 0 } }, { duration: 300, delay: _ }),
            (x.disableLabelAnimation = !0)
        }
      })
    }),
    (t.prototype._initOrUpdateEndLabel = function (e, t, i) {
      var r = e.getModel('endLabel')
      if (r.get('show')) {
        var n = e.getData(),
          a = this._polyline,
          o = this._endLabel
        o ||
          (((o = this._endLabel = new ZRText({ z2: 200 })).ignoreClip = !0),
          a.setTextContent(this._endLabel),
          (a.disableLabelAnimation = !0))
        var s = getLastIndexNotNull(n.getLayout('points'))
        s >= 0 &&
          (setLabelStyle(
            a,
            getLabelStatesModels(e, 'endLabel'),
            {
              inheritColor: i,
              labelFetcher: e,
              labelDataIndex: s,
              defaultText: function (e, t, i) {
                return null != i ? getDefaultInterpolatedLabel(n, i) : getDefaultLabel(n, e)
              },
              enableTextSetter: !0
            },
            getEndLabelStateSpecified(r, t)
          ),
          (a.textConfig.position = null))
      } else this._endLabel && (this._polyline.removeTextContent(), (this._endLabel = null))
    }),
    (t.prototype._endLabelOnDuring = function (e, t, i, r, n, a, o) {
      var s = this._endLabel,
        l = this._polyline
      if (s) {
        e < 1 && null == r.originalX && ((r.originalX = s.x), (r.originalY = s.y))
        var h = i.getLayout('points'),
          u = i.hostModel,
          p = u.get('connectNulls'),
          c = a.get('precision'),
          d = a.get('distance') || 0,
          f = o.getBaseAxis(),
          m = f.isHorizontal(),
          g = f.inverse,
          y = t.shape,
          v = g ? (m ? y.x : y.y + y.height) : m ? y.x + y.width : y.y,
          _ = (m ? d : 0) * (g ? -1 : 1),
          x = (m ? 0 : -d) * (g ? -1 : 1),
          S = m ? 'x' : 'y',
          b = getIndexRange(h, v, S),
          T = b.range,
          A = T[1] - T[0],
          w = void 0
        if (A >= 1) {
          if (A > 1 && !p) {
            var M = getPointAtIndex(h, T[0])
            s.attr({ x: M[0] + _, y: M[1] + x }), n && (w = u.getRawValue(T[0]))
          } else {
            ;(M = l.getPointOn(v, S)) && s.attr({ x: M[0] + _, y: M[1] + x })
            var C = u.getRawValue(T[0]),
              P = u.getRawValue(T[1])
            n && (w = interpolateRawValues(i, c, C, P, b.t))
          }
          r.lastFrameIndex = T[0]
        } else {
          var E = 1 === e || r.lastFrameIndex > 0 ? T[0] : 0
          M = getPointAtIndex(h, E)
          n && (w = u.getRawValue(E)), s.attr({ x: M[0] + _, y: M[1] + x })
        }
        n && labelInner(s).setLabelText(w)
      }
    }),
    (t.prototype._doUpdateAnimation = function (e, t, i, r, n, a) {
      var o = this._polyline,
        s = this._polygon,
        l = e.hostModel,
        h = lineAnimationDiff(
          this._data,
          e,
          this._stackedOnPoints,
          t,
          this._coordSys,
          i,
          this._valueOrigin
        ),
        u = h.current,
        p = h.stackedOnCurrent,
        c = h.next,
        d = h.stackedOnNext
      if (
        (n &&
          ((u = turnPointsIntoStep(h.current, i, n)),
          (p = turnPointsIntoStep(h.stackedOnCurrent, i, n)),
          (c = turnPointsIntoStep(h.next, i, n)),
          (d = turnPointsIntoStep(h.stackedOnNext, i, n))),
        getBoundingDiff(u, c) > 3e3 || (s && getBoundingDiff(p, d) > 3e3))
      )
        return o.setShape({ points: c }), void (s && s.setShape({ points: c, stackedOnPoints: d }))
      ;(o.shape.__points = h.current), (o.shape.points = u)
      var f = { shape: { points: c } }
      h.current !== u && (f.shape.__points = h.next),
        o.stopAnimation(),
        updateProps$1(o, f, l),
        s &&
          (s.setShape({ points: u, stackedOnPoints: p }),
          s.stopAnimation(),
          updateProps$1(s, { shape: { stackedOnPoints: d } }, l),
          o.shape.points !== s.shape.points && (s.shape.points = o.shape.points))
      for (var m = [], g = h.status, y = 0; y < g.length; y++) {
        if ('=' === g[y].cmd) {
          var v = e.getItemGraphicEl(g[y].idx1)
          v && m.push({ el: v, ptIdx: y })
        }
      }
      o.animators &&
        o.animators.length &&
        o.animators[0].during(function () {
          s && s.dirtyShape()
          for (var e = o.shape.__points, t = 0; t < m.length; t++) {
            var i = m[t].el,
              r = 2 * m[t].ptIdx
            ;(i.x = e[r]), (i.y = e[r + 1]), i.markRedraw()
          }
        })
    }),
    (t.prototype.remove = function (e) {
      var t = this.group,
        i = this._data
      this._lineGroup.removeAll(),
        this._symbolDraw.remove(!0),
        i &&
          i.eachItemGraphicEl(function (e, r) {
            e.__temp && (t.remove(e), i.setItemGraphicEl(r, null))
          }),
        (this._polyline =
          this._polygon =
          this._coordSys =
          this._points =
          this._stackedOnPoints =
          this._endLabel =
          this._data =
            null)
    }),
    (t.type = 'line'),
    t
  )
})(ChartView)
function pointsLayout(e, t) {
  return {
    seriesType: e,
    plan: createRenderPlanner(),
    reset: function (e) {
      var i = e.getData(),
        r = e.coordinateSystem,
        n = e.pipelineContext,
        a = t || n.large
      if (r) {
        var o = map$1(r.dimensions, function (e) {
            return i.mapDimension(e)
          }).slice(0, 2),
          s = o.length,
          l = i.getCalculationInfo('stackResultDimension')
        isDimensionStacked(i, o[0]) && (o[0] = l), isDimensionStacked(i, o[1]) && (o[1] = l)
        var h = i.getDimensionInfo(o[0]),
          u = i.getDimensionInfo(o[1]),
          p = h && h.index,
          c = u && u.index
        return (
          s && {
            progress: function (e, t) {
              for (
                var i = e.end - e.start,
                  n = a && createFloat32Array(i * s),
                  o = [],
                  l = [],
                  h = e.start,
                  u = 0;
                h < e.end;
                h++
              ) {
                var d = void 0
                if (1 === s) {
                  var f = t.getByDimIdx(p, h)
                  d = r.dataToPoint(f, null, l)
                } else
                  (o[0] = t.getByDimIdx(p, h)),
                    (o[1] = t.getByDimIdx(c, h)),
                    (d = r.dataToPoint(o, null, l))
                a ? ((n[u++] = d[0]), (n[u++] = d[1])) : t.setItemLayout(h, d.slice())
              }
              a && t.setLayout('points', n)
            }
          }
        )
      }
    }
  }
}
var samplers = {
    average: function (e) {
      for (var t = 0, i = 0, r = 0; r < e.length; r++) isNaN(e[r]) || ((t += e[r]), i++)
      return 0 === i ? NaN : t / i
    },
    sum: function (e) {
      for (var t = 0, i = 0; i < e.length; i++) t += e[i] || 0
      return t
    },
    max: function (e) {
      for (var t = -1 / 0, i = 0; i < e.length; i++) e[i] > t && (t = e[i])
      return isFinite(t) ? t : NaN
    },
    min: function (e) {
      for (var t = 1 / 0, i = 0; i < e.length; i++) e[i] < t && (t = e[i])
      return isFinite(t) ? t : NaN
    },
    nearest: function (e) {
      return e[0]
    }
  },
  indexSampler = function (e) {
    return Math.round(e.length / 2)
  }
function dataSample(e) {
  return {
    seriesType: e,
    reset: function (e, t, i) {
      var r = e.getData(),
        n = e.get('sampling'),
        a = e.coordinateSystem,
        o = r.count()
      if (o > 10 && 'cartesian2d' === a.type && n) {
        var s = a.getBaseAxis(),
          l = a.getOtherAxis(s),
          h = s.getExtent(),
          u = i.getDevicePixelRatio(),
          p = Math.abs(h[1] - h[0]) * (u || 1),
          c = Math.round(o / p)
        if (c > 1) {
          'lttb' === n && e.setData(r.lttbDownSample(r.mapDimension(l.dim), 1 / c))
          var d = void 0
          'string' == typeof n ? (d = samplers[n]) : 'function' == typeof n && (d = n),
            d && e.setData(r.downSample(r.mapDimension(l.dim), 1 / c, d, indexSampler))
        }
      }
    }
  }
}
function install$Q(e) {
  e.registerChartView(LineView),
    e.registerSeriesModel(LineSeriesModel),
    e.registerLayout(pointsLayout('line', !0)),
    e.registerVisual({
      seriesType: 'line',
      reset: function (e) {
        var t = e.getData(),
          i = e.getModel('lineStyle').getLineStyle()
        i && !i.stroke && (i.stroke = t.getVisual('style').fill), t.setVisual('legendLineStyle', i)
      }
    }),
    e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'))
}
var BaseBarSeriesModel = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), i
  }
  return (
    __extends(t, e),
    (t.prototype.getInitialData = function (e, t) {
      return createListFromArray(this.getSource(), this, { useEncodeDefaulter: !0 })
    }),
    (t.prototype.getMarkerPosition = function (e) {
      var t = this.coordinateSystem
      if (t) {
        var i = t.dataToPoint(t.clampData(e)),
          r = this.getData(),
          n = r.getLayout('offset'),
          a = r.getLayout('size')
        return (i[t.getBaseAxis().isHorizontal() ? 0 : 1] += n + a / 2), i
      }
      return [NaN, NaN]
    }),
    (t.type = 'series.__base_bar__'),
    (t.defaultOption = {
      zlevel: 0,
      z: 2,
      coordinateSystem: 'cartesian2d',
      legendHoverLink: !0,
      barMinHeight: 0,
      barMinAngle: 0,
      large: !1,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: 'mod'
    }),
    t
  )
})(SeriesModel)
SeriesModel.registerClass(BaseBarSeriesModel)
var BarSeriesModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.getInitialData = function () {
        return createListFromArray(this.getSource(), this, {
          useEncodeDefaulter: !0,
          createInvertedIndices: !!this.get('realtimeSort', !0) || null
        })
      }),
      (t.prototype.getProgressive = function () {
        return !!this.get('large') && this.get('progressive')
      }),
      (t.prototype.getProgressiveThreshold = function () {
        var e = this.get('progressiveThreshold'),
          t = this.get('largeThreshold')
        return t > e && (e = t), e
      }),
      (t.prototype.brushSelector = function (e, t, i) {
        return i.rect(t.getItemLayout(e))
      }),
      (t.type = 'series.bar'),
      (t.dependencies = ['grid', 'polar']),
      (t.defaultOption = inheritDefaultOption(BaseBarSeriesModel.defaultOption, {
        clip: !0,
        roundCap: !1,
        showBackground: !1,
        backgroundStyle: {
          color: 'rgba(180, 180, 180, 0.2)',
          borderColor: null,
          borderWidth: 0,
          borderType: 'solid',
          borderRadius: 0,
          shadowBlur: 0,
          shadowColor: null,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          opacity: 1
        },
        select: { itemStyle: { borderColor: '#212121' } },
        realtimeSort: !1
      })),
      t
    )
  })(BaseBarSeriesModel),
  SausageShape = function () {
    ;(this.cx = 0),
      (this.cy = 0),
      (this.r0 = 0),
      (this.r = 0),
      (this.startAngle = 0),
      (this.endAngle = 2 * Math.PI),
      (this.clockwise = !0)
  },
  SausagePath = (function (e) {
    function t(t) {
      var i = e.call(this, t) || this
      return (i.type = 'sausage'), i
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultShape = function () {
        return new SausageShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        var i = t.cx,
          r = t.cy,
          n = Math.max(t.r0 || 0, 0),
          a = Math.max(t.r, 0),
          o = 0.5 * (a - n),
          s = n + o,
          l = t.startAngle,
          h = t.endAngle,
          u = t.clockwise,
          p = Math.cos(l),
          c = Math.sin(l),
          d = Math.cos(h),
          f = Math.sin(h)
        ;(u ? h - l < 2 * Math.PI : l - h < 2 * Math.PI) &&
          (e.moveTo(p * n + i, c * n + r), e.arc(p * s + i, c * s + r, o, -Math.PI + l, l, !u)),
          e.arc(i, r, a, l, h, !u),
          e.moveTo(d * a + i, f * a + r),
          e.arc(d * s + i, f * s + r, o, h - 2 * Math.PI, h - Math.PI, !u),
          0 !== n && (e.arc(i, r, n, h, l, u), e.moveTo(p * n + i, f * n + r)),
          e.closePath()
      }),
      t
    )
  })(Path),
  _eventPos = [0, 0],
  mathMax$4 = Math.max,
  mathMin$4 = Math.min
function getClipArea(e, t) {
  var i = e.getArea && e.getArea()
  if (isCoordinateSystemType(e, 'cartesian2d')) {
    var r = e.getBaseAxis()
    if ('category' !== r.type || !r.onBand) {
      var n = t.getLayout('bandWidth')
      r.isHorizontal() ? ((i.x -= n), (i.width += 2 * n)) : ((i.y -= n), (i.height += 2 * n))
    }
  }
  return i
}
var BarView = (function (e) {
    function t() {
      var i = e.call(this) || this
      return (i.type = t.type), (i._isFirstFrame = !0), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i, r) {
        ;(this._model = e), this._removeOnRenderedListener(i), this._updateDrawMode(e)
        var n = e.get('coordinateSystem')
        ;('cartesian2d' !== n && 'polar' !== n) ||
          (this._isLargeDraw ? this._renderLarge(e, t, i) : this._renderNormal(e, t, i, r))
      }),
      (t.prototype.incrementalPrepareRender = function (e) {
        this._clear(), this._updateDrawMode(e), this._updateLargeClip(e)
      }),
      (t.prototype.incrementalRender = function (e, t) {
        this._incrementalRenderLarge(e, t)
      }),
      (t.prototype._updateDrawMode = function (e) {
        var t = e.pipelineContext.large
        ;(null != this._isLargeDraw && t === this._isLargeDraw) ||
          ((this._isLargeDraw = t), this._clear())
      }),
      (t.prototype._renderNormal = function (e, t, i, r) {
        var n,
          a = this.group,
          o = e.getData(),
          s = this._data,
          l = e.coordinateSystem,
          h = l.getBaseAxis()
        'cartesian2d' === l.type
          ? (n = h.isHorizontal())
          : 'polar' === l.type && (n = 'angle' === h.dim)
        var u = e.isAnimationEnabled() ? e : null,
          p = shouldRealtimeSort(e, l)
        p && this._enableRealtimeSort(p, o, i)
        var c = e.get('clip', !0) || p,
          d = getClipArea(l, o)
        a.removeClipPath()
        var f = e.get('roundCap', !0),
          m = e.get('showBackground', !0),
          g = e.getModel('backgroundStyle'),
          y = g.get('borderRadius') || 0,
          v = [],
          _ = this._backgroundEls,
          x = r && r.isInitSort,
          S = r && 'changeAxisOrder' === r.type
        function b(e) {
          var t = getLayout[l.type](o, e),
            i = createBackgroundEl(l, n, t)
          return (
            i.useStyle(g.getItemStyle()),
            'cartesian2d' === l.type && i.setShape('r', y),
            (v[e] = i),
            i
          )
        }
        o.diff(s)
          .add(function (t) {
            var i = o.getItemModel(t),
              r = getLayout[l.type](o, t, i)
            if ((m && b(t), o.hasValue(t))) {
              var s = !1
              c && (s = clip[l.type](d, r))
              var g = elementCreator[l.type](e, o, t, r, n, u, h.model, !1, f)
              updateStyle(g, o, t, i, r, e, n, 'polar' === l.type),
                x
                  ? g.attr({ shape: r })
                  : p
                  ? updateRealtimeAnimation(p, u, g, r, t, n, !1, !1)
                  : initProps(g, { shape: r }, e, t),
                o.setItemGraphicEl(t, g),
                a.add(g),
                (g.ignore = s)
            }
          })
          .update(function (t, i) {
            var r = o.getItemModel(t),
              T = getLayout[l.type](o, t, r)
            if (m) {
              var A = void 0
              0 === _.length
                ? (A = b(i))
                : ((A = _[i]).useStyle(g.getItemStyle()),
                  'cartesian2d' === l.type && A.setShape('r', y),
                  (v[t] = A))
              var w = getLayout[l.type](o, t)
              updateProps$1(A, { shape: createBackgroundShape(n, w, l) }, u, t)
            }
            var M = s.getItemGraphicEl(i)
            if (!o.hasValue(t)) return a.remove(M), void (M = null)
            var C = !1
            c && (C = clip[l.type](d, T)) && a.remove(M),
              M || (M = elementCreator[l.type](e, o, t, T, n, u, h.model, !!M, f)),
              S || updateStyle(M, o, t, r, T, e, n, 'polar' === l.type),
              x
                ? M.attr({ shape: T })
                : p
                ? updateRealtimeAnimation(p, u, M, T, t, n, !0, S)
                : updateProps$1(M, { shape: T }, e, t, null),
              o.setItemGraphicEl(t, M),
              (M.ignore = C),
              a.add(M)
          })
          .remove(function (t) {
            var i = s.getItemGraphicEl(t)
            i && removeElementWithFadeOut(i, e, t)
          })
          .execute()
        var T = this._backgroundGroup || (this._backgroundGroup = new Group$3())
        T.removeAll()
        for (var A = 0; A < v.length; ++A) T.add(v[A])
        a.add(T), (this._backgroundEls = v), (this._data = o)
      }),
      (t.prototype._renderLarge = function (e, t, i) {
        this._clear(), createLarge$1(e, this.group), this._updateLargeClip(e)
      }),
      (t.prototype._incrementalRenderLarge = function (e, t) {
        this._removeBackground(), createLarge$1(t, this.group, !0)
      }),
      (t.prototype._updateLargeClip = function (e) {
        var t = e.get('clip', !0) ? createClipPath(e.coordinateSystem, !1, e) : null
        t ? this.group.setClipPath(t) : this.group.removeClipPath()
      }),
      (t.prototype._enableRealtimeSort = function (e, t, i) {
        var r = this
        if (t.count()) {
          var n = e.baseAxis
          if (this._isFirstFrame) this._dispatchInitSort(t, e, i), (this._isFirstFrame = !1)
          else {
            var a = function (e) {
              var i = t.getItemGraphicEl(e)
              if (i) {
                var r = i.shape
                return (n.isHorizontal() ? Math.abs(r.height) : Math.abs(r.width)) || 0
              }
              return 0
            }
            ;(this._onRendered = function () {
              r._updateSortWithinSameData(t, a, n, i)
            }),
              i.getZr().on('rendered', this._onRendered)
          }
        }
      }),
      (t.prototype._dataSort = function (e, t, i) {
        var r = []
        return (
          e.each(e.mapDimension(t.dim), function (e, t) {
            var n = i(t)
            ;(n = null == n ? NaN : n), r.push({ dataIndex: t, mappedValue: n, ordinalNumber: e })
          }),
          r.sort(function (e, t) {
            return t.mappedValue - e.mappedValue
          }),
          {
            ordinalNumbers: map$1(r, function (e) {
              return e.ordinalNumber
            })
          }
        )
      }),
      (t.prototype._isOrderChangedWithinSameData = function (e, t, i) {
        for (
          var r = i.scale,
            n = e.mapDimension(i.dim),
            a = Number.MAX_VALUE,
            o = 0,
            s = r.getOrdinalMeta().categories.length;
          o < s;
          ++o
        ) {
          var l = e.rawIndexOf(n, r.getRawOrdinalNumber(o)),
            h = l < 0 ? Number.MIN_VALUE : t(e.indexOfRawIndex(l))
          if (h > a) return !0
          a = h
        }
        return !1
      }),
      (t.prototype._isOrderDifferentInView = function (e, t) {
        for (
          var i = t.scale,
            r = i.getExtent(),
            n = Math.max(0, r[0]),
            a = Math.min(r[1], i.getOrdinalMeta().categories.length - 1);
          n <= a;
          ++n
        )
          if (e.ordinalNumbers[n] !== i.getRawOrdinalNumber(n)) return !0
      }),
      (t.prototype._updateSortWithinSameData = function (e, t, i, r) {
        if (this._isOrderChangedWithinSameData(e, t, i)) {
          var n = this._dataSort(e, i, t)
          this._isOrderDifferentInView(n, i) &&
            (this._removeOnRenderedListener(r),
            r.dispatchAction({
              type: 'changeAxisOrder',
              componentType: i.dim + 'Axis',
              axisId: i.index,
              sortInfo: n
            }))
        }
      }),
      (t.prototype._dispatchInitSort = function (e, t, i) {
        var r = t.baseAxis,
          n = this._dataSort(e, r, function (i) {
            return e.get(e.mapDimension(t.otherAxis.dim), i)
          })
        i.dispatchAction({
          type: 'changeAxisOrder',
          componentType: r.dim + 'Axis',
          isInitSort: !0,
          axisId: r.index,
          sortInfo: n,
          animation: { duration: 0 }
        })
      }),
      (t.prototype.remove = function (e, t) {
        this._clear(this._model), this._removeOnRenderedListener(t)
      }),
      (t.prototype.dispose = function (e, t) {
        this._removeOnRenderedListener(t)
      }),
      (t.prototype._removeOnRenderedListener = function (e) {
        this._onRendered && (e.getZr().off('rendered', this._onRendered), (this._onRendered = null))
      }),
      (t.prototype._clear = function (e) {
        var t = this.group,
          i = this._data
        e && e.isAnimationEnabled() && i && !this._isLargeDraw
          ? (this._removeBackground(),
            (this._backgroundEls = []),
            i.eachItemGraphicEl(function (t) {
              removeElementWithFadeOut(t, e, getECData(t).dataIndex)
            }))
          : t.removeAll(),
          (this._data = null),
          (this._isFirstFrame = !0)
      }),
      (t.prototype._removeBackground = function () {
        this.group.remove(this._backgroundGroup), (this._backgroundGroup = null)
      }),
      (t.type = 'bar'),
      t
    )
  })(ChartView),
  clip = {
    cartesian2d: function (e, t) {
      var i = t.width < 0 ? -1 : 1,
        r = t.height < 0 ? -1 : 1
      i < 0 && ((t.x += t.width), (t.width = -t.width)),
        r < 0 && ((t.y += t.height), (t.height = -t.height))
      var n = e.x + e.width,
        a = e.y + e.height,
        o = mathMax$4(t.x, e.x),
        s = mathMin$4(t.x + t.width, n),
        l = mathMax$4(t.y, e.y),
        h = mathMin$4(t.y + t.height, a),
        u = s < o,
        p = h < l
      return (
        (t.x = u && o > n ? s : o),
        (t.y = p && l > a ? h : l),
        (t.width = u ? 0 : s - o),
        (t.height = p ? 0 : h - l),
        i < 0 && ((t.x += t.width), (t.width = -t.width)),
        r < 0 && ((t.y += t.height), (t.height = -t.height)),
        u || p
      )
    },
    polar: function (e, t) {
      var i = t.r0 <= t.r ? 1 : -1
      if (i < 0) {
        var r = t.r
        ;(t.r = t.r0), (t.r0 = r)
      }
      var n = mathMin$4(t.r, e.r),
        a = mathMax$4(t.r0, e.r0)
      ;(t.r = n), (t.r0 = a)
      var o = n - a < 0
      if (i < 0) {
        r = t.r
        ;(t.r = t.r0), (t.r0 = r)
      }
      return o
    }
  },
  elementCreator = {
    cartesian2d: function (e, t, i, r, n, a, o, s, l) {
      var h = new Rect$2({ shape: extend$3({}, r), z2: 1 })
      ;((h.__dataIndex = i), (h.name = 'item'), a) && (h.shape[n ? 'height' : 'width'] = 0)
      return h
    },
    polar: function (e, t, i, r, n, a, o, s, l) {
      var h = r.startAngle < r.endAngle,
        u = new (!n && l ? SausagePath : Sector)({ shape: defaults$1({ clockwise: h }, r), z2: 1 })
      if (((u.name = 'item'), a)) {
        var p = n ? 'r' : 'endAngle',
          c = {}
        ;(u.shape[p] = n ? 0 : r.startAngle),
          (c[p] = r[p]),
          (s ? updateProps$1 : initProps)(u, { shape: c }, a)
      }
      return u
    }
  }
function shouldRealtimeSort(e, t) {
  var i = e.get('realtimeSort', !0),
    r = t.getBaseAxis()
  if (i && 'category' === r.type && 'cartesian2d' === t.type)
    return { baseAxis: r, otherAxis: t.getOtherAxis(r) }
}
function updateRealtimeAnimation(e, t, i, r, n, a, o, s) {
  var l, h
  a
    ? ((h = { x: r.x, width: r.width }), (l = { y: r.y, height: r.height }))
    : ((h = { y: r.y, height: r.height }), (l = { x: r.x, width: r.width })),
    s || (o ? updateProps$1 : initProps)(i, { shape: l }, t, n, null),
    (o ? updateProps$1 : initProps)(i, { shape: h }, t ? e.baseAxis.model : null, n)
}
var getLayout = {
  cartesian2d: function (e, t, i) {
    var r = e.getItemLayout(t),
      n = i ? getLineWidth(i, r) : 0,
      a = r.width > 0 ? 1 : -1,
      o = r.height > 0 ? 1 : -1
    return {
      x: r.x + (a * n) / 2,
      y: r.y + (o * n) / 2,
      width: r.width - a * n,
      height: r.height - o * n
    }
  },
  polar: function (e, t, i) {
    var r = e.getItemLayout(t)
    return { cx: r.cx, cy: r.cy, r0: r.r0, r: r.r, startAngle: r.startAngle, endAngle: r.endAngle }
  }
}
function isZeroOnPolar(e) {
  return null != e.startAngle && null != e.endAngle && e.startAngle === e.endAngle
}
function updateStyle(e, t, i, r, n, a, o, s) {
  var l = t.getItemVisual(i, 'style')
  s || e.setShape('r', r.get(['itemStyle', 'borderRadius']) || 0), e.useStyle(l)
  var h = r.getShallow('cursor')
  if ((h && e.attr('cursor', h), !s)) {
    var u = o ? (n.height > 0 ? 'bottom' : 'top') : n.width > 0 ? 'left' : 'right',
      p = getLabelStatesModels(r)
    setLabelStyle(e, p, {
      labelFetcher: a,
      labelDataIndex: i,
      defaultText: getDefaultLabel(a.getData(), i),
      inheritColor: l.fill,
      defaultOpacity: l.opacity,
      defaultOutsidePosition: u
    }),
      setLabelValueAnimation(e.getTextContent(), p, a.getRawValue(i), function (e) {
        return getDefaultInterpolatedLabel(t, e)
      })
  }
  var c = r.getModel(['emphasis'])
  enableHoverEmphasis(e, c.get('focus'), c.get('blurScope')),
    setStatesStylesFromModel(e, r),
    isZeroOnPolar(n) &&
      ((e.style.fill = 'none'),
      (e.style.stroke = 'none'),
      each$i(e.states, function (e) {
        e.style && (e.style.fill = e.style.stroke = 'none')
      }))
}
function getLineWidth(e, t) {
  var i = e.get(['itemStyle', 'borderColor'])
  if (!i || 'none' === i) return 0
  var r = e.get(['itemStyle', 'borderWidth']) || 0,
    n = isNaN(t.width) ? Number.MAX_VALUE : Math.abs(t.width),
    a = isNaN(t.height) ? Number.MAX_VALUE : Math.abs(t.height)
  return Math.min(r, n, a)
}
var LagePathShape = function () {},
  LargePath = (function (e) {
    function t(t) {
      var i = e.call(this, t) || this
      return (i.type = 'largeBar'), i
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultShape = function () {
        return new LagePathShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        for (
          var i = t.points, r = this.__startPoint, n = this.__baseDimIdx, a = 0;
          a < i.length;
          a += 2
        )
          (r[n] = i[a + n]), e.moveTo(r[0], r[1]), e.lineTo(i[a], i[a + 1])
      }),
      t
    )
  })(Path)
function createLarge$1(e, t, i) {
  var r = e.getData(),
    n = [],
    a = r.getLayout('valueAxisHorizontal') ? 1 : 0
  n[1 - a] = r.getLayout('valueAxisStart')
  var o = r.getLayout('largeDataIndices'),
    s = r.getLayout('barWidth'),
    l = e.getModel('backgroundStyle')
  if (e.get('showBackground', !0)) {
    var h = r.getLayout('largeBackgroundPoints'),
      u = []
    u[1 - a] = r.getLayout('backgroundStart')
    var p = new LargePath({ shape: { points: h }, incremental: !!i, silent: !0, z2: 0 })
    ;(p.__startPoint = u),
      (p.__baseDimIdx = a),
      (p.__largeDataIndices = o),
      (p.__barWidth = s),
      setLargeBackgroundStyle(p, l, r),
      t.add(p)
  }
  var c = new LargePath({ shape: { points: r.getLayout('largePoints') }, incremental: !!i })
  ;(c.__startPoint = n),
    (c.__baseDimIdx = a),
    (c.__largeDataIndices = o),
    (c.__barWidth = s),
    t.add(c),
    setLargeStyle$1(c, e, r),
    (getECData(c).seriesIndex = e.seriesIndex),
    e.get('silent') ||
      (c.on('mousedown', largePathUpdateDataIndex), c.on('mousemove', largePathUpdateDataIndex))
}
var largePathUpdateDataIndex = throttle(
  function (e) {
    var t = largePathFindDataIndex(this, e.offsetX, e.offsetY)
    getECData(this).dataIndex = t >= 0 ? t : null
  },
  30,
  !1
)
function largePathFindDataIndex(e, t, i) {
  var r = e.__baseDimIdx,
    n = 1 - r,
    a = e.shape.points,
    o = e.__largeDataIndices,
    s = Math.abs(e.__barWidth / 2),
    l = e.__startPoint[n]
  ;(_eventPos[0] = t), (_eventPos[1] = i)
  for (
    var h = _eventPos[r], u = _eventPos[1 - r], p = h - s, c = h + s, d = 0, f = a.length / 2;
    d < f;
    d++
  ) {
    var m = 2 * d,
      g = a[m + r],
      y = a[m + n]
    if (g >= p && g <= c && (l <= y ? u >= l && u <= y : u >= y && u <= l)) return o[d]
  }
  return -1
}
function setLargeStyle$1(e, t, i) {
  var r = i.getVisual('style')
  e.useStyle(extend$3({}, r)),
    (e.style.fill = null),
    (e.style.stroke = r.fill),
    (e.style.lineWidth = i.getLayout('barWidth'))
}
function setLargeBackgroundStyle(e, t, i) {
  var r = t.get('borderColor') || t.get('color'),
    n = t.getItemStyle()
  e.useStyle(n),
    (e.style.fill = null),
    (e.style.stroke = r),
    (e.style.lineWidth = i.getLayout('barWidth'))
}
function createBackgroundShape(e, t, i) {
  if (isCoordinateSystemType(i, 'cartesian2d')) {
    var r = t,
      n = i.getArea()
    return {
      x: e ? r.x : n.x,
      y: e ? n.y : r.y,
      width: e ? r.width : n.width,
      height: e ? n.height : r.height
    }
  }
  var a = t
  return {
    cx: (n = i.getArea()).cx,
    cy: n.cy,
    r0: e ? n.r0 : a.r0,
    r: e ? n.r : a.r,
    startAngle: e ? a.startAngle : 0,
    endAngle: e ? a.endAngle : 2 * Math.PI
  }
}
function createBackgroundEl(e, t, i) {
  return new ('polar' === e.type ? Sector : Rect$2)({
    shape: createBackgroundShape(t, i, e),
    silent: !0,
    z2: 0
  })
}
function install$P(e) {
  e.registerChartView(BarView),
    e.registerSeriesModel(BarSeriesModel),
    e.registerLayout(e.PRIORITY.VISUAL.LAYOUT, curry$1(layout$3, 'bar')),
    e.registerLayout(e.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, largeLayout),
    e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, dataSample('bar')),
    e.registerAction(
      { type: 'changeAxisOrder', event: 'changeAxisOrder', update: 'update' },
      function (e, t) {
        var i = e.componentType || 'series'
        t.eachComponent({ mainType: i, query: e }, function (t) {
          e.sortInfo && t.axis.setCategorySortInfo(e.sortInfo)
        })
      }
    )
}
var PI2$2 = 2 * Math.PI,
  RADIAN$2 = Math.PI / 180
function getViewRect$5(e, t) {
  return getLayoutRect(e.getBoxLayoutParams(), { width: t.getWidth(), height: t.getHeight() })
}
function pieLayout(e, t, i) {
  t.eachSeriesByType(e, function (e) {
    var t = e.getData(),
      r = t.mapDimension('value'),
      n = getViewRect$5(e, i),
      a = e.get('center'),
      o = e.get('radius')
    isArray$1(o) || (o = [0, o]), isArray$1(a) || (a = [a, a])
    var s = parsePercent$1(n.width, i.getWidth()),
      l = parsePercent$1(n.height, i.getHeight()),
      h = Math.min(s, l),
      u = parsePercent$1(a[0], s) + n.x,
      p = parsePercent$1(a[1], l) + n.y,
      c = parsePercent$1(o[0], h / 2),
      d = parsePercent$1(o[1], h / 2),
      f = -e.get('startAngle') * RADIAN$2,
      m = e.get('minAngle') * RADIAN$2,
      g = 0
    t.each(r, function (e) {
      !isNaN(e) && g++
    })
    var y = t.getSum(r),
      v = (Math.PI / (y || g)) * 2,
      _ = e.get('clockwise'),
      x = e.get('roseType'),
      S = e.get('stillShowZeroSum'),
      b = t.getDataExtent(r)
    b[0] = 0
    var T = PI2$2,
      A = 0,
      w = f,
      M = _ ? 1 : -1
    if (
      (t.setLayout({ viewRect: n, r: d }),
      t.each(r, function (e, i) {
        var r
        if (isNaN(e))
          t.setItemLayout(i, {
            angle: NaN,
            startAngle: NaN,
            endAngle: NaN,
            clockwise: _,
            cx: u,
            cy: p,
            r0: c,
            r: x ? NaN : d
          })
        else {
          ;(r = 'area' !== x ? (0 === y && S ? v : e * v) : PI2$2 / g) < m
            ? ((r = m), (T -= m))
            : (A += e)
          var n = w + M * r
          t.setItemLayout(i, {
            angle: r,
            startAngle: w,
            endAngle: n,
            clockwise: _,
            cx: u,
            cy: p,
            r0: c,
            r: x ? linearMap$2(e, b, [c, d]) : d
          }),
            (w = n)
        }
      }),
      T < PI2$2 && g)
    )
      if (T <= 0.001) {
        var C = PI2$2 / g
        t.each(r, function (e, i) {
          if (!isNaN(e)) {
            var r = t.getItemLayout(i)
            ;(r.angle = C), (r.startAngle = f + M * i * C), (r.endAngle = f + M * (i + 1) * C)
          }
        })
      } else
        (v = T / A),
          (w = f),
          t.each(r, function (e, i) {
            if (!isNaN(e)) {
              var r = t.getItemLayout(i),
                n = r.angle === m ? m : e * v
              ;(r.startAngle = w), (r.endAngle = w + M * n), (w += M * n)
            }
          })
  })
}
function dataFilter$1(e) {
  return {
    seriesType: e,
    reset: function (e, t) {
      var i = t.findComponents({ mainType: 'legend' })
      if (i && i.length) {
        var r = e.getData()
        r.filterSelf(function (e) {
          for (var t = r.getName(e), n = 0; n < i.length; n++) if (!i[n].isSelected(t)) return !1
          return !0
        })
      }
    }
  }
}
var RADIAN$1 = Math.PI / 180
function adjustSingleSide(e, t, i, r, n, a, o, s, l, h) {
  if (!(e.length < 2)) {
    for (var u = e.length, p = 0; p < u; p++)
      if ('outer' === e[p].position && 'labelLine' === e[p].labelAlignTo) {
        var c = e[p].label.x - h
        ;(e[p].linePoints[1][0] += c), (e[p].label.x = h)
      }
    shiftLayoutOnY(e, l, l + o) &&
      (function (e) {
        for (var a = { list: [], maxY: 0 }, o = { list: [], maxY: 0 }, s = 0; s < e.length; s++)
          if ('none' === e[s].labelAlignTo) {
            var l = e[s],
              h = l.label.y > i ? o : a,
              u = Math.abs(l.label.y - i)
            if (u > h.maxY) {
              var p = l.label.x - t - l.len2 * n,
                c = r + l.len,
                f = Math.abs(p) < c ? Math.sqrt((u * u) / (1 - (p * p) / c / c)) : c
              ;(h.rB = f), (h.maxY = u)
            }
            h.list.push(l)
          }
        d(a), d(o)
      })(e)
  }
  function d(e) {
    for (var a = e.rB, o = a * a, s = 0; s < e.list.length; s++) {
      var l = e.list[s],
        h = Math.abs(l.label.y - i),
        u = r + l.len,
        p = u * u,
        c = Math.sqrt((1 - Math.abs((h * h) / o)) * p)
      l.label.x = t + (c + l.len2) * n
    }
  }
}
function avoidOverlap(e, t, i, r, n, a, o, s) {
  for (var l = [], h = [], u = Number.MAX_VALUE, p = -Number.MAX_VALUE, c = 0; c < e.length; c++) {
    var d = e[c].label
    isPositionCenter(e[c]) ||
      (d.x < t ? ((u = Math.min(u, d.x)), l.push(e[c])) : ((p = Math.max(p, d.x)), h.push(e[c])))
  }
  adjustSingleSide(h, t, i, r, 1, n, a, o, s, p), adjustSingleSide(l, t, i, r, -1, n, a, o, s, u)
  for (c = 0; c < e.length; c++) {
    var f = e[c]
    d = f.label
    if (!isPositionCenter(f)) {
      var m = f.linePoints
      if (m) {
        var g = 'edge' === f.labelAlignTo,
          y = f.rect.width,
          v = void 0
        ;(v = g
          ? d.x < t
            ? m[2][0] - f.labelDistance - o - f.edgeDistance
            : o + n - f.edgeDistance - m[2][0] - f.labelDistance
          : d.x < t
          ? d.x - o - f.bleedMargin
          : o + n - d.x - f.bleedMargin) < f.rect.width &&
          ((f.label.style.width = v), 'edge' === f.labelAlignTo && (y = v))
        var _ = m[1][0] - m[2][0]
        g
          ? d.x < t
            ? (m[2][0] = o + f.edgeDistance + y + f.labelDistance)
            : (m[2][0] = o + n - f.edgeDistance - y - f.labelDistance)
          : (d.x < t ? (m[2][0] = d.x + f.labelDistance) : (m[2][0] = d.x - f.labelDistance),
            (m[1][0] = m[2][0] + _)),
          (m[1][1] = m[2][1] = d.y)
      }
    }
  }
}
function isPositionCenter(e) {
  return 'center' === e.position
}
function pieLabelLayout(e) {
  var t,
    i,
    r = e.getData(),
    n = [],
    a = !1,
    o = (e.get('minShowLabelAngle') || 0) * RADIAN$1,
    s = r.getLayout('viewRect'),
    l = r.getLayout('r'),
    h = s.width,
    u = s.x,
    p = s.y,
    c = s.height
  function d(e) {
    e.ignore = !0
  }
  r.each(function (e) {
    var s = r.getItemGraphicEl(e),
      p = s.shape,
      c = s.getTextContent(),
      f = s.getTextGuideLine(),
      m = r.getItemModel(e),
      g = m.getModel('label'),
      y = g.get('position') || m.get(['emphasis', 'label', 'position']),
      v = g.get('distanceToLabelLine'),
      _ = g.get('alignTo'),
      x = parsePercent$1(g.get('edgeDistance'), h),
      S = g.get('bleedMargin'),
      b = m.getModel('labelLine'),
      T = b.get('length')
    T = parsePercent$1(T, h)
    var A = b.get('length2')
    if (((A = parsePercent$1(A, h)), Math.abs(p.endAngle - p.startAngle) < o))
      return each$i(c.states, d), void (c.ignore = !0)
    if (
      (function (e) {
        if (!e.ignore) return !0
        for (var t in e.states) if (!1 === e.states[t].ignore) return !0
        return !1
      })(c)
    ) {
      var w,
        M,
        C,
        P,
        E = (p.startAngle + p.endAngle) / 2,
        I = Math.cos(E),
        D = Math.sin(E)
      ;(t = p.cx), (i = p.cy)
      var L,
        R = 'inside' === y || 'inner' === y
      if ('center' === y) (w = p.cx), (M = p.cy), (P = 'center')
      else {
        var O = (R ? ((p.r + p.r0) / 2) * I : p.r * I) + t,
          k = (R ? ((p.r + p.r0) / 2) * D : p.r * D) + i
        if (((w = O + 3 * I), (M = k + 3 * D), !R)) {
          var $ = O + I * (T + l - p.r),
            N = k + D * (T + l - p.r),
            F = $ + (I < 0 ? -1 : 1) * A
          ;(w = 'edge' === _ ? (I < 0 ? u + x : u + h - x) : F + (I < 0 ? -v : v)),
            (M = N),
            (C = [
              [O, k],
              [$, N],
              [F, N]
            ])
        }
        P = R ? 'center' : 'edge' === _ ? (I > 0 ? 'right' : 'left') : I > 0 ? 'left' : 'right'
      }
      var B = g.get('rotate')
      if (
        ((L = 'number' == typeof B ? B * (Math.PI / 180) : B ? (I < 0 ? -E + Math.PI : -E) : 0),
        (a = !!L),
        (c.x = w),
        (c.y = M),
        (c.rotation = L),
        c.setStyle({ verticalAlign: 'middle' }),
        R)
      ) {
        c.setStyle({ align: P })
        var V = c.states.select
        V && ((V.x += c.x), (V.y += c.y))
      } else {
        var z = c.getBoundingRect().clone()
        z.applyTransform(c.getComputedTransform())
        var G = (c.style.margin || 0) + 2.1
        ;(z.y -= G / 2),
          (z.height += G),
          n.push({
            label: c,
            labelLine: f,
            position: y,
            len: T,
            len2: A,
            minTurnAngle: b.get('minTurnAngle'),
            maxSurfaceAngle: b.get('maxSurfaceAngle'),
            surfaceNormal: new Point(I, D),
            linePoints: C,
            textAlign: P,
            labelDistance: v,
            labelAlignTo: _,
            edgeDistance: x,
            bleedMargin: S,
            rect: z
          })
      }
      s.setTextConfig({ inside: R })
    }
  }),
    !a && e.get('avoidLabelOverlap') && avoidOverlap(n, t, i, l, h, c, u, p)
  for (var f = 0; f < n.length; f++) {
    var m = n[f],
      g = m.label,
      y = m.labelLine,
      v = isNaN(g.x) || isNaN(g.y)
    if (g) {
      g.setStyle({ align: m.textAlign }), v && (each$i(g.states, d), (g.ignore = !0))
      var _ = g.states.select
      _ && ((_.x += g.x), (_.y += g.y))
    }
    if (y) {
      var x = m.linePoints
      v || !x
        ? (each$i(y.states, d), (y.ignore = !0))
        : (limitTurnAngle(x, m.minTurnAngle),
          limitSurfaceAngle(x, m.surfaceNormal, m.maxSurfaceAngle),
          y.setShape({ points: x }),
          (g.__hostTarget.textGuideLineConfig = { anchor: new Point(x[0][0], x[0][1]) }))
    }
  }
}
function getSectorCornerRadius(e, t) {
  var i = e.get('borderRadius')
  return null == i
    ? null
    : (isArray$1(i) || (i = [i, i]),
      { innerCornerRadius: parsePercent$2(i[0], t.r0), cornerRadius: parsePercent$2(i[1], t.r) })
}
var PiePiece = (function (e) {
    function t(t, i, r) {
      var n = e.call(this) || this
      n.z2 = 2
      var a = new ZRText()
      return n.setTextContent(a), n.updateData(t, i, r, !0), n
    }
    return (
      __extends(t, e),
      (t.prototype.updateData = function (e, t, i, r) {
        var n = this,
          a = e.hostModel,
          o = e.getItemModel(t),
          s = o.getModel('emphasis'),
          l = e.getItemLayout(t),
          h = extend$3(getSectorCornerRadius(o.getModel('itemStyle'), l) || {}, l)
        if (isNaN(h.startAngle)) n.setShape(h)
        else {
          if (r)
            n.setShape(h),
              'scale' === a.getShallow('animationType')
                ? ((n.shape.r = l.r0), initProps(n, { shape: { r: l.r } }, a, t))
                : null != i
                ? (n.setShape({ startAngle: i, endAngle: i }),
                  initProps(n, { shape: { startAngle: l.startAngle, endAngle: l.endAngle } }, a, t))
                : ((n.shape.endAngle = l.startAngle),
                  updateProps$1(n, { shape: { endAngle: l.endAngle } }, a, t))
          else updateProps$1(n, { shape: h }, a, t)
          n.useStyle(e.getItemVisual(t, 'style')), setStatesStylesFromModel(n, o)
          var u = (l.startAngle + l.endAngle) / 2,
            p = a.get('selectedOffset'),
            c = Math.cos(u) * p,
            d = Math.sin(u) * p,
            f = o.getShallow('cursor')
          f && n.attr('cursor', f),
            this._updateLabel(a, e, t),
            (n.ensureState('emphasis').shape = __assign(
              { r: l.r + ((s.get('scale') && s.get('scaleSize')) || 0) },
              getSectorCornerRadius(s.getModel('itemStyle'), l)
            )),
            extend$3(n.ensureState('select'), {
              x: c,
              y: d,
              shape: getSectorCornerRadius(o.getModel(['select', 'itemStyle']), l)
            }),
            extend$3(n.ensureState('blur'), {
              shape: getSectorCornerRadius(o.getModel(['blur', 'itemStyle']), l)
            })
          var m = n.getTextGuideLine(),
            g = n.getTextContent()
          m && extend$3(m.ensureState('select'), { x: c, y: d }),
            extend$3(g.ensureState('select'), { x: c, y: d }),
            enableHoverEmphasis(this, s.get('focus'), s.get('blurScope'))
        }
      }),
      (t.prototype._updateLabel = function (e, t, i) {
        var r = this,
          n = t.getItemModel(i),
          a = n.getModel('labelLine'),
          o = t.getItemVisual(i, 'style'),
          s = o && o.fill,
          l = o && o.opacity
        setLabelStyle(r, getLabelStatesModels(n), {
          labelFetcher: t.hostModel,
          labelDataIndex: i,
          inheritColor: s,
          defaultOpacity: l,
          defaultText: e.getFormattedLabel(i, 'normal') || t.getName(i)
        })
        var h = r.getTextContent()
        r.setTextConfig({ position: null, rotation: null }), h.attr({ z2: 10 })
        var u = e.get(['label', 'position'])
        if ('outside' !== u && 'outer' !== u) r.removeTextGuideLine()
        else {
          var p = this.getTextGuideLine()
          p || ((p = new Polyline$1()), this.setTextGuideLine(p)),
            setLabelLineStyle(this, getLabelLineStatesModels(n), {
              stroke: s,
              opacity: retrieve3(a.get(['lineStyle', 'opacity']), l, 1)
            })
        }
      }),
      t
    )
  })(Sector),
  PieView = (function (e) {
    function t() {
      var t = (null !== e && e.apply(this, arguments)) || this
      return (t.ignoreLabelLineUpdate = !0), t
    }
    return (
      __extends(t, e),
      (t.prototype.init = function () {
        var e = new Group$3()
        this._sectorGroup = e
      }),
      (t.prototype.render = function (e, t, i, r) {
        var n,
          a = e.getData(),
          o = this._data,
          s = this.group
        if (!o && a.count() > 0) {
          for (var l = a.getItemLayout(0), h = 1; isNaN(l && l.startAngle) && h < a.count(); ++h)
            l = a.getItemLayout(h)
          l && (n = l.startAngle)
        }
        a
          .diff(o)
          .add(function (e) {
            var t = new PiePiece(a, e, n)
            a.setItemGraphicEl(e, t), s.add(t)
          })
          .update(function (e, t) {
            var i = o.getItemGraphicEl(t)
            i.updateData(a, e, n), i.off('click'), s.add(i), a.setItemGraphicEl(e, i)
          })
          .remove(function (t) {
            removeElementWithFadeOut(o.getItemGraphicEl(t), e, t)
          })
          .execute(),
          pieLabelLayout(e),
          'expansion' !== e.get('animationTypeUpdate') && (this._data = a)
      }),
      (t.prototype.dispose = function () {}),
      (t.prototype.containPoint = function (e, t) {
        var i = t.getData().getItemLayout(0)
        if (i) {
          var r = e[0] - i.cx,
            n = e[1] - i.cy,
            a = Math.sqrt(r * r + n * n)
          return a <= i.r && a >= i.r0
        }
      }),
      (t.type = 'pie'),
      t
    )
  })(ChartView)
function createListSimply(e, t, i) {
  t = (isArray$1(t) && { coordDimensions: t }) || extend$3({}, t)
  var r = e.getSource(),
    n = createDimensions(r, t),
    a = new List(n, e)
  return a.initData(r, i), a
}
var LegendVisualProvider = (function () {
    function e(e, t) {
      ;(this._getDataWithEncodedVisual = e), (this._getRawData = t)
    }
    return (
      (e.prototype.getAllNames = function () {
        var e = this._getRawData()
        return e.mapArray(e.getName)
      }),
      (e.prototype.containName = function (e) {
        return this._getRawData().indexOfName(e) >= 0
      }),
      (e.prototype.indexOfName = function (e) {
        return this._getDataWithEncodedVisual().indexOfName(e)
      }),
      (e.prototype.getItemVisual = function (e, t) {
        return this._getDataWithEncodedVisual().getItemVisual(e, t)
      }),
      e
    )
  })(),
  PieSeriesModel = (function (e) {
    function t() {
      var t = (null !== e && e.apply(this, arguments)) || this
      return (t.useColorPaletteOnData = !0), t
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (t) {
        e.prototype.init.apply(this, arguments),
          (this.legendVisualProvider = new LegendVisualProvider(
            bind$2(this.getData, this),
            bind$2(this.getRawData, this)
          )),
          this._defaultLabelLine(t)
      }),
      (t.prototype.mergeOption = function () {
        e.prototype.mergeOption.apply(this, arguments)
      }),
      (t.prototype.getInitialData = function () {
        return createListSimply(this, {
          coordDimensions: ['value'],
          encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
        })
      }),
      (t.prototype.getDataParams = function (t) {
        var i = this.getData(),
          r = e.prototype.getDataParams.call(this, t),
          n = []
        return (
          i.each(i.mapDimension('value'), function (e) {
            n.push(e)
          }),
          (r.percent = getPercentWithPrecision(n, t, i.hostModel.get('percentPrecision'))),
          r.$vars.push('percent'),
          r
        )
      }),
      (t.prototype._defaultLabelLine = function (e) {
        defaultEmphasis(e, 'labelLine', ['show'])
        var t = e.labelLine,
          i = e.emphasis.labelLine
        ;(t.show = t.show && e.label.show), (i.show = i.show && e.emphasis.label.show)
      }),
      (t.type = 'series.pie'),
      (t.defaultOption = {
        zlevel: 0,
        z: 2,
        legendHoverLink: !0,
        center: ['50%', '50%'],
        radius: [0, '75%'],
        clockwise: !0,
        startAngle: 90,
        minAngle: 0,
        minShowLabelAngle: 0,
        selectedOffset: 10,
        percentPrecision: 2,
        stillShowZeroSum: !0,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        width: null,
        height: null,
        label: {
          rotate: 0,
          show: !0,
          overflow: 'truncate',
          position: 'outer',
          alignTo: 'none',
          edgeDistance: '25%',
          bleedMargin: 10,
          distanceToLabelLine: 5
        },
        labelLine: {
          show: !0,
          length: 15,
          length2: 15,
          smooth: !1,
          minTurnAngle: 90,
          maxSurfaceAngle: 90,
          lineStyle: { width: 1, type: 'solid' }
        },
        itemStyle: { borderWidth: 1 },
        labelLayout: { hideOverlap: !0 },
        emphasis: { scale: !0, scaleSize: 5 },
        avoidLabelOverlap: !0,
        animationType: 'expansion',
        animationDuration: 1e3,
        animationTypeUpdate: 'transition',
        animationEasingUpdate: 'cubicInOut',
        animationDurationUpdate: 500,
        animationEasing: 'cubicInOut'
      }),
      t
    )
  })(SeriesModel)
function install$O(e) {
  e.registerChartView(PieView),
    e.registerSeriesModel(PieSeriesModel),
    createLegacyDataSelectAction('pie', e.registerAction),
    e.registerLayout(curry$1(pieLayout, 'pie')),
    e.registerProcessor(dataFilter$1('pie'))
}
var ScatterSeriesModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.hasSymbolVisual = !0), i
    }
    return (
      __extends(t, e),
      (t.prototype.getInitialData = function (e, t) {
        return createListFromArray(this.getSource(), this, { useEncodeDefaulter: !0 })
      }),
      (t.prototype.getProgressive = function () {
        var e = this.option.progressive
        return null == e ? (this.option.large ? 5e3 : this.get('progressive')) : e
      }),
      (t.prototype.getProgressiveThreshold = function () {
        var e = this.option.progressiveThreshold
        return null == e ? (this.option.large ? 1e4 : this.get('progressiveThreshold')) : e
      }),
      (t.prototype.brushSelector = function (e, t, i) {
        return i.point(t.getItemLayout(e))
      }),
      (t.type = 'series.scatter'),
      (t.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar']),
      (t.defaultOption = {
        coordinateSystem: 'cartesian2d',
        zlevel: 0,
        z: 2,
        legendHoverLink: !0,
        symbolSize: 10,
        large: !1,
        largeThreshold: 2e3,
        itemStyle: { opacity: 0.8 },
        emphasis: { scale: !0 },
        clip: !0,
        select: { itemStyle: { borderColor: '#212121' } }
      }),
      t
    )
  })(SeriesModel),
  BOOST_SIZE_THRESHOLD = 4,
  LargeSymbolPathShape = function () {},
  LargeSymbolPath = (function (e) {
    function t(t) {
      return e.call(this, t) || this
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultShape = function () {
        return new LargeSymbolPathShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        var i = t.points,
          r = t.size,
          n = this.symbolProxy,
          a = n.shape,
          o = e.getContext ? e.getContext() : e
        if (o && r[0] < BOOST_SIZE_THRESHOLD) this._ctx = o
        else {
          this._ctx = null
          for (var s = 0; s < i.length; ) {
            var l = i[s++],
              h = i[s++]
            isNaN(l) ||
              isNaN(h) ||
              (this.softClipShape && !this.softClipShape.contain(l, h)) ||
              ((a.x = l - r[0] / 2),
              (a.y = h - r[1] / 2),
              (a.width = r[0]),
              (a.height = r[1]),
              n.buildPath(e, a, !0))
          }
        }
      }),
      (t.prototype.afterBrush = function () {
        var e = this.shape,
          t = e.points,
          i = e.size,
          r = this._ctx
        if (r)
          for (var n = 0; n < t.length; ) {
            var a = t[n++],
              o = t[n++]
            isNaN(a) ||
              isNaN(o) ||
              (this.softClipShape && !this.softClipShape.contain(a, o)) ||
              r.fillRect(a - i[0] / 2, o - i[1] / 2, i[0], i[1])
          }
      }),
      (t.prototype.findDataIndex = function (e, t) {
        for (
          var i = this.shape,
            r = i.points,
            n = i.size,
            a = Math.max(n[0], 4),
            o = Math.max(n[1], 4),
            s = r.length / 2 - 1;
          s >= 0;
          s--
        ) {
          var l = 2 * s,
            h = r[l] - a / 2,
            u = r[l + 1] - o / 2
          if (e >= h && t >= u && e <= h + a && t <= u + o) return s
        }
        return -1
      }),
      t
    )
  })(Path),
  LargeSymbolDraw = (function () {
    function e() {
      this.group = new Group$3()
    }
    return (
      (e.prototype.isPersistent = function () {
        return !this._incremental
      }),
      (e.prototype.updateData = function (e, t) {
        this.group.removeAll()
        var i = new LargeSymbolPath({ rectHover: !0, cursor: 'default' })
        i.setShape({ points: e.getLayout('points') }),
          this._setCommon(i, e, !1, t),
          this.group.add(i),
          (this._incremental = null)
      }),
      (e.prototype.updateLayout = function (e) {
        if (!this._incremental) {
          var t = e.getLayout('points')
          this.group.eachChild(function (e) {
            if (null != e.startIndex) {
              var i = 2 * (e.endIndex - e.startIndex),
                r = 4 * e.startIndex * 2
              t = new Float32Array(t.buffer, r, i)
            }
            e.setShape('points', t)
          })
        }
      }),
      (e.prototype.incrementalPrepareUpdate = function (e) {
        this.group.removeAll(),
          this._clearIncremental(),
          e.count() > 2e6
            ? (this._incremental ||
                (this._incremental = new IncrementalDisplayable({ silent: !0 })),
              this.group.add(this._incremental))
            : (this._incremental = null)
      }),
      (e.prototype.incrementalUpdate = function (e, t, i) {
        var r
        this._incremental
          ? ((r = new LargeSymbolPath()), this._incremental.addDisplayable(r, !0))
          : (((r = new LargeSymbolPath({
              rectHover: !0,
              cursor: 'default',
              startIndex: e.start,
              endIndex: e.end
            })).incremental = !0),
            this.group.add(r)),
          r.setShape({ points: t.getLayout('points') }),
          this._setCommon(r, t, !!this._incremental, i)
      }),
      (e.prototype._setCommon = function (e, t, i, r) {
        var n = t.hostModel
        r = r || {}
        var a = t.getVisual('symbolSize')
        e.setShape('size', a instanceof Array ? a : [a, a]),
          (e.softClipShape = r.clipShape || null),
          (e.symbolProxy = createSymbol$1(t.getVisual('symbol'), 0, 0, 0, 0)),
          (e.setColor = e.symbolProxy.setColor)
        var o = e.shape.size[0] < BOOST_SIZE_THRESHOLD
        e.useStyle(
          n
            .getModel('itemStyle')
            .getItemStyle(o ? ['color', 'shadowBlur', 'shadowColor'] : ['color'])
        )
        var s = t.getVisual('style'),
          l = s && s.fill
        if ((l && e.setColor(l), !i)) {
          var h = getECData(e)
          ;(h.seriesIndex = n.seriesIndex),
            e.on('mousemove', function (t) {
              h.dataIndex = null
              var i = e.findDataIndex(t.offsetX, t.offsetY)
              i >= 0 && (h.dataIndex = i + (e.startIndex || 0))
            })
        }
      }),
      (e.prototype.remove = function () {
        this._clearIncremental(), (this._incremental = null), this.group.removeAll()
      }),
      (e.prototype._clearIncremental = function () {
        var e = this._incremental
        e && e.clearDisplaybles()
      }),
      e
    )
  })(),
  ScatterView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i) {
        var r = e.getData()
        this._updateSymbolDraw(r, e).updateData(r, { clipShape: this._getClipShape(e) }),
          (this._finished = !0)
      }),
      (t.prototype.incrementalPrepareRender = function (e, t, i) {
        var r = e.getData()
        this._updateSymbolDraw(r, e).incrementalPrepareUpdate(r), (this._finished = !1)
      }),
      (t.prototype.incrementalRender = function (e, t, i) {
        this._symbolDraw.incrementalUpdate(e, t.getData(), { clipShape: this._getClipShape(t) }),
          (this._finished = e.end === t.getData().count())
      }),
      (t.prototype.updateTransform = function (e, t, i) {
        var r = e.getData()
        if (
          (this.group.dirty(),
          !this._finished || r.count() > 1e4 || !this._symbolDraw.isPersistent())
        )
          return { update: !0 }
        var n = pointsLayout('').reset(e, t, i)
        n.progress && n.progress({ start: 0, end: r.count(), count: r.count() }, r),
          this._symbolDraw.updateLayout(r)
      }),
      (t.prototype._getClipShape = function (e) {
        var t = e.coordinateSystem,
          i = t && t.getArea && t.getArea()
        return e.get('clip', !0) ? i : null
      }),
      (t.prototype._updateSymbolDraw = function (e, t) {
        var i = this._symbolDraw,
          r = t.pipelineContext.large
        return (
          (i && r === this._isLargeDraw) ||
            (i && i.remove(),
            (i = this._symbolDraw = r ? new LargeSymbolDraw() : new SymbolDraw()),
            (this._isLargeDraw = r),
            this.group.removeAll()),
          this.group.add(i.group),
          i
        )
      }),
      (t.prototype.remove = function (e, t) {
        this._symbolDraw && this._symbolDraw.remove(!0), (this._symbolDraw = null)
      }),
      (t.prototype.dispose = function () {}),
      (t.type = 'scatter'),
      t
    )
  })(ChartView),
  GridModel = (function (e) {
    function t() {
      return (null !== e && e.apply(this, arguments)) || this
    }
    return (
      __extends(t, e),
      (t.type = 'grid'),
      (t.dependencies = ['xAxis', 'yAxis']),
      (t.layoutMode = 'box'),
      (t.defaultOption = {
        show: !1,
        zlevel: 0,
        z: 0,
        left: '10%',
        top: 60,
        right: '10%',
        bottom: 70,
        containLabel: !1,
        backgroundColor: 'rgba(0,0,0,0)',
        borderWidth: 1,
        borderColor: '#ccc'
      }),
      t
    )
  })(ComponentModel),
  CartesianAxisModel = (function (e) {
    function t() {
      return (null !== e && e.apply(this, arguments)) || this
    }
    return (
      __extends(t, e),
      (t.prototype.getCoordSysModel = function () {
        return this.getReferringComponents('grid', SINGLE_REFERRING).models[0]
      }),
      (t.type = 'cartesian2dAxis'),
      t
    )
  })(ComponentModel)
mixin(CartesianAxisModel, AxisModelCommonMixin)
var defaultOption$1 = {
    show: !0,
    zlevel: 0,
    z: 0,
    inverse: !1,
    name: '',
    nameLocation: 'end',
    nameRotate: null,
    nameTruncate: { maxWidth: null, ellipsis: '...', placeholder: '.' },
    nameTextStyle: {},
    nameGap: 15,
    silent: !1,
    triggerEvent: !1,
    tooltip: { show: !1 },
    axisPointer: {},
    axisLine: {
      show: !0,
      onZero: !0,
      onZeroAxisIndex: null,
      lineStyle: { color: '#6E7079', width: 1, type: 'solid' },
      symbol: ['none', 'none'],
      symbolSize: [10, 15]
    },
    axisTick: { show: !0, inside: !1, length: 5, lineStyle: { width: 1 } },
    axisLabel: {
      show: !0,
      inside: !1,
      rotate: 0,
      showMinLabel: null,
      showMaxLabel: null,
      margin: 8,
      fontSize: 12
    },
    splitLine: { show: !0, lineStyle: { color: ['#E0E6F1'], width: 1, type: 'solid' } },
    splitArea: {
      show: !1,
      areaStyle: { color: ['rgba(250,250,250,0.2)', 'rgba(210,219,238,0.2)'] }
    }
  },
  categoryAxis = merge(
    {
      boundaryGap: !0,
      deduplication: null,
      splitLine: { show: !1 },
      axisTick: { alignWithLabel: !1, interval: 'auto' },
      axisLabel: { interval: 'auto' }
    },
    defaultOption$1
  ),
  valueAxis = merge(
    {
      boundaryGap: [0, 0],
      axisLine: { show: 'auto' },
      axisTick: { show: 'auto' },
      splitNumber: 5,
      minorTick: { show: !1, splitNumber: 5, length: 3, lineStyle: {} },
      minorSplitLine: { show: !1, lineStyle: { color: '#F4F7FD', width: 1 } }
    },
    defaultOption$1
  ),
  timeAxis = merge(
    {
      scale: !0,
      splitNumber: 6,
      axisLabel: { showMinLabel: !1, showMaxLabel: !1, rich: { primary: { fontWeight: 'bold' } } },
      splitLine: { show: !1 }
    },
    valueAxis
  ),
  logAxis = defaults$1({ scale: !0, logBase: 10 }, valueAxis),
  axisDefault = { category: categoryAxis, value: valueAxis, time: timeAxis, log: logAxis },
  AXIS_TYPES = { value: 1, category: 1, time: 1, log: 1 }
function axisModelCreator(e, t, i, r) {
  each$i(AXIS_TYPES, function (n, a) {
    var o = merge(merge({}, axisDefault[a], !0), r, !0),
      s = (function (e) {
        function i() {
          for (var i = [], r = 0; r < arguments.length; r++) i[r] = arguments[r]
          var n = e.apply(this, i) || this
          return (n.type = t + 'Axis.' + a), n
        }
        return (
          __extends(i, e),
          (i.prototype.mergeDefaultAndTheme = function (e, t) {
            var i = fetchLayoutMode(this),
              r = i ? getLayoutParams(e) : {}
            merge(e, t.getTheme().get(a + 'Axis')),
              merge(e, this.getDefaultOption()),
              (e.type = getAxisType(e)),
              i && mergeLayoutParam(e, r, i)
          }),
          (i.prototype.optionUpdated = function () {
            'category' === this.option.type &&
              (this.__ordinalMeta = OrdinalMeta.createByAxisModel(this))
          }),
          (i.prototype.getCategories = function (e) {
            var t = this.option
            if ('category' === t.type) return e ? t.data : this.__ordinalMeta.categories
          }),
          (i.prototype.getOrdinalMeta = function () {
            return this.__ordinalMeta
          }),
          (i.type = t + 'Axis.' + a),
          (i.defaultOption = o),
          i
        )
      })(i)
    e.registerComponentModel(s)
  }),
    e.registerSubTypeDefaulter(t + 'Axis', getAxisType)
}
function getAxisType(e) {
  return e.type || (e.data ? 'category' : 'value')
}
var Cartesian = (function () {
    function e(e) {
      ;(this.type = 'cartesian'), (this._dimList = []), (this._axes = {}), (this.name = e || '')
    }
    return (
      (e.prototype.getAxis = function (e) {
        return this._axes[e]
      }),
      (e.prototype.getAxes = function () {
        return map$1(
          this._dimList,
          function (e) {
            return this._axes[e]
          },
          this
        )
      }),
      (e.prototype.getAxesByScale = function (e) {
        return (
          (e = e.toLowerCase()),
          filter$1(this.getAxes(), function (t) {
            return t.scale.type === e
          })
        )
      }),
      (e.prototype.addAxis = function (e) {
        var t = e.dim
        ;(this._axes[t] = e), this._dimList.push(t)
      }),
      e
    )
  })(),
  cartesian2DDimensions = ['x', 'y']
function canCalculateAffineTransform(e) {
  return 'interval' === e.type || 'time' === e.type
}
var Cartesian2D = (function (e) {
    function t() {
      var t = (null !== e && e.apply(this, arguments)) || this
      return (t.type = 'cartesian2d'), (t.dimensions = cartesian2DDimensions), t
    }
    return (
      __extends(t, e),
      (t.prototype.calcAffineTransform = function () {
        this._transform = this._invTransform = null
        var e = this.getAxis('x').scale,
          t = this.getAxis('y').scale
        if (canCalculateAffineTransform(e) && canCalculateAffineTransform(t)) {
          var i = e.getExtent(),
            r = t.getExtent(),
            n = this.dataToPoint([i[0], r[0]]),
            a = this.dataToPoint([i[1], r[1]]),
            o = i[1] - i[0],
            s = r[1] - r[0]
          if (o && s) {
            var l = (a[0] - n[0]) / o,
              h = (a[1] - n[1]) / s,
              u = n[0] - i[0] * l,
              p = n[1] - r[0] * h,
              c = (this._transform = [l, 0, 0, h, u, p])
            this._invTransform = invert([], c)
          }
        }
      }),
      (t.prototype.getBaseAxis = function () {
        return (
          this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x')
        )
      }),
      (t.prototype.containPoint = function (e) {
        var t = this.getAxis('x'),
          i = this.getAxis('y')
        return t.contain(t.toLocalCoord(e[0])) && i.contain(i.toLocalCoord(e[1]))
      }),
      (t.prototype.containData = function (e) {
        return this.getAxis('x').containData(e[0]) && this.getAxis('y').containData(e[1])
      }),
      (t.prototype.dataToPoint = function (e, t, i) {
        i = i || []
        var r = e[0],
          n = e[1]
        if (this._transform && null != r && isFinite(r) && null != n && isFinite(n))
          return applyTransform$1(i, e, this._transform)
        var a = this.getAxis('x'),
          o = this.getAxis('y')
        return (
          (i[0] = a.toGlobalCoord(a.dataToCoord(r, t))),
          (i[1] = o.toGlobalCoord(o.dataToCoord(n, t))),
          i
        )
      }),
      (t.prototype.clampData = function (e, t) {
        var i = this.getAxis('x').scale,
          r = this.getAxis('y').scale,
          n = i.getExtent(),
          a = r.getExtent(),
          o = i.parse(e[0]),
          s = r.parse(e[1])
        return (
          ((t = t || [])[0] = Math.min(Math.max(Math.min(n[0], n[1]), o), Math.max(n[0], n[1]))),
          (t[1] = Math.min(Math.max(Math.min(a[0], a[1]), s), Math.max(a[0], a[1]))),
          t
        )
      }),
      (t.prototype.pointToData = function (e, t) {
        var i = []
        if (this._invTransform) return applyTransform$1(i, e, this._invTransform)
        var r = this.getAxis('x'),
          n = this.getAxis('y')
        return (
          (i[0] = r.coordToData(r.toLocalCoord(e[0]), t)),
          (i[1] = n.coordToData(n.toLocalCoord(e[1]), t)),
          i
        )
      }),
      (t.prototype.getOtherAxis = function (e) {
        return this.getAxis('x' === e.dim ? 'y' : 'x')
      }),
      (t.prototype.getArea = function () {
        var e = this.getAxis('x').getGlobalExtent(),
          t = this.getAxis('y').getGlobalExtent(),
          i = Math.min(e[0], e[1]),
          r = Math.min(t[0], t[1]),
          n = Math.max(e[0], e[1]) - i,
          a = Math.max(t[0], t[1]) - r
        return new BoundingRect(i, r, n, a)
      }),
      t
    )
  })(Cartesian),
  Axis2D = (function (e) {
    function t(t, i, r, n, a) {
      var o = e.call(this, t, i, r) || this
      return (o.index = 0), (o.type = n || 'value'), (o.position = a || 'bottom'), o
    }
    return (
      __extends(t, e),
      (t.prototype.isHorizontal = function () {
        var e = this.position
        return 'top' === e || 'bottom' === e
      }),
      (t.prototype.getGlobalExtent = function (e) {
        var t = this.getExtent()
        return (
          (t[0] = this.toGlobalCoord(t[0])),
          (t[1] = this.toGlobalCoord(t[1])),
          e && t[0] > t[1] && t.reverse(),
          t
        )
      }),
      (t.prototype.pointToData = function (e, t) {
        return this.coordToData(this.toLocalCoord(e['x' === this.dim ? 0 : 1]), t)
      }),
      (t.prototype.setCategorySortInfo = function (e) {
        if ('category' !== this.type) return !1
        ;(this.model.option.categorySortInfo = e), this.scale.setSortInfo(e)
      }),
      t
    )
  })(Axis)
function layout$2(e, t, i) {
  i = i || {}
  var r = e.coordinateSystem,
    n = t.axis,
    a = {},
    o = n.getAxesOnZeroOf()[0],
    s = n.position,
    l = o ? 'onZero' : s,
    h = n.dim,
    u = r.getRect(),
    p = [u.x, u.x + u.width, u.y, u.y + u.height],
    c = { left: 0, right: 1, top: 0, bottom: 1, onZero: 2 },
    d = t.get('offset') || 0,
    f = 'x' === h ? [p[2] - d, p[3] + d] : [p[0] - d, p[1] + d]
  if (o) {
    var m = o.toGlobalCoord(o.dataToCoord(0))
    f[c.onZero] = Math.max(Math.min(m, f[1]), f[0])
  }
  ;(a.position = ['y' === h ? f[c[l]] : p[0], 'x' === h ? f[c[l]] : p[3]]),
    (a.rotation = (Math.PI / 2) * ('x' === h ? 0 : 1))
  ;(a.labelDirection =
    a.tickDirection =
    a.nameDirection =
      { top: -1, bottom: 1, left: -1, right: 1 }[s]),
    (a.labelOffset = o ? f[c[s]] - f[c.onZero] : 0),
    t.get(['axisTick', 'inside']) && (a.tickDirection = -a.tickDirection),
    retrieve(i.labelInside, t.get(['axisLabel', 'inside'])) &&
      (a.labelDirection = -a.labelDirection)
  var g = t.get(['axisLabel', 'rotate'])
  return (a.labelRotate = 'top' === l ? -g : g), (a.z2 = 1), a
}
function isCartesian2DSeries(e) {
  return 'cartesian2d' === e.get('coordinateSystem')
}
function findAxisModels(e) {
  var t = { xAxisModel: null, yAxisModel: null }
  return (
    each$i(t, function (i, r) {
      var n = r.replace(/Model$/, ''),
        a = e.getReferringComponents(n, SINGLE_REFERRING).models[0]
      t[r] = a
    }),
    t
  )
}
var Grid = (function () {
  function e(e, t, i) {
    ;(this.type = 'grid'),
      (this._coordsMap = {}),
      (this._coordsList = []),
      (this._axesMap = {}),
      (this._axesList = []),
      (this.axisPointerEnabled = !0),
      (this.dimensions = cartesian2DDimensions),
      this._initCartesian(e, t, i),
      (this.model = e)
  }
  return (
    (e.prototype.getRect = function () {
      return this._rect
    }),
    (e.prototype.update = function (e, t) {
      var i = this._axesMap
      this._updateScale(e, this.model),
        each$i(i.x, function (e) {
          niceScaleExtent(e.scale, e.model)
        }),
        each$i(i.y, function (e) {
          niceScaleExtent(e.scale, e.model)
        })
      var r = {}
      each$i(i.x, function (e) {
        fixAxisOnZero(i, 'y', e, r)
      }),
        each$i(i.y, function (e) {
          fixAxisOnZero(i, 'x', e, r)
        }),
        this.resize(this.model, t)
    }),
    (e.prototype.resize = function (e, t, i) {
      var r = e.getBoxLayoutParams(),
        n = !i && e.get('containLabel'),
        a = getLayoutRect(r, { width: t.getWidth(), height: t.getHeight() })
      this._rect = a
      var o = this._axesList
      function s() {
        each$i(o, function (e) {
          var t = e.isHorizontal(),
            i = t ? [0, a.width] : [0, a.height],
            r = e.inverse ? 1 : 0
          e.setExtent(i[r], i[1 - r]), updateAxisTransform(e, t ? a.x : a.y)
        })
      }
      s(),
        n &&
          (each$i(o, function (e) {
            if (!e.model.get(['axisLabel', 'inside'])) {
              var t = estimateLabelUnionRect(e)
              if (t) {
                var i = e.isHorizontal() ? 'height' : 'width',
                  r = e.model.get(['axisLabel', 'margin'])
                ;(a[i] -= t[i] + r),
                  'top' === e.position
                    ? (a.y += t.height + r)
                    : 'left' === e.position && (a.x += t.width + r)
              }
            }
          }),
          s()),
        each$i(this._coordsList, function (e) {
          e.calcAffineTransform()
        })
    }),
    (e.prototype.getAxis = function (e, t) {
      var i = this._axesMap[e]
      if (null != i) return i[t || 0]
    }),
    (e.prototype.getAxes = function () {
      return this._axesList.slice()
    }),
    (e.prototype.getCartesian = function (e, t) {
      if (null != e && null != t) {
        var i = 'x' + e + 'y' + t
        return this._coordsMap[i]
      }
      isObject$7(e) && ((t = e.yAxisIndex), (e = e.xAxisIndex))
      for (var r = 0, n = this._coordsList; r < n.length; r++)
        if (n[r].getAxis('x').index === e || n[r].getAxis('y').index === t) return n[r]
    }),
    (e.prototype.getCartesians = function () {
      return this._coordsList.slice()
    }),
    (e.prototype.convertToPixel = function (e, t, i) {
      var r = this._findConvertTarget(t)
      return r.cartesian
        ? r.cartesian.dataToPoint(i)
        : r.axis
        ? r.axis.toGlobalCoord(r.axis.dataToCoord(i))
        : null
    }),
    (e.prototype.convertFromPixel = function (e, t, i) {
      var r = this._findConvertTarget(t)
      return r.cartesian
        ? r.cartesian.pointToData(i)
        : r.axis
        ? r.axis.coordToData(r.axis.toLocalCoord(i))
        : null
    }),
    (e.prototype._findConvertTarget = function (e) {
      var t,
        i,
        r = e.seriesModel,
        n = e.xAxisModel || (r && r.getReferringComponents('xAxis', SINGLE_REFERRING).models[0]),
        a = e.yAxisModel || (r && r.getReferringComponents('yAxis', SINGLE_REFERRING).models[0]),
        o = e.gridModel,
        s = this._coordsList
      if (r) indexOf$1(s, (t = r.coordinateSystem)) < 0 && (t = null)
      else if (n && a) t = this.getCartesian(n.componentIndex, a.componentIndex)
      else if (n) i = this.getAxis('x', n.componentIndex)
      else if (a) i = this.getAxis('y', a.componentIndex)
      else if (o) {
        o.coordinateSystem === this && (t = this._coordsList[0])
      }
      return { cartesian: t, axis: i }
    }),
    (e.prototype.containPoint = function (e) {
      var t = this._coordsList[0]
      if (t) return t.containPoint(e)
    }),
    (e.prototype._initCartesian = function (e, t, i) {
      var r = this,
        n = this,
        a = { left: !1, right: !1, top: !1, bottom: !1 },
        o = { x: {}, y: {} },
        s = { x: 0, y: 0 }
      if (
        (t.eachComponent('xAxis', l('x'), this),
        t.eachComponent('yAxis', l('y'), this),
        !s.x || !s.y)
      )
        return (this._axesMap = {}), void (this._axesList = [])
      function l(t) {
        return function (i, r) {
          if (isAxisUsedInTheGrid(i, e)) {
            var l = i.get('position')
            'x' === t
              ? 'top' !== l && 'bottom' !== l && (l = a.bottom ? 'top' : 'bottom')
              : 'left' !== l && 'right' !== l && (l = a.left ? 'right' : 'left'),
              (a[l] = !0)
            var h = new Axis2D(t, createScaleByModel$1(i), [0, 0], i.get('type'), l),
              u = 'category' === h.type
            ;(h.onBand = u && i.get('boundaryGap')),
              (h.inverse = i.get('inverse')),
              (i.axis = h),
              (h.model = i),
              (h.grid = n),
              (h.index = r),
              n._axesList.push(h),
              (o[t][r] = h),
              s[t]++
          }
        }
      }
      ;(this._axesMap = o),
        each$i(o.x, function (t, i) {
          each$i(o.y, function (n, a) {
            var o = 'x' + i + 'y' + a,
              s = new Cartesian2D(o)
            ;(s.master = r),
              (s.model = e),
              (r._coordsMap[o] = s),
              r._coordsList.push(s),
              s.addAxis(t),
              s.addAxis(n)
          })
        })
    }),
    (e.prototype._updateScale = function (e, t) {
      function i(e, t) {
        each$i(getDataDimensionsOnAxis(e, t.dim), function (i) {
          t.scale.unionExtentFromData(e, i)
        })
      }
      each$i(this._axesList, function (e) {
        if ((e.scale.setExtent(1 / 0, -1 / 0), 'category' === e.type)) {
          var t = e.model.get('categorySortInfo')
          e.scale.setSortInfo(t)
        }
      }),
        e.eachSeries(function (e) {
          if (isCartesian2DSeries(e)) {
            var r = findAxisModels(e),
              n = r.xAxisModel,
              a = r.yAxisModel
            if (!isAxisUsedInTheGrid(n, t) || !isAxisUsedInTheGrid(a, t)) return
            var o = this.getCartesian(n.componentIndex, a.componentIndex),
              s = e.getData(),
              l = o.getAxis('x'),
              h = o.getAxis('y')
            'list' === s.type && (i(s, l), i(s, h))
          }
        }, this)
    }),
    (e.prototype.getTooltipAxes = function (e) {
      var t = [],
        i = []
      return (
        each$i(this.getCartesians(), function (r) {
          var n = null != e && 'auto' !== e ? r.getAxis(e) : r.getBaseAxis(),
            a = r.getOtherAxis(n)
          indexOf$1(t, n) < 0 && t.push(n), indexOf$1(i, a) < 0 && i.push(a)
        }),
        { baseAxes: t, otherAxes: i }
      )
    }),
    (e.create = function (t, i) {
      var r = []
      return (
        t.eachComponent('grid', function (n, a) {
          var o = new e(n, t, i)
          ;(o.name = 'grid_' + a), o.resize(n, i, !0), (n.coordinateSystem = o), r.push(o)
        }),
        t.eachSeries(function (e) {
          if (isCartesian2DSeries(e)) {
            var t = findAxisModels(e),
              i = t.xAxisModel,
              r = t.yAxisModel,
              n = i.getCoordSysModel().coordinateSystem
            e.coordinateSystem = n.getCartesian(i.componentIndex, r.componentIndex)
          }
        }),
        r
      )
    }),
    (e.dimensions = cartesian2DDimensions),
    e
  )
})()
function isAxisUsedInTheGrid(e, t) {
  return e.getCoordSysModel() === t
}
function fixAxisOnZero(e, t, i, r) {
  i.getAxesOnZeroOf = function () {
    return n ? [n] : []
  }
  var n,
    a = e[t],
    o = i.model,
    s = o.get(['axisLine', 'onZero']),
    l = o.get(['axisLine', 'onZeroAxisIndex'])
  if (s) {
    if (null != l) canOnZeroToAxis(a[l]) && (n = a[l])
    else
      for (var h in a)
        if (a.hasOwnProperty(h) && canOnZeroToAxis(a[h]) && !r[u(a[h])]) {
          n = a[h]
          break
        }
    n && (r[u(n)] = !0)
  }
  function u(e) {
    return e.dim + '_' + e.index
  }
}
function canOnZeroToAxis(e) {
  return e && 'category' !== e.type && 'time' !== e.type && ifAxisCrossZero(e)
}
function updateAxisTransform(e, t) {
  var i = e.getExtent(),
    r = i[0] + i[1]
  ;(e.toGlobalCoord =
    'x' === e.dim
      ? function (e) {
          return e + t
        }
      : function (e) {
          return r - e + t
        }),
    (e.toLocalCoord =
      'x' === e.dim
        ? function (e) {
            return e - t
          }
        : function (e) {
            return r - e + t
          })
}
var PI$3 = Math.PI,
  AxisBuilder = (function () {
    function e(e, t) {
      ;(this.group = new Group$3()),
        (this.opt = t),
        (this.axisModel = e),
        defaults$1(t, {
          labelOffset: 0,
          nameDirection: 1,
          tickDirection: 1,
          labelDirection: 1,
          silent: !0,
          handleAutoShown: function () {
            return !0
          }
        })
      var i = new Group$3({ x: t.position[0], y: t.position[1], rotation: t.rotation })
      i.updateTransform(), (this._transformGroup = i)
    }
    return (
      (e.prototype.hasBuilder = function (e) {
        return !!builders[e]
      }),
      (e.prototype.add = function (e) {
        builders[e](this.opt, this.axisModel, this.group, this._transformGroup)
      }),
      (e.prototype.getGroup = function () {
        return this.group
      }),
      (e.innerTextLayout = function (e, t, i) {
        var r,
          n,
          a = remRadian(t - e)
        return (
          isRadianAroundZero(a)
            ? ((n = i > 0 ? 'top' : 'bottom'), (r = 'center'))
            : isRadianAroundZero(a - PI$3)
            ? ((n = i > 0 ? 'bottom' : 'top'), (r = 'center'))
            : ((n = 'middle'),
              (r = a > 0 && a < PI$3 ? (i > 0 ? 'right' : 'left') : i > 0 ? 'left' : 'right')),
          { rotation: a, textAlign: r, textVerticalAlign: n }
        )
      }),
      (e.makeAxisEventDataBase = function (e) {
        var t = { componentType: e.mainType, componentIndex: e.componentIndex }
        return (t[e.mainType + 'Index'] = e.componentIndex), t
      }),
      (e.isLabelSilent = function (e) {
        var t = e.get('tooltip')
        return e.get('silent') || !(e.get('triggerEvent') || (t && t.show))
      }),
      e
    )
  })(),
  builders = {
    axisLine: function (e, t, i, r) {
      var n = t.get(['axisLine', 'show'])
      if (('auto' === n && e.handleAutoShown && (n = e.handleAutoShown('axisLine')), n)) {
        var a = t.axis.getExtent(),
          o = r.transform,
          s = [a[0], 0],
          l = [a[1], 0]
        o && (applyTransform$1(s, s, o), applyTransform$1(l, l, o))
        var h = extend$3(
            { lineCap: 'round' },
            t.getModel(['axisLine', 'lineStyle']).getLineStyle()
          ),
          u = new Line$1({
            subPixelOptimize: !0,
            shape: { x1: s[0], y1: s[1], x2: l[0], y2: l[1] },
            style: h,
            strokeContainThreshold: e.strokeContainThreshold || 5,
            silent: !0,
            z2: 1
          })
        ;(u.anid = 'line'), i.add(u)
        var p = t.get(['axisLine', 'symbol']),
          c = t.get(['axisLine', 'symbolSize']),
          d = t.get(['axisLine', 'symbolOffset']) || 0
        if (('number' == typeof d && (d = [d, d]), null != p)) {
          'string' == typeof p && (p = [p, p]),
            ('string' != typeof c && 'number' != typeof c) || (c = [c, c])
          var f = c[0],
            m = c[1]
          each$i(
            [
              { rotate: e.rotation + Math.PI / 2, offset: d[0], r: 0 },
              {
                rotate: e.rotation - Math.PI / 2,
                offset: d[1],
                r: Math.sqrt((s[0] - l[0]) * (s[0] - l[0]) + (s[1] - l[1]) * (s[1] - l[1]))
              }
            ],
            function (t, r) {
              if ('none' !== p[r] && null != p[r]) {
                var n = createSymbol$1(p[r], -f / 2, -m / 2, f, m, h.stroke, !0),
                  a = t.r + t.offset
                n.attr({
                  rotation: t.rotate,
                  x: s[0] + a * Math.cos(e.rotation),
                  y: s[1] - a * Math.sin(e.rotation),
                  silent: !0,
                  z2: 11
                }),
                  i.add(n)
              }
            }
          )
        }
      }
    },
    axisTickLabel: function (e, t, i, r) {
      var n = buildAxisMajorTicks(i, r, t, e)
      fixMinMaxLabelShow(t, buildAxisLabel(i, r, t, e), n),
        buildAxisMinorTicks(i, r, t, e.tickDirection)
    },
    axisName: function (e, t, i, r) {
      var n = retrieve(e.axisName, t.get('name'))
      if (n) {
        var a,
          o,
          s = t.get('nameLocation'),
          l = e.nameDirection,
          h = t.getModel('nameTextStyle'),
          u = t.get('nameGap') || 0,
          p = t.axis.getExtent(),
          c = p[0] > p[1] ? -1 : 1,
          d = [
            'start' === s ? p[0] - c * u : 'end' === s ? p[1] + c * u : (p[0] + p[1]) / 2,
            isNameLocationCenter(s) ? e.labelOffset + l * u : 0
          ],
          f = t.get('nameRotate')
        null != f && (f = (f * PI$3) / 180),
          isNameLocationCenter(s)
            ? (a = AxisBuilder.innerTextLayout(e.rotation, null != f ? f : e.rotation, l))
            : ((a = endTextLayout(e.rotation, s, f || 0, p)),
              null != (o = e.axisNameAvailableWidth) &&
                ((o = Math.abs(o / Math.sin(a.rotation))), !isFinite(o) && (o = null)))
        var m = h.getFont(),
          g = t.get('nameTruncate', !0) || {},
          y = g.ellipsis,
          v = retrieve(e.nameTruncateMaxWidth, g.maxWidth, o),
          _ = new ZRText({
            x: d[0],
            y: d[1],
            rotation: a.rotation,
            silent: AxisBuilder.isLabelSilent(t),
            style: createTextStyle(h, {
              text: n,
              font: m,
              overflow: 'truncate',
              width: v,
              ellipsis: y,
              fill: h.getTextColor() || t.get(['axisLine', 'lineStyle', 'color']),
              align: h.get('align') || a.textAlign,
              verticalAlign: h.get('verticalAlign') || a.textVerticalAlign
            }),
            z2: 1
          })
        if (
          (setTooltipConfig({ el: _, componentModel: t, itemName: n }),
          (_.__fullText = n),
          (_.anid = 'name'),
          t.get('triggerEvent'))
        ) {
          var x = AxisBuilder.makeAxisEventDataBase(t)
          ;(x.targetType = 'axisName'), (x.name = n), (getECData(_).eventData = x)
        }
        r.add(_), _.updateTransform(), i.add(_), _.decomposeTransform()
      }
    }
  }
function endTextLayout(e, t, i, r) {
  var n,
    a,
    o = remRadian(i - e),
    s = r[0] > r[1],
    l = ('start' === t && !s) || ('start' !== t && s)
  return (
    isRadianAroundZero(o - PI$3 / 2)
      ? ((a = l ? 'bottom' : 'top'), (n = 'center'))
      : isRadianAroundZero(o - 1.5 * PI$3)
      ? ((a = l ? 'top' : 'bottom'), (n = 'center'))
      : ((a = 'middle'),
        (n = o < 1.5 * PI$3 && o > PI$3 / 2 ? (l ? 'left' : 'right') : l ? 'right' : 'left')),
    { rotation: o, textAlign: n, textVerticalAlign: a }
  )
}
function fixMinMaxLabelShow(e, t, i) {
  if (!shouldShowAllLabels(e.axis)) {
    var r = e.get(['axisLabel', 'showMinLabel']),
      n = e.get(['axisLabel', 'showMaxLabel'])
    i = i || []
    var a = (t = t || [])[0],
      o = t[1],
      s = t[t.length - 1],
      l = t[t.length - 2],
      h = i[0],
      u = i[1],
      p = i[i.length - 1],
      c = i[i.length - 2]
    !1 === r
      ? (ignoreEl(a), ignoreEl(h))
      : isTwoLabelOverlapped(a, o) && (r ? (ignoreEl(o), ignoreEl(u)) : (ignoreEl(a), ignoreEl(h))),
      !1 === n
        ? (ignoreEl(s), ignoreEl(p))
        : isTwoLabelOverlapped(l, s) &&
          (n ? (ignoreEl(l), ignoreEl(c)) : (ignoreEl(s), ignoreEl(p)))
  }
}
function ignoreEl(e) {
  e && (e.ignore = !0)
}
function isTwoLabelOverlapped(e, t) {
  var i = e && e.getBoundingRect().clone(),
    r = t && t.getBoundingRect().clone()
  if (i && r) {
    var n = identity([])
    return (
      rotate(n, n, -e.rotation),
      i.applyTransform(mul([], n, e.getLocalTransform())),
      r.applyTransform(mul([], n, t.getLocalTransform())),
      i.intersect(r)
    )
  }
}
function isNameLocationCenter(e) {
  return 'middle' === e || 'center' === e
}
function createTicks(e, t, i, r, n) {
  for (var a = [], o = [], s = [], l = 0; l < e.length; l++) {
    var h = e[l].coord
    ;(o[0] = h),
      (o[1] = 0),
      (s[0] = h),
      (s[1] = i),
      t && (applyTransform$1(o, o, t), applyTransform$1(s, s, t))
    var u = new Line$1({
      subPixelOptimize: !0,
      shape: { x1: o[0], y1: o[1], x2: s[0], y2: s[1] },
      style: r,
      z2: 2,
      autoBatch: !0,
      silent: !0
    })
    ;(u.anid = n + '_' + e[l].tickValue), a.push(u)
  }
  return a
}
function buildAxisMajorTicks(e, t, i, r) {
  var n = i.axis,
    a = i.getModel('axisTick'),
    o = a.get('show')
  if (
    ('auto' === o && r.handleAutoShown && (o = r.handleAutoShown('axisTick')),
    o && !n.scale.isBlank())
  ) {
    for (
      var s = a.getModel('lineStyle'),
        l = r.tickDirection * a.get('length'),
        h = createTicks(
          n.getTicksCoords(),
          t.transform,
          l,
          defaults$1(s.getLineStyle(), { stroke: i.get(['axisLine', 'lineStyle', 'color']) }),
          'ticks'
        ),
        u = 0;
      u < h.length;
      u++
    )
      e.add(h[u])
    return h
  }
}
function buildAxisMinorTicks(e, t, i, r) {
  var n = i.axis,
    a = i.getModel('minorTick')
  if (a.get('show') && !n.scale.isBlank()) {
    var o = n.getMinorTicksCoords()
    if (o.length)
      for (
        var s = a.getModel('lineStyle'),
          l = r * a.get('length'),
          h = defaults$1(
            s.getLineStyle(),
            defaults$1(i.getModel('axisTick').getLineStyle(), {
              stroke: i.get(['axisLine', 'lineStyle', 'color'])
            })
          ),
          u = 0;
        u < o.length;
        u++
      )
        for (
          var p = createTicks(o[u], t.transform, l, h, 'minorticks_' + u), c = 0;
          c < p.length;
          c++
        )
          e.add(p[c])
  }
}
function buildAxisLabel(e, t, i, r) {
  var n = i.axis
  if (retrieve(r.axisLabelShow, i.get(['axisLabel', 'show'])) && !n.scale.isBlank()) {
    var a = i.getModel('axisLabel'),
      o = a.get('margin'),
      s = n.getViewLabels(),
      l = ((retrieve(r.labelRotate, a.get('rotate')) || 0) * PI$3) / 180,
      h = AxisBuilder.innerTextLayout(r.rotation, l, r.labelDirection),
      u = i.getCategories && i.getCategories(!0),
      p = [],
      c = AxisBuilder.isLabelSilent(i),
      d = i.get('triggerEvent')
    return (
      each$i(s, function (s, l) {
        var f = 'ordinal' === n.scale.type ? n.scale.getRawOrdinalNumber(s.tickValue) : s.tickValue,
          m = s.formattedLabel,
          g = s.rawLabel,
          y = a
        if (u && u[f]) {
          var v = u[f]
          isObject$7(v) && v.textStyle && (y = new Model(v.textStyle, a, i.ecModel))
        }
        var _ = y.getTextColor() || i.get(['axisLine', 'lineStyle', 'color']),
          x = n.dataToCoord(f),
          S = new ZRText({
            x: x,
            y: r.labelOffset + r.labelDirection * o,
            rotation: h.rotation,
            silent: c,
            z2: 10,
            style: createTextStyle(y, {
              text: m,
              align: y.getShallow('align', !0) || h.textAlign,
              verticalAlign:
                y.getShallow('verticalAlign', !0) ||
                y.getShallow('baseline', !0) ||
                h.textVerticalAlign,
              fill:
                'function' == typeof _
                  ? _('category' === n.type ? g : 'value' === n.type ? f + '' : f, l)
                  : _
            })
          })
        if (((S.anid = 'label_' + f), d)) {
          var b = AxisBuilder.makeAxisEventDataBase(i)
          ;(b.targetType = 'axisLabel'), (b.value = g), (getECData(S).eventData = b)
        }
        t.add(S), S.updateTransform(), p.push(S), e.add(S), S.decomposeTransform()
      }),
      p
    )
  }
}
function collect(e, t) {
  var i = { axesInfo: {}, seriesInvolved: !1, coordSysAxesInfo: {}, coordSysMap: {} }
  return collectAxesInfo(i, e, t), i.seriesInvolved && collectSeriesInfo(i, e), i
}
function collectAxesInfo(e, t, i) {
  var r = t.getComponent('tooltip'),
    n = t.getComponent('axisPointer'),
    a = n.get('link', !0) || [],
    o = []
  each$i(i.getCoordinateSystems(), function (i) {
    if (i.axisPointerEnabled) {
      var s = makeKey(i.model),
        l = (e.coordSysAxesInfo[s] = {})
      e.coordSysMap[s] = i
      var h = i.model.getModel('tooltip', r)
      if ((each$i(i.getAxes(), curry$1(d, !1, null)), i.getTooltipAxes && r && h.get('show'))) {
        var u = 'axis' === h.get('trigger'),
          p = 'cross' === h.get(['axisPointer', 'type']),
          c = i.getTooltipAxes(h.get(['axisPointer', 'axis']))
        ;(u || p) && each$i(c.baseAxes, curry$1(d, !p || 'cross', u)),
          p && each$i(c.otherAxes, curry$1(d, 'cross', !1))
      }
    }
    function d(r, s, u) {
      var p = u.model.getModel('axisPointer', n),
        c = p.get('show')
      if (c && ('auto' !== c || r || isHandleTrigger(p))) {
        null == s && (s = p.get('triggerTooltip'))
        var d = (p = r ? makeAxisPointerModel(u, h, n, t, r, s) : p).get('snap'),
          f = makeKey(u.model),
          m = s || d || 'category' === u.type,
          g = (e.axesInfo[f] = {
            key: f,
            axis: u,
            coordSys: i,
            axisPointerModel: p,
            triggerTooltip: s,
            involveSeries: m,
            snap: d,
            useHandle: isHandleTrigger(p),
            seriesModels: [],
            linkGroup: null
          })
        ;(l[f] = g), (e.seriesInvolved = e.seriesInvolved || m)
        var y = getLinkGroupIndex(a, u)
        if (null != y) {
          var v = o[y] || (o[y] = { axesInfo: {} })
          ;(v.axesInfo[f] = g), (v.mapper = a[y].mapper), (g.linkGroup = v)
        }
      }
    }
  })
}
function makeAxisPointerModel(e, t, i, r, n, a) {
  var o = t.getModel('axisPointer'),
    s = {}
  each$i(
    [
      'type',
      'snap',
      'lineStyle',
      'shadowStyle',
      'label',
      'animation',
      'animationDurationUpdate',
      'animationEasingUpdate',
      'z'
    ],
    function (e) {
      s[e] = clone$3(o.get(e))
    }
  ),
    (s.snap = 'category' !== e.type && !!a),
    'cross' === o.get('type') && (s.type = 'line')
  var l = s.label || (s.label = {})
  if ((null == l.show && (l.show = !1), 'cross' === n)) {
    var h = o.get(['label', 'show'])
    if (((l.show = null == h || h), !a)) {
      var u = (s.lineStyle = o.get('crossStyle'))
      u && defaults$1(l, u.textStyle)
    }
  }
  return e.model.getModel('axisPointer', new Model(s, i, r))
}
function collectSeriesInfo(e, t) {
  t.eachSeries(function (t) {
    var i = t.coordinateSystem,
      r = t.get(['tooltip', 'trigger'], !0),
      n = t.get(['tooltip', 'show'], !0)
    i &&
      'none' !== r &&
      !1 !== r &&
      'item' !== r &&
      !1 !== n &&
      !1 !== t.get(['axisPointer', 'show'], !0) &&
      each$i(e.coordSysAxesInfo[makeKey(i.model)], function (e) {
        var r = e.axis
        i.getAxis(r.dim) === r &&
          (e.seriesModels.push(t),
          null == e.seriesDataCount && (e.seriesDataCount = 0),
          (e.seriesDataCount += t.getData().count()))
      })
  })
}
function getLinkGroupIndex(e, t) {
  for (var i = t.model, r = t.dim, n = 0; n < e.length; n++) {
    var a = e[n] || {}
    if (
      checkPropInLink(a[r + 'AxisId'], i.id) ||
      checkPropInLink(a[r + 'AxisIndex'], i.componentIndex) ||
      checkPropInLink(a[r + 'AxisName'], i.name)
    )
      return n
  }
}
function checkPropInLink(e, t) {
  return 'all' === e || (isArray$1(e) && indexOf$1(e, t) >= 0) || e === t
}
function fixValue(e) {
  var t = getAxisInfo$1(e)
  if (t) {
    var i = t.axisPointerModel,
      r = t.axis.scale,
      n = i.option,
      a = i.get('status'),
      o = i.get('value')
    null != o && (o = r.parse(o))
    var s = isHandleTrigger(i)
    null == a && (n.status = s ? 'show' : 'hide')
    var l = r.getExtent().slice()
    l[0] > l[1] && l.reverse(),
      (null == o || o > l[1]) && (o = l[1]),
      o < l[0] && (o = l[0]),
      (n.value = o),
      s && (n.status = t.axis.scale.isBlank() ? 'hide' : 'show')
  }
}
function getAxisInfo$1(e) {
  var t = (e.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo
  return t && t.axesInfo[makeKey(e)]
}
function getAxisPointerModel(e) {
  var t = getAxisInfo$1(e)
  return t && t.axisPointerModel
}
function isHandleTrigger(e) {
  return !!e.get(['handle', 'show'])
}
function makeKey(e) {
  return e.type + '||' + e.id
}
var axisPointerClazz = {},
  AxisView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (t, i, r, n) {
        this.axisPointerClass && fixValue(t),
          e.prototype.render.apply(this, arguments),
          this._doUpdateAxisPointerClass(t, r, !0)
      }),
      (t.prototype.updateAxisPointer = function (e, t, i, r) {
        this._doUpdateAxisPointerClass(e, i, !1)
      }),
      (t.prototype.remove = function (e, t) {
        var i = this._axisPointer
        i && i.remove(t)
      }),
      (t.prototype.dispose = function (t, i) {
        this._disposeAxisPointer(i), e.prototype.dispose.apply(this, arguments)
      }),
      (t.prototype._doUpdateAxisPointerClass = function (e, i, r) {
        var n = t.getAxisPointerClass(this.axisPointerClass)
        if (n) {
          var a = getAxisPointerModel(e)
          a
            ? (this._axisPointer || (this._axisPointer = new n())).render(e, a, i, r)
            : this._disposeAxisPointer(i)
        }
      }),
      (t.prototype._disposeAxisPointer = function (e) {
        this._axisPointer && this._axisPointer.dispose(e), (this._axisPointer = null)
      }),
      (t.registerAxisPointerClass = function (e, t) {
        axisPointerClazz[e] = t
      }),
      (t.getAxisPointerClass = function (e) {
        return e && axisPointerClazz[e]
      }),
      (t.type = 'axis'),
      t
    )
  })(ComponentView),
  inner$g = makeInner()
function rectCoordAxisBuildSplitArea(e, t, i, r) {
  var n = i.axis
  if (!n.scale.isBlank()) {
    var a = i.getModel('splitArea'),
      o = a.getModel('areaStyle'),
      s = o.get('color'),
      l = r.coordinateSystem.getRect(),
      h = n.getTicksCoords({ tickModel: a, clamp: !0 })
    if (h.length) {
      var u = s.length,
        p = inner$g(e).splitAreaColors,
        c = createHashMap(),
        d = 0
      if (p)
        for (var f = 0; f < h.length; f++) {
          var m = p.get(h[f].tickValue)
          if (null != m) {
            d = (m + (u - 1) * f) % u
            break
          }
        }
      var g = n.toGlobalCoord(h[0].coord),
        y = o.getAreaStyle()
      s = isArray$1(s) ? s : [s]
      for (f = 1; f < h.length; f++) {
        var v = n.toGlobalCoord(h[f].coord),
          _ = void 0,
          x = void 0,
          S = void 0,
          b = void 0
        n.isHorizontal()
          ? ((_ = g), (x = l.y), (S = v - _), (b = l.height), (g = _ + S))
          : ((_ = l.x), (x = g), (S = l.width), (g = x + (b = v - x)))
        var T = h[f - 1].tickValue
        null != T && c.set(T, d),
          t.add(
            new Rect$2({
              anid: null != T ? 'area_' + T : null,
              shape: { x: _, y: x, width: S, height: b },
              style: defaults$1({ fill: s[d] }, y),
              autoBatch: !0,
              silent: !0
            })
          ),
          (d = (d + 1) % u)
      }
      inner$g(e).splitAreaColors = c
    }
  }
}
function rectCoordAxisHandleRemove(e) {
  inner$g(e).splitAreaColors = null
}
var axisBuilderAttrs$3 = ['axisLine', 'axisTickLabel', 'axisName'],
  selfBuilderAttrs$2 = ['splitArea', 'splitLine', 'minorSplitLine'],
  CartesianAxisView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.axisPointerClass = 'CartesianAxisPointer'), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (t, i, r, n) {
        this.group.removeAll()
        var a = this._axisGroup
        if (((this._axisGroup = new Group$3()), this.group.add(this._axisGroup), t.get('show'))) {
          var o = t.getCoordSysModel(),
            s = layout$2(o, t),
            l = new AxisBuilder(
              t,
              extend$3(
                {
                  handleAutoShown: function (e) {
                    for (var i = o.coordinateSystem.getCartesians(), r = 0; r < i.length; r++) {
                      var n = i[r].getOtherAxis(t.axis).type
                      if ('value' === n || 'log' === n) return !0
                    }
                    return !1
                  }
                },
                s
              )
            )
          each$i(axisBuilderAttrs$3, l.add, l),
            this._axisGroup.add(l.getGroup()),
            each$i(
              selfBuilderAttrs$2,
              function (e) {
                t.get([e, 'show']) && axisElementBuilders$2[e](this, this._axisGroup, t, o)
              },
              this
            ),
            groupTransition(a, this._axisGroup, t),
            e.prototype.render.call(this, t, i, r, n)
        }
      }),
      (t.prototype.remove = function () {
        rectCoordAxisHandleRemove(this)
      }),
      (t.type = 'cartesianAxis'),
      t
    )
  })(AxisView),
  axisElementBuilders$2 = {
    splitLine: function (e, t, i, r) {
      var n = i.axis
      if (!n.scale.isBlank()) {
        var a = i.getModel('splitLine'),
          o = a.getModel('lineStyle'),
          s = o.get('color')
        s = isArray$1(s) ? s : [s]
        for (
          var l = r.coordinateSystem.getRect(),
            h = n.isHorizontal(),
            u = 0,
            p = n.getTicksCoords({ tickModel: a }),
            c = [],
            d = [],
            f = o.getLineStyle(),
            m = 0;
          m < p.length;
          m++
        ) {
          var g = n.toGlobalCoord(p[m].coord)
          h
            ? ((c[0] = g), (c[1] = l.y), (d[0] = g), (d[1] = l.y + l.height))
            : ((c[0] = l.x), (c[1] = g), (d[0] = l.x + l.width), (d[1] = g))
          var y = u++ % s.length,
            v = p[m].tickValue
          t.add(
            new Line$1({
              anid: null != v ? 'line_' + p[m].tickValue : null,
              subPixelOptimize: !0,
              autoBatch: !0,
              shape: { x1: c[0], y1: c[1], x2: d[0], y2: d[1] },
              style: defaults$1({ stroke: s[y] }, f),
              silent: !0
            })
          )
        }
      }
    },
    minorSplitLine: function (e, t, i, r) {
      var n = i.axis,
        a = i.getModel('minorSplitLine').getModel('lineStyle'),
        o = r.coordinateSystem.getRect(),
        s = n.isHorizontal(),
        l = n.getMinorTicksCoords()
      if (l.length)
        for (var h = [], u = [], p = a.getLineStyle(), c = 0; c < l.length; c++)
          for (var d = 0; d < l[c].length; d++) {
            var f = n.toGlobalCoord(l[c][d].coord)
            s
              ? ((h[0] = f), (h[1] = o.y), (u[0] = f), (u[1] = o.y + o.height))
              : ((h[0] = o.x), (h[1] = f), (u[0] = o.x + o.width), (u[1] = f)),
              t.add(
                new Line$1({
                  anid: 'minor_line_' + l[c][d].tickValue,
                  subPixelOptimize: !0,
                  autoBatch: !0,
                  shape: { x1: h[0], y1: h[1], x2: u[0], y2: u[1] },
                  style: p,
                  silent: !0
                })
              )
          }
    },
    splitArea: function (e, t, i, r) {
      rectCoordAxisBuildSplitArea(e, t, i, r)
    }
  },
  CartesianXAxisView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return __extends(t, e), (t.type = 'xAxis'), t
  })(CartesianAxisView),
  CartesianYAxisView = (function (e) {
    function t() {
      var t = (null !== e && e.apply(this, arguments)) || this
      return (t.type = CartesianXAxisView.type), t
    }
    return __extends(t, e), (t.type = 'yAxis'), t
  })(CartesianAxisView),
  GridView = (function (e) {
    function t() {
      var t = (null !== e && e.apply(this, arguments)) || this
      return (t.type = 'grid'), t
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t) {
        this.group.removeAll(),
          e.get('show') &&
            this.group.add(
              new Rect$2({
                shape: e.coordinateSystem.getRect(),
                style: defaults$1({ fill: e.get('backgroundColor') }, e.getItemStyle()),
                silent: !0,
                z2: -1
              })
            )
      }),
      (t.type = 'grid'),
      t
    )
  })(ComponentView),
  extraOption = { offset: 0 }
function install$N(e) {
  e.registerComponentView(GridView),
    e.registerComponentModel(GridModel),
    e.registerCoordinateSystem('cartesian2d', Grid),
    axisModelCreator(e, 'x', CartesianAxisModel, extraOption),
    axisModelCreator(e, 'y', CartesianAxisModel, extraOption),
    e.registerComponentView(CartesianXAxisView),
    e.registerComponentView(CartesianYAxisView),
    e.registerPreprocessor(function (e) {
      e.xAxis && e.yAxis && !e.grid && (e.grid = {})
    })
}
function install$M(e) {
  use(install$N),
    e.registerSeriesModel(ScatterSeriesModel),
    e.registerChartView(ScatterView),
    e.registerLayout(pointsLayout('scatter'))
}
function radarLayout(e) {
  e.eachSeriesByType('radar', function (e) {
    var t = e.getData(),
      i = [],
      r = e.coordinateSystem
    if (r) {
      var n = r.getIndicatorAxes()
      each$i(n, function (e, a) {
        t.each(t.mapDimension(n[a].dim), function (e, t) {
          i[t] = i[t] || []
          var n = r.dataToPoint(e, a)
          i[t][a] = isValidPoint(n) ? n : getValueMissingPoint(r)
        })
      }),
        t.each(function (e) {
          var n =
            find$1(i[e], function (e) {
              return isValidPoint(e)
            }) || getValueMissingPoint(r)
          i[e].push(n.slice()), t.setItemLayout(e, i[e])
        })
    }
  })
}
function isValidPoint(e) {
  return !isNaN(e[0]) && !isNaN(e[1])
}
function getValueMissingPoint(e) {
  return [e.cx, e.cy]
}
function radarBackwardCompat(e) {
  var t = e.polar
  if (t) {
    isArray$1(t) || (t = [t])
    var i = []
    each$i(t, function (t, r) {
      t.indicator
        ? (t.type && !t.shape && (t.shape = t.type),
          (e.radar = e.radar || []),
          isArray$1(e.radar) || (e.radar = [e.radar]),
          e.radar.push(t))
        : i.push(t)
    }),
      (e.polar = i)
  }
  each$i(e.series, function (e) {
    e && 'radar' === e.type && e.polarIndex && (e.radarIndex = e.polarIndex)
  })
}
function normalizeSymbolSize$1(e) {
  return isArray$1(e) || (e = [+e, +e]), e
}
var RadarView$1 = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i) {
        var r = e.coordinateSystem,
          n = this.group,
          a = e.getData(),
          o = this._data
        function s(e, t) {
          var i = e.getItemVisual(t, 'symbol') || 'circle'
          if ('none' !== i) {
            var r = normalizeSymbolSize$1(e.getItemVisual(t, 'symbolSize')),
              n = createSymbol$1(i, -1, -1, 2, 2),
              a = e.getItemVisual(t, 'symbolRotate') || 0
            return (
              n.attr({
                style: { strokeNoScale: !0 },
                z2: 100,
                scaleX: r[0] / 2,
                scaleY: r[1] / 2,
                rotation: (a * Math.PI) / 180 || 0
              }),
              n
            )
          }
        }
        function l(t, i, r, n, a, o) {
          r.removeAll()
          for (var l = 0; l < i.length - 1; l++) {
            var h = s(n, a)
            h &&
              ((h.__dimIdx = l),
              t[l]
                ? (h.setPosition(t[l]),
                  graphic[o ? 'initProps' : 'updateProps'](h, { x: i[l][0], y: i[l][1] }, e, a))
                : h.setPosition(i[l]),
              r.add(h))
          }
        }
        function h(e) {
          return map$1(e, function (e) {
            return [r.cx, r.cy]
          })
        }
        a
          .diff(o)
          .add(function (t) {
            var i = a.getItemLayout(t)
            if (i) {
              var r = new Polygon(),
                n = new Polyline$1(),
                o = { shape: { points: i } }
              ;(r.shape.points = h(i)),
                (n.shape.points = h(i)),
                initProps(r, o, e, t),
                initProps(n, o, e, t)
              var s = new Group$3(),
                u = new Group$3()
              s.add(n),
                s.add(r),
                s.add(u),
                l(n.shape.points, i, u, a, t, !0),
                a.setItemGraphicEl(t, s)
            }
          })
          .update(function (t, i) {
            var r = o.getItemGraphicEl(i),
              n = r.childAt(0),
              s = r.childAt(1),
              h = r.childAt(2),
              u = { shape: { points: a.getItemLayout(t) } }
            u.shape.points &&
              (l(n.shape.points, u.shape.points, h, a, t, !1),
              updateProps$1(n, u, e),
              updateProps$1(s, u, e),
              a.setItemGraphicEl(t, r))
          })
          .remove(function (e) {
            n.remove(o.getItemGraphicEl(e))
          })
          .execute(),
          a.eachItemGraphicEl(function (e, t) {
            var i = a.getItemModel(t),
              r = e.childAt(0),
              o = e.childAt(1),
              s = e.childAt(2),
              l = a.getItemVisual(t, 'style'),
              h = l.fill
            n.add(e),
              r.useStyle(
                defaults$1(i.getModel('lineStyle').getLineStyle(), { fill: 'none', stroke: h })
              ),
              setStatesStylesFromModel(r, i, 'lineStyle'),
              setStatesStylesFromModel(o, i, 'areaStyle')
            var u = i.getModel('areaStyle'),
              p = u.isEmpty() && u.parentModel.isEmpty()
            ;(o.ignore = p),
              each$i(['emphasis', 'select', 'blur'], function (e) {
                var t = i.getModel([e, 'areaStyle']),
                  r = t.isEmpty() && t.parentModel.isEmpty()
                o.ensureState(e).ignore = r && p
              }),
              o.useStyle(defaults$1(u.getAreaStyle(), { fill: h, opacity: 0.7, decal: l.decal }))
            var c = i.getModel('emphasis'),
              d = c.getModel('itemStyle').getItemStyle()
            s.eachChild(function (e) {
              if (e instanceof ZRImage) {
                var r = e.style
                e.useStyle(
                  extend$3({ image: r.image, x: r.x, y: r.y, width: r.width, height: r.height }, l)
                )
              } else e.useStyle(l), e.setColor(h)
              e.ensureState('emphasis').style = clone$3(d)
              var n = a.get(a.dimensions[e.__dimIdx], t)
              ;(null == n || isNaN(n)) && (n = ''),
                setLabelStyle(e, getLabelStatesModels(i), {
                  labelFetcher: a.hostModel,
                  labelDataIndex: t,
                  labelDimIndex: e.__dimIdx,
                  defaultText: n,
                  inheritColor: h,
                  defaultOpacity: l.opacity
                })
            }),
              enableHoverEmphasis(e, c.get('focus'), c.get('blurScope'))
          }),
          (this._data = a)
      }),
      (t.prototype.remove = function () {
        this.group.removeAll(), (this._data = null)
      }),
      (t.type = 'radar'),
      t
    )
  })(ChartView),
  RadarSeriesModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.useColorPaletteOnData = !0), (i.hasSymbolVisual = !0), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (t) {
        e.prototype.init.apply(this, arguments),
          (this.legendVisualProvider = new LegendVisualProvider(
            bind$2(this.getData, this),
            bind$2(this.getRawData, this)
          ))
      }),
      (t.prototype.getInitialData = function (e, t) {
        return createListSimply(this, { generateCoord: 'indicator_', generateCoordCount: 1 / 0 })
      }),
      (t.prototype.formatTooltip = function (e, t, i) {
        var r = this.getData(),
          n = this.coordinateSystem.getIndicatorAxes(),
          a = this.getData().getName(e),
          o = '' === a ? this.name : a,
          s = retrieveVisualColorForTooltipMarker(this, e)
        return createTooltipMarkup('section', {
          header: o,
          sortBlocks: !0,
          blocks: map$1(n, function (t) {
            var i = r.get(r.mapDimension(t.dim), e)
            return createTooltipMarkup('nameValue', {
              markerType: 'subItem',
              markerColor: s,
              name: t.name,
              value: i,
              sortParam: i
            })
          })
        })
      }),
      (t.prototype.getTooltipPosition = function (e) {
        if (null != e)
          for (
            var t = this.getData(),
              i = this.coordinateSystem,
              r = t.getValues(
                map$1(i.dimensions, function (e) {
                  return t.mapDimension(e)
                }),
                e
              ),
              n = 0,
              a = r.length;
            n < a;
            n++
          )
            if (!isNaN(r[n])) {
              var o = i.getIndicatorAxes()
              return i.coordToPoint(o[n].dataToCoord(r[n]), n)
            }
      }),
      (t.type = 'series.radar'),
      (t.dependencies = ['radar']),
      (t.defaultOption = {
        zlevel: 0,
        z: 2,
        coordinateSystem: 'radar',
        legendHoverLink: !0,
        radarIndex: 0,
        lineStyle: { width: 2, type: 'solid' },
        label: { position: 'top' },
        symbolSize: 8
      }),
      t
    )
  })(SeriesModel),
  valueAxisDefault = axisDefault.value
function defaultsShow(e, t) {
  return defaults$1({ show: t }, e)
}
var RadarModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.optionUpdated = function () {
        var e = this.get('boundaryGap'),
          t = this.get('splitNumber'),
          i = this.get('scale'),
          r = this.get('axisLine'),
          n = this.get('axisTick'),
          a = this.get('axisLabel'),
          o = this.get('axisName'),
          s = this.get(['axisName', 'show']),
          l = this.get(['axisName', 'formatter']),
          h = this.get('axisNameGap'),
          u = this.get('triggerEvent'),
          p = map$1(
            this.get('indicator') || [],
            function (p) {
              null != p.max && p.max > 0 && !p.min
                ? (p.min = 0)
                : null != p.min && p.min < 0 && !p.max && (p.max = 0)
              var c = o
              null != p.color && (c = defaults$1({ color: p.color }, o))
              var d = merge(
                clone$3(p),
                {
                  boundaryGap: e,
                  splitNumber: t,
                  scale: i,
                  axisLine: r,
                  axisTick: n,
                  axisLabel: a,
                  name: p.text,
                  nameLocation: 'end',
                  nameGap: h,
                  nameTextStyle: c,
                  triggerEvent: u
                },
                !1
              )
              if ((s || (d.name = ''), 'string' == typeof l)) {
                var f = d.name
                d.name = l.replace('{value}', null != f ? f : '')
              } else 'function' == typeof l && (d.name = l(d.name, d))
              var m = new Model(d, null, this.ecModel)
              return (
                mixin(m, AxisModelCommonMixin.prototype),
                (m.mainType = 'radar'),
                (m.componentIndex = this.componentIndex),
                m
              )
            },
            this
          )
        this._indicatorModels = p
      }),
      (t.prototype.getIndicatorModels = function () {
        return this._indicatorModels
      }),
      (t.type = 'radar'),
      (t.defaultOption = {
        zlevel: 0,
        z: 0,
        center: ['50%', '50%'],
        radius: '75%',
        startAngle: 90,
        axisName: { show: !0 },
        boundaryGap: [0, 0],
        splitNumber: 5,
        axisNameGap: 15,
        scale: !1,
        shape: 'polygon',
        axisLine: merge({ lineStyle: { color: '#bbb' } }, valueAxisDefault.axisLine),
        axisLabel: defaultsShow(valueAxisDefault.axisLabel, !1),
        axisTick: defaultsShow(valueAxisDefault.axisTick, !1),
        splitLine: defaultsShow(valueAxisDefault.splitLine, !0),
        splitArea: defaultsShow(valueAxisDefault.splitArea, !0),
        indicator: []
      }),
      t
    )
  })(ComponentModel),
  axisBuilderAttrs$2 = ['axisLine', 'axisTickLabel', 'axisName'],
  RadarView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i) {
        this.group.removeAll(), this._buildAxes(e), this._buildSplitLineAndArea(e)
      }),
      (t.prototype._buildAxes = function (e) {
        var t = e.coordinateSystem
        each$i(
          map$1(t.getIndicatorAxes(), function (e) {
            return new AxisBuilder(e.model, {
              position: [t.cx, t.cy],
              rotation: e.angle,
              labelDirection: -1,
              tickDirection: -1,
              nameDirection: 1
            })
          }),
          function (e) {
            each$i(axisBuilderAttrs$2, e.add, e), this.group.add(e.getGroup())
          },
          this
        )
      }),
      (t.prototype._buildSplitLineAndArea = function (e) {
        var t = e.coordinateSystem,
          i = t.getIndicatorAxes()
        if (i.length) {
          var r = e.get('shape'),
            n = e.getModel('splitLine'),
            a = e.getModel('splitArea'),
            o = n.getModel('lineStyle'),
            s = a.getModel('areaStyle'),
            l = n.get('show'),
            h = a.get('show'),
            u = o.get('color'),
            p = s.get('color'),
            c = isArray$1(u) ? u : [u],
            d = isArray$1(p) ? p : [p],
            f = [],
            m = []
          if ('circle' === r)
            for (var g = i[0].getTicksCoords(), y = t.cx, v = t.cy, _ = 0; _ < g.length; _++) {
              if (l) f[C(f, c, _)].push(new Circle({ shape: { cx: y, cy: v, r: g[_].coord } }))
              if (h && _ < g.length - 1)
                m[C(m, d, _)].push(
                  new Ring({ shape: { cx: y, cy: v, r0: g[_].coord, r: g[_ + 1].coord } })
                )
            }
          else {
            var x,
              S = map$1(i, function (e, i) {
                var r = e.getTicksCoords()
                return (
                  (x = null == x ? r.length - 1 : Math.min(r.length - 1, x)),
                  map$1(r, function (e) {
                    return t.coordToPoint(e.coord, i)
                  })
                )
              }),
              b = []
            for (_ = 0; _ <= x; _++) {
              for (var T = [], A = 0; A < i.length; A++) T.push(S[A][_])
              if ((T[0] && T.push(T[0].slice()), l))
                f[C(f, c, _)].push(new Polyline$1({ shape: { points: T } }))
              if (h && b) m[C(m, d, _ - 1)].push(new Polygon({ shape: { points: T.concat(b) } }))
              b = T.slice().reverse()
            }
          }
          var w = o.getLineStyle(),
            M = s.getAreaStyle()
          each$i(
            m,
            function (e, t) {
              this.group.add(
                mergePath(e, {
                  style: defaults$1({ stroke: 'none', fill: d[t % d.length] }, M),
                  silent: !0
                })
              )
            },
            this
          ),
            each$i(
              f,
              function (e, t) {
                this.group.add(
                  mergePath(e, {
                    style: defaults$1({ fill: 'none', stroke: c[t % c.length] }, w),
                    silent: !0
                  })
                )
              },
              this
            )
        }
        function C(e, t, i) {
          var r = i % t.length
          return (e[r] = e[r] || []), r
        }
      }),
      (t.type = 'radar'),
      t
    )
  })(ComponentView),
  IndicatorAxis = (function (e) {
    function t(t, i, r) {
      var n = e.call(this, t, i, r) || this
      return (n.type = 'value'), (n.angle = 0), (n.name = ''), n
    }
    return __extends(t, e), t
  })(Axis),
  Radar = (function () {
    function e(e, t, i) {
      ;(this.dimensions = []),
        (this._model = e),
        (this._indicatorAxes = map$1(
          e.getIndicatorModels(),
          function (e, t) {
            var i = 'indicator_' + t,
              r = new IndicatorAxis(i, new IntervalScale())
            return (r.name = e.get('name')), (r.model = e), (e.axis = r), this.dimensions.push(i), r
          },
          this
        )),
        this.resize(e, i)
    }
    return (
      (e.prototype.getIndicatorAxes = function () {
        return this._indicatorAxes
      }),
      (e.prototype.dataToPoint = function (e, t) {
        var i = this._indicatorAxes[t]
        return this.coordToPoint(i.dataToCoord(e), t)
      }),
      (e.prototype.coordToPoint = function (e, t) {
        var i = this._indicatorAxes[t].angle
        return [this.cx + e * Math.cos(i), this.cy - e * Math.sin(i)]
      }),
      (e.prototype.pointToData = function (e) {
        var t = e[0] - this.cx,
          i = e[1] - this.cy,
          r = Math.sqrt(t * t + i * i)
        ;(t /= r), (i /= r)
        for (
          var n, a = Math.atan2(-i, t), o = 1 / 0, s = -1, l = 0;
          l < this._indicatorAxes.length;
          l++
        ) {
          var h = this._indicatorAxes[l],
            u = Math.abs(a - h.angle)
          u < o && ((n = h), (s = l), (o = u))
        }
        return [s, +(n && n.coordToData(r))]
      }),
      (e.prototype.resize = function (e, t) {
        var i = e.get('center'),
          r = t.getWidth(),
          n = t.getHeight(),
          a = Math.min(r, n) / 2
        ;(this.cx = parsePercent$1(i[0], r)),
          (this.cy = parsePercent$1(i[1], n)),
          (this.startAngle = (e.get('startAngle') * Math.PI) / 180)
        var o = e.get('radius')
        ;('string' != typeof o && 'number' != typeof o) || (o = [0, o]),
          (this.r0 = parsePercent$1(o[0], a)),
          (this.r = parsePercent$1(o[1], a)),
          each$i(
            this._indicatorAxes,
            function (e, t) {
              e.setExtent(this.r0, this.r)
              var i = this.startAngle + (t * Math.PI * 2) / this._indicatorAxes.length
              ;(i = Math.atan2(Math.sin(i), Math.cos(i))), (e.angle = i)
            },
            this
          )
      }),
      (e.prototype.update = function (e, t) {
        var i = this._indicatorAxes,
          r = this._model
        each$i(i, function (e) {
          e.scale.setExtent(1 / 0, -1 / 0)
        }),
          e.eachSeriesByType(
            'radar',
            function (t, n) {
              if (
                'radar' === t.get('coordinateSystem') &&
                e.getComponent('radar', t.get('radarIndex')) === r
              ) {
                var a = t.getData()
                each$i(i, function (e) {
                  e.scale.unionExtentFromData(a, a.mapDimension(e.dim))
                })
              }
            },
            this
          )
        var n = r.get('splitNumber')
        function a(e) {
          var t = Math.pow(10, Math.floor(Math.log(e) / Math.LN10)),
            i = e / t
          return 2 === i ? (i = 5) : (i *= 2), i * t
        }
        each$i(i, function (e, t) {
          var i = getScaleExtent(e.scale, e.model).extent
          niceScaleExtent(e.scale, e.model)
          var r = e.model,
            o = e.scale,
            s = parseAxisModelMinMax(o, r.get('min', !0)),
            l = parseAxisModelMinMax(o, r.get('max', !0)),
            h = o.getInterval()
          if (null != s && null != l) o.setExtent(+s, +l), o.setInterval((l - s) / n)
          else if (null != s) {
            var u = void 0
            do {
              ;(u = s + h * n), o.setExtent(+s, u), o.setInterval(h), (h = a(h))
            } while (u < i[1] && isFinite(u) && isFinite(i[1]))
          } else if (null != l) {
            var p = void 0
            do {
              ;(p = l - h * n), o.setExtent(p, +l), o.setInterval(h), (h = a(h))
            } while (p > i[0] && isFinite(p) && isFinite(i[0]))
          } else {
            o.getTicks().length - 1 > n && (h = a(h))
            p = round$2((u = Math.ceil(i[1] / h) * h) - h * n)
            o.setExtent(p, u), o.setInterval(h)
          }
        })
      }),
      (e.prototype.convertToPixel = function (e, t, i) {
        return console.warn('Not implemented.'), null
      }),
      (e.prototype.convertFromPixel = function (e, t, i) {
        return console.warn('Not implemented.'), null
      }),
      (e.prototype.containPoint = function (e) {
        return console.warn('Not implemented.'), !1
      }),
      (e.create = function (t, i) {
        var r = []
        return (
          t.eachComponent('radar', function (n) {
            var a = new e(n, t, i)
            r.push(a), (n.coordinateSystem = a)
          }),
          t.eachSeriesByType('radar', function (e) {
            'radar' === e.get('coordinateSystem') &&
              (e.coordinateSystem = r[e.get('radarIndex') || 0])
          }),
          r
        )
      }),
      (e.dimensions = []),
      e
    )
  })()
function install$L(e) {
  e.registerCoordinateSystem('radar', Radar),
    e.registerComponentModel(RadarModel),
    e.registerComponentView(RadarView),
    e.registerVisual({
      seriesType: 'radar',
      reset: function (e) {
        var t = e.getData()
        t.each(function (e) {
          t.setItemVisual(e, 'legendIcon', 'roundRect')
        }),
          t.setVisual('legendIcon', 'roundRect')
      }
    })
}
function install$K(e) {
  use(install$L),
    e.registerChartView(RadarView$1),
    e.registerSeriesModel(RadarSeriesModel),
    e.registerLayout(radarLayout),
    e.registerProcessor(dataFilter$1('radar')),
    e.registerPreprocessor(radarBackwardCompat)
}
var ATTR = '\0_ec_interaction_mutex'
function take(e, t, i) {
  getStore(e)[t] = i
}
function release(e, t, i) {
  var r = getStore(e)
  r[t] === i && (r[t] = null)
}
function isTaken(e, t) {
  return !!getStore(e)[t]
}
function getStore(e) {
  return e[ATTR] || (e[ATTR] = {})
}
registerAction(
  { type: 'takeGlobalCursor', event: 'globalCursorTaken', update: 'update' },
  function () {}
)
var RoamController = (function (e) {
  function t(t) {
    var i = e.call(this) || this
    i._zr = t
    var r = bind$2(i._mousedownHandler, i),
      n = bind$2(i._mousemoveHandler, i),
      a = bind$2(i._mouseupHandler, i),
      o = bind$2(i._mousewheelHandler, i),
      s = bind$2(i._pinchHandler, i)
    return (
      (i.enable = function (e, i) {
        this.disable(),
          (this._opt = defaults$1(clone$3(i) || {}, {
            zoomOnMouseWheel: !0,
            moveOnMouseMove: !0,
            moveOnMouseWheel: !1,
            preventDefaultMouseMove: !0
          })),
          null == e && (e = !0),
          (!0 !== e && 'move' !== e && 'pan' !== e) ||
            (t.on('mousedown', r), t.on('mousemove', n), t.on('mouseup', a)),
          (!0 !== e && 'scale' !== e && 'zoom' !== e) || (t.on('mousewheel', o), t.on('pinch', s))
      }),
      (i.disable = function () {
        t.off('mousedown', r),
          t.off('mousemove', n),
          t.off('mouseup', a),
          t.off('mousewheel', o),
          t.off('pinch', s)
      }),
      i
    )
  }
  return (
    __extends(t, e),
    (t.prototype.isDragging = function () {
      return this._dragging
    }),
    (t.prototype.isPinching = function () {
      return this._pinching
    }),
    (t.prototype.setPointerChecker = function (e) {
      this.pointerChecker = e
    }),
    (t.prototype.dispose = function () {
      this.disable()
    }),
    (t.prototype._mousedownHandler = function (e) {
      if (!(isMiddleOrRightButtonOnMouseUpDown(e) || (e.target && e.target.draggable))) {
        var t = e.offsetX,
          i = e.offsetY
        this.pointerChecker &&
          this.pointerChecker(e, t, i) &&
          ((this._x = t), (this._y = i), (this._dragging = !0))
      }
    }),
    (t.prototype._mousemoveHandler = function (e) {
      if (
        this._dragging &&
        isAvailableBehavior('moveOnMouseMove', e, this._opt) &&
        'pinch' !== e.gestureEvent &&
        !isTaken(this._zr, 'globalPan')
      ) {
        var t = e.offsetX,
          i = e.offsetY,
          r = this._x,
          n = this._y,
          a = t - r,
          o = i - n
        ;(this._x = t),
          (this._y = i),
          this._opt.preventDefaultMouseMove && stop(e.event),
          trigger$2(this, 'pan', 'moveOnMouseMove', e, {
            dx: a,
            dy: o,
            oldX: r,
            oldY: n,
            newX: t,
            newY: i,
            isAvailableBehavior: null
          })
      }
    }),
    (t.prototype._mouseupHandler = function (e) {
      isMiddleOrRightButtonOnMouseUpDown(e) || (this._dragging = !1)
    }),
    (t.prototype._mousewheelHandler = function (e) {
      var t = isAvailableBehavior('zoomOnMouseWheel', e, this._opt),
        i = isAvailableBehavior('moveOnMouseWheel', e, this._opt),
        r = e.wheelDelta,
        n = Math.abs(r),
        a = e.offsetX,
        o = e.offsetY
      if (0 !== r && (t || i)) {
        if (t) {
          var s = n > 3 ? 1.4 : n > 1 ? 1.2 : 1.1
          checkPointerAndTrigger(this, 'zoom', 'zoomOnMouseWheel', e, {
            scale: r > 0 ? s : 1 / s,
            originX: a,
            originY: o,
            isAvailableBehavior: null
          })
        }
        if (i) {
          var l = Math.abs(r)
          checkPointerAndTrigger(this, 'scrollMove', 'moveOnMouseWheel', e, {
            scrollDelta: (r > 0 ? 1 : -1) * (l > 3 ? 0.4 : l > 1 ? 0.15 : 0.05),
            originX: a,
            originY: o,
            isAvailableBehavior: null
          })
        }
      }
    }),
    (t.prototype._pinchHandler = function (e) {
      isTaken(this._zr, 'globalPan') ||
        checkPointerAndTrigger(this, 'zoom', null, e, {
          scale: e.pinchScale > 1 ? 1.1 : 1 / 1.1,
          originX: e.pinchX,
          originY: e.pinchY,
          isAvailableBehavior: null
        })
    }),
    t
  )
})(Eventful)
function checkPointerAndTrigger(e, t, i, r, n) {
  e.pointerChecker &&
    e.pointerChecker(r, n.originX, n.originY) &&
    (stop(r.event), trigger$2(e, t, i, r, n))
}
function trigger$2(e, t, i, r, n) {
  ;(n.isAvailableBehavior = bind$2(isAvailableBehavior, null, i, r)), e.trigger(t, n)
}
function isAvailableBehavior(e, t, i) {
  var r = i[e]
  return !e || (r && (!isString(r) || t.event[r + 'Key']))
}
function updateViewOnPan(e, t, i) {
  var r = e.target
  ;(r.x += t), (r.y += i), r.dirty()
}
function updateViewOnZoom(e, t, i, r) {
  var n = e.target,
    a = e.zoomLimit,
    o = (e.zoom = e.zoom || 1)
  if (((o *= t), a)) {
    var s = a.min || 0,
      l = a.max || 1 / 0
    o = Math.max(Math.min(l, o), s)
  }
  var h = o / e.zoom
  ;(e.zoom = o),
    (n.x -= (i - n.x) * (h - 1)),
    (n.y -= (r - n.y) * (h - 1)),
    (n.scaleX *= h),
    (n.scaleY *= h),
    n.dirty()
}
var IRRELEVANT_EXCLUDES = { axisPointer: 1, tooltip: 1, brush: 1 }
function onIrrelevantElement(e, t, i) {
  var r = t.getComponentByElement(e.topTarget),
    n = r && r.coordinateSystem
  return r && r !== i && !IRRELEVANT_EXCLUDES.hasOwnProperty(r.mainType) && n && n.model !== i
}
var OPTION_STYLE_ENABLED_TAGS = [
    'rect',
    'circle',
    'line',
    'ellipse',
    'polygon',
    'polyline',
    'path'
  ],
  OPTION_STYLE_ENABLED_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS),
  STATE_TRIGGER_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(['g'])),
  LABEL_HOST_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(['g'])),
  mapLabelRaw = makeInner()
function getFixedItemStyle(e) {
  var t = e.getItemStyle(),
    i = e.get('areaColor')
  return null != i && (t.fill = i), t
}
var MapDraw = (function () {
  function e(e) {
    var t = new Group$3()
    ;(this.uid = getUID('ec_map_draw')),
      (this._controller = new RoamController(e.getZr())),
      (this._controllerHost = { target: t }),
      (this.group = t),
      t.add((this._regionsGroup = new Group$3())),
      t.add((this._svgGroup = new Group$3()))
  }
  return (
    (e.prototype.draw = function (e, t, i, r, n) {
      var a = 'geo' === e.mainType,
        o = e.getData && e.getData()
      a &&
        t.eachComponent({ mainType: 'series', subType: 'map' }, function (t) {
          o || t.getHostGeoModel() !== e || (o = t.getData())
        })
      var s = e.coordinateSystem,
        l = this._regionsGroup,
        h = this.group,
        u = s.getTransformInfo(),
        p = u.raw,
        c = u.roam
      !l.childAt(0) || n
        ? ((h.x = c.x), (h.y = c.y), (h.scaleX = c.scaleX), (h.scaleY = c.scaleY), h.dirty())
        : updateProps$1(h, c, e)
      var d = o && o.getVisual('visualMeta') && o.getVisual('visualMeta').length > 0,
        f = {
          api: i,
          geo: s,
          mapOrGeoModel: e,
          data: o,
          isVisualEncodedByVisualMap: d,
          isGeo: a,
          transformInfoRaw: p
        }
      'geoJSON' === s.resourceType
        ? this._buildGeoJSON(f)
        : 'geoSVG' === s.resourceType && this._buildSVG(f),
        this._updateController(e, t, i),
        this._updateMapSelectHandler(e, l, i, r)
    }),
    (e.prototype._buildGeoJSON = function (e) {
      var t = (this._regionsGroupByName = createHashMap()),
        i = createHashMap(),
        r = this._regionsGroup,
        n = e.transformInfoRaw,
        a = e.mapOrGeoModel,
        o = e.data,
        s = function (e) {
          return [e[0] * n.scaleX + n.x, e[1] * n.scaleY + n.y]
        }
      r.removeAll(),
        each$i(e.geo.regions, function (n) {
          var l = n.name,
            h = t.get(l),
            u = i.get(l) || {},
            p = u.dataIdx,
            c = u.regionModel
          h ||
            ((h = t.set(l, new Group$3())),
            r.add(h),
            (p = o ? o.indexOfName(l) : null),
            (c = e.isGeo ? a.getRegionModel(l) : o ? o.getItemModel(p) : null),
            i.set(l, { dataIdx: p, regionModel: c }))
          var d = new CompoundPath({ segmentIgnoreThreshold: 1, shape: { paths: [] } })
          h.add(d),
            each$i(n.geometries, function (e) {
              if ('polygon' === e.type) {
                for (var t = [], i = 0; i < e.exterior.length; ++i) t.push(s(e.exterior[i]))
                d.shape.paths.push(new Polygon({ segmentIgnoreThreshold: 1, shape: { points: t } }))
                for (i = 0; i < (e.interiors ? e.interiors.length : 0); ++i) {
                  for (var r = e.interiors[i], n = [], a = 0; a < r.length; ++a) n.push(s(r[a]))
                  d.shape.paths.push(
                    new Polygon({ segmentIgnoreThreshold: 1, shape: { points: n } })
                  )
                }
              }
            }),
            applyOptionStyleForRegion(e, d, p, c),
            d instanceof Displayable && (d.culling = !0)
          var f = s(n.getCenter())
          resetLabelForRegion(e, d, l, c, a, p, f)
        }),
        t.each(function (t, r) {
          var n = i.get(r),
            o = n.dataIdx,
            s = n.regionModel
          resetEventTriggerForRegion(e, t, r, s, a, o),
            resetTooltipForRegion(e, t, r, s, a),
            resetStateTriggerForRegion(e, t, r, s, a)
        }, this)
    }),
    (e.prototype._buildSVG = function (e) {
      var t = e.geo.map,
        i = e.transformInfoRaw
      ;(this._svgGroup.x = i.x),
        (this._svgGroup.y = i.y),
        (this._svgGroup.scaleX = i.scaleX),
        (this._svgGroup.scaleY = i.scaleY),
        this._svgResourceChanged(t) && (this._freeSVG(), this._useSVG(t))
      var r = (this._svgDispatcherMap = createHashMap()),
        n = !1
      each$i(
        this._svgGraphicRecord.named,
        function (t) {
          var i = t.name,
            a = e.mapOrGeoModel,
            o = e.data,
            s = t.svgNodeTagLower,
            l = t.el,
            h = o ? o.indexOfName(i) : null,
            u = a.getRegionModel(i)
          ;(null != OPTION_STYLE_ENABLED_TAG_MAP.get(s) &&
            l instanceof Displayable &&
            applyOptionStyleForRegion(e, l, h, u),
          l instanceof Displayable && (l.culling = !0),
          (l.z2EmphasisLift = 0),
          t.namedFrom) ||
            (null != LABEL_HOST_MAP.get(s) && resetLabelForRegion(e, l, i, u, a, h, null),
            resetEventTriggerForRegion(e, l, i, u, a, h),
            resetTooltipForRegion(e, l, i, u, a),
            null != STATE_TRIGGER_TAG_MAP.get(s) &&
              ('self' === resetStateTriggerForRegion(e, l, i, u, a) && (n = !0),
              (r.get(i) || r.set(i, [])).push(l)))
        },
        this
      ),
        this._enableBlurEntireSVG(n, e)
    }),
    (e.prototype._enableBlurEntireSVG = function (e, t) {
      if (e && t.isGeo) {
        var i = t.mapOrGeoModel.getModel(['blur', 'itemStyle']).getItemStyle().opacity
        this._svgGraphicRecord.root.traverse(function (e) {
          if (!e.isGroup) {
            setDefaultStateProxy(e)
            var t = e.ensureState('blur').style || {}
            null == t.opacity && null != i && (t.opacity = i), e.ensureState('emphasis')
          }
        })
      }
    }),
    (e.prototype.remove = function () {
      this._regionsGroup.removeAll(),
        (this._regionsGroupByName = null),
        this._svgGroup.removeAll(),
        this._freeSVG(),
        this._controller.dispose(),
        (this._controllerHost = null)
    }),
    (e.prototype.findHighDownDispatchers = function (e, t) {
      if (null == e) return []
      var i = t.coordinateSystem
      if ('geoJSON' === i.resourceType) {
        var r = this._regionsGroupByName
        if (r) {
          var n = r.get(e)
          return n ? [n] : []
        }
      } else if ('geoSVG' === i.resourceType)
        return (this._svgDispatcherMap && this._svgDispatcherMap.get(e)) || []
    }),
    (e.prototype._svgResourceChanged = function (e) {
      return this._svgMapName !== e
    }),
    (e.prototype._useSVG = function (e) {
      var t = geoSourceManager.getGeoResource(e)
      if (t && 'geoSVG' === t.type) {
        var i = t.useGraphic(this.uid)
        this._svgGroup.add(i.root), (this._svgGraphicRecord = i), (this._svgMapName = e)
      }
    }),
    (e.prototype._freeSVG = function () {
      var e = this._svgMapName
      if (null != e) {
        var t = geoSourceManager.getGeoResource(e)
        t && 'geoSVG' === t.type && t.freeGraphic(this.uid),
          (this._svgGraphicRecord = null),
          (this._svgDispatcherMap = null),
          this._svgGroup.removeAll(),
          (this._svgMapName = null)
      }
    }),
    (e.prototype._updateController = function (e, t, i) {
      var r = e.coordinateSystem,
        n = this._controller,
        a = this._controllerHost
      ;(a.zoomLimit = e.get('scaleLimit')), (a.zoom = r.getZoom()), n.enable(e.get('roam') || !1)
      var o = e.mainType
      function s() {
        var t = { type: 'geoRoam', componentType: o }
        return (t[o + 'Id'] = e.id), t
      }
      n.off('pan').on(
        'pan',
        function (e) {
          ;(this._mouseDownFlag = !1),
            updateViewOnPan(a, e.dx, e.dy),
            i.dispatchAction(extend$3(s(), { dx: e.dx, dy: e.dy }))
        },
        this
      ),
        n.off('zoom').on(
          'zoom',
          function (e) {
            ;(this._mouseDownFlag = !1),
              updateViewOnZoom(a, e.scale, e.originX, e.originY),
              i.dispatchAction(
                extend$3(s(), { zoom: e.scale, originX: e.originX, originY: e.originY })
              )
          },
          this
        ),
        n.setPointerChecker(function (t, n, a) {
          return r.containPoint([n, a]) && !onIrrelevantElement(t, i, e)
        })
    }),
    (e.prototype.resetForLabelLayout = function () {
      this.group.traverse(function (e) {
        var t = e.getTextContent()
        t && (t.ignore = mapLabelRaw(t).ignore)
      })
    }),
    (e.prototype._updateMapSelectHandler = function (e, t, i, r) {
      var n = this
      t.off('mousedown'),
        t.off('click'),
        e.get('selectedMode') &&
          (t.on('mousedown', function () {
            n._mouseDownFlag = !0
          }),
          t.on('click', function (e) {
            n._mouseDownFlag && (n._mouseDownFlag = !1)
          }))
    }),
    e
  )
})()
function applyOptionStyleForRegion(e, t, i, r) {
  var n = r.getModel('itemStyle'),
    a = r.getModel(['emphasis', 'itemStyle']),
    o = r.getModel(['blur', 'itemStyle']),
    s = r.getModel(['select', 'itemStyle']),
    l = getFixedItemStyle(n),
    h = getFixedItemStyle(a),
    u = getFixedItemStyle(s),
    p = getFixedItemStyle(o),
    c = e.data
  if (c) {
    var d = c.getItemVisual(i, 'style'),
      f = c.getItemVisual(i, 'decal')
    e.isVisualEncodedByVisualMap && d.fill && (l.fill = d.fill),
      f && (l.decal = createOrUpdatePatternFromDecal(f, e.api))
  }
  t.setStyle(l),
    (t.style.strokeNoScale = !0),
    (t.ensureState('emphasis').style = h),
    (t.ensureState('select').style = u),
    (t.ensureState('blur').style = p),
    setDefaultStateProxy(t)
}
function resetLabelForRegion(e, t, i, r, n, a, o) {
  var s = e.data,
    l = e.isGeo,
    h = s && isNaN(s.get(s.mapDimension('value'), a)),
    u = s && s.getItemLayout(a)
  if (l || h || (u && u.showLabel)) {
    var p = l ? i : a,
      c = void 0
    ;(!s || a >= 0) && (c = n)
    var d = o ? { normal: { align: 'center', verticalAlign: 'middle' } } : null
    setLabelStyle(
      t,
      getLabelStatesModels(r),
      { labelFetcher: c, labelDataIndex: p, defaultText: i },
      d
    )
    var f = t.getTextContent()
    if (f && ((mapLabelRaw(f).ignore = f.ignore), t.textConfig && o)) {
      var m = t.getBoundingRect().clone()
      ;(t.textConfig.layoutRect = m),
        (t.textConfig.position = [
          ((o[0] - m.x) / m.width) * 100 + '%',
          ((o[1] - m.y) / m.height) * 100 + '%'
        ])
    }
    t.disableLabelAnimation = !0
  } else t.removeTextContent(), t.removeTextConfig(), (t.disableLabelAnimation = null)
}
function resetEventTriggerForRegion(e, t, i, r, n, a) {
  e.data
    ? e.data.setItemGraphicEl(a, t)
    : (getECData(t).eventData = {
        componentType: 'geo',
        componentIndex: n.componentIndex,
        geoIndex: n.componentIndex,
        name: i,
        region: (r && r.option) || {}
      })
}
function resetTooltipForRegion(e, t, i, r, n) {
  e.data ||
    setTooltipConfig({ el: t, componentModel: n, itemName: i, itemTooltipOption: r.get('tooltip') })
}
function resetStateTriggerForRegion(e, t, i, r, n) {
  t.highDownSilentOnTouch = !!n.get('selectedMode')
  var a = r.getModel('emphasis'),
    o = a.get('focus')
  return (
    enableHoverEmphasis(t, o, a.get('blurScope')),
    e.isGeo && enableComponentHighDownFeatures(t, n, i),
    o
  )
}
var MapView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i, r) {
        if (!r || 'mapToggleSelect' !== r.type || r.from !== this.uid) {
          var n = this.group
          if ((n.removeAll(), !e.getHostGeoModel())) {
            if (
              (this._mapDraw && r && 'geoRoam' === r.type && this._mapDraw.resetForLabelLayout(),
              r && 'geoRoam' === r.type && 'series' === r.componentType && r.seriesId === e.id)
            )
              (a = this._mapDraw) && n.add(a.group)
            else if (e.needsDrawMap) {
              var a = this._mapDraw || new MapDraw(i)
              n.add(a.group), a.draw(e, t, i, this, r), (this._mapDraw = a)
            } else this._mapDraw && this._mapDraw.remove(), (this._mapDraw = null)
            e.get('showLegendSymbol') && t.getComponent('legend') && this._renderSymbols(e, t, i)
          }
        }
      }),
      (t.prototype.remove = function () {
        this._mapDraw && this._mapDraw.remove(), (this._mapDraw = null), this.group.removeAll()
      }),
      (t.prototype.dispose = function () {
        this._mapDraw && this._mapDraw.remove(), (this._mapDraw = null)
      }),
      (t.prototype._renderSymbols = function (e, t, i) {
        var r = e.originalData,
          n = this.group
        r.each(r.mapDimension('value'), function (t, i) {
          if (!isNaN(t)) {
            var a = r.getItemLayout(i)
            if (a && a.point) {
              var o = a.point,
                s = a.offset,
                l = new Circle({
                  style: { fill: e.getData().getVisual('style').fill },
                  shape: { cx: o[0] + 9 * s, cy: o[1], r: 3 },
                  silent: !0,
                  z2: 8 + (s ? 0 : Z2_EMPHASIS_LIFT + 1)
                })
              if (!s) {
                var h = e.mainSeries.getData(),
                  u = r.getName(i),
                  p = h.indexOfName(u),
                  c = r.getItemModel(i),
                  d = c.getModel('label'),
                  f = h.getItemGraphicEl(p)
                setLabelStyle(l, getLabelStatesModels(c), {
                  labelFetcher: {
                    getFormattedLabel: function (t, i) {
                      return e.getFormattedLabel(p, i)
                    }
                  }
                }),
                  (l.disableLabelAnimation = !0),
                  d.get('position') || l.setTextConfig({ position: 'bottom' }),
                  (f.onHoverStateChange = function (e) {
                    setStatesFlag(l, e)
                  })
              }
              n.add(l)
            }
          }
        })
      }),
      (t.type = 'map'),
      t
    )
  })(ChartView),
  MapSeries = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (
        (i.type = t.type),
        (i.needsDrawMap = !1),
        (i.seriesGroup = []),
        (i.getTooltipPosition = function (e) {
          if (null != e) {
            var t = this.getData().getName(e),
              i = this.coordinateSystem,
              r = i.getRegion(t)
            return r && i.dataToPoint(r.getCenter())
          }
        }),
        i
      )
    }
    return (
      __extends(t, e),
      (t.prototype.getInitialData = function (e) {
        for (
          var t = createListSimply(this, {
              coordDimensions: ['value'],
              encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
            }),
            i = createHashMap(),
            r = [],
            n = 0,
            a = t.count();
          n < a;
          n++
        ) {
          var o = t.getName(n)
          i.set(o, !0)
        }
        return (
          each$i(
            geoSourceManager.load(this.getMapType(), this.option.nameMap, this.option.nameProperty)
              .regions,
            function (e) {
              var t = e.name
              i.get(t) || r.push(t)
            }
          ),
          t.appendValues([], r),
          t
        )
      }),
      (t.prototype.getHostGeoModel = function () {
        var e = this.option.geoIndex
        return null != e ? this.ecModel.getComponent('geo', e) : null
      }),
      (t.prototype.getMapType = function () {
        return (this.getHostGeoModel() || this).option.map
      }),
      (t.prototype.getRawValue = function (e) {
        var t = this.getData()
        return t.get(t.mapDimension('value'), e)
      }),
      (t.prototype.getRegionModel = function (e) {
        var t = this.getData()
        return t.getItemModel(t.indexOfName(e))
      }),
      (t.prototype.formatTooltip = function (e, t, i) {
        for (
          var r = this.getData(),
            n = this.getRawValue(e),
            a = r.getName(e),
            o = this.seriesGroup,
            s = [],
            l = 0;
          l < o.length;
          l++
        ) {
          var h = o[l].originalData.indexOfName(a),
            u = r.mapDimension('value')
          isNaN(o[l].originalData.get(u, h)) || s.push(o[l].name)
        }
        return createTooltipMarkup('section', {
          header: s.join(', '),
          noHeader: !s.length,
          blocks: [createTooltipMarkup('nameValue', { name: a, value: n })]
        })
      }),
      (t.prototype.setZoom = function (e) {
        this.option.zoom = e
      }),
      (t.prototype.setCenter = function (e) {
        this.option.center = e
      }),
      (t.prototype.getLegendIcon = function (e) {
        var t = e.icon || 'roundRect',
          i = createSymbol$1(t, 0, 0, e.itemWidth, e.itemHeight, e.itemStyle.fill)
        return (
          i.setStyle(e.itemStyle),
          (i.style.stroke = 'none'),
          t.indexOf('empty') > -1 &&
            ((i.style.stroke = i.style.fill), (i.style.fill = '#fff'), (i.style.lineWidth = 2)),
          i
        )
      }),
      (t.type = 'series.map'),
      (t.dependencies = ['geo']),
      (t.layoutMode = 'box'),
      (t.defaultOption = {
        zlevel: 0,
        z: 2,
        coordinateSystem: 'geo',
        map: '',
        left: 'center',
        top: 'center',
        aspectScale: null,
        showLegendSymbol: !0,
        boundingCoords: null,
        center: null,
        zoom: 1,
        scaleLimit: null,
        selectedMode: !0,
        label: { show: !1, color: '#000' },
        itemStyle: { borderWidth: 0.5, borderColor: '#444', areaColor: '#eee' },
        emphasis: {
          label: { show: !0, color: 'rgb(100,0,0)' },
          itemStyle: { areaColor: 'rgba(255,215,0,0.8)' }
        },
        select: {
          label: { show: !0, color: 'rgb(100,0,0)' },
          itemStyle: { color: 'rgba(255,215,0,0.8)' }
        },
        nameProperty: 'name'
      }),
      t
    )
  })(SeriesModel)
function dataStatistics(e, t) {
  var i = {}
  return (
    each$i(e, function (e) {
      e.each(e.mapDimension('value'), function (t, r) {
        var n = 'ec-' + e.getName(r)
        ;(i[n] = i[n] || []), isNaN(t) || i[n].push(t)
      })
    }),
    e[0].map(e[0].mapDimension('value'), function (r, n) {
      for (
        var a, o = 'ec-' + e[0].getName(n), s = 0, l = 1 / 0, h = -1 / 0, u = i[o].length, p = 0;
        p < u;
        p++
      )
        (l = Math.min(l, i[o][p])), (h = Math.max(h, i[o][p])), (s += i[o][p])
      return (
        (a = 'min' === t ? l : 'max' === t ? h : 'average' === t ? s / u : s), 0 === u ? NaN : a
      )
    })
  )
}
function mapDataStatistic(e) {
  var t = {}
  e.eachSeriesByType('map', function (e) {
    var i = e.getHostGeoModel(),
      r = i ? 'o' + i.id : 'i' + e.getMapType()
    ;(t[r] = t[r] || []).push(e)
  }),
    each$i(t, function (e, t) {
      for (
        var i = dataStatistics(
            map$1(e, function (e) {
              return e.getData()
            }),
            e[0].get('mapValueCalculation')
          ),
          r = 0;
        r < e.length;
        r++
      )
        e[r].originalData = e[r].getData()
      for (r = 0; r < e.length; r++)
        (e[r].seriesGroup = e),
          (e[r].needsDrawMap = 0 === r && !e[r].getHostGeoModel()),
          e[r].setData(i.cloneShallow()),
          (e[r].mainSeries = e[0])
    })
}
function mapSymbolLayout(e) {
  var t = {}
  e.eachSeriesByType('map', function (i) {
    var r = i.getMapType()
    if (!i.getHostGeoModel() && !t[r]) {
      var n = {}
      each$i(i.seriesGroup, function (t) {
        var i = t.coordinateSystem,
          r = t.originalData
        t.get('showLegendSymbol') &&
          e.getComponent('legend') &&
          r.each(r.mapDimension('value'), function (e, t) {
            var a = r.getName(t),
              o = i.getRegion(a)
            if (o && !isNaN(e)) {
              var s = n[a] || 0,
                l = i.dataToPoint(o.getCenter())
              ;(n[a] = s + 1), r.setItemLayout(t, { point: l, offset: s })
            }
          })
      })
      var a = i.getData()
      a.each(function (e) {
        var t = a.getName(e),
          i = a.getItemLayout(e) || {}
        ;(i.showLabel = !n[t]), a.setItemLayout(e, i)
      }),
        (t[r] = !0)
    }
  })
}
var v2ApplyTransform = applyTransform$1,
  View = (function (e) {
    function t(t) {
      var i = e.call(this) || this
      return (
        (i.type = 'view'),
        (i.dimensions = ['x', 'y']),
        (i._roamTransformable = new Transformable()),
        (i._rawTransformable = new Transformable()),
        (i.name = t),
        i
      )
    }
    return (
      __extends(t, e),
      (t.prototype.setBoundingRect = function (e, t, i, r) {
        return (this._rect = new BoundingRect(e, t, i, r)), this._rect
      }),
      (t.prototype.getBoundingRect = function () {
        return this._rect
      }),
      (t.prototype.setViewRect = function (e, t, i, r) {
        this._transformTo(e, t, i, r), (this._viewRect = new BoundingRect(e, t, i, r))
      }),
      (t.prototype._transformTo = function (e, t, i, r) {
        var n = this.getBoundingRect(),
          a = this._rawTransformable
        a.transform = n.calculateTransform(new BoundingRect(e, t, i, r))
        var o = a.parent
        ;(a.parent = null), a.decomposeTransform(), (a.parent = o), this._updateTransform()
      }),
      (t.prototype.setCenter = function (e) {
        e && ((this._center = e), this._updateCenterAndZoom())
      }),
      (t.prototype.setZoom = function (e) {
        e = e || 1
        var t = this.zoomLimit
        t && (null != t.max && (e = Math.min(t.max, e)), null != t.min && (e = Math.max(t.min, e))),
          (this._zoom = e),
          this._updateCenterAndZoom()
      }),
      (t.prototype.getDefaultCenter = function () {
        var e = this.getBoundingRect()
        return [e.x + e.width / 2, e.y + e.height / 2]
      }),
      (t.prototype.getCenter = function () {
        return this._center || this.getDefaultCenter()
      }),
      (t.prototype.getZoom = function () {
        return this._zoom || 1
      }),
      (t.prototype.getRoamTransform = function () {
        return this._roamTransformable.getLocalTransform()
      }),
      (t.prototype._updateCenterAndZoom = function () {
        var e = this._rawTransformable.getLocalTransform(),
          t = this._roamTransformable,
          i = this.getDefaultCenter(),
          r = this.getCenter(),
          n = this.getZoom()
        ;(r = applyTransform$1([], r, e)),
          (i = applyTransform$1([], i, e)),
          (t.originX = r[0]),
          (t.originY = r[1]),
          (t.x = i[0] - r[0]),
          (t.y = i[1] - r[1]),
          (t.scaleX = t.scaleY = n),
          this._updateTransform()
      }),
      (t.prototype._updateTransform = function () {
        var e = this._roamTransformable,
          t = this._rawTransformable
        ;(t.parent = e),
          e.updateTransform(),
          t.updateTransform(),
          copy(this.transform || (this.transform = []), t.transform || create$1()),
          (this._rawTransform = t.getLocalTransform()),
          (this.invTransform = this.invTransform || []),
          invert(this.invTransform, this.transform),
          this.decomposeTransform()
      }),
      (t.prototype.getTransformInfo = function () {
        var e = this._rawTransformable,
          t = this._roamTransformable,
          i = new Transformable()
        return (
          (i.transform = t.transform),
          i.decomposeTransform(),
          {
            roam: { x: i.x, y: i.y, scaleX: i.scaleX, scaleY: i.scaleY },
            raw: { x: e.x, y: e.y, scaleX: e.scaleX, scaleY: e.scaleY }
          }
        )
      }),
      (t.prototype.getViewRect = function () {
        return this._viewRect
      }),
      (t.prototype.getViewRectAfterRoam = function () {
        var e = this.getBoundingRect().clone()
        return e.applyTransform(this.transform), e
      }),
      (t.prototype.dataToPoint = function (e, t, i) {
        var r = t ? this._rawTransform : this.transform
        return (i = i || []), r ? v2ApplyTransform(i, e, r) : copy$1(i, e)
      }),
      (t.prototype.pointToData = function (e) {
        var t = this.invTransform
        return t ? v2ApplyTransform([], e, t) : [e[0], e[1]]
      }),
      (t.prototype.convertToPixel = function (e, t, i) {
        var r = getCoordSys$4(t)
        return r === this ? r.dataToPoint(i) : null
      }),
      (t.prototype.convertFromPixel = function (e, t, i) {
        var r = getCoordSys$4(t)
        return r === this ? r.pointToData(i) : null
      }),
      (t.prototype.containPoint = function (e) {
        return this.getViewRectAfterRoam().contain(e[0], e[1])
      }),
      (t.dimensions = ['x', 'y']),
      t
    )
  })(Transformable)
function getCoordSys$4(e) {
  var t = e.seriesModel
  return t ? t.coordinateSystem : null
}
var GEO_DEFAULT_PARAMS = {
    geoJSON: { aspectScale: 0.75, invertLongitute: !0 },
    geoSVG: { aspectScale: 1, invertLongitute: !1 }
  },
  Geo = (function (e) {
    function t(t, i, r) {
      var n = e.call(this, t) || this
      ;(n.dimensions = ['lng', 'lat']),
        (n.type = 'geo'),
        (n._nameCoordMap = createHashMap()),
        (n.map = i)
      var a = geoSourceManager.load(i, r.nameMap, r.nameProperty),
        o = geoSourceManager.getGeoResource(i)
      n.resourceType = o ? o.type : null
      var s = GEO_DEFAULT_PARAMS[o.type]
      ;(n._regionsMap = a.regionsMap),
        (n._invertLongitute = s.invertLongitute),
        (n.regions = a.regions),
        (n.aspectScale = retrieve2(r.aspectScale, s.aspectScale))
      var l = a.boundingRect
      return n.setBoundingRect(l.x, l.y, l.width, l.height), n
    }
    return (
      __extends(t, e),
      (t.prototype._transformTo = function (e, t, i, r) {
        var n = this.getBoundingRect(),
          a = this._invertLongitute
        ;(n = n.clone()), a && (n.y = -n.y - n.height)
        var o = this._rawTransformable
        o.transform = n.calculateTransform(new BoundingRect(e, t, i, r))
        var s = o.parent
        ;(o.parent = null),
          o.decomposeTransform(),
          (o.parent = s),
          a && (o.scaleY = -o.scaleY),
          this._updateTransform()
      }),
      (t.prototype.getRegion = function (e) {
        return this._regionsMap.get(e)
      }),
      (t.prototype.getRegionByCoord = function (e) {
        for (var t = this.regions, i = 0; i < t.length; i++) {
          var r = t[i]
          if ('geoJSON' === r.type && r.contain(e)) return t[i]
        }
      }),
      (t.prototype.addGeoCoord = function (e, t) {
        this._nameCoordMap.set(e, t)
      }),
      (t.prototype.getGeoCoord = function (e) {
        var t = this._regionsMap.get(e)
        return this._nameCoordMap.get(e) || (t && t.getCenter())
      }),
      (t.prototype.dataToPoint = function (e, t, i) {
        if (('string' == typeof e && (e = this.getGeoCoord(e)), e))
          return View.prototype.dataToPoint.call(this, e, t, i)
      }),
      (t.prototype.convertToPixel = function (e, t, i) {
        var r = getCoordSys$3(t)
        return r === this ? r.dataToPoint(i) : null
      }),
      (t.prototype.convertFromPixel = function (e, t, i) {
        var r = getCoordSys$3(t)
        return r === this ? r.pointToData(i) : null
      }),
      t
    )
  })(View)
function getCoordSys$3(e) {
  var t = e.geoModel,
    i = e.seriesModel
  return t
    ? t.coordinateSystem
    : i
    ? i.coordinateSystem ||
      (i.getReferringComponents('geo', SINGLE_REFERRING).models[0] || {}).coordinateSystem
    : null
}
function resizeGeo(e, t) {
  var i = e.get('boundingCoords')
  if (null != i) {
    var r = i[0],
      n = i[1]
    isNaN(r[0]) ||
      isNaN(r[1]) ||
      isNaN(n[0]) ||
      isNaN(n[1]) ||
      this.setBoundingRect(r[0], r[1], n[0] - r[0], n[1] - r[1])
  }
  var a,
    o,
    s,
    l = this.getBoundingRect(),
    h = e.get('layoutCenter'),
    u = e.get('layoutSize'),
    p = t.getWidth(),
    c = t.getHeight(),
    d = (l.width / l.height) * this.aspectScale,
    f = !1
  if (
    (h &&
      u &&
      ((a = [parsePercent$1(h[0], p), parsePercent$1(h[1], c)]),
      (o = parsePercent$1(u, Math.min(p, c))),
      isNaN(a[0]) || isNaN(a[1]) || isNaN(o) || (f = !0)),
    f)
  )
    (s = {}),
      d > 1 ? ((s.width = o), (s.height = o / d)) : ((s.height = o), (s.width = o * d)),
      (s.y = a[1] - s.height / 2),
      (s.x = a[0] - s.width / 2)
  else {
    var m = e.getBoxLayoutParams()
    ;(m.aspect = d), (s = getLayoutRect(m, { width: p, height: c }))
  }
  this.setViewRect(s.x, s.y, s.width, s.height),
    this.setCenter(e.get('center')),
    this.setZoom(e.get('zoom'))
}
function setGeoCoords(e, t) {
  each$i(t.get('geoCoord'), function (t, i) {
    e.addGeoCoord(i, t)
  })
}
mixin(Geo, View)
var GeoCreator = (function () {
    function e() {
      this.dimensions = Geo.prototype.dimensions
    }
    return (
      (e.prototype.create = function (e, t) {
        var i = []
        e.eachComponent('geo', function (e, r) {
          var n = e.get('map'),
            a = new Geo(n + r, n, {
              nameMap: e.get('nameMap'),
              nameProperty: e.get('nameProperty'),
              aspectScale: e.get('aspectScale')
            })
          ;(a.zoomLimit = e.get('scaleLimit')),
            i.push(a),
            (e.coordinateSystem = a),
            (a.model = e),
            (a.resize = resizeGeo),
            a.resize(e, t)
        }),
          e.eachSeries(function (e) {
            if ('geo' === e.get('coordinateSystem')) {
              var t = e.get('geoIndex') || 0
              e.coordinateSystem = i[t]
            }
          })
        var r = {}
        return (
          e.eachSeriesByType('map', function (e) {
            if (!e.getHostGeoModel()) {
              var t = e.getMapType()
              ;(r[t] = r[t] || []), r[t].push(e)
            }
          }),
          each$i(r, function (e, r) {
            var n = map$1(e, function (e) {
                return e.get('nameMap')
              }),
              a = new Geo(r, r, {
                nameMap: mergeAll(n),
                nameProperty: e[0].get('nameProperty'),
                aspectScale: e[0].get('aspectScale')
              })
            ;(a.zoomLimit = retrieve.apply(
              null,
              map$1(e, function (e) {
                return e.get('scaleLimit')
              })
            )),
              i.push(a),
              (a.resize = resizeGeo),
              a.resize(e[0], t),
              each$i(e, function (e) {
                ;(e.coordinateSystem = a), setGeoCoords(a, e)
              })
          }),
          i
        )
      }),
      (e.prototype.getFilledRegions = function (e, t, i, r) {
        for (var n = (e || []).slice(), a = createHashMap(), o = 0; o < n.length; o++)
          a.set(n[o].name, n[o])
        return (
          each$i(geoSourceManager.load(t, i, r).regions, function (e) {
            var t = e.name
            !a.get(t) && n.push({ name: t })
          }),
          n
        )
      }),
      e
    )
  })(),
  geoCreator = new GeoCreator(),
  GeoModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (e, t, i) {
        var r = geoSourceManager.getGeoResource(e.map)
        if (r && 'geoJSON' === r.type) {
          var n = (e.itemStyle = e.itemStyle || {})
          'color' in n || (n.color = '#eee')
        }
        this.mergeDefaultAndTheme(e, i), defaultEmphasis(e, 'label', ['show'])
      }),
      (t.prototype.optionUpdated = function () {
        var e = this,
          t = this.option
        t.regions = geoCreator.getFilledRegions(t.regions, t.map, t.nameMap, t.nameProperty)
        var i = {}
        ;(this._optionModelMap = reduce(
          t.regions || [],
          function (t, r) {
            var n = r.name
            return n && (t.set(n, new Model(r, e, e.ecModel)), r.selected && (i[n] = !0)), t
          },
          createHashMap()
        )),
          t.selectedMap || (t.selectedMap = i)
      }),
      (t.prototype.getRegionModel = function (e) {
        return this._optionModelMap.get(e) || new Model(null, this, this.ecModel)
      }),
      (t.prototype.getFormattedLabel = function (e, t) {
        var i = this.getRegionModel(e),
          r =
            'normal' === t
              ? i.get(['label', 'formatter'])
              : i.get(['emphasis', 'label', 'formatter']),
          n = { name: e }
        return 'function' == typeof r
          ? ((n.status = t), r(n))
          : 'string' == typeof r
          ? r.replace('{a}', null != e ? e : '')
          : void 0
      }),
      (t.prototype.setZoom = function (e) {
        this.option.zoom = e
      }),
      (t.prototype.setCenter = function (e) {
        this.option.center = e
      }),
      (t.prototype.select = function (e) {
        var t = this.option,
          i = t.selectedMode
        i &&
          ('multiple' !== i && (t.selectedMap = null),
          ((t.selectedMap || (t.selectedMap = {}))[e] = !0))
      }),
      (t.prototype.unSelect = function (e) {
        var t = this.option.selectedMap
        t && (t[e] = !1)
      }),
      (t.prototype.toggleSelected = function (e) {
        this[this.isSelected(e) ? 'unSelect' : 'select'](e)
      }),
      (t.prototype.isSelected = function (e) {
        var t = this.option.selectedMap
        return !(!t || !t[e])
      }),
      (t.type = 'geo'),
      (t.layoutMode = 'box'),
      (t.defaultOption = {
        zlevel: 0,
        z: 0,
        show: !0,
        left: 'center',
        top: 'center',
        aspectScale: null,
        silent: !1,
        map: '',
        boundingCoords: null,
        center: null,
        zoom: 1,
        scaleLimit: null,
        label: { show: !1, color: '#000' },
        itemStyle: { borderWidth: 0.5, borderColor: '#444' },
        emphasis: {
          label: { show: !0, color: 'rgb(100,0,0)' },
          itemStyle: { color: 'rgba(255,215,0,0.8)' }
        },
        select: {
          label: { show: !0, color: 'rgb(100,0,0)' },
          itemStyle: { color: 'rgba(255,215,0,0.8)' }
        },
        regions: []
      }),
      t
    )
  })(ComponentModel)
function updateCenterAndZoom(e, t, i) {
  var r = e.getZoom(),
    n = e.getCenter(),
    a = t.zoom,
    o = e.dataToPoint(n)
  if (
    (null != t.dx &&
      null != t.dy &&
      ((o[0] -= t.dx), (o[1] -= t.dy), e.setCenter(e.pointToData(o))),
    null != a)
  ) {
    if (i) {
      var s = i.min || 0,
        l = i.max || 1 / 0
      a = Math.max(Math.min(r * a, l), s) / r
    }
    ;(e.scaleX *= a), (e.scaleY *= a)
    var h = (t.originX - e.x) * (a - 1),
      u = (t.originY - e.y) * (a - 1)
    ;(e.x -= h), (e.y -= u), e.updateTransform(), e.setCenter(e.pointToData(o)), e.setZoom(a * r)
  }
  return { center: e.getCenter(), zoom: e.getZoom() }
}
var GeoView = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), (i.focusBlurEnabled = !0), i
  }
  return (
    __extends(t, e),
    (t.prototype.init = function (e, t) {
      var i = new MapDraw(t)
      ;(this._mapDraw = i), this.group.add(i.group), (this._api = t)
    }),
    (t.prototype.render = function (e, t, i, r) {
      var n = this._mapDraw
      e.get('show') ? n.draw(e, t, i, this, r) : this._mapDraw.group.removeAll(),
        n.group.on('click', this._handleRegionClick, this),
        (n.group.silent = e.get('silent')),
        (this._model = e),
        this.updateSelectStatus(e, t, i)
    }),
    (t.prototype._handleRegionClick = function (e) {
      var t
      findEventDispatcher(
        e.target,
        function (e) {
          return null != (t = getECData(e).eventData)
        },
        !0
      ),
        t &&
          this._api.dispatchAction({ type: 'geoToggleSelect', geoId: this._model.id, name: t.name })
    }),
    (t.prototype.updateSelectStatus = function (e, t, i) {
      var r = this
      this._mapDraw.group.traverse(function (e) {
        var t = getECData(e).eventData
        if (t) return r._model.isSelected(t.name) ? i.enterSelect(e) : i.leaveSelect(e), !0
      })
    }),
    (t.prototype.findHighDownDispatchers = function (e) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(e, this._model)
    }),
    (t.prototype.dispose = function () {
      this._mapDraw && this._mapDraw.remove()
    }),
    (t.type = 'geo'),
    t
  )
})(ComponentView)
function install$J(e) {
  function t(t, i) {
    ;(i.update = 'geo:updateSelectStatus'),
      e.registerAction(i, function (e, i) {
        var r = {},
          n = []
        return (
          i.eachComponent({ mainType: 'geo', query: e }, function (i) {
            i[t](e.name),
              each$i(i.coordinateSystem.regions, function (e) {
                r[e.name] = i.isSelected(e.name) || !1
              })
            var a = []
            each$i(r, function (e, t) {
              r[t] && a.push(t)
            }),
              n.push({ geoIndex: i.componentIndex, name: a })
          }),
          { selected: r, allSelected: n, name: e.name }
        )
      })
  }
  e.registerCoordinateSystem('geo', geoCreator),
    e.registerComponentModel(GeoModel),
    e.registerComponentView(GeoView),
    t('toggleSelected', { type: 'geoToggleSelect', event: 'geoselectchanged' }),
    t('select', { type: 'geoSelect', event: 'geoselected' }),
    t('unSelect', { type: 'geoUnSelect', event: 'geounselected' }),
    e.registerAction(
      { type: 'geoRoam', event: 'geoRoam', update: 'updateTransform' },
      function (e, t) {
        var i = e.componentType || 'series'
        t.eachComponent({ mainType: i, query: e }, function (t) {
          var r = t.coordinateSystem
          if ('geo' === r.type) {
            var n = updateCenterAndZoom(r, e, t.get('scaleLimit'))
            t.setCenter && t.setCenter(n.center),
              t.setZoom && t.setZoom(n.zoom),
              'series' === i &&
                each$i(t.seriesGroup, function (e) {
                  e.setCenter(n.center), e.setZoom(n.zoom)
                })
          }
        })
      }
    )
}
function install$I(e) {
  use(install$J),
    e.registerChartView(MapView),
    e.registerSeriesModel(MapSeries),
    e.registerLayout(mapSymbolLayout),
    e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic),
    createLegacyDataSelectAction('map', e.registerAction)
}
function init(e) {
  var t = e
  t.hierNode = {
    defaultAncestor: null,
    ancestor: t,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null
  }
  for (var i, r, n = [t]; (i = n.pop()); )
    if (((r = i.children), i.isExpand && r.length))
      for (var a = r.length - 1; a >= 0; a--) {
        var o = r[a]
        ;(o.hierNode = {
          defaultAncestor: null,
          ancestor: o,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i: a,
          thread: null
        }),
          n.push(o)
      }
}
function firstWalk(e, t) {
  var i = e.isExpand ? e.children : [],
    r = e.parentNode.children,
    n = e.hierNode.i ? r[e.hierNode.i - 1] : null
  if (i.length) {
    executeShifts(e)
    var a = (i[0].hierNode.prelim + i[i.length - 1].hierNode.prelim) / 2
    n
      ? ((e.hierNode.prelim = n.hierNode.prelim + t(e, n)),
        (e.hierNode.modifier = e.hierNode.prelim - a))
      : (e.hierNode.prelim = a)
  } else n && (e.hierNode.prelim = n.hierNode.prelim + t(e, n))
  e.parentNode.hierNode.defaultAncestor = apportion(
    e,
    n,
    e.parentNode.hierNode.defaultAncestor || r[0],
    t
  )
}
function secondWalk(e) {
  var t = e.hierNode.prelim + e.parentNode.hierNode.modifier
  e.setLayout({ x: t }, !0), (e.hierNode.modifier += e.parentNode.hierNode.modifier)
}
function separation(e) {
  return arguments.length ? e : defaultSeparation
}
function radialCoordinate(e, t) {
  return (e -= Math.PI / 2), { x: t * Math.cos(e), y: t * Math.sin(e) }
}
function getViewRect$4(e, t) {
  return getLayoutRect(e.getBoxLayoutParams(), { width: t.getWidth(), height: t.getHeight() })
}
function executeShifts(e) {
  for (var t = e.children, i = t.length, r = 0, n = 0; --i >= 0; ) {
    var a = t[i]
    ;(a.hierNode.prelim += r),
      (a.hierNode.modifier += r),
      (n += a.hierNode.change),
      (r += a.hierNode.shift + n)
  }
}
function apportion(e, t, i, r) {
  if (t) {
    for (
      var n = e,
        a = e,
        o = a.parentNode.children[0],
        s = t,
        l = n.hierNode.modifier,
        h = a.hierNode.modifier,
        u = o.hierNode.modifier,
        p = s.hierNode.modifier;
      (s = nextRight(s)), (a = nextLeft(a)), s && a;

    ) {
      ;(n = nextRight(n)), (o = nextLeft(o)), (n.hierNode.ancestor = e)
      var c = s.hierNode.prelim + p - a.hierNode.prelim - h + r(s, a)
      c > 0 && (moveSubtree(nextAncestor(s, e, i), e, c), (h += c), (l += c)),
        (p += s.hierNode.modifier),
        (h += a.hierNode.modifier),
        (l += n.hierNode.modifier),
        (u += o.hierNode.modifier)
    }
    s && !nextRight(n) && ((n.hierNode.thread = s), (n.hierNode.modifier += p - l)),
      a && !nextLeft(o) && ((o.hierNode.thread = a), (o.hierNode.modifier += h - u), (i = e))
  }
  return i
}
function nextRight(e) {
  var t = e.children
  return t.length && e.isExpand ? t[t.length - 1] : e.hierNode.thread
}
function nextLeft(e) {
  var t = e.children
  return t.length && e.isExpand ? t[0] : e.hierNode.thread
}
function nextAncestor(e, t, i) {
  return e.hierNode.ancestor.parentNode === t.parentNode ? e.hierNode.ancestor : i
}
function moveSubtree(e, t, i) {
  var r = i / (t.hierNode.i - e.hierNode.i)
  ;(t.hierNode.change -= r),
    (t.hierNode.shift += i),
    (t.hierNode.modifier += i),
    (t.hierNode.prelim += i),
    (e.hierNode.change += r)
}
function defaultSeparation(e, t) {
  return e.parentNode === t.parentNode ? 1 : 2
}
var TreeEdgeShape = function () {
    ;(this.parentPoint = []), (this.childPoints = [])
  },
  TreePath = (function (e) {
    function t(t) {
      return e.call(this, t) || this
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultStyle = function () {
        return { stroke: '#000', fill: null }
      }),
      (t.prototype.getDefaultShape = function () {
        return new TreeEdgeShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        var i = t.childPoints,
          r = i.length,
          n = t.parentPoint,
          a = i[0],
          o = i[r - 1]
        if (1 === r) return e.moveTo(n[0], n[1]), void e.lineTo(a[0], a[1])
        var s = t.orient,
          l = 'TB' === s || 'BT' === s ? 0 : 1,
          h = 1 - l,
          u = parsePercent$1(t.forkPosition, 1),
          p = []
        ;(p[l] = n[l]),
          (p[h] = n[h] + (o[h] - n[h]) * u),
          e.moveTo(n[0], n[1]),
          e.lineTo(p[0], p[1]),
          e.moveTo(a[0], a[1]),
          (p[l] = a[l]),
          e.lineTo(p[0], p[1]),
          (p[l] = o[l]),
          e.lineTo(p[0], p[1]),
          e.lineTo(o[0], o[1])
        for (var c = 1; c < r - 1; c++) {
          var d = i[c]
          e.moveTo(d[0], d[1]), (p[l] = d[l]), e.lineTo(p[0], p[1])
        }
      }),
      t
    )
  })(Path),
  TreeView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i._mainGroup = new Group$3()), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (e, t) {
        ;(this._controller = new RoamController(t.getZr())),
          (this._controllerHost = { target: this.group }),
          this.group.add(this._mainGroup)
      }),
      (t.prototype.render = function (e, t, i) {
        var r = e.getData(),
          n = e.layoutInfo,
          a = this._mainGroup
        'radial' === e.get('layout')
          ? ((a.x = n.x + n.width / 2), (a.y = n.y + n.height / 2))
          : ((a.x = n.x), (a.y = n.y)),
          this._updateViewCoordSys(e),
          this._updateController(e, t, i)
        var o = this._data
        r
          .diff(o)
          .add(function (t) {
            symbolNeedsDraw(r, t) && updateNode(r, t, null, a, e)
          })
          .update(function (t, i) {
            var n = o.getItemGraphicEl(i)
            symbolNeedsDraw(r, t) ? updateNode(r, t, n, a, e) : n && removeNode(o, i, n, a, e)
          })
          .remove(function (t) {
            var i = o.getItemGraphicEl(t)
            i && removeNode(o, t, i, a, e)
          })
          .execute(),
          (this._nodeScaleRatio = e.get('nodeScaleRatio')),
          this._updateNodeAndLinkScale(e),
          !0 === e.get('expandAndCollapse') &&
            r.eachItemGraphicEl(function (t, r) {
              t.off('click').on('click', function () {
                i.dispatchAction({ type: 'treeExpandAndCollapse', seriesId: e.id, dataIndex: r })
              })
            }),
          (this._data = r)
      }),
      (t.prototype._updateViewCoordSys = function (e) {
        var t = e.getData(),
          i = []
        t.each(function (e) {
          var r = t.getItemLayout(e)
          !r || isNaN(r.x) || isNaN(r.y) || i.push([+r.x, +r.y])
        })
        var r = [],
          n = []
        fromPoints(i, r, n)
        var a = this._min,
          o = this._max
        n[0] - r[0] == 0 && ((r[0] = a ? a[0] : r[0] - 1), (n[0] = o ? o[0] : n[0] + 1)),
          n[1] - r[1] == 0 && ((r[1] = a ? a[1] : r[1] - 1), (n[1] = o ? o[1] : n[1] + 1))
        var s = (e.coordinateSystem = new View())
        ;(s.zoomLimit = e.get('scaleLimit')),
          s.setBoundingRect(r[0], r[1], n[0] - r[0], n[1] - r[1]),
          s.setCenter(e.get('center')),
          s.setZoom(e.get('zoom')),
          this.group.attr({ x: s.x, y: s.y, scaleX: s.scaleX, scaleY: s.scaleY }),
          (this._min = r),
          (this._max = n)
      }),
      (t.prototype._updateController = function (e, t, i) {
        var r = this,
          n = this._controller,
          a = this._controllerHost,
          o = this.group
        n.setPointerChecker(function (t, r, n) {
          var a = o.getBoundingRect()
          return a.applyTransform(o.transform), a.contain(r, n) && !onIrrelevantElement(t, i, e)
        }),
          n.enable(e.get('roam')),
          (a.zoomLimit = e.get('scaleLimit')),
          (a.zoom = e.coordinateSystem.getZoom()),
          n
            .off('pan')
            .off('zoom')
            .on('pan', function (t) {
              updateViewOnPan(a, t.dx, t.dy),
                i.dispatchAction({ seriesId: e.id, type: 'treeRoam', dx: t.dx, dy: t.dy })
            })
            .on('zoom', function (t) {
              updateViewOnZoom(a, t.scale, t.originX, t.originY),
                i.dispatchAction({
                  seriesId: e.id,
                  type: 'treeRoam',
                  zoom: t.scale,
                  originX: t.originX,
                  originY: t.originY
                }),
                r._updateNodeAndLinkScale(e),
                i.updateLabelLayout()
            })
      }),
      (t.prototype._updateNodeAndLinkScale = function (e) {
        var t = e.getData(),
          i = this._getNodeGlobalScale(e)
        t.eachItemGraphicEl(function (e, t) {
          e.setSymbolScale(i)
        })
      }),
      (t.prototype._getNodeGlobalScale = function (e) {
        var t = e.coordinateSystem
        if ('view' !== t.type) return 1
        var i = this._nodeScaleRatio,
          r = t.scaleX || 1
        return ((t.getZoom() - 1) * i + 1) / r
      }),
      (t.prototype.dispose = function () {
        this._controller && this._controller.dispose(), (this._controllerHost = null)
      }),
      (t.prototype.remove = function () {
        this._mainGroup.removeAll(), (this._data = null)
      }),
      (t.type = 'tree'),
      t
    )
  })(ChartView)
function symbolNeedsDraw(e, t) {
  var i = e.getItemLayout(t)
  return i && !isNaN(i.x) && !isNaN(i.y)
}
function updateNode(e, t, i, r, n) {
  var a = !i,
    o = e.tree.getNodeByDataIndex(t),
    s = o.getModel(),
    l = o.getVisual('style').fill,
    h = !1 === o.isExpand && 0 !== o.children.length ? l : '#fff',
    u = e.tree.root,
    p = o.parentNode === u ? o : o.parentNode || o,
    c = e.getItemGraphicEl(p.dataIndex),
    d = p.getLayout(),
    f = c ? { x: c.__oldX, y: c.__oldY, rawX: c.__radialOldRawX, rawY: c.__radialOldRawY } : d,
    m = o.getLayout()
  a
    ? (((i = new Symbol$1(e, t, null, { symbolInnerColor: h, useNameLabel: !0 })).x = f.x),
      (i.y = f.y))
    : i.updateData(e, t, null, { symbolInnerColor: h, useNameLabel: !0 }),
    (i.__radialOldRawX = i.__radialRawX),
    (i.__radialOldRawY = i.__radialRawY),
    (i.__radialRawX = m.rawX),
    (i.__radialRawY = m.rawY),
    r.add(i),
    e.setItemGraphicEl(t, i),
    (i.__oldX = i.x),
    (i.__oldY = i.y),
    updateProps$1(i, { x: m.x, y: m.y }, n)
  var g = i.getSymbolPath()
  if ('radial' === n.get('layout')) {
    var y = u.children[0],
      v = y.getLayout(),
      _ = y.children.length,
      x = void 0,
      S = void 0
    if (m.x === v.x && !0 === o.isExpand) {
      var b = {
        x: (y.children[0].getLayout().x + y.children[_ - 1].getLayout().x) / 2,
        y: (y.children[0].getLayout().y + y.children[_ - 1].getLayout().y) / 2
      }
      ;(x = Math.atan2(b.y - v.y, b.x - v.x)) < 0 && (x = 2 * Math.PI + x),
        (S = b.x < v.x) && (x -= Math.PI)
    } else
      (x = Math.atan2(m.y - v.y, m.x - v.x)) < 0 && (x = 2 * Math.PI + x),
        0 === o.children.length || (0 !== o.children.length && !1 === o.isExpand)
          ? (S = m.x < v.x) && (x -= Math.PI)
          : (S = m.x > v.x) || (x -= Math.PI)
    var T = S ? 'left' : 'right',
      A = s.getModel('label'),
      w = A.get('rotate'),
      M = w * (Math.PI / 180),
      C = g.getTextContent()
    C &&
      (g.setTextConfig({
        position: A.get('position') || T,
        rotation: null == w ? -x : M,
        origin: 'center'
      }),
      C.setStyle('verticalAlign', 'middle'))
  }
  var P = s.get(['emphasis', 'focus']),
    E =
      'ancestor' === P
        ? o.getAncestorsIndices()
        : 'descendant' === P
        ? o.getDescendantIndices()
        : null
  E && (getECData(i).focus = E),
    drawEdge(n, o, u, i, f, d, m, r),
    i.__edge &&
      (i.onHoverStateChange = function (t) {
        if ('blur' !== t) {
          var r = o.parentNode && e.getItemGraphicEl(o.parentNode.dataIndex)
          ;(r && r.hoverState === HOVER_STATE_BLUR) || setStatesFlag(i.__edge, t)
        }
      })
}
function drawEdge(e, t, i, r, n, a, o, s) {
  var l = t.getModel(),
    h = e.get('edgeShape'),
    u = e.get('layout'),
    p = e.getOrient(),
    c = e.get(['lineStyle', 'curveness']),
    d = e.get('edgeForkPosition'),
    f = l.getModel('lineStyle').getLineStyle(),
    m = r.__edge
  if ('curve' === h)
    t.parentNode &&
      t.parentNode !== i &&
      (m || (m = r.__edge = new BezierCurve({ shape: getEdgeShape(u, p, c, n, n) })),
      updateProps$1(m, { shape: getEdgeShape(u, p, c, a, o) }, e))
  else if (
    'polyline' === h &&
    'orthogonal' === u &&
    t !== i &&
    t.children &&
    0 !== t.children.length &&
    !0 === t.isExpand
  ) {
    for (var g = t.children, y = [], v = 0; v < g.length; v++) {
      var _ = g[v].getLayout()
      y.push([_.x, _.y])
    }
    m ||
      (m = r.__edge =
        new TreePath({
          shape: { parentPoint: [o.x, o.y], childPoints: [[o.x, o.y]], orient: p, forkPosition: d }
        })),
      updateProps$1(m, { shape: { parentPoint: [o.x, o.y], childPoints: y } }, e)
  }
  m &&
    (m.useStyle(defaults$1({ strokeNoScale: !0, fill: null }, f)),
    setStatesStylesFromModel(m, l, 'lineStyle'),
    setDefaultStateProxy(m),
    s.add(m))
}
function removeNode(e, t, i, r, n) {
  for (
    var a,
      o = e.tree.getNodeByDataIndex(t),
      s = e.tree.root,
      l = o.parentNode === s ? o : o.parentNode || o;
    null == (a = l.getLayout());

  )
    l = l.parentNode === s ? l : l.parentNode || l
  var h = { duration: n.get('animationDurationUpdate'), easing: n.get('animationEasingUpdate') }
  removeElement(i, { x: a.x + 1, y: a.y + 1 }, n, {
    cb: function () {
      r.remove(i), e.setItemGraphicEl(t, null)
    },
    removeOpt: h
  }),
    i.fadeOut(null, { fadeLabel: !0, animation: h })
  var u = e.getItemGraphicEl(l.dataIndex).__edge,
    p = i.__edge || (!1 === l.isExpand || 1 === l.children.length ? u : void 0),
    c = n.get('edgeShape'),
    d = n.get('layout'),
    f = n.get('orient'),
    m = n.get(['lineStyle', 'curveness'])
  p &&
    ('curve' === c
      ? removeElement(p, { shape: getEdgeShape(d, f, m, a, a), style: { opacity: 0 } }, n, {
          cb: function () {
            r.remove(p)
          },
          removeOpt: h
        })
      : 'polyline' === c &&
        'orthogonal' === n.get('layout') &&
        removeElement(
          p,
          { shape: { parentPoint: [a.x, a.y], childPoints: [[a.x, a.y]] }, style: { opacity: 0 } },
          n,
          {
            cb: function () {
              r.remove(p)
            },
            removeOpt: h
          }
        ))
}
function getEdgeShape(e, t, i, r, n) {
  var a, o, s, l, h, u, p, c
  if ('radial' === e) {
    ;(h = r.rawX), (p = r.rawY), (u = n.rawX), (c = n.rawY)
    var d = radialCoordinate(h, p),
      f = radialCoordinate(h, p + (c - p) * i),
      m = radialCoordinate(u, c + (p - c) * i),
      g = radialCoordinate(u, c)
    return {
      x1: d.x || 0,
      y1: d.y || 0,
      x2: g.x || 0,
      y2: g.y || 0,
      cpx1: f.x || 0,
      cpy1: f.y || 0,
      cpx2: m.x || 0,
      cpy2: m.y || 0
    }
  }
  return (
    (h = r.x),
    (p = r.y),
    (u = n.x),
    (c = n.y),
    ('LR' !== t && 'RL' !== t) || ((a = h + (u - h) * i), (o = p), (s = u + (h - u) * i), (l = c)),
    ('TB' !== t && 'BT' !== t) || ((a = h), (o = p + (c - p) * i), (s = u), (l = c + (p - c) * i)),
    { x1: h, y1: p, x2: u, y2: c, cpx1: a, cpy1: o, cpx2: s, cpy2: l }
  )
}
var inner$f = makeInner()
function linkList(e) {
  var t = e.mainData,
    i = e.datas
  i || ((i = { main: t }), (e.datasAttr = { main: 'data' })),
    (e.datas = e.mainData = null),
    linkAll(t, i, e),
    each$i(i, function (i) {
      each$i(t.TRANSFERABLE_METHODS, function (t) {
        i.wrapMethod(t, curry$1(transferInjection, e))
      })
    }),
    t.wrapMethod('cloneShallow', curry$1(cloneShallowInjection, e)),
    each$i(t.CHANGABLE_METHODS, function (i) {
      t.wrapMethod(i, curry$1(changeInjection, e))
    }),
    assert$1(i[t.dataType] === t)
}
function transferInjection(e, t) {
  if (isMainData(this)) {
    var i = extend$3({}, inner$f(this).datas)
    ;(i[this.dataType] = t), linkAll(t, i, e)
  } else linkSingle(t, this.dataType, inner$f(this).mainData, e)
  return t
}
function changeInjection(e, t) {
  return e.struct && e.struct.update(), t
}
function cloneShallowInjection(e, t) {
  return (
    each$i(inner$f(t).datas, function (i, r) {
      i !== t && linkSingle(i.cloneShallow(), r, t, e)
    }),
    t
  )
}
function getLinkedData(e) {
  var t = inner$f(this).mainData
  return null == e || null == t ? t : inner$f(t).datas[e]
}
function getLinkedDataAll() {
  var e = inner$f(this).mainData
  return null == e
    ? [{ data: e }]
    : map$1(keys(inner$f(e).datas), function (t) {
        return { type: t, data: inner$f(e).datas[t] }
      })
}
function isMainData(e) {
  return inner$f(e).mainData === e
}
function linkAll(e, t, i) {
  ;(inner$f(e).datas = {}),
    each$i(t, function (t, r) {
      linkSingle(t, r, e, i)
    })
}
function linkSingle(e, t, i, r) {
  ;(inner$f(i).datas[t] = e),
    (inner$f(e).mainData = i),
    (e.dataType = t),
    r.struct && ((e[r.structAttr] = r.struct), (r.struct[r.datasAttr[t]] = e)),
    (e.getLinkedData = getLinkedData),
    (e.getLinkedDataAll = getLinkedDataAll)
}
var TreeNode = (function () {
    function e(e, t) {
      ;(this.depth = 0),
        (this.height = 0),
        (this.dataIndex = -1),
        (this.children = []),
        (this.viewChildren = []),
        (this.isExpand = !1),
        (this.name = e || ''),
        (this.hostTree = t)
    }
    return (
      (e.prototype.isRemoved = function () {
        return this.dataIndex < 0
      }),
      (e.prototype.eachNode = function (e, t, i) {
        'function' == typeof e && ((i = t), (t = e), (e = null)),
          isString((e = e || {})) && (e = { order: e })
        var r,
          n = e.order || 'preorder',
          a = this[e.attr || 'children']
        'preorder' === n && (r = t.call(i, this))
        for (var o = 0; !r && o < a.length; o++) a[o].eachNode(e, t, i)
        'postorder' === n && t.call(i, this)
      }),
      (e.prototype.updateDepthAndHeight = function (e) {
        var t = 0
        this.depth = e
        for (var i = 0; i < this.children.length; i++) {
          var r = this.children[i]
          r.updateDepthAndHeight(e + 1), r.height > t && (t = r.height)
        }
        this.height = t + 1
      }),
      (e.prototype.getNodeById = function (e) {
        if (this.getId() === e) return this
        for (var t = 0, i = this.children, r = i.length; t < r; t++) {
          var n = i[t].getNodeById(e)
          if (n) return n
        }
      }),
      (e.prototype.contains = function (e) {
        if (e === this) return !0
        for (var t = 0, i = this.children, r = i.length; t < r; t++) {
          var n = i[t].contains(e)
          if (n) return n
        }
      }),
      (e.prototype.getAncestors = function (e) {
        for (var t = [], i = e ? this : this.parentNode; i; ) t.push(i), (i = i.parentNode)
        return t.reverse(), t
      }),
      (e.prototype.getAncestorsIndices = function () {
        for (var e = [], t = this; t; ) e.push(t.dataIndex), (t = t.parentNode)
        return e.reverse(), e
      }),
      (e.prototype.getDescendantIndices = function () {
        var e = []
        return (
          this.eachNode(function (t) {
            e.push(t.dataIndex)
          }),
          e
        )
      }),
      (e.prototype.getValue = function (e) {
        var t = this.hostTree.data
        return t.get(t.getDimension(e || 'value'), this.dataIndex)
      }),
      (e.prototype.setLayout = function (e, t) {
        this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, e, t)
      }),
      (e.prototype.getLayout = function () {
        return this.hostTree.data.getItemLayout(this.dataIndex)
      }),
      (e.prototype.getModel = function (e) {
        if (!(this.dataIndex < 0))
          return this.hostTree.data.getItemModel(this.dataIndex).getModel(e)
      }),
      (e.prototype.getLevelModel = function () {
        return (this.hostTree.levelModels || [])[this.depth]
      }),
      (e.prototype.setVisual = function (e, t) {
        this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, e, t)
      }),
      (e.prototype.getVisual = function (e) {
        return this.hostTree.data.getItemVisual(this.dataIndex, e)
      }),
      (e.prototype.getRawIndex = function () {
        return this.hostTree.data.getRawIndex(this.dataIndex)
      }),
      (e.prototype.getId = function () {
        return this.hostTree.data.getId(this.dataIndex)
      }),
      (e.prototype.isAncestorOf = function (e) {
        for (var t = e.parentNode; t; ) {
          if (t === this) return !0
          t = t.parentNode
        }
        return !1
      }),
      (e.prototype.isDescendantOf = function (e) {
        return e !== this && e.isAncestorOf(this)
      }),
      e
    )
  })(),
  Tree = (function () {
    function e(e) {
      ;(this.type = 'tree'), (this._nodes = []), (this.hostModel = e)
    }
    return (
      (e.prototype.eachNode = function (e, t, i) {
        this.root.eachNode(e, t, i)
      }),
      (e.prototype.getNodeByDataIndex = function (e) {
        var t = this.data.getRawIndex(e)
        return this._nodes[t]
      }),
      (e.prototype.getNodeById = function (e) {
        return this.root.getNodeById(e)
      }),
      (e.prototype.update = function () {
        for (var e = this.data, t = this._nodes, i = 0, r = t.length; i < r; i++)
          t[i].dataIndex = -1
        for (i = 0, r = e.count(); i < r; i++) t[e.getRawIndex(i)].dataIndex = i
      }),
      (e.prototype.clearLayouts = function () {
        this.data.clearItemLayouts()
      }),
      (e.createTree = function (t, i, r) {
        var n = new e(i),
          a = [],
          o = 1
        !(function e(t, i) {
          var r = t.value
          ;(o = Math.max(o, isArray$1(r) ? r.length : 1)), a.push(t)
          var s = new TreeNode(convertOptionIdName(t.name, ''), n)
          i ? addChild(s, i) : (n.root = s), n._nodes.push(s)
          var l = t.children
          if (l) for (var h = 0; h < l.length; h++) e(l[h], s)
        })(t),
          n.root.updateDepthAndHeight(0)
        var s = createDimensions(a, { coordDimensions: ['value'], dimensionsCount: o }),
          l = new List(s, i)
        return (
          l.initData(a),
          r && r(l),
          linkList({ mainData: l, struct: n, structAttr: 'tree' }),
          n.update(),
          n
        )
      }),
      e
    )
  })()
function addChild(e, t) {
  var i = t.children
  e.parentNode !== t && (i.push(e), (e.parentNode = t))
}
function retrieveTargetInfo(e, t, i) {
  if (e && indexOf$1(t, e.type) >= 0) {
    var r = i.getData().tree.root,
      n = e.targetNode
    if (('string' == typeof n && (n = r.getNodeById(n)), n && r.contains(n))) return { node: n }
    var a = e.targetNodeId
    if (null != a && (n = r.getNodeById(a))) return { node: n }
  }
}
function getPathToRoot(e) {
  for (var t = []; e; ) (e = e.parentNode) && t.push(e)
  return t.reverse()
}
function aboveViewRoot(e, t) {
  return indexOf$1(getPathToRoot(e), t) >= 0
}
function wrapTreePathInfo(e, t) {
  for (var i = []; e; ) {
    var r = e.dataIndex
    i.push({ name: e.name, dataIndex: r, value: t.getRawValue(r) }), (e = e.parentNode)
  }
  return i.reverse(), i
}
var TreeSeriesModel = (function (e) {
  function t() {
    var t = (null !== e && e.apply(this, arguments)) || this
    return (t.hasSymbolVisual = !0), (t.ignoreStyleOnData = !0), t
  }
  return (
    __extends(t, e),
    (t.prototype.getInitialData = function (e) {
      var t = { name: e.name, children: e.data },
        i = e.leaves || {},
        r = new Model(i, this, this.ecModel),
        n = Tree.createTree(t, this, function (e) {
          e.wrapMethod('getItemModel', function (e, t) {
            var i = n.getNodeByDataIndex(t)
            return (i && i.children.length && i.isExpand) || (e.parentModel = r), e
          })
        })
      var a = 0
      n.eachNode('preorder', function (e) {
        e.depth > a && (a = e.depth)
      })
      var o = e.expandAndCollapse && e.initialTreeDepth >= 0 ? e.initialTreeDepth : a
      return (
        n.root.eachNode('preorder', function (e) {
          var t = e.hostTree.data.getRawDataItem(e.dataIndex)
          e.isExpand = t && null != t.collapsed ? !t.collapsed : e.depth <= o
        }),
        n.data
      )
    }),
    (t.prototype.getOrient = function () {
      var e = this.get('orient')
      return 'horizontal' === e ? (e = 'LR') : 'vertical' === e && (e = 'TB'), e
    }),
    (t.prototype.setZoom = function (e) {
      this.option.zoom = e
    }),
    (t.prototype.setCenter = function (e) {
      this.option.center = e
    }),
    (t.prototype.formatTooltip = function (e, t, i) {
      for (
        var r = this.getData().tree,
          n = r.root.children[0],
          a = r.getNodeByDataIndex(e),
          o = a.getValue(),
          s = a.name;
        a && a !== n;

      )
        (s = a.parentNode.name + '.' + s), (a = a.parentNode)
      return createTooltipMarkup('nameValue', { name: s, value: o, noValue: isNaN(o) || null == o })
    }),
    (t.prototype.getDataParams = function (t) {
      var i = e.prototype.getDataParams.apply(this, arguments),
        r = this.getData().tree.getNodeByDataIndex(t)
      return (i.treeAncestors = wrapTreePathInfo(r, this)), i
    }),
    (t.type = 'series.tree'),
    (t.layoutMode = 'box'),
    (t.defaultOption = {
      zlevel: 0,
      z: 2,
      coordinateSystem: 'view',
      left: '12%',
      top: '12%',
      right: '12%',
      bottom: '12%',
      layout: 'orthogonal',
      edgeShape: 'curve',
      edgeForkPosition: '50%',
      roam: !1,
      nodeScaleRatio: 0.4,
      center: null,
      zoom: 1,
      orient: 'LR',
      symbol: 'emptyCircle',
      symbolSize: 7,
      expandAndCollapse: !0,
      initialTreeDepth: 2,
      lineStyle: { color: '#ccc', width: 1.5, curveness: 0.5 },
      itemStyle: { color: 'lightsteelblue', borderWidth: 1.5 },
      label: { show: !0 },
      animationEasing: 'linear',
      animationDuration: 700,
      animationDurationUpdate: 500
    }),
    t
  )
})(SeriesModel)
function eachAfter(e, t, i) {
  for (var r, n = [e], a = []; (r = n.pop()); )
    if ((a.push(r), r.isExpand)) {
      var o = r.children
      if (o.length) for (var s = 0; s < o.length; s++) n.push(o[s])
    }
  for (; (r = a.pop()); ) t(r, i)
}
function eachBefore(e, t) {
  for (var i, r = [e]; (i = r.pop()); )
    if ((t(i), i.isExpand)) {
      var n = i.children
      if (n.length) for (var a = n.length - 1; a >= 0; a--) r.push(n[a])
    }
}
function treeLayout(e, t) {
  e.eachSeriesByType('tree', function (e) {
    commonLayout(e, t)
  })
}
function commonLayout(e, t) {
  var i = getViewRect$4(e, t)
  e.layoutInfo = i
  var r = e.get('layout'),
    n = 0,
    a = 0,
    o = null
  'radial' === r
    ? ((n = 2 * Math.PI),
      (a = Math.min(i.height, i.width) / 2),
      (o = separation(function (e, t) {
        return (e.parentNode === t.parentNode ? 1 : 2) / e.depth
      })))
    : ((n = i.width), (a = i.height), (o = separation()))
  var s = e.getData().tree.root,
    l = s.children[0]
  if (l) {
    init(s),
      eachAfter(l, firstWalk, o),
      (s.hierNode.modifier = -l.hierNode.prelim),
      eachBefore(l, secondWalk)
    var h = l,
      u = l,
      p = l
    eachBefore(l, function (e) {
      var t = e.getLayout().x
      t < h.getLayout().x && (h = e), t > u.getLayout().x && (u = e), e.depth > p.depth && (p = e)
    })
    var c = h === u ? 1 : o(h, u) / 2,
      d = c - h.getLayout().x,
      f = 0,
      m = 0,
      g = 0,
      y = 0
    if ('radial' === r)
      (f = n / (u.getLayout().x + c + d)),
        (m = a / (p.depth - 1 || 1)),
        eachBefore(l, function (e) {
          ;(g = (e.getLayout().x + d) * f), (y = (e.depth - 1) * m)
          var t = radialCoordinate(g, y)
          e.setLayout({ x: t.x, y: t.y, rawX: g, rawY: y }, !0)
        })
    else {
      var v = e.getOrient()
      'RL' === v || 'LR' === v
        ? ((m = a / (u.getLayout().x + c + d)),
          (f = n / (p.depth - 1 || 1)),
          eachBefore(l, function (e) {
            ;(y = (e.getLayout().x + d) * m),
              (g = 'LR' === v ? (e.depth - 1) * f : n - (e.depth - 1) * f),
              e.setLayout({ x: g, y: y }, !0)
          }))
        : ('TB' !== v && 'BT' !== v) ||
          ((f = n / (u.getLayout().x + c + d)),
          (m = a / (p.depth - 1 || 1)),
          eachBefore(l, function (e) {
            ;(g = (e.getLayout().x + d) * f),
              (y = 'TB' === v ? (e.depth - 1) * m : a - (e.depth - 1) * m),
              e.setLayout({ x: g, y: y }, !0)
          }))
    }
  }
}
function treeVisual(e) {
  e.eachSeriesByType('tree', function (e) {
    var t = e.getData()
    t.tree.eachNode(function (e) {
      var i = e.getModel().getModel('itemStyle').getItemStyle()
      extend$3(t.ensureUniqueItemVisual(e.dataIndex, 'style'), i)
    })
  })
}
function installTreeAction(e) {
  e.registerAction(
    { type: 'treeExpandAndCollapse', event: 'treeExpandAndCollapse', update: 'update' },
    function (e, t) {
      t.eachComponent({ mainType: 'series', subType: 'tree', query: e }, function (t) {
        var i = e.dataIndex,
          r = t.getData().tree.getNodeByDataIndex(i)
        r.isExpand = !r.isExpand
      })
    }
  ),
    e.registerAction({ type: 'treeRoam', event: 'treeRoam', update: 'none' }, function (e, t) {
      t.eachComponent({ mainType: 'series', subType: 'tree', query: e }, function (t) {
        var i = updateCenterAndZoom(t.coordinateSystem, e)
        t.setCenter && t.setCenter(i.center), t.setZoom && t.setZoom(i.zoom)
      })
    })
}
function install$H(e) {
  e.registerChartView(TreeView),
    e.registerSeriesModel(TreeSeriesModel),
    e.registerLayout(treeLayout),
    e.registerVisual(treeVisual),
    installTreeAction(e)
}
var noop = function () {},
  actionTypes = ['treemapZoomToNode', 'treemapRender', 'treemapMove']
function installTreemapAction(e) {
  for (var t = 0; t < actionTypes.length; t++)
    e.registerAction({ type: actionTypes[t], update: 'updateView' }, noop)
  e.registerAction({ type: 'treemapRootToNode', update: 'updateView' }, function (e, t) {
    t.eachComponent({ mainType: 'series', subType: 'treemap', query: e }, function (t, i) {
      var r = retrieveTargetInfo(e, ['treemapZoomToNode', 'treemapRootToNode'], t)
      if (r) {
        var n = t.getViewRoot()
        n && (e.direction = aboveViewRoot(n, r.node) ? 'rollUp' : 'drillDown'),
          t.resetViewRoot(r.node)
      }
    })
  })
}
function enableAriaDecalForTree(e) {
  var t = e.getData().tree,
    i = {}
  t.eachNode(function (t) {
    for (var r = t; r && r.depth > 1; ) r = r.parentNode
    var n = getDecalFromPalette(e.ecModel, r.name || r.dataIndex + '', i)
    t.setVisual('decal', n)
  })
}
var TreemapSeriesModel = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), (i.preventUsingHoverLayer = !0), i
  }
  return (
    __extends(t, e),
    (t.prototype.getInitialData = function (e, t) {
      var i = { name: e.name, children: e.data }
      completeTreeValue$1(i)
      var r = e.levels || [],
        n = (this.designatedVisualItemStyle = {}),
        a = new Model({ itemStyle: n }, this, t),
        o = map$1(
          (r = e.levels = setDefault(r, t)) || [],
          function (e) {
            return new Model(e, a, t)
          },
          this
        ),
        s = Tree.createTree(i, this, function (e) {
          e.wrapMethod('getItemModel', function (e, t) {
            var i = s.getNodeByDataIndex(t),
              r = i ? o[i.depth] : null
            return (e.parentModel = r || a), e
          })
        })
      return s.data
    }),
    (t.prototype.optionUpdated = function () {
      this.resetViewRoot()
    }),
    (t.prototype.formatTooltip = function (e, t, i) {
      var r = this.getData(),
        n = this.getRawValue(e)
      return createTooltipMarkup('nameValue', { name: r.getName(e), value: n })
    }),
    (t.prototype.getDataParams = function (t) {
      var i = e.prototype.getDataParams.apply(this, arguments),
        r = this.getData().tree.getNodeByDataIndex(t)
      return (i.treePathInfo = wrapTreePathInfo(r, this)), i
    }),
    (t.prototype.setLayoutInfo = function (e) {
      ;(this.layoutInfo = this.layoutInfo || {}), extend$3(this.layoutInfo, e)
    }),
    (t.prototype.mapIdToIndex = function (e) {
      var t = this._idIndexMap
      t || ((t = this._idIndexMap = createHashMap()), (this._idIndexMapCount = 0))
      var i = t.get(e)
      return null == i && t.set(e, (i = this._idIndexMapCount++)), i
    }),
    (t.prototype.getViewRoot = function () {
      return this._viewRoot
    }),
    (t.prototype.resetViewRoot = function (e) {
      e ? (this._viewRoot = e) : (e = this._viewRoot)
      var t = this.getRawData().tree.root
      ;(e && (e === t || t.contains(e))) || (this._viewRoot = t)
    }),
    (t.prototype.enableAriaDecal = function () {
      enableAriaDecalForTree(this)
    }),
    (t.type = 'series.treemap'),
    (t.layoutMode = 'box'),
    (t.defaultOption = {
      progressive: 0,
      left: 'center',
      top: 'middle',
      width: '80%',
      height: '80%',
      sort: !0,
      clipWindow: 'origin',
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: '',
      zoomToNodeRatio: 0.1024,
      roam: !0,
      nodeClick: 'zoomToNode',
      animation: !0,
      animationDurationUpdate: 900,
      animationEasing: 'quinticInOut',
      breadcrumb: {
        show: !0,
        height: 22,
        left: 'center',
        top: 'bottom',
        emptyItemWidth: 25,
        itemStyle: { color: 'rgba(0,0,0,0.7)', textStyle: { color: '#fff' } }
      },
      label: {
        show: !0,
        distance: 0,
        padding: 5,
        position: 'inside',
        color: '#fff',
        overflow: 'truncate'
      },
      upperLabel: {
        show: !1,
        position: [0, '50%'],
        height: 20,
        overflow: 'truncate',
        verticalAlign: 'middle'
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: '#fff',
        borderColorSaturation: null
      },
      emphasis: {
        upperLabel: { show: !0, position: [0, '50%'], ellipsis: !0, verticalAlign: 'middle' }
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: 'index',
      visibleMin: 10,
      childrenVisibleMin: null,
      levels: []
    }),
    t
  )
})(SeriesModel)
function completeTreeValue$1(e) {
  var t = 0
  each$i(e.children, function (e) {
    completeTreeValue$1(e)
    var i = e.value
    isArray$1(i) && (i = i[0]), (t += i)
  })
  var i = e.value
  isArray$1(i) && (i = i[0]),
    (null == i || isNaN(i)) && (i = t),
    i < 0 && (i = 0),
    isArray$1(e.value) ? (e.value[0] = i) : (e.value = i)
}
function setDefault(e, t) {
  var i = normalizeToArray(t.get('color')),
    r = normalizeToArray(t.get(['aria', 'decal', 'decals']))
  if (i) {
    var n, a
    each$i((e = e || []), function (e) {
      var t = new Model(e),
        i = t.get('color'),
        r = t.get('decal')
      ;(t.get(['itemStyle', 'color']) || (i && 'none' !== i)) && (n = !0),
        (t.get(['itemStyle', 'decal']) || (r && 'none' !== r)) && (a = !0)
    })
    var o = e[0] || (e[0] = {})
    return n || (o.color = i.slice()), !a && r && (o.decal = r.slice()), e
  }
}
var TEXT_PADDING = 8,
  ITEM_GAP = 8,
  ARRAY_LENGTH = 5,
  Breadcrumb = (function () {
    function e(e) {
      ;(this.group = new Group$3()), e.add(this.group)
    }
    return (
      (e.prototype.render = function (e, t, i, r) {
        var n = e.getModel('breadcrumb'),
          a = this.group
        if ((a.removeAll(), n.get('show') && i)) {
          var o = n.getModel('itemStyle'),
            s = o.getModel('textStyle'),
            l = {
              pos: {
                left: n.get('left'),
                right: n.get('right'),
                top: n.get('top'),
                bottom: n.get('bottom')
              },
              box: { width: t.getWidth(), height: t.getHeight() },
              emptyItemWidth: n.get('emptyItemWidth'),
              totalWidth: 0,
              renderList: []
            }
          this._prepare(i, l, s),
            this._renderContent(e, l, o, s, r),
            positionElement(a, l.pos, l.box)
        }
      }),
      (e.prototype._prepare = function (e, t, i) {
        for (var r = e; r; r = r.parentNode) {
          var n = convertOptionIdName(r.getModel().get('name'), ''),
            a = i.getTextRect(n),
            o = Math.max(a.width + 2 * TEXT_PADDING, t.emptyItemWidth)
          ;(t.totalWidth += o + ITEM_GAP), t.renderList.push({ node: r, text: n, width: o })
        }
      }),
      (e.prototype._renderContent = function (e, t, i, r, n) {
        for (
          var a = 0,
            o = t.emptyItemWidth,
            s = e.get(['breadcrumb', 'height']),
            l = getAvailableSize(t.pos, t.box),
            h = t.totalWidth,
            u = t.renderList,
            p = u.length - 1;
          p >= 0;
          p--
        ) {
          var c = u[p],
            d = c.node,
            f = c.width,
            m = c.text
          h > l.width && ((h -= f - o), (f = o), (m = null))
          var g = new Polygon({
            shape: { points: makeItemPoints(a, 0, f, s, p === u.length - 1, 0 === p) },
            style: defaults$1(i.getItemStyle(), { lineJoin: 'bevel' }),
            textContent: new ZRText({
              style: { text: m, fill: r.getTextColor(), font: r.getFont() }
            }),
            textConfig: { position: 'inside' },
            z2: 1e4 * Z2_EMPHASIS_LIFT,
            onclick: curry$1(n, d)
          })
          ;(g.disableLabelAnimation = !0),
            this.group.add(g),
            packEventData(g, e, d),
            (a += f + ITEM_GAP)
        }
      }),
      (e.prototype.remove = function () {
        this.group.removeAll()
      }),
      e
    )
  })()
function makeItemPoints(e, t, i, r, n, a) {
  var o = [
    [n ? e : e - ARRAY_LENGTH, t],
    [e + i, t],
    [e + i, t + r],
    [n ? e : e - ARRAY_LENGTH, t + r]
  ]
  return !a && o.splice(2, 0, [e + i + ARRAY_LENGTH, t + r / 2]), !n && o.push([e, t + r / 2]), o
}
function packEventData(e, t, i) {
  getECData(e).eventData = {
    componentType: 'series',
    componentSubType: 'treemap',
    componentIndex: t.componentIndex,
    seriesIndex: t.componentIndex,
    seriesName: t.name,
    seriesType: 'treemap',
    selfType: 'breadcrumb',
    nodeData: { dataIndex: i && i.dataIndex, name: i && i.name },
    treePathInfo: i && wrapTreePathInfo(i, t)
  }
}
var AnimationWrap = (function () {
  function e() {
    ;(this._storage = []), (this._elExistsMap = {})
  }
  return (
    (e.prototype.add = function (e, t, i, r, n) {
      return (
        !this._elExistsMap[e.id] &&
        ((this._elExistsMap[e.id] = !0),
        this._storage.push({ el: e, target: t, duration: i, delay: r, easing: n }),
        !0)
      )
    }),
    (e.prototype.finished = function (e) {
      return (this._finishedCallback = e), this
    }),
    (e.prototype.start = function () {
      for (
        var e = this,
          t = this._storage.length,
          i = function () {
            --t <= 0 &&
              ((e._storage.length = 0),
              (e._elExistsMap = {}),
              e._finishedCallback && e._finishedCallback())
          },
          r = 0,
          n = this._storage.length;
        r < n;
        r++
      ) {
        var a = this._storage[r]
        a.el.animateTo(a.target, {
          duration: a.duration,
          delay: a.delay,
          easing: a.easing,
          setToFinal: !0,
          done: i,
          aborted: i
        })
      }
      return this
    }),
    e
  )
})()
function createWrap() {
  return new AnimationWrap()
}
var Group$2 = Group$3,
  Rect$1 = Rect$2,
  DRAG_THRESHOLD = 3,
  PATH_LABEL_NOAMAL = 'label',
  PATH_UPPERLABEL_NORMAL = 'upperLabel',
  Z2_BASE = 10 * Z2_EMPHASIS_LIFT,
  Z2_BG = 2 * Z2_EMPHASIS_LIFT,
  Z2_CONTENT = 3 * Z2_EMPHASIS_LIFT,
  getStateItemStyle = makeStyleMapper([
    ['fill', 'color'],
    ['stroke', 'strokeColor'],
    ['lineWidth', 'strokeWidth'],
    ['shadowBlur'],
    ['shadowOffsetX'],
    ['shadowOffsetY'],
    ['shadowColor']
  ]),
  getItemStyleNormal = function (e) {
    var t = getStateItemStyle(e)
    return (t.stroke = t.fill = t.lineWidth = null), t
  },
  inner$e = makeInner(),
  TreemapView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i._state = 'ready'), (i._storage = createStorage()), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i, r) {
        if (
          !(
            indexOf$1(t.findComponents({ mainType: 'series', subType: 'treemap', query: r }), e) < 0
          )
        ) {
          ;(this.seriesModel = e), (this.api = i), (this.ecModel = t)
          var n = retrieveTargetInfo(r, ['treemapZoomToNode', 'treemapRootToNode'], e),
            a = r && r.type,
            o = e.layoutInfo,
            s = !this._oldTree,
            l = this._storage,
            h =
              'treemapRootToNode' === a && n && l
                ? { rootNodeGroup: l.nodeGroup[n.node.getRawIndex()], direction: r.direction }
                : null,
            u = this._giveContainerGroup(o),
            p = this._doRender(u, e, h)
          s || (a && 'treemapZoomToNode' !== a && 'treemapRootToNode' !== a)
            ? p.renderFinally()
            : this._doAnimation(u, p, e, h),
            this._resetController(i),
            this._renderBreadcrumb(e, i, n)
        }
      }),
      (t.prototype._giveContainerGroup = function (e) {
        var t = this._containerGroup
        return (
          t || ((t = this._containerGroup = new Group$2()), this._initEvents(t), this.group.add(t)),
          (t.x = e.x),
          (t.y = e.y),
          t
        )
      }),
      (t.prototype._doRender = function (e, t, i) {
        var r = t.getData().tree,
          n = this._oldTree,
          a = createStorage(),
          o = createStorage(),
          s = this._storage,
          l = []
        !(function e(r, n, h, u, p) {
          u
            ? ((n = r),
              each$i(r, function (e, t) {
                !e.isRemoved() && d(t, t)
              }))
            : new DataDiffer(n, r, c, c).add(d).update(d).remove(curry$1(d, null)).execute()
          function c(e) {
            return e.getId()
          }
          function d(c, d) {
            var f = null != c ? r[c] : null,
              m = null != d ? n[d] : null,
              g = (function (e, r, n, h) {
                return renderNode(t, o, s, i, a, l, e, r, n, h)
              })(f, m, h, p)
            g && e((f && f.viewChildren) || [], (m && m.viewChildren) || [], g, u, p + 1)
          }
        })(r.root ? [r.root] : [], n && n.root ? [n.root] : [], e, r === n || !n, 0)
        var h,
          u,
          p =
            ((h = s),
            (u = createStorage()),
            h &&
              each$i(h, function (e, t) {
                var i = u[t]
                each$i(e, function (e) {
                  e && (i.push(e), (inner$e(e).willDelete = !0))
                })
              }),
            u)
        return (
          (this._oldTree = r),
          (this._storage = o),
          {
            lastsForAnimation: a,
            willDeleteEls: p,
            renderFinally: function () {
              each$i(p, function (e) {
                each$i(e, function (e) {
                  e.parent && e.parent.remove(e)
                })
              }),
                each$i(l, function (e) {
                  ;(e.invisible = !0), e.dirty()
                })
            }
          }
        )
      }),
      (t.prototype._doAnimation = function (e, t, i, r) {
        if (i.get('animation')) {
          var n = i.get('animationDurationUpdate'),
            a = i.get('animationEasing'),
            o = (isFunction$1(n) ? 0 : n) || 0,
            s = (isFunction$1(a) ? null : a) || 'cubicOut',
            l = createWrap()
          each$i(t.willDeleteEls, function (e, t) {
            each$i(e, function (e, i) {
              if (!e.invisible) {
                var n,
                  a = e.parent,
                  h = inner$e(a)
                if (r && 'drillDown' === r.direction)
                  n =
                    a === r.rootNodeGroup
                      ? {
                          shape: { x: 0, y: 0, width: h.nodeWidth, height: h.nodeHeight },
                          style: { opacity: 0 }
                        }
                      : { style: { opacity: 0 } }
                else {
                  var u = 0,
                    p = 0
                  h.willDelete || ((u = h.nodeWidth / 2), (p = h.nodeHeight / 2)),
                    (n =
                      'nodeGroup' === t
                        ? { x: u, y: p, style: { opacity: 0 } }
                        : { shape: { x: u, y: p, width: 0, height: 0 }, style: { opacity: 0 } })
                }
                n && l.add(e, n, o, 0, s)
              }
            })
          }),
            each$i(
              this._storage,
              function (e, i) {
                each$i(e, function (e, r) {
                  var n = t.lastsForAnimation[i][r],
                    a = {}
                  n &&
                    (e instanceof Group$3
                      ? null != n.oldX && ((a.x = e.x), (a.y = e.y), (e.x = n.oldX), (e.y = n.oldY))
                      : (n.oldShape && ((a.shape = extend$3({}, e.shape)), e.setShape(n.oldShape)),
                        n.fadein
                          ? (e.setStyle('opacity', 0), (a.style = { opacity: 1 }))
                          : 1 !== e.style.opacity && (a.style = { opacity: 1 })),
                    l.add(e, a, o, 0, s))
                })
              },
              this
            ),
            (this._state = 'animating'),
            l
              .finished(
                bind$2(function () {
                  ;(this._state = 'ready'), t.renderFinally()
                }, this)
              )
              .start()
        }
      }),
      (t.prototype._resetController = function (e) {
        var t = this._controller
        t ||
          ((t = this._controller = new RoamController(e.getZr())).enable(
            this.seriesModel.get('roam')
          ),
          t.on('pan', bind$2(this._onPan, this)),
          t.on('zoom', bind$2(this._onZoom, this)))
        var i = new BoundingRect(0, 0, e.getWidth(), e.getHeight())
        t.setPointerChecker(function (e, t, r) {
          return i.contain(t, r)
        })
      }),
      (t.prototype._clearController = function () {
        var e = this._controller
        e && (e.dispose(), (e = null))
      }),
      (t.prototype._onPan = function (e) {
        if (
          'animating' !== this._state &&
          (Math.abs(e.dx) > DRAG_THRESHOLD || Math.abs(e.dy) > DRAG_THRESHOLD)
        ) {
          var t = this.seriesModel.getData().tree.root
          if (!t) return
          var i = t.getLayout()
          if (!i) return
          this.api.dispatchAction({
            type: 'treemapMove',
            from: this.uid,
            seriesId: this.seriesModel.id,
            rootRect: { x: i.x + e.dx, y: i.y + e.dy, width: i.width, height: i.height }
          })
        }
      }),
      (t.prototype._onZoom = function (e) {
        var t = e.originX,
          i = e.originY
        if ('animating' !== this._state) {
          var r = this.seriesModel.getData().tree.root
          if (!r) return
          var n = r.getLayout()
          if (!n) return
          var a = new BoundingRect(n.x, n.y, n.width, n.height),
            o = this.seriesModel.layoutInfo
          ;(t -= o.x), (i -= o.y)
          var s = create$1()
          translate$1(s, s, [-t, -i]),
            scale$1(s, s, [e.scale, e.scale]),
            translate$1(s, s, [t, i]),
            a.applyTransform(s),
            this.api.dispatchAction({
              type: 'treemapRender',
              from: this.uid,
              seriesId: this.seriesModel.id,
              rootRect: { x: a.x, y: a.y, width: a.width, height: a.height }
            })
        }
      }),
      (t.prototype._initEvents = function (e) {
        var t = this
        e.on(
          'click',
          function (e) {
            if ('ready' === t._state) {
              var i = t.seriesModel.get('nodeClick', !0)
              if (i) {
                var r = t.findTarget(e.offsetX, e.offsetY)
                if (r) {
                  var n = r.node
                  if (n.getLayout().isLeafRoot) t._rootToNode(r)
                  else if ('zoomToNode' === i) t._zoomToNode(r)
                  else if ('link' === i) {
                    var a = n.hostTree.data.getItemModel(n.dataIndex),
                      o = a.get('link', !0),
                      s = a.get('target', !0) || 'blank'
                    o && windowOpen(o, s)
                  }
                }
              }
            }
          },
          this
        )
      }),
      (t.prototype._renderBreadcrumb = function (e, t, i) {
        var r = this
        i ||
          (i =
            null != e.get('leafDepth', !0)
              ? { node: e.getViewRoot() }
              : this.findTarget(t.getWidth() / 2, t.getHeight() / 2)) ||
          (i = { node: e.getData().tree.root }),
          (this._breadcrumb || (this._breadcrumb = new Breadcrumb(this.group))).render(
            e,
            t,
            i.node,
            function (t) {
              'animating' !== r._state &&
                (aboveViewRoot(e.getViewRoot(), t)
                  ? r._rootToNode({ node: t })
                  : r._zoomToNode({ node: t }))
            }
          )
      }),
      (t.prototype.remove = function () {
        this._clearController(),
          this._containerGroup && this._containerGroup.removeAll(),
          (this._storage = createStorage()),
          (this._state = 'ready'),
          this._breadcrumb && this._breadcrumb.remove()
      }),
      (t.prototype.dispose = function () {
        this._clearController()
      }),
      (t.prototype._zoomToNode = function (e) {
        this.api.dispatchAction({
          type: 'treemapZoomToNode',
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: e.node
        })
      }),
      (t.prototype._rootToNode = function (e) {
        this.api.dispatchAction({
          type: 'treemapRootToNode',
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: e.node
        })
      }),
      (t.prototype.findTarget = function (e, t) {
        var i
        return (
          this.seriesModel.getViewRoot().eachNode(
            { attr: 'viewChildren', order: 'preorder' },
            function (r) {
              var n = this._storage.background[r.getRawIndex()]
              if (n) {
                var a = n.transformCoordToLocal(e, t),
                  o = n.shape
                if (
                  !(o.x <= a[0] && a[0] <= o.x + o.width && o.y <= a[1] && a[1] <= o.y + o.height)
                )
                  return !1
                i = { node: r, offsetX: a[0], offsetY: a[1] }
              }
            },
            this
          ),
          i
        )
      }),
      (t.type = 'treemap'),
      t
    )
  })(ChartView)
function createStorage() {
  return { nodeGroup: [], background: [], content: [] }
}
function renderNode(e, t, i, r, n, a, o, s, l, h) {
  if (o) {
    var u = o.getLayout(),
      p = e.getData(),
      c = o.getModel()
    if ((p.setItemGraphicEl(o.dataIndex, null), u && u.isInView)) {
      var d = u.width,
        f = u.height,
        m = u.borderWidth,
        g = u.invisible,
        y = o.getRawIndex(),
        v = s && s.getRawIndex(),
        _ = o.viewChildren,
        x = u.upperHeight,
        S = _ && _.length,
        b = c.getModel('itemStyle'),
        T = c.getModel(['emphasis', 'itemStyle']),
        A = c.getModel(['blur', 'itemStyle']),
        w = c.getModel(['select', 'itemStyle']),
        M = b.get('borderRadius') || 0,
        C = $('nodeGroup', Group$2)
      if (C) {
        if (
          (l.add(C),
          (C.x = u.x || 0),
          (C.y = u.y || 0),
          C.markRedraw(),
          (inner$e(C).nodeWidth = d),
          (inner$e(C).nodeHeight = f),
          u.isAboveViewRoot)
        )
          return C
        var P = $('background', Rect$1, h, Z2_BG)
        P &&
          (function (t, i, r) {
            var n = getECData(i)
            if (
              ((n.dataIndex = o.dataIndex),
              (n.seriesIndex = e.seriesIndex),
              i.setShape({ x: 0, y: 0, width: d, height: f, r: M }),
              g)
            )
              R(i)
            else {
              i.invisible = !1
              var a = o.getVisual('style'),
                s = a.stroke,
                l = getItemStyleNormal(b)
              l.fill = s
              var h = getStateItemStyle(T)
              h.fill = T.get('borderColor')
              var u = getStateItemStyle(A)
              u.fill = A.get('borderColor')
              var p = getStateItemStyle(w)
              if (((p.fill = w.get('borderColor')), r)) {
                var c = d - 2 * m
                O(i, s, a.opacity, { x: m, y: 0, width: c, height: x })
              } else i.removeTextContent()
              i.setStyle(l),
                (i.ensureState('emphasis').style = h),
                (i.ensureState('blur').style = u),
                (i.ensureState('select').style = p),
                setDefaultStateProxy(i)
            }
            t.add(i)
          })(C, P, S && u.upperLabelHeight)
        var E = c.get(['emphasis', 'focus']),
          I = c.get(['emphasis', 'blurScope']),
          D =
            'ancestor' === E
              ? o.getAncestorsIndices()
              : 'descendant' === E
              ? o.getDescendantIndices()
              : E
        if (S)
          isHighDownDispatcher(C) && setAsHighDownDispatcher(C, !1),
            P &&
              (setAsHighDownDispatcher(P, !0),
              p.setItemGraphicEl(o.dataIndex, P),
              enableHoverFocus(P, D, I))
        else {
          var L = $('content', Rect$1, h, Z2_CONTENT)
          L &&
            (function (t, i) {
              var r = getECData(i)
              ;(r.dataIndex = o.dataIndex), (r.seriesIndex = e.seriesIndex)
              var n = Math.max(d - 2 * m, 0),
                a = Math.max(f - 2 * m, 0)
              if (((i.culling = !0), i.setShape({ x: m, y: m, width: n, height: a, r: M }), g)) R(i)
              else {
                i.invisible = !1
                var s = o.getVisual('style'),
                  l = s.fill,
                  h = getItemStyleNormal(b)
                ;(h.fill = l), (h.decal = s.decal)
                var u = getStateItemStyle(T),
                  p = getStateItemStyle(A),
                  c = getStateItemStyle(w)
                O(i, l, s.opacity, null),
                  i.setStyle(h),
                  (i.ensureState('emphasis').style = u),
                  (i.ensureState('blur').style = p),
                  (i.ensureState('select').style = c),
                  setDefaultStateProxy(i)
              }
              t.add(i)
            })(C, L),
            P && isHighDownDispatcher(P) && setAsHighDownDispatcher(P, !1),
            setAsHighDownDispatcher(C, !0),
            p.setItemGraphicEl(o.dataIndex, C),
            enableHoverFocus(C, D, I)
        }
        return C
      }
    }
  }
  function R(e) {
    !e.invisible && a.push(e)
  }
  function O(t, i, r, n) {
    var a = c.getModel(n ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL),
      s = convertOptionIdName(c.get('name'), null),
      l = a.getShallow('show')
    setLabelStyle(t, getLabelStatesModels(c, n ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), {
      defaultText: l ? s : null,
      inheritColor: i,
      defaultOpacity: r,
      labelFetcher: e,
      labelDataIndex: o.dataIndex
    })
    var h = t.getTextContent(),
      p = h.style,
      d = normalizeCssArray$1(p.padding || 0)
    n && (t.setTextConfig({ layoutRect: n }), (h.disableLabelLayout = !0)),
      (h.beforeUpdate = function () {
        var e = Math.max((n ? n.width : t.shape.width) - d[1] - d[3], 0),
          i = Math.max((n ? n.height : t.shape.height) - d[0] - d[2], 0)
        ;(p.width === e && p.height === i) || h.setStyle({ width: e, height: i })
      }),
      (p.truncateMinChar = 2),
      (p.lineOverflow = 'truncate'),
      k(p, n, u)
    var f = h.getState('emphasis')
    k(f ? f.style : null, n, u)
  }
  function k(t, i, r) {
    var n = t ? t.text : null
    if (!i && r.isLeafRoot && null != n) {
      var a = e.get('drillDownIcon', !0)
      t.text = a ? a + ' ' + n : n
    }
  }
  function $(e, a, s, l) {
    var h = null != v && i[e][v],
      u = n[e]
    return (
      h
        ? ((i[e][v] = null),
          (function (e, t) {
            var i = (e[y] = {})
            t instanceof Group$2
              ? ((i.oldX = t.x), (i.oldY = t.y))
              : (i.oldShape = extend$3({}, t.shape))
          })(u, h))
        : g ||
          ((h = new a()) instanceof Displayable && (h.z2 = calculateZ2(s, l)),
          (function (e, t) {
            var i = (e[y] = {}),
              a = o.parentNode,
              s = t instanceof Group$3
            if (a && (!r || 'drillDown' === r.direction)) {
              var l = 0,
                h = 0,
                u = n.background[a.getRawIndex()]
              !r && u && u.oldShape && ((l = u.oldShape.width), (h = u.oldShape.height)),
                s
                  ? ((i.oldX = 0), (i.oldY = h))
                  : (i.oldShape = { x: l, y: h, width: 0, height: 0 })
            }
            i.fadein = !s
          })(u, h)),
      (t[e][y] = h)
    )
  }
}
function calculateZ2(e, t) {
  return e * Z2_BASE + t
}
var each$e = each$i,
  isObject$3 = isObject$7,
  CATEGORY_DEFAULT_VISUAL_INDEX = -1,
  VisualMapping = (function () {
    function e(t) {
      var i = t.mappingMethod,
        r = t.type,
        n = (this.option = clone$3(t))
      ;(this.type = r), (this.mappingMethod = i), (this._normalizeData = normalizers[i])
      var a = e.visualHandlers[r]
      ;(this.applyVisual = a.applyVisual),
        (this.getColorMapper = a.getColorMapper),
        (this._normalizedToVisual = a._normalizedToVisual[i]),
        'piecewise' === i
          ? (normalizeVisualRange(n), preprocessForPiecewise(n))
          : 'category' === i
          ? n.categories
            ? preprocessForSpecifiedCategory(n)
            : normalizeVisualRange(n, !0)
          : (assert$1('linear' !== i || n.dataExtent), normalizeVisualRange(n))
    }
    return (
      (e.prototype.mapValueToVisual = function (e) {
        var t = this._normalizeData(e)
        return this._normalizedToVisual(t, e)
      }),
      (e.prototype.getNormalizer = function () {
        return bind$2(this._normalizeData, this)
      }),
      (e.listVisualTypes = function () {
        return keys(e.visualHandlers)
      }),
      (e.isValidType = function (t) {
        return e.visualHandlers.hasOwnProperty(t)
      }),
      (e.eachVisual = function (e, t, i) {
        isObject$7(e) ? each$i(e, t, i) : t.call(i, e)
      }),
      (e.mapVisual = function (t, i, r) {
        var n,
          a = isArray$1(t) ? [] : isObject$7(t) ? {} : ((n = !0), null)
        return (
          e.eachVisual(t, function (e, t) {
            var o = i.call(r, e, t)
            n ? (a = o) : (a[t] = o)
          }),
          a
        )
      }),
      (e.retrieveVisuals = function (t) {
        var i,
          r = {}
        return (
          t &&
            each$e(e.visualHandlers, function (e, n) {
              t.hasOwnProperty(n) && ((r[n] = t[n]), (i = !0))
            }),
          i ? r : null
        )
      }),
      (e.prepareVisualTypes = function (e) {
        if (isArray$1(e)) e = e.slice()
        else {
          if (!isObject$3(e)) return []
          var t = []
          each$e(e, function (e, i) {
            t.push(i)
          }),
            (e = t)
        }
        return (
          e.sort(function (e, t) {
            return 'color' === t && 'color' !== e && 0 === e.indexOf('color') ? 1 : -1
          }),
          e
        )
      }),
      (e.dependsOn = function (e, t) {
        return 'color' === t ? !(!e || 0 !== e.indexOf(t)) : e === t
      }),
      (e.findPieceIndex = function (e, t, i) {
        for (var r, n = 1 / 0, a = 0, o = t.length; a < o; a++) {
          var s = t[a].value
          if (null != s) {
            if (s === e || ('string' == typeof s && s === e + '')) return a
            i && p(s, a)
          }
        }
        for (a = 0, o = t.length; a < o; a++) {
          var l = t[a],
            h = l.interval,
            u = l.close
          if (h) {
            if (h[0] === -1 / 0) {
              if (littleThan(u[1], e, h[1])) return a
            } else if (h[1] === 1 / 0) {
              if (littleThan(u[0], h[0], e)) return a
            } else if (littleThan(u[0], h[0], e) && littleThan(u[1], e, h[1])) return a
            i && p(h[0], a), i && p(h[1], a)
          }
        }
        if (i) return e === 1 / 0 ? t.length - 1 : e === -1 / 0 ? 0 : r
        function p(t, i) {
          var a = Math.abs(t - e)
          a < n && ((n = a), (r = i))
        }
      }),
      (e.visualHandlers = {
        color: {
          applyVisual: makeApplyVisual('color'),
          getColorMapper: function () {
            var e = this.option
            return bind$2(
              'category' === e.mappingMethod
                ? function (e, t) {
                    return !t && (e = this._normalizeData(e)), doMapCategory.call(this, e)
                  }
                : function (t, i, r) {
                    var n = !!r
                    return (
                      !i && (t = this._normalizeData(t)),
                      (r = fastLerp(t, e.parsedVisual, r)),
                      n ? r : stringify(r, 'rgba')
                    )
                  },
              this
            )
          },
          _normalizedToVisual: {
            linear: function (e) {
              return stringify(fastLerp(e, this.option.parsedVisual), 'rgba')
            },
            category: doMapCategory,
            piecewise: function (e, t) {
              var i = getSpecifiedVisual.call(this, t)
              return null == i && (i = stringify(fastLerp(e, this.option.parsedVisual), 'rgba')), i
            },
            fixed: doMapFixed
          }
        },
        colorHue: makePartialColorVisualHandler(function (e, t) {
          return modifyHSL(e, t)
        }),
        colorSaturation: makePartialColorVisualHandler(function (e, t) {
          return modifyHSL(e, null, t)
        }),
        colorLightness: makePartialColorVisualHandler(function (e, t) {
          return modifyHSL(e, null, null, t)
        }),
        colorAlpha: makePartialColorVisualHandler(function (e, t) {
          return modifyAlpha(e, t)
        }),
        decal: {
          applyVisual: makeApplyVisual('decal'),
          _normalizedToVisual: {
            linear: null,
            category: doMapCategory,
            piecewise: null,
            fixed: null
          }
        },
        opacity: {
          applyVisual: makeApplyVisual('opacity'),
          _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
        },
        liftZ: {
          applyVisual: makeApplyVisual('liftZ'),
          _normalizedToVisual: {
            linear: doMapFixed,
            category: doMapFixed,
            piecewise: doMapFixed,
            fixed: doMapFixed
          }
        },
        symbol: {
          applyVisual: function (e, t, i) {
            i('symbol', this.mapValueToVisual(e))
          },
          _normalizedToVisual: {
            linear: doMapToArray,
            category: doMapCategory,
            piecewise: function (e, t) {
              var i = getSpecifiedVisual.call(this, t)
              return null == i && (i = doMapToArray.call(this, e)), i
            },
            fixed: doMapFixed
          }
        },
        symbolSize: {
          applyVisual: makeApplyVisual('symbolSize'),
          _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
        }
      }),
      e
    )
  })()
function preprocessForPiecewise(e) {
  var t = e.pieceList
  ;(e.hasSpecialVisual = !1),
    each$i(t, function (t, i) {
      ;(t.originIndex = i), null != t.visual && (e.hasSpecialVisual = !0)
    })
}
function preprocessForSpecifiedCategory(e) {
  var t = e.categories,
    i = (e.categoryMap = {}),
    r = e.visual
  if (
    (each$e(t, function (e, t) {
      i[e] = t
    }),
    !isArray$1(r))
  ) {
    var n = []
    isObject$7(r)
      ? each$e(r, function (e, t) {
          var r = i[t]
          n[null != r ? r : CATEGORY_DEFAULT_VISUAL_INDEX] = e
        })
      : (n[CATEGORY_DEFAULT_VISUAL_INDEX] = r),
      (r = setVisualToOption(e, n))
  }
  for (var a = t.length - 1; a >= 0; a--) null == r[a] && (delete i[t[a]], t.pop())
}
function normalizeVisualRange(e, t) {
  var i = e.visual,
    r = []
  isObject$7(i)
    ? each$e(i, function (e) {
        r.push(e)
      })
    : null != i && r.push(i)
  t || 1 !== r.length || { color: 1, symbol: 1 }.hasOwnProperty(e.type) || (r[1] = r[0]),
    setVisualToOption(e, r)
}
function makePartialColorVisualHandler(e) {
  return {
    applyVisual: function (t, i, r) {
      var n = this.mapValueToVisual(t)
      r('color', e(i('color'), n))
    },
    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
  }
}
function doMapToArray(e) {
  var t = this.option.visual
  return t[Math.round(linearMap$2(e, [0, 1], [0, t.length - 1], !0))] || {}
}
function makeApplyVisual(e) {
  return function (t, i, r) {
    r(e, this.mapValueToVisual(t))
  }
}
function doMapCategory(e) {
  var t = this.option.visual
  return t[this.option.loop && e !== CATEGORY_DEFAULT_VISUAL_INDEX ? e % t.length : e]
}
function doMapFixed() {
  return this.option.visual[0]
}
function createNormalizedToNumericVisual(e) {
  return {
    linear: function (t) {
      return linearMap$2(t, e, this.option.visual, !0)
    },
    category: doMapCategory,
    piecewise: function (t, i) {
      var r = getSpecifiedVisual.call(this, i)
      return null == r && (r = linearMap$2(t, e, this.option.visual, !0)), r
    },
    fixed: doMapFixed
  }
}
function getSpecifiedVisual(e) {
  var t = this.option,
    i = t.pieceList
  if (t.hasSpecialVisual) {
    var r = i[VisualMapping.findPieceIndex(e, i)]
    if (r && r.visual) return r.visual[this.type]
  }
}
function setVisualToOption(e, t) {
  return (
    (e.visual = t),
    'color' === e.type &&
      (e.parsedVisual = map$1(t, function (e) {
        return parse(e)
      })),
    t
  )
}
var normalizers = {
  linear: function (e) {
    return linearMap$2(e, this.option.dataExtent, [0, 1], !0)
  },
  piecewise: function (e) {
    var t = this.option.pieceList,
      i = VisualMapping.findPieceIndex(e, t, !0)
    if (null != i) return linearMap$2(i, [0, t.length - 1], [0, 1], !0)
  },
  category: function (e) {
    var t = this.option.categories ? this.option.categoryMap[e] : e
    return null == t ? CATEGORY_DEFAULT_VISUAL_INDEX : t
  },
  fixed: noop$1
}
function littleThan(e, t, i) {
  return e ? t <= i : t < i
}
var ITEM_STYLE_NORMAL = 'itemStyle',
  inner$d = makeInner(),
  treemapVisual = {
    seriesType: 'treemap',
    reset: function (e) {
      var t = e.getData().tree.root
      t.isRemoved() || travelTree(t, {}, e.getViewRoot().getAncestors(), e)
    }
  }
function travelTree(e, t, i, r) {
  var n = e.getModel(),
    a = e.getLayout(),
    o = e.hostTree.data
  if (a && !a.invisible && a.isInView) {
    var s,
      l = n.getModel(ITEM_STYLE_NORMAL),
      h = buildVisuals(l, t, r),
      u = o.ensureUniqueItemVisual(e.dataIndex, 'style'),
      p = l.get('borderColor'),
      c = l.get('borderColorSaturation')
    null != c && (p = calculateBorderColor(c, (s = calculateColor(h)))), (u.stroke = p)
    var d = e.viewChildren
    if (d && d.length) {
      var f = buildVisualMapping(e, n, a, l, h, d)
      each$i(d, function (e, t) {
        ;(e.depth >= i.length || e === i[e.depth]) &&
          travelTree(e, mapVisual$1(n, h, e, t, f, r), i, r)
      })
    } else (s = calculateColor(h)), (u.fill = s)
  }
}
function buildVisuals(e, t, i) {
  var r = extend$3({}, t),
    n = i.designatedVisualItemStyle
  return (
    each$i(['color', 'colorAlpha', 'colorSaturation'], function (i) {
      n[i] = t[i]
      var a = e.get(i)
      ;(n[i] = null), null != a && (r[i] = a)
    }),
    r
  )
}
function calculateColor(e) {
  var t = getValueVisualDefine(e, 'color')
  if (t) {
    var i = getValueVisualDefine(e, 'colorAlpha'),
      r = getValueVisualDefine(e, 'colorSaturation')
    return r && (t = modifyHSL(t, null, null, r)), i && (t = modifyAlpha(t, i)), t
  }
}
function calculateBorderColor(e, t) {
  return null != t ? modifyHSL(t, null, null, e) : null
}
function getValueVisualDefine(e, t) {
  var i = e[t]
  if (null != i && 'none' !== i) return i
}
function buildVisualMapping(e, t, i, r, n, a) {
  if (a && a.length) {
    var o =
      getRangeVisual(t, 'color') ||
      (null != n.color &&
        'none' !== n.color &&
        (getRangeVisual(t, 'colorAlpha') || getRangeVisual(t, 'colorSaturation')))
    if (o) {
      var s = t.get('visualMin'),
        l = t.get('visualMax'),
        h = i.dataExtent.slice()
      null != s && s < h[0] && (h[0] = s), null != l && l > h[1] && (h[1] = l)
      var u = t.get('colorMappingBy'),
        p = { type: o.name, dataExtent: h, visual: o.range }
      'color' !== p.type || ('index' !== u && 'id' !== u)
        ? (p.mappingMethod = 'linear')
        : ((p.mappingMethod = 'category'), (p.loop = !0))
      var c = new VisualMapping(p)
      return (inner$d(c).drColorMappingBy = u), c
    }
  }
}
function getRangeVisual(e, t) {
  var i = e.get(t)
  return isArray$1(i) && i.length ? { name: t, range: i } : null
}
function mapVisual$1(e, t, i, r, n, a) {
  var o = extend$3({}, t)
  if (n) {
    var s = n.type,
      l = 'color' === s && inner$d(n).drColorMappingBy,
      h =
        'index' === l
          ? r
          : 'id' === l
          ? a.mapIdToIndex(i.getId())
          : i.getValue(e.get('visualDimension'))
    o[s] = n.mapValueToVisual(h)
  }
  return o
}
var mathMax$3 = Math.max,
  mathMin$3 = Math.min,
  retrieveValue = retrieve,
  each$d = each$i,
  PATH_BORDER_WIDTH = ['itemStyle', 'borderWidth'],
  PATH_GAP_WIDTH = ['itemStyle', 'gapWidth'],
  PATH_UPPER_LABEL_SHOW = ['upperLabel', 'show'],
  PATH_UPPER_LABEL_HEIGHT = ['upperLabel', 'height'],
  treemapLayout = {
    seriesType: 'treemap',
    reset: function (e, t, i, r) {
      var n = i.getWidth(),
        a = i.getHeight(),
        o = e.option,
        s = getLayoutRect(e.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() }),
        l = o.size || [],
        h = parsePercent$1(retrieveValue(s.width, l[0]), n),
        u = parsePercent$1(retrieveValue(s.height, l[1]), a),
        p = r && r.type,
        c = retrieveTargetInfo(r, ['treemapZoomToNode', 'treemapRootToNode'], e),
        d = 'treemapRender' === p || 'treemapMove' === p ? r.rootRect : null,
        f = e.getViewRoot(),
        m = getPathToRoot(f)
      if ('treemapMove' !== p) {
        var g =
            'treemapZoomToNode' === p
              ? estimateRootSize(e, c, f, h, u)
              : d
              ? [d.width, d.height]
              : [h, u],
          y = o.sort
        y && 'asc' !== y && 'desc' !== y && (y = 'desc')
        var v = { squareRatio: o.squareRatio, sort: y, leafDepth: o.leafDepth }
        f.hostTree.clearLayouts()
        var _ = { x: 0, y: 0, width: g[0], height: g[1], area: g[0] * g[1] }
        f.setLayout(_),
          squarify(f, v, !1, 0),
          (_ = f.getLayout()),
          each$d(m, function (e, t) {
            var i = (m[t + 1] || f).getValue()
            e.setLayout(extend$3({ dataExtent: [i, i], borderWidth: 0, upperHeight: 0 }, _))
          })
      }
      var x = e.getData().tree.root
      x.setLayout(calculateRootPosition(s, d, c), !0),
        e.setLayoutInfo(s),
        prunning(x, new BoundingRect(-s.x, -s.y, n, a), m, f, 0)
    }
  }
function squarify(e, t, i, r) {
  var n, a
  if (!e.isRemoved()) {
    var o = e.getLayout()
    ;(n = o.width), (a = o.height)
    var s = e.getModel(),
      l = s.get(PATH_BORDER_WIDTH),
      h = s.get(PATH_GAP_WIDTH) / 2,
      u = getUpperLabelHeight(s),
      p = Math.max(l, u),
      c = l - h,
      d = p - h
    e.setLayout({ borderWidth: l, upperHeight: p, upperLabelHeight: u }, !0)
    var f = (n = mathMax$3(n - 2 * c, 0)) * (a = mathMax$3(a - c - d, 0)),
      m = initChildren$1(e, s, f, t, i, r)
    if (m.length) {
      var g = { x: c, y: d, width: n, height: a },
        y = mathMin$3(n, a),
        v = 1 / 0,
        _ = []
      _.area = 0
      for (var x = 0, S = m.length; x < S; ) {
        var b = m[x]
        _.push(b), (_.area += b.getLayout().area)
        var T = worst(_, y, t.squareRatio)
        T <= v
          ? (x++, (v = T))
          : ((_.area -= _.pop().getLayout().area),
            position(_, y, g, h, !1),
            (y = mathMin$3(g.width, g.height)),
            (_.length = _.area = 0),
            (v = 1 / 0))
      }
      if ((_.length && position(_, y, g, h, !0), !i)) {
        var A = s.get('childrenVisibleMin')
        null != A && f < A && (i = !0)
      }
      for (x = 0, S = m.length; x < S; x++) squarify(m[x], t, i, r + 1)
    }
  }
}
function initChildren$1(e, t, i, r, n, a) {
  var o = e.children || [],
    s = r.sort
  'asc' !== s && 'desc' !== s && (s = null)
  var l = null != r.leafDepth && r.leafDepth <= a
  if (n && !l) return (e.viewChildren = [])
  sort$1(
    (o = filter$1(o, function (e) {
      return !e.isRemoved()
    })),
    s
  )
  var h = statistic(t, o, s)
  if (0 === h.sum) return (e.viewChildren = [])
  if (((h.sum = filterByThreshold(t, i, h.sum, s, o)), 0 === h.sum)) return (e.viewChildren = [])
  for (var u = 0, p = o.length; u < p; u++) {
    var c = (o[u].getValue() / h.sum) * i
    o[u].setLayout({ area: c })
  }
  return (
    l && (o.length && e.setLayout({ isLeafRoot: !0 }, !0), (o.length = 0)),
    (e.viewChildren = o),
    e.setLayout({ dataExtent: h.dataExtent }, !0),
    o
  )
}
function filterByThreshold(e, t, i, r, n) {
  if (!r) return i
  for (var a = e.get('visibleMin'), o = n.length, s = o, l = o - 1; l >= 0; l--) {
    var h = n['asc' === r ? o - l - 1 : l].getValue()
    ;(h / i) * t < a && ((s = l), (i -= h))
  }
  return 'asc' === r ? n.splice(0, o - s) : n.splice(s, o - s), i
}
function sort$1(e, t) {
  return (
    t &&
      e.sort(function (e, i) {
        var r = 'asc' === t ? e.getValue() - i.getValue() : i.getValue() - e.getValue()
        return 0 === r ? ('asc' === t ? e.dataIndex - i.dataIndex : i.dataIndex - e.dataIndex) : r
      }),
    e
  )
}
function statistic(e, t, i) {
  for (var r = 0, n = 0, a = t.length; n < a; n++) r += t[n].getValue()
  var o,
    s = e.get('visualDimension')
  return (
    t && t.length
      ? 'value' === s && i
        ? ((o = [t[t.length - 1].getValue(), t[0].getValue()]), 'asc' === i && o.reverse())
        : ((o = [1 / 0, -1 / 0]),
          each$d(t, function (e) {
            var t = e.getValue(s)
            t < o[0] && (o[0] = t), t > o[1] && (o[1] = t)
          }))
      : (o = [NaN, NaN]),
    { sum: r, dataExtent: o }
  )
}
function worst(e, t, i) {
  for (var r = 0, n = 1 / 0, a = 0, o = void 0, s = e.length; a < s; a++)
    (o = e[a].getLayout().area) && (o < n && (n = o), o > r && (r = o))
  var l = e.area * e.area,
    h = t * t * i
  return l ? mathMax$3((h * r) / l, l / (h * n)) : 1 / 0
}
function position(e, t, i, r, n) {
  var a = t === i.width ? 0 : 1,
    o = 1 - a,
    s = ['x', 'y'],
    l = ['width', 'height'],
    h = i[s[a]],
    u = t ? e.area / t : 0
  ;(n || u > i[l[o]]) && (u = i[l[o]])
  for (var p = 0, c = e.length; p < c; p++) {
    var d = e[p],
      f = {},
      m = u ? d.getLayout().area / u : 0,
      g = (f[l[o]] = mathMax$3(u - 2 * r, 0)),
      y = i[s[a]] + i[l[a]] - h,
      v = p === c - 1 || y < m ? y : m,
      _ = (f[l[a]] = mathMax$3(v - 2 * r, 0))
    ;(f[s[o]] = i[s[o]] + mathMin$3(r, g / 2)),
      (f[s[a]] = h + mathMin$3(r, _ / 2)),
      (h += v),
      d.setLayout(f, !0)
  }
  ;(i[s[o]] += u), (i[l[o]] -= u)
}
function estimateRootSize(e, t, i, r, n) {
  var a,
    o = (t || {}).node,
    s = [r, n]
  if (!o || o === i) return s
  for (var l = r * n, h = l * e.option.zoomToNodeRatio; (a = o.parentNode); ) {
    for (var u = 0, p = a.children, c = 0, d = p.length; c < d; c++) u += p[c].getValue()
    var f = o.getValue()
    if (0 === f) return s
    h *= u / f
    var m = a.getModel(),
      g = m.get(PATH_BORDER_WIDTH)
    ;(h += 4 * g * g + (3 * g + Math.max(g, getUpperLabelHeight(m))) * Math.pow(h, 0.5)) >
      MAX_SAFE_INTEGER && (h = MAX_SAFE_INTEGER),
      (o = a)
  }
  h < l && (h = l)
  var y = Math.pow(h / l, 0.5)
  return [r * y, n * y]
}
function calculateRootPosition(e, t, i) {
  if (t) return { x: t.x, y: t.y }
  var r = { x: 0, y: 0 }
  if (!i) return r
  var n = i.node,
    a = n.getLayout()
  if (!a) return r
  for (var o = [a.width / 2, a.height / 2], s = n; s; ) {
    var l = s.getLayout()
    ;(o[0] += l.x), (o[1] += l.y), (s = s.parentNode)
  }
  return { x: e.width / 2 - o[0], y: e.height / 2 - o[1] }
}
function prunning(e, t, i, r, n) {
  var a = e.getLayout(),
    o = i[n],
    s = o && o === e
  if (!((o && !s) || (n === i.length && e !== r))) {
    e.setLayout({ isInView: !0, invisible: !s && !t.intersect(a), isAboveViewRoot: s }, !0)
    var l = new BoundingRect(t.x - a.x, t.y - a.y, t.width, t.height)
    each$d(e.viewChildren || [], function (e) {
      prunning(e, l, i, r, n + 1)
    })
  }
}
function getUpperLabelHeight(e) {
  return e.get(PATH_UPPER_LABEL_SHOW) ? e.get(PATH_UPPER_LABEL_HEIGHT) : 0
}
function install$G(e) {
  e.registerSeriesModel(TreemapSeriesModel),
    e.registerChartView(TreemapView),
    e.registerVisual(treemapVisual),
    e.registerLayout(treemapLayout),
    installTreemapAction(e)
}
function categoryFilter(e) {
  var t = e.findComponents({ mainType: 'legend' })
  t &&
    t.length &&
    e.eachSeriesByType('graph', function (e) {
      var i = e.getCategoriesData(),
        r = e.getGraph().data,
        n = i.mapArray(i.getName)
      r.filterSelf(function (e) {
        var i = r.getItemModel(e).getShallow('category')
        if (null != i) {
          'number' == typeof i && (i = n[i])
          for (var a = 0; a < t.length; a++) if (!t[a].isSelected(i)) return !1
        }
        return !0
      })
    })
}
function categoryVisual(e) {
  var t = {}
  e.eachSeriesByType('graph', function (e) {
    var i = e.getCategoriesData(),
      r = e.getData(),
      n = {}
    i.each(function (r) {
      var a = i.getName(r)
      n['ec-' + a] = r
      var o = i.getItemModel(r),
        s = o.getModel('itemStyle').getItemStyle()
      s.fill || (s.fill = e.getColorFromPalette(a, t)), i.setItemVisual(r, 'style', s)
      for (var l = ['symbol', 'symbolSize', 'symbolKeepAspect'], h = 0; h < l.length; h++) {
        var u = o.getShallow(l[h], !0)
        null != u && i.setItemVisual(r, l[h], u)
      }
    }),
      i.count() &&
        r.each(function (e) {
          var t = r.getItemModel(e).getShallow('category')
          if (null != t) {
            'string' == typeof t && (t = n['ec-' + t])
            var a = i.getItemVisual(t, 'style')
            extend$3(r.ensureUniqueItemVisual(e, 'style'), a)
            for (var o = ['symbol', 'symbolSize', 'symbolKeepAspect'], s = 0; s < o.length; s++)
              r.setItemVisual(e, o[s], i.getItemVisual(t, o[s]))
          }
        })
  })
}
function normalize$1(e) {
  return e instanceof Array || (e = [e, e]), e
}
function graphEdgeVisual(e) {
  e.eachSeriesByType('graph', function (e) {
    var t = e.getGraph(),
      i = e.getEdgeData(),
      r = normalize$1(e.get('edgeSymbol')),
      n = normalize$1(e.get('edgeSymbolSize'))
    i.setVisual('fromSymbol', r && r[0]),
      i.setVisual('toSymbol', r && r[1]),
      i.setVisual('fromSymbolSize', n && n[0]),
      i.setVisual('toSymbolSize', n && n[1]),
      i.setVisual('style', e.getModel('lineStyle').getLineStyle()),
      i.each(function (e) {
        var r = i.getItemModel(e),
          n = t.getEdgeByIndex(e),
          a = normalize$1(r.getShallow('symbol', !0)),
          o = normalize$1(r.getShallow('symbolSize', !0)),
          s = r.getModel('lineStyle').getLineStyle(),
          l = i.ensureUniqueItemVisual(e, 'style')
        switch ((extend$3(l, s), l.stroke)) {
          case 'source':
            var h = n.node1.getVisual('style')
            l.stroke = h && h.fill
            break
          case 'target':
            h = n.node2.getVisual('style')
            l.stroke = h && h.fill
        }
        a[0] && n.setVisual('fromSymbol', a[0]),
          a[1] && n.setVisual('toSymbol', a[1]),
          o[0] && n.setVisual('fromSymbolSize', o[0]),
          o[1] && n.setVisual('toSymbolSize', o[1])
      })
  })
}
var KEY_DELIMITER = '--\x3e',
  getAutoCurvenessParams = function (e) {
    return e.get('autoCurveness') || null
  },
  createCurveness = function (e, t) {
    var i = getAutoCurvenessParams(e),
      r = 20,
      n = []
    if ('number' == typeof i) r = i
    else if (isArray$1(i)) return void (e.__curvenessList = i)
    t > r && (r = t)
    var a = r % 2 ? r + 2 : r + 3
    n = []
    for (var o = 0; o < a; o++) n.push(((o % 2 ? o + 1 : o) / 10) * (o % 2 ? -1 : 1))
    e.__curvenessList = n
  },
  getKeyOfEdges = function (e, t, i) {
    var r = [e.id, e.dataIndex].join('.'),
      n = [t.id, t.dataIndex].join('.')
    return [i.uid, r, n].join(KEY_DELIMITER)
  },
  getOppositeKey = function (e) {
    var t = e.split(KEY_DELIMITER)
    return [t[0], t[2], t[1]].join(KEY_DELIMITER)
  },
  getEdgeFromMap = function (e, t) {
    var i = getKeyOfEdges(e.node1, e.node2, t)
    return t.__edgeMap[i]
  },
  getTotalLengthBetweenNodes = function (e, t) {
    return (
      getEdgeMapLengthWithKey(getKeyOfEdges(e.node1, e.node2, t), t) +
      getEdgeMapLengthWithKey(getKeyOfEdges(e.node2, e.node1, t), t)
    )
  },
  getEdgeMapLengthWithKey = function (e, t) {
    var i = t.__edgeMap
    return i[e] ? i[e].length : 0
  }
function initCurvenessList(e) {
  getAutoCurvenessParams(e) && ((e.__curvenessList = []), (e.__edgeMap = {}), createCurveness(e))
}
function createEdgeMapForCurveness(e, t, i, r) {
  if (getAutoCurvenessParams(i)) {
    var n = getKeyOfEdges(e, t, i),
      a = i.__edgeMap,
      o = a[getOppositeKey(n)]
    a[n] && !o ? (a[n].isForward = !0) : o && a[n] && ((o.isForward = !0), (a[n].isForward = !1)),
      (a[n] = a[n] || []),
      a[n].push(r)
  }
}
function getCurvenessForEdge(e, t, i, r) {
  var n = getAutoCurvenessParams(t),
    a = isArray$1(n)
  if (!n) return null
  var o = getEdgeFromMap(e, t)
  if (!o) return null
  for (var s = -1, l = 0; l < o.length; l++)
    if (o[l] === i) {
      s = l
      break
    }
  var h = getTotalLengthBetweenNodes(e, t)
  createCurveness(t, h), (e.lineStyle = e.lineStyle || {})
  var u = getKeyOfEdges(e.node1, e.node2, t),
    p = t.__curvenessList,
    c = a || h % 2 ? 0 : 1
  if (o.isForward) return p[c + s]
  var d = getOppositeKey(u),
    f = getEdgeMapLengthWithKey(d, t),
    m = p[s + f + c]
  return r
    ? a
      ? n && 0 === n[0]
        ? (f + c) % 2
          ? m
          : -m
        : ((f % 2 ? 0 : 1) + c) % 2
        ? m
        : -m
      : (f + c) % 2
      ? m
      : -m
    : p[s + f + c]
}
function simpleLayout(e) {
  var t = e.coordinateSystem
  if (!t || 'view' === t.type) {
    var i = e.getGraph()
    i.eachNode(function (e) {
      var t = e.getModel()
      e.setLayout([+t.get('x'), +t.get('y')])
    }),
      simpleLayoutEdge(i, e)
  }
}
function simpleLayoutEdge(e, t) {
  e.eachEdge(function (e, i) {
    var r = retrieve3(
        e.getModel().get(['lineStyle', 'curveness']),
        -getCurvenessForEdge(e, t, i, !0),
        0
      ),
      n = clone$2(e.node1.getLayout()),
      a = clone$2(e.node2.getLayout()),
      o = [n, a]
    ;+r && o.push([(n[0] + a[0]) / 2 - (n[1] - a[1]) * r, (n[1] + a[1]) / 2 - (a[0] - n[0]) * r]),
      e.setLayout(o)
  })
}
function graphSimpleLayout(e, t) {
  e.eachSeriesByType('graph', function (e) {
    var t = e.get('layout'),
      i = e.coordinateSystem
    if (i && 'view' !== i.type) {
      var r = e.getData(),
        n = []
      each$i(i.dimensions, function (e) {
        n = n.concat(r.mapDimensionsAll(e))
      })
      for (var a = 0; a < r.count(); a++) {
        for (var o = [], s = !1, l = 0; l < n.length; l++) {
          var h = r.get(n[l], a)
          isNaN(h) || (s = !0), o.push(h)
        }
        s ? r.setItemLayout(a, i.dataToPoint(o)) : r.setItemLayout(a, [NaN, NaN])
      }
      simpleLayoutEdge(r.graph, e)
    } else (t && 'none' !== t) || simpleLayout(e)
  })
}
function getNodeGlobalScale(e) {
  var t = e.coordinateSystem
  if ('view' !== t.type) return 1
  var i = e.option.nodeScaleRatio,
    r = t.scaleX
  return ((t.getZoom() - 1) * i + 1) / r
}
function getSymbolSize(e) {
  var t = e.getVisual('symbolSize')
  return t instanceof Array && (t = (t[0] + t[1]) / 2), +t
}
var PI$2 = Math.PI,
  _symbolRadiansHalf = []
function circularLayout(e, t) {
  var i = e.coordinateSystem
  if (!i || 'view' === i.type) {
    var r = i.getBoundingRect(),
      n = e.getData(),
      a = n.graph,
      o = r.width / 2 + r.x,
      s = r.height / 2 + r.y,
      l = Math.min(r.width, r.height) / 2,
      h = n.count()
    n.setLayout({ cx: o, cy: s }),
      h &&
        (_layoutNodesBasedOn[t](e, a, n, l, o, s, h),
        a.eachEdge(function (t, i) {
          var r,
            n = retrieve3(
              t.getModel().get(['lineStyle', 'curveness']),
              getCurvenessForEdge(t, e, i),
              0
            ),
            a = clone$2(t.node1.getLayout()),
            l = clone$2(t.node2.getLayout()),
            h = (a[0] + l[0]) / 2,
            u = (a[1] + l[1]) / 2
          ;+n && (r = [o * (n *= 3) + h * (1 - n), s * n + u * (1 - n)]), t.setLayout([a, l, r])
        }))
  }
}
var _layoutNodesBasedOn = {
  value: function (e, t, i, r, n, a, o) {
    var s = 0,
      l = i.getSum('value'),
      h = (2 * Math.PI) / (l || o)
    t.eachNode(function (e) {
      var t = e.getValue('value'),
        i = (h * (l ? t : 1)) / 2
      ;(s += i), e.setLayout([r * Math.cos(s) + n, r * Math.sin(s) + a]), (s += i)
    })
  },
  symbolSize: function (e, t, i, r, n, a, o) {
    var s = 0
    _symbolRadiansHalf.length = o
    var l = getNodeGlobalScale(e)
    t.eachNode(function (e) {
      var t = getSymbolSize(e)
      isNaN(t) && (t = 2), t < 0 && (t = 0), (t *= l)
      var i = Math.asin(t / 2 / r)
      isNaN(i) && (i = PI$2 / 2), (_symbolRadiansHalf[e.dataIndex] = i), (s += 2 * i)
    })
    var h = (2 * PI$2 - s) / o / 2,
      u = 0
    t.eachNode(function (e) {
      var t = h + _symbolRadiansHalf[e.dataIndex]
      ;(u += t), e.setLayout([r * Math.cos(u) + n, r * Math.sin(u) + a]), (u += t)
    })
  }
}
function graphCircularLayout(e) {
  e.eachSeriesByType('graph', function (e) {
    'circular' === e.get('layout') && circularLayout(e, 'symbolSize')
  })
}
var scaleAndAdd = scaleAndAdd$1
function forceLayout(e, t, i) {
  for (
    var r = e,
      n = t,
      a = i.rect,
      o = a.width,
      s = a.height,
      l = [a.x + o / 2, a.y + s / 2],
      h = null == i.gravity ? 0.1 : i.gravity,
      u = 0;
    u < r.length;
    u++
  ) {
    var p = r[u]
    p.p || (p.p = create$2(o * (Math.random() - 0.5) + l[0], s * (Math.random() - 0.5) + l[1])),
      (p.pp = clone$2(p.p)),
      (p.edges = null)
  }
  var c,
    d,
    f = null == i.friction ? 0.6 : i.friction,
    m = f
  return {
    warmUp: function () {
      m = 0.8 * f
    },
    setFixed: function (e) {
      r[e].fixed = !0
    },
    setUnfixed: function (e) {
      r[e].fixed = !1
    },
    beforeStep: function (e) {
      c = e
    },
    afterStep: function (e) {
      d = e
    },
    step: function (e) {
      c && c(r, n)
      for (var t = [], i = r.length, a = 0; a < n.length; a++) {
        var o = n[a]
        if (!o.ignoreForceLayout) {
          var s = o.n1
          sub(t, (g = o.n2).p, s.p)
          var u = len(t) - o.d,
            p = g.w / (s.w + g.w)
          isNaN(p) && (p = 0),
            normalize$3(t, t),
            !s.fixed && scaleAndAdd(s.p, s.p, t, p * u * m),
            !g.fixed && scaleAndAdd(g.p, g.p, t, -(1 - p) * u * m)
        }
      }
      for (a = 0; a < i; a++) {
        ;(_ = r[a]).fixed || (sub(t, l, _.p), scaleAndAdd(_.p, _.p, t, h * m))
      }
      for (a = 0; a < i; a++) {
        s = r[a]
        for (var f = a + 1; f < i; f++) {
          var g
          sub(t, (g = r[f]).p, s.p),
            0 === (u = len(t)) && (set$1(t, Math.random() - 0.5, Math.random() - 0.5), (u = 1))
          var y = (s.rep + g.rep) / u / u
          !s.fixed && scaleAndAdd(s.pp, s.pp, t, y), !g.fixed && scaleAndAdd(g.pp, g.pp, t, -y)
        }
      }
      var v = []
      for (a = 0; a < i; a++) {
        var _
        ;(_ = r[a]).fixed || (sub(v, _.p, _.pp), scaleAndAdd(_.p, _.p, v, m), copy$1(_.pp, _.p))
      }
      var x = (m *= 0.992) < 0.01
      d && d(r, n, x), e && e(x)
    }
  }
}
function graphForceLayout(e) {
  e.eachSeriesByType('graph', function (e) {
    var t = e.coordinateSystem
    if (!t || 'view' === t.type)
      if ('force' === e.get('layout')) {
        var i = e.preservedPoints || {},
          r = e.getGraph(),
          n = r.data,
          a = r.edgeData,
          o = e.getModel('force'),
          s = o.get('initLayout')
        e.preservedPoints
          ? n.each(function (e) {
              var t = n.getId(e)
              n.setItemLayout(e, i[t] || [NaN, NaN])
            })
          : s && 'none' !== s
          ? 'circular' === s && circularLayout(e, 'value')
          : simpleLayout(e)
        var l = n.getDataExtent('value'),
          h = a.getDataExtent('value'),
          u = o.get('repulsion'),
          p = o.get('edgeLength'),
          c = isArray$1(u) ? u : [u, u],
          d = isArray$1(p) ? p : [p, p]
        d = [d[1], d[0]]
        var f = n.mapArray('value', function (e, t) {
            var i = n.getItemLayout(t),
              r = linearMap$2(e, l, c)
            return (
              isNaN(r) && (r = (c[0] + c[1]) / 2),
              {
                w: r,
                rep: r,
                fixed: n.getItemModel(t).get('fixed'),
                p: !i || isNaN(i[0]) || isNaN(i[1]) ? null : i
              }
            )
          }),
          m = a.mapArray('value', function (t, i) {
            var n = r.getEdgeByIndex(i),
              a = linearMap$2(t, h, d)
            isNaN(a) && (a = (d[0] + d[1]) / 2)
            var o = n.getModel(),
              s = retrieve3(
                n.getModel().get(['lineStyle', 'curveness']),
                -getCurvenessForEdge(n, e, i, !0),
                0
              )
            return {
              n1: f[n.node1.dataIndex],
              n2: f[n.node2.dataIndex],
              d: a,
              curveness: s,
              ignoreForceLayout: o.get('ignoreForceLayout')
            }
          }),
          g = t.getBoundingRect(),
          y = forceLayout(f, m, { rect: g, gravity: o.get('gravity'), friction: o.get('friction') })
        y.beforeStep(function (e, t) {
          for (var i = 0, n = e.length; i < n; i++)
            e[i].fixed && copy$1(e[i].p, r.getNodeByIndex(i).getLayout())
        }),
          y.afterStep(function (e, t, a) {
            for (var o = 0, s = e.length; o < s; o++)
              e[o].fixed || r.getNodeByIndex(o).setLayout(e[o].p), (i[n.getId(o)] = e[o].p)
            for (o = 0, s = t.length; o < s; o++) {
              var l = t[o],
                h = r.getEdgeByIndex(o),
                u = l.n1.p,
                p = l.n2.p,
                c = h.getLayout()
              ;((c = c ? c.slice() : [])[0] = c[0] || []),
                (c[1] = c[1] || []),
                copy$1(c[0], u),
                copy$1(c[1], p),
                +l.curveness &&
                  (c[2] = [
                    (u[0] + p[0]) / 2 - (u[1] - p[1]) * l.curveness,
                    (u[1] + p[1]) / 2 - (p[0] - u[0]) * l.curveness
                  ]),
                h.setLayout(c)
            }
          }),
          (e.forceLayout = y),
          (e.preservedPoints = i),
          y.step()
      } else e.forceLayout = null
  })
}
function getViewRect$3(e, t, i) {
  return getLayoutRect(extend$3(e.getBoxLayoutParams(), { aspect: i }), {
    width: t.getWidth(),
    height: t.getHeight()
  })
}
function createViewCoordSys(e, t) {
  var i = []
  return (
    e.eachSeriesByType('graph', function (e) {
      var r = e.get('coordinateSystem')
      if (!r || 'view' === r) {
        var n = e.getData(),
          a = [],
          o = []
        fromPoints(
          n.mapArray(function (e) {
            var t = n.getItemModel(e)
            return [+t.get('x'), +t.get('y')]
          }),
          a,
          o
        ),
          o[0] - a[0] == 0 && ((o[0] += 1), (a[0] -= 1)),
          o[1] - a[1] == 0 && ((o[1] += 1), (a[1] -= 1))
        var s = (o[0] - a[0]) / (o[1] - a[1]),
          l = getViewRect$3(e, t, s)
        isNaN(s) && ((a = [l.x, l.y]), (o = [l.x + l.width, l.y + l.height]))
        var h = o[0] - a[0],
          u = o[1] - a[1],
          p = l.width,
          c = l.height,
          d = (e.coordinateSystem = new View())
        ;(d.zoomLimit = e.get('scaleLimit')),
          d.setBoundingRect(a[0], a[1], h, u),
          d.setViewRect(l.x, l.y, p, c),
          d.setCenter(e.get('center')),
          d.setZoom(e.get('zoom')),
          i.push(d)
      }
    }),
    i
  )
}
var straightLineProto = Line$1.prototype,
  bezierCurveProto = BezierCurve.prototype,
  StraightLineShape = function () {
    ;(this.x1 = 0), (this.y1 = 0), (this.x2 = 0), (this.y2 = 0), (this.percent = 1)
  }
function isStraightLine(e) {
  return isNaN(+e.cpx1) || isNaN(+e.cpy1)
}
!(function (e) {
  function t() {
    return (null !== e && e.apply(this, arguments)) || this
  }
  __extends(t, e)
})(StraightLineShape)
var ECLinePath = (function (e) {
    function t(t) {
      var i = e.call(this, t) || this
      return (i.type = 'ec-line'), i
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultStyle = function () {
        return { stroke: '#000', fill: null }
      }),
      (t.prototype.getDefaultShape = function () {
        return new StraightLineShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        isStraightLine(t)
          ? straightLineProto.buildPath.call(this, e, t)
          : bezierCurveProto.buildPath.call(this, e, t)
      }),
      (t.prototype.pointAt = function (e) {
        return isStraightLine(this.shape)
          ? straightLineProto.pointAt.call(this, e)
          : bezierCurveProto.pointAt.call(this, e)
      }),
      (t.prototype.tangentAt = function (e) {
        var t = this.shape,
          i = isStraightLine(t)
            ? [t.x2 - t.x1, t.y2 - t.y1]
            : bezierCurveProto.tangentAt.call(this, e)
        return normalize$3(i, i)
      }),
      t
    )
  })(Path),
  SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol']
function makeSymbolTypeKey(e) {
  return '_' + e + 'Type'
}
function createSymbol(e, t, i) {
  var r = t.getItemVisual(i, e)
  if (r && 'none' !== r) {
    var n = t.getItemVisual(i, e + 'Size'),
      a = t.getItemVisual(i, e + 'Rotate'),
      o = t.getItemVisual(i, e + 'Offset') || 0,
      s = t.getItemVisual(i, e + 'KeepAspect'),
      l = isArray$1(n) ? n : [n, n],
      h = isArray$1(o) ? o : [o, o]
    ;(h[0] = parsePercent$1(h[0], l[0])), (h[1] = parsePercent$1(retrieve2(h[1], h[0]), l[1]))
    var u = createSymbol$1(r, -l[0] / 2 + h[0], -l[1] / 2 + h[1], l[0], l[1], null, s)
    return (
      (u.__specifiedRotation = null == a || isNaN(a) ? void 0 : (+a * Math.PI) / 180 || 0),
      (u.name = e),
      u
    )
  }
}
function createLine(e) {
  var t = new ECLinePath({ name: 'line', subPixelOptimize: !0 })
  return setLinePoints(t.shape, e), t
}
function setLinePoints(e, t) {
  ;(e.x1 = t[0][0]), (e.y1 = t[0][1]), (e.x2 = t[1][0]), (e.y2 = t[1][1]), (e.percent = 1)
  var i = t[2]
  i ? ((e.cpx1 = i[0]), (e.cpy1 = i[1])) : ((e.cpx1 = NaN), (e.cpy1 = NaN))
}
var Line = (function (e) {
    function t(t, i, r) {
      var n = e.call(this) || this
      return n._createLine(t, i, r), n
    }
    return (
      __extends(t, e),
      (t.prototype._createLine = function (e, t, i) {
        var r = e.hostModel,
          n = createLine(e.getItemLayout(t))
        ;(n.shape.percent = 0),
          initProps(n, { shape: { percent: 1 } }, r, t),
          this.add(n),
          each$i(
            SYMBOL_CATEGORIES,
            function (i) {
              var r = createSymbol(i, e, t)
              this.add(r), (this[makeSymbolTypeKey(i)] = e.getItemVisual(t, i))
            },
            this
          ),
          this._updateCommonStl(e, t, i)
      }),
      (t.prototype.updateData = function (e, t, i) {
        var r = e.hostModel,
          n = this.childOfName('line'),
          a = e.getItemLayout(t),
          o = { shape: {} }
        setLinePoints(o.shape, a),
          updateProps$1(n, o, r, t),
          each$i(
            SYMBOL_CATEGORIES,
            function (i) {
              var r = e.getItemVisual(t, i),
                n = makeSymbolTypeKey(i)
              if (this[n] !== r) {
                this.remove(this.childOfName(i))
                var a = createSymbol(i, e, t)
                this.add(a)
              }
              this[n] = r
            },
            this
          ),
          this._updateCommonStl(e, t, i)
      }),
      (t.prototype.getLinePath = function () {
        return this.childAt(0)
      }),
      (t.prototype._updateCommonStl = function (e, t, i) {
        var r = e.hostModel,
          n = this.childOfName('line'),
          a = i && i.emphasisLineStyle,
          o = i && i.blurLineStyle,
          s = i && i.selectLineStyle,
          l = i && i.labelStatesModels
        if (!i || e.hasItemOption) {
          var h = e.getItemModel(t)
          ;(a = h.getModel(['emphasis', 'lineStyle']).getLineStyle()),
            (o = h.getModel(['blur', 'lineStyle']).getLineStyle()),
            (s = h.getModel(['select', 'lineStyle']).getLineStyle()),
            (l = getLabelStatesModels(h))
        }
        var u = e.getItemVisual(t, 'style'),
          p = u.stroke
        n.useStyle(u),
          (n.style.fill = null),
          (n.style.strokeNoScale = !0),
          (n.ensureState('emphasis').style = a),
          (n.ensureState('blur').style = o),
          (n.ensureState('select').style = s),
          each$i(
            SYMBOL_CATEGORIES,
            function (e) {
              var t = this.childOfName(e)
              if (t) {
                t.setColor(p), (t.style.opacity = u.opacity)
                for (var i = 0; i < SPECIAL_STATES.length; i++) {
                  var r = SPECIAL_STATES[i],
                    a = n.getState(r)
                  if (a) {
                    var o = a.style || {},
                      s = t.ensureState(r),
                      l = s.style || (s.style = {})
                    null != o.stroke && (l[t.__isEmptyBrush ? 'stroke' : 'fill'] = o.stroke),
                      null != o.opacity && (l.opacity = o.opacity)
                  }
                }
                t.markRedraw()
              }
            },
            this
          )
        var c = r.getRawValue(t)
        setLabelStyle(this, l, {
          labelDataIndex: t,
          labelFetcher: {
            getFormattedLabel: function (t, i) {
              return r.getFormattedLabel(t, i, e.dataType)
            }
          },
          inheritColor: p || '#000',
          defaultOpacity: u.opacity,
          defaultText: (null == c ? e.getName(t) : isFinite(c) ? round$2(c) : c) + ''
        })
        var d = this.getTextContent()
        if (d) {
          var f = l.normal
          ;(d.__align = d.style.align),
            (d.__verticalAlign = d.style.verticalAlign),
            (d.__position = f.get('position') || 'middle')
          var m = f.get('distance')
          isArray$1(m) || (m = [m, m]), (d.__labelDistance = m)
        }
        this.setTextConfig({ position: null, local: !0, inside: !1 }), enableHoverEmphasis(this)
      }),
      (t.prototype.highlight = function () {
        enterEmphasis(this)
      }),
      (t.prototype.downplay = function () {
        leaveEmphasis(this)
      }),
      (t.prototype.updateLayout = function (e, t) {
        this.setLinePoints(e.getItemLayout(t))
      }),
      (t.prototype.setLinePoints = function (e) {
        var t = this.childOfName('line')
        setLinePoints(t.shape, e), t.dirty()
      }),
      (t.prototype.beforeUpdate = function () {
        var e = this,
          t = e.childOfName('fromSymbol'),
          i = e.childOfName('toSymbol'),
          r = e.getTextContent()
        if (t || i || (r && !r.ignore)) {
          for (var n = 1, a = this.parent; a; ) a.scaleX && (n /= a.scaleX), (a = a.parent)
          var o = e.childOfName('line')
          if (this.__dirty || o.__dirty) {
            var s = o.shape.percent,
              l = o.pointAt(0),
              h = o.pointAt(s),
              u = sub([], h, l)
            if (
              (normalize$3(u, u),
              t && (t.setPosition(l), T(t, 0), (t.scaleX = t.scaleY = n * s), t.markRedraw()),
              i && (i.setPosition(h), T(i, 1), (i.scaleX = i.scaleY = n * s), i.markRedraw()),
              r && !r.ignore)
            ) {
              ;(r.x = r.y = 0), (r.originX = r.originY = 0)
              var p = void 0,
                c = void 0,
                d = r.__labelDistance,
                f = d[0] * n,
                m = d[1] * n,
                g = s / 2,
                y = o.tangentAt(g),
                v = [y[1], -y[0]],
                _ = o.pointAt(g)
              v[1] > 0 && ((v[0] = -v[0]), (v[1] = -v[1]))
              var x = y[0] < 0 ? -1 : 1
              if ('start' !== r.__position && 'end' !== r.__position) {
                var S = -Math.atan2(y[1], y[0])
                h[0] < l[0] && (S = Math.PI + S), (r.rotation = S)
              }
              var b = void 0
              switch (r.__position) {
                case 'insideStartTop':
                case 'insideMiddleTop':
                case 'insideEndTop':
                case 'middle':
                  ;(b = -m), (c = 'bottom')
                  break
                case 'insideStartBottom':
                case 'insideMiddleBottom':
                case 'insideEndBottom':
                  ;(b = m), (c = 'top')
                  break
                default:
                  ;(b = 0), (c = 'middle')
              }
              switch (r.__position) {
                case 'end':
                  ;(r.x = u[0] * f + h[0]),
                    (r.y = u[1] * m + h[1]),
                    (p = u[0] > 0.8 ? 'left' : u[0] < -0.8 ? 'right' : 'center'),
                    (c = u[1] > 0.8 ? 'top' : u[1] < -0.8 ? 'bottom' : 'middle')
                  break
                case 'start':
                  ;(r.x = -u[0] * f + l[0]),
                    (r.y = -u[1] * m + l[1]),
                    (p = u[0] > 0.8 ? 'right' : u[0] < -0.8 ? 'left' : 'center'),
                    (c = u[1] > 0.8 ? 'bottom' : u[1] < -0.8 ? 'top' : 'middle')
                  break
                case 'insideStartTop':
                case 'insideStart':
                case 'insideStartBottom':
                  ;(r.x = f * x + l[0]),
                    (r.y = l[1] + b),
                    (p = y[0] < 0 ? 'right' : 'left'),
                    (r.originX = -f * x),
                    (r.originY = -b)
                  break
                case 'insideMiddleTop':
                case 'insideMiddle':
                case 'insideMiddleBottom':
                case 'middle':
                  ;(r.x = _[0]), (r.y = _[1] + b), (p = 'center'), (r.originY = -b)
                  break
                case 'insideEndTop':
                case 'insideEnd':
                case 'insideEndBottom':
                  ;(r.x = -f * x + h[0]),
                    (r.y = h[1] + b),
                    (p = y[0] >= 0 ? 'right' : 'left'),
                    (r.originX = f * x),
                    (r.originY = -b)
              }
              ;(r.scaleX = r.scaleY = n),
                r.setStyle({ verticalAlign: r.__verticalAlign || c, align: r.__align || p })
            }
          }
        }
        function T(e, t) {
          var i = e.__specifiedRotation
          if (null == i) {
            var r = o.tangentAt(t)
            e.attr('rotation', ((1 === t ? -1 : 1) * Math.PI) / 2 - Math.atan2(r[1], r[0]))
          } else e.attr('rotation', i)
        }
      }),
      t
    )
  })(Group$3),
  LineDraw = (function () {
    function e(e) {
      ;(this.group = new Group$3()), (this._LineCtor = e || Line)
    }
    return (
      (e.prototype.isPersistent = function () {
        return !0
      }),
      (e.prototype.updateData = function (e) {
        var t = this,
          i = this,
          r = i.group,
          n = i._lineData
        ;(i._lineData = e), n || r.removeAll()
        var a = makeSeriesScope$1(e)
        e.diff(n)
          .add(function (i) {
            t._doAdd(e, i, a)
          })
          .update(function (i, r) {
            t._doUpdate(n, e, r, i, a)
          })
          .remove(function (e) {
            r.remove(n.getItemGraphicEl(e))
          })
          .execute()
      }),
      (e.prototype.updateLayout = function () {
        var e = this._lineData
        e &&
          e.eachItemGraphicEl(function (t, i) {
            t.updateLayout(e, i)
          }, this)
      }),
      (e.prototype.incrementalPrepareUpdate = function (e) {
        ;(this._seriesScope = makeSeriesScope$1(e)), (this._lineData = null), this.group.removeAll()
      }),
      (e.prototype.incrementalUpdate = function (e, t) {
        function i(e) {
          e.isGroup ||
            isEffectObject(e) ||
            ((e.incremental = !0), (e.ensureState('emphasis').hoverLayer = !0))
        }
        for (var r = e.start; r < e.end; r++) {
          if (lineNeedsDraw(t.getItemLayout(r))) {
            var n = new this._LineCtor(t, r, this._seriesScope)
            n.traverse(i), this.group.add(n), t.setItemGraphicEl(r, n)
          }
        }
      }),
      (e.prototype.remove = function () {
        this.group.removeAll()
      }),
      (e.prototype._doAdd = function (e, t, i) {
        if (lineNeedsDraw(e.getItemLayout(t))) {
          var r = new this._LineCtor(e, t, i)
          e.setItemGraphicEl(t, r), this.group.add(r)
        }
      }),
      (e.prototype._doUpdate = function (e, t, i, r, n) {
        var a = e.getItemGraphicEl(i)
        lineNeedsDraw(t.getItemLayout(r))
          ? (a ? a.updateData(t, r, n) : (a = new this._LineCtor(t, r, n)),
            t.setItemGraphicEl(r, a),
            this.group.add(a))
          : this.group.remove(a)
      }),
      e
    )
  })()
function isEffectObject(e) {
  return e.animators && e.animators.length > 0
}
function makeSeriesScope$1(e) {
  var t = e.hostModel
  return {
    lineStyle: t.getModel('lineStyle').getLineStyle(),
    emphasisLineStyle: t.getModel(['emphasis', 'lineStyle']).getLineStyle(),
    blurLineStyle: t.getModel(['blur', 'lineStyle']).getLineStyle(),
    selectLineStyle: t.getModel(['select', 'lineStyle']).getLineStyle(),
    labelStatesModels: getLabelStatesModels(t)
  }
}
function isPointNaN(e) {
  return isNaN(e[0]) || isNaN(e[1])
}
function lineNeedsDraw(e) {
  return !isPointNaN(e[0]) && !isPointNaN(e[1])
}
var v1 = [],
  v2 = [],
  v3 = [],
  quadraticAt = quadraticAt$1,
  v2DistSquare = distSquare,
  mathAbs = Math.abs
function intersectCurveCircle(e, t, i) {
  for (
    var r, n = e[0], a = e[1], o = e[2], s = 1 / 0, l = i * i, h = 0.1, u = 0.1;
    u <= 0.9;
    u += 0.1
  ) {
    ;(v1[0] = quadraticAt(n[0], a[0], o[0], u)),
      (v1[1] = quadraticAt(n[1], a[1], o[1], u)),
      (d = mathAbs(v2DistSquare(v1, t) - l)) < s && ((s = d), (r = u))
  }
  for (var p = 0; p < 32; p++) {
    var c = r + h
    ;(v2[0] = quadraticAt(n[0], a[0], o[0], r)),
      (v2[1] = quadraticAt(n[1], a[1], o[1], r)),
      (v3[0] = quadraticAt(n[0], a[0], o[0], c)),
      (v3[1] = quadraticAt(n[1], a[1], o[1], c))
    var d = v2DistSquare(v2, t) - l
    if (mathAbs(d) < 0.01) break
    var f = v2DistSquare(v3, t) - l
    ;(h /= 2), d < 0 ? (f >= 0 ? (r += h) : (r -= h)) : f >= 0 ? (r -= h) : (r += h)
  }
  return r
}
function adjustEdge(e, t) {
  var i = [],
    r = quadraticSubdivide,
    n = [[], [], []],
    a = [[], []],
    o = []
  ;(t /= 2),
    e.eachEdge(function (e, s) {
      var l = e.getLayout(),
        h = e.getVisual('fromSymbol'),
        u = e.getVisual('toSymbol')
      l.__original ||
        ((l.__original = [clone$2(l[0]), clone$2(l[1])]), l[2] && l.__original.push(clone$2(l[2])))
      var p = l.__original
      if (null != l[2]) {
        if ((copy$1(n[0], p[0]), copy$1(n[1], p[2]), copy$1(n[2], p[1]), h && 'none' !== h)) {
          var c = getSymbolSize(e.node1),
            d = intersectCurveCircle(n, p[0], c * t)
          r(n[0][0], n[1][0], n[2][0], d, i),
            (n[0][0] = i[3]),
            (n[1][0] = i[4]),
            r(n[0][1], n[1][1], n[2][1], d, i),
            (n[0][1] = i[3]),
            (n[1][1] = i[4])
        }
        if (u && 'none' !== u) {
          ;(c = getSymbolSize(e.node2)), (d = intersectCurveCircle(n, p[1], c * t))
          r(n[0][0], n[1][0], n[2][0], d, i),
            (n[1][0] = i[1]),
            (n[2][0] = i[2]),
            r(n[0][1], n[1][1], n[2][1], d, i),
            (n[1][1] = i[1]),
            (n[2][1] = i[2])
        }
        copy$1(l[0], n[0]), copy$1(l[1], n[2]), copy$1(l[2], n[1])
      } else {
        if (
          (copy$1(a[0], p[0]),
          copy$1(a[1], p[1]),
          sub(o, a[1], a[0]),
          normalize$3(o, o),
          h && 'none' !== h)
        ) {
          c = getSymbolSize(e.node1)
          scaleAndAdd$1(a[0], a[0], o, c * t)
        }
        if (u && 'none' !== u) {
          c = getSymbolSize(e.node2)
          scaleAndAdd$1(a[1], a[1], o, -c * t)
        }
        copy$1(l[0], a[0]), copy$1(l[1], a[1])
      }
    })
}
function isViewCoordSys(e) {
  return 'view' === e.type
}
var GraphView = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), i
  }
  return (
    __extends(t, e),
    (t.prototype.init = function (e, t) {
      var i = new SymbolDraw(),
        r = new LineDraw(),
        n = this.group
      ;(this._controller = new RoamController(t.getZr())),
        (this._controllerHost = { target: n }),
        n.add(i.group),
        n.add(r.group),
        (this._symbolDraw = i),
        (this._lineDraw = r),
        (this._firstRender = !0)
    }),
    (t.prototype.render = function (e, t, i) {
      var r = this,
        n = e.coordinateSystem
      this._model = e
      var a = this._symbolDraw,
        o = this._lineDraw,
        s = this.group
      if (isViewCoordSys(n)) {
        var l = { x: n.x, y: n.y, scaleX: n.scaleX, scaleY: n.scaleY }
        this._firstRender ? s.attr(l) : updateProps$1(s, l, e)
      }
      adjustEdge(e.getGraph(), getNodeGlobalScale(e))
      var h = e.getData()
      a.updateData(h)
      var u = e.getEdgeData()
      o.updateData(u),
        this._updateNodeAndLinkScale(),
        this._updateController(e, t, i),
        clearTimeout(this._layoutTimeout)
      var p = e.forceLayout,
        c = e.get(['force', 'layoutAnimation'])
      p && this._startForceLayoutIteration(p, c),
        h.graph.eachNode(function (e) {
          var t = e.dataIndex,
            i = e.getGraphicEl(),
            n = e.getModel()
          i.off('drag').off('dragend')
          var a = n.get('draggable')
          a &&
            i
              .on('drag', function () {
                p &&
                  (p.warmUp(),
                  !r._layouting && r._startForceLayoutIteration(p, c),
                  p.setFixed(t),
                  h.setItemLayout(t, [i.x, i.y]))
              })
              .on('dragend', function () {
                p && p.setUnfixed(t)
              }),
            i.setDraggable(a && !!p),
            'adjacency' === n.get(['emphasis', 'focus']) &&
              (getECData(i).focus = e.getAdjacentDataIndices())
        }),
        h.graph.eachEdge(function (e) {
          var t = e.getGraphicEl()
          'adjacency' === e.getModel().get(['emphasis', 'focus']) &&
            (getECData(t).focus = {
              edge: [e.dataIndex],
              node: [e.node1.dataIndex, e.node2.dataIndex]
            })
        })
      var d = 'circular' === e.get('layout') && e.get(['circular', 'rotateLabel']),
        f = h.getLayout('cx'),
        m = h.getLayout('cy')
      h.eachItemGraphicEl(function (e, t) {
        var i = h.getItemModel(t).get(['label', 'rotate']) || 0,
          r = e.getSymbolPath()
        if (d) {
          var n = h.getItemLayout(t),
            a = Math.atan2(n[1] - m, n[0] - f)
          a < 0 && (a = 2 * Math.PI + a)
          var o = n[0] < f
          o && (a -= Math.PI)
          var s = o ? 'left' : 'right'
          r.setTextConfig({ rotation: -a, position: s, origin: 'center' })
          var l = r.ensureState('emphasis')
          extend$3(l.textConfig || (l.textConfig = {}), { position: s })
        } else r.setTextConfig({ rotation: (i *= Math.PI / 180) })
      }),
        (this._firstRender = !1)
    }),
    (t.prototype.dispose = function () {
      this._controller && this._controller.dispose(), (this._controllerHost = null)
    }),
    (t.prototype._startForceLayoutIteration = function (e, t) {
      var i = this
      !(function r() {
        e.step(function (e) {
          i.updateLayout(i._model),
            (i._layouting = !e) && (t ? (i._layoutTimeout = setTimeout(r, 16)) : r())
        })
      })()
    }),
    (t.prototype._updateController = function (e, t, i) {
      var r = this,
        n = this._controller,
        a = this._controllerHost,
        o = this.group
      n.setPointerChecker(function (t, r, n) {
        var a = o.getBoundingRect()
        return a.applyTransform(o.transform), a.contain(r, n) && !onIrrelevantElement(t, i, e)
      }),
        isViewCoordSys(e.coordinateSystem)
          ? (n.enable(e.get('roam')),
            (a.zoomLimit = e.get('scaleLimit')),
            (a.zoom = e.coordinateSystem.getZoom()),
            n
              .off('pan')
              .off('zoom')
              .on('pan', function (t) {
                updateViewOnPan(a, t.dx, t.dy),
                  i.dispatchAction({ seriesId: e.id, type: 'graphRoam', dx: t.dx, dy: t.dy })
              })
              .on('zoom', function (t) {
                updateViewOnZoom(a, t.scale, t.originX, t.originY),
                  i.dispatchAction({
                    seriesId: e.id,
                    type: 'graphRoam',
                    zoom: t.scale,
                    originX: t.originX,
                    originY: t.originY
                  }),
                  r._updateNodeAndLinkScale(),
                  adjustEdge(e.getGraph(), getNodeGlobalScale(e)),
                  r._lineDraw.updateLayout(),
                  i.updateLabelLayout()
              }))
          : n.disable()
    }),
    (t.prototype._updateNodeAndLinkScale = function () {
      var e = this._model,
        t = e.getData(),
        i = getNodeGlobalScale(e)
      t.eachItemGraphicEl(function (e, t) {
        e.setSymbolScale(i)
      })
    }),
    (t.prototype.updateLayout = function (e) {
      adjustEdge(e.getGraph(), getNodeGlobalScale(e)),
        this._symbolDraw.updateLayout(),
        this._lineDraw.updateLayout()
    }),
    (t.prototype.remove = function (e, t) {
      this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove()
    }),
    (t.type = 'graph'),
    t
  )
})(ChartView)
function generateNodeKey(e) {
  return '_EC_' + e
}
var Graph = (function () {
    function e(e) {
      ;(this.type = 'graph'),
        (this.nodes = []),
        (this.edges = []),
        (this._nodesMap = {}),
        (this._edgesMap = {}),
        (this._directed = e || !1)
    }
    return (
      (e.prototype.isDirected = function () {
        return this._directed
      }),
      (e.prototype.addNode = function (e, t) {
        e = null == e ? '' + t : '' + e
        var i = this._nodesMap
        if (!i[generateNodeKey(e)]) {
          var r = new GraphNode(e, t)
          return (r.hostGraph = this), this.nodes.push(r), (i[generateNodeKey(e)] = r), r
        }
      }),
      (e.prototype.getNodeByIndex = function (e) {
        var t = this.data.getRawIndex(e)
        return this.nodes[t]
      }),
      (e.prototype.getNodeById = function (e) {
        return this._nodesMap[generateNodeKey(e)]
      }),
      (e.prototype.addEdge = function (e, t, i) {
        var r = this._nodesMap,
          n = this._edgesMap
        if (
          ('number' == typeof e && (e = this.nodes[e]),
          'number' == typeof t && (t = this.nodes[t]),
          e instanceof GraphNode || (e = r[generateNodeKey(e)]),
          t instanceof GraphNode || (t = r[generateNodeKey(t)]),
          e && t)
        ) {
          var a = e.id + '-' + t.id,
            o = new GraphEdge(e, t, i)
          return (
            (o.hostGraph = this),
            this._directed && (e.outEdges.push(o), t.inEdges.push(o)),
            e.edges.push(o),
            e !== t && t.edges.push(o),
            this.edges.push(o),
            (n[a] = o),
            o
          )
        }
      }),
      (e.prototype.getEdgeByIndex = function (e) {
        var t = this.edgeData.getRawIndex(e)
        return this.edges[t]
      }),
      (e.prototype.getEdge = function (e, t) {
        e instanceof GraphNode && (e = e.id), t instanceof GraphNode && (t = t.id)
        var i = this._edgesMap
        return this._directed ? i[e + '-' + t] : i[e + '-' + t] || i[t + '-' + e]
      }),
      (e.prototype.eachNode = function (e, t) {
        for (var i = this.nodes, r = i.length, n = 0; n < r; n++)
          i[n].dataIndex >= 0 && e.call(t, i[n], n)
      }),
      (e.prototype.eachEdge = function (e, t) {
        for (var i = this.edges, r = i.length, n = 0; n < r; n++)
          i[n].dataIndex >= 0 &&
            i[n].node1.dataIndex >= 0 &&
            i[n].node2.dataIndex >= 0 &&
            e.call(t, i[n], n)
      }),
      (e.prototype.breadthFirstTraverse = function (e, t, i, r) {
        if ((t instanceof GraphNode || (t = this._nodesMap[generateNodeKey(t)]), t)) {
          for (
            var n = 'out' === i ? 'outEdges' : 'in' === i ? 'inEdges' : 'edges', a = 0;
            a < this.nodes.length;
            a++
          )
            this.nodes[a].__visited = !1
          if (!e.call(r, t, null))
            for (var o = [t]; o.length; ) {
              var s = o.shift(),
                l = s[n]
              for (a = 0; a < l.length; a++) {
                var h = l[a],
                  u = h.node1 === s ? h.node2 : h.node1
                if (!u.__visited) {
                  if (e.call(r, u, s)) return
                  o.push(u), (u.__visited = !0)
                }
              }
            }
        }
      }),
      (e.prototype.update = function () {
        for (
          var e = this.data, t = this.edgeData, i = this.nodes, r = this.edges, n = 0, a = i.length;
          n < a;
          n++
        )
          i[n].dataIndex = -1
        for (n = 0, a = e.count(); n < a; n++) i[e.getRawIndex(n)].dataIndex = n
        t.filterSelf(function (e) {
          var i = r[t.getRawIndex(e)]
          return i.node1.dataIndex >= 0 && i.node2.dataIndex >= 0
        })
        for (n = 0, a = r.length; n < a; n++) r[n].dataIndex = -1
        for (n = 0, a = t.count(); n < a; n++) r[t.getRawIndex(n)].dataIndex = n
      }),
      (e.prototype.clone = function () {
        for (
          var t = new e(this._directed), i = this.nodes, r = this.edges, n = 0;
          n < i.length;
          n++
        )
          t.addNode(i[n].id, i[n].dataIndex)
        for (n = 0; n < r.length; n++) {
          var a = r[n]
          t.addEdge(a.node1.id, a.node2.id, a.dataIndex)
        }
        return t
      }),
      e
    )
  })(),
  GraphNode = (function () {
    function e(e, t) {
      ;(this.inEdges = []),
        (this.outEdges = []),
        (this.edges = []),
        (this.dataIndex = -1),
        (this.id = null == e ? '' : e),
        (this.dataIndex = null == t ? -1 : t)
    }
    return (
      (e.prototype.degree = function () {
        return this.edges.length
      }),
      (e.prototype.inDegree = function () {
        return this.inEdges.length
      }),
      (e.prototype.outDegree = function () {
        return this.outEdges.length
      }),
      (e.prototype.getModel = function (e) {
        if (!(this.dataIndex < 0))
          return this.hostGraph.data.getItemModel(this.dataIndex).getModel(e)
      }),
      (e.prototype.getAdjacentDataIndices = function () {
        for (var e = { edge: [], node: [] }, t = 0; t < this.edges.length; t++) {
          var i = this.edges[t]
          i.dataIndex < 0 ||
            (e.edge.push(i.dataIndex), e.node.push(i.node1.dataIndex, i.node2.dataIndex))
        }
        return e
      }),
      e
    )
  })(),
  GraphEdge = (function () {
    function e(e, t, i) {
      ;(this.dataIndex = -1),
        (this.node1 = e),
        (this.node2 = t),
        (this.dataIndex = null == i ? -1 : i)
    }
    return (
      (e.prototype.getModel = function (e) {
        if (!(this.dataIndex < 0))
          return this.hostGraph.edgeData.getItemModel(this.dataIndex).getModel(e)
      }),
      (e.prototype.getAdjacentDataIndices = function () {
        return { edge: [this.dataIndex], node: [this.node1.dataIndex, this.node2.dataIndex] }
      }),
      e
    )
  })()
function createGraphDataProxyMixin(e, t) {
  return {
    getValue: function (i) {
      var r = this[e][t]
      return r.get(r.getDimension(i || 'value'), this.dataIndex)
    },
    setVisual: function (i, r) {
      this.dataIndex >= 0 && this[e][t].setItemVisual(this.dataIndex, i, r)
    },
    getVisual: function (i) {
      return this[e][t].getItemVisual(this.dataIndex, i)
    },
    setLayout: function (i, r) {
      this.dataIndex >= 0 && this[e][t].setItemLayout(this.dataIndex, i, r)
    },
    getLayout: function () {
      return this[e][t].getItemLayout(this.dataIndex)
    },
    getGraphicEl: function () {
      return this[e][t].getItemGraphicEl(this.dataIndex)
    },
    getRawIndex: function () {
      return this[e][t].getRawIndex(this.dataIndex)
    }
  }
}
function createGraphFromNodeEdge(e, t, i, r, n) {
  for (var a = new Graph(r), o = 0; o < e.length; o++) a.addNode(retrieve(e[o].id, e[o].name, o), o)
  var s = [],
    l = [],
    h = 0
  for (o = 0; o < t.length; o++) {
    var u = t[o],
      p = u.source,
      c = u.target
    a.addEdge(p, c, h) &&
      (l.push(u), s.push(retrieve(convertOptionIdName(u.id, null), p + ' > ' + c)), h++)
  }
  var d,
    f = i.get('coordinateSystem')
  if ('cartesian2d' === f || 'polar' === f) d = createListFromArray(e, i)
  else {
    var m = CoordinateSystemManager.get(f),
      g = (m && m.dimensions) || []
    indexOf$1(g, 'value') < 0 && g.concat(['value'])
    var y = createDimensions(e, { coordDimensions: g })
    ;(d = new List(y, i)).initData(e)
  }
  var v = new List(['value'], i)
  return (
    v.initData(l, s),
    n && n(d, v),
    linkList({
      mainData: d,
      struct: a,
      structAttr: 'graph',
      datas: { node: d, edge: v },
      datasAttr: { node: 'data', edge: 'edgeData' }
    }),
    a.update(),
    a
  )
}
mixin(GraphNode, createGraphDataProxyMixin('hostGraph', 'data')),
  mixin(GraphEdge, createGraphDataProxyMixin('hostGraph', 'edgeData'))
var GraphSeriesModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.hasSymbolVisual = !0), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (t) {
        e.prototype.init.apply(this, arguments)
        var i = this
        function r() {
          return i._categoriesData
        }
        ;(this.legendVisualProvider = new LegendVisualProvider(r, r)),
          this.fillDataTextStyle(t.edges || t.links),
          this._updateCategoriesData()
      }),
      (t.prototype.mergeOption = function (t) {
        e.prototype.mergeOption.apply(this, arguments),
          this.fillDataTextStyle(t.edges || t.links),
          this._updateCategoriesData()
      }),
      (t.prototype.mergeDefaultAndTheme = function (t) {
        e.prototype.mergeDefaultAndTheme.apply(this, arguments),
          defaultEmphasis(t, 'edgeLabel', ['show'])
      }),
      (t.prototype.getInitialData = function (e, t) {
        var i = e.edges || e.links || [],
          r = e.data || e.nodes || [],
          n = this
        if (r && i) {
          initCurvenessList(this)
          var a = createGraphFromNodeEdge(r, i, this, !0, function (e, t) {
            e.wrapMethod('getItemModel', function (e) {
              var t = n._categoriesModels[e.getShallow('category')]
              return t && ((t.parentModel = e.parentModel), (e.parentModel = t)), e
            })
            var i = Model.prototype.getModel
            function r(e, t) {
              var r = i.call(this, e, t)
              return (r.resolveParentPath = a), r
            }
            function a(e) {
              if (e && ('label' === e[0] || 'label' === e[1])) {
                var t = e.slice()
                return (
                  'label' === e[0]
                    ? (t[0] = 'edgeLabel')
                    : 'label' === e[1] && (t[1] = 'edgeLabel'),
                  t
                )
              }
              return e
            }
            t.wrapMethod('getItemModel', function (e) {
              return (e.resolveParentPath = a), (e.getModel = r), e
            })
          })
          return (
            each$i(
              a.edges,
              function (e) {
                createEdgeMapForCurveness(e.node1, e.node2, this, e.dataIndex)
              },
              this
            ),
            a.data
          )
        }
      }),
      (t.prototype.getGraph = function () {
        return this.getData().graph
      }),
      (t.prototype.getEdgeData = function () {
        return this.getGraph().edgeData
      }),
      (t.prototype.getCategoriesData = function () {
        return this._categoriesData
      }),
      (t.prototype.formatTooltip = function (e, t, i) {
        if ('edge' === i) {
          var r = this.getData(),
            n = this.getDataParams(e, i),
            a = r.graph.getEdgeByIndex(e),
            o = r.getName(a.node1.dataIndex),
            s = r.getName(a.node2.dataIndex),
            l = []
          return (
            null != o && l.push(o),
            null != s && l.push(s),
            createTooltipMarkup('nameValue', {
              name: l.join(' > '),
              value: n.value,
              noValue: null == n.value
            })
          )
        }
        return defaultSeriesFormatTooltip({ series: this, dataIndex: e, multipleSeries: t })
      }),
      (t.prototype._updateCategoriesData = function () {
        var e = map$1(this.option.categories || [], function (e) {
            return null != e.value ? e : extend$3({ value: 0 }, e)
          }),
          t = new List(['value'], this)
        t.initData(e),
          (this._categoriesData = t),
          (this._categoriesModels = t.mapArray(function (e) {
            return t.getItemModel(e)
          }))
      }),
      (t.prototype.setZoom = function (e) {
        this.option.zoom = e
      }),
      (t.prototype.setCenter = function (e) {
        this.option.center = e
      }),
      (t.prototype.isAnimationEnabled = function () {
        return (
          e.prototype.isAnimationEnabled.call(this) &&
          !('force' === this.get('layout') && this.get(['force', 'layoutAnimation']))
        )
      }),
      (t.type = 'series.graph'),
      (t.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar']),
      (t.defaultOption = {
        zlevel: 0,
        z: 2,
        coordinateSystem: 'view',
        legendHoverLink: !0,
        layout: null,
        circular: { rotateLabel: !1 },
        force: {
          initLayout: null,
          repulsion: [0, 50],
          gravity: 0.1,
          friction: 0.6,
          edgeLength: 30,
          layoutAnimation: !0
        },
        left: 'center',
        top: 'center',
        symbol: 'circle',
        symbolSize: 10,
        edgeSymbol: ['none', 'none'],
        edgeSymbolSize: 10,
        edgeLabel: { position: 'middle', distance: 5 },
        draggable: !1,
        roam: !1,
        center: null,
        zoom: 1,
        nodeScaleRatio: 0.6,
        label: { show: !1, formatter: '{b}' },
        itemStyle: {},
        lineStyle: { color: '#aaa', width: 1, opacity: 0.5 },
        emphasis: { scale: !0, label: { show: !0 } },
        select: { itemStyle: { borderColor: '#212121' } }
      }),
      t
    )
  })(SeriesModel),
  actionInfo$1 = { type: 'graphRoam', event: 'graphRoam', update: 'none' }
function install$F(e) {
  e.registerChartView(GraphView),
    e.registerSeriesModel(GraphSeriesModel),
    e.registerProcessor(categoryFilter),
    e.registerVisual(categoryVisual),
    e.registerVisual(graphEdgeVisual),
    e.registerLayout(graphSimpleLayout),
    e.registerLayout(e.PRIORITY.VISUAL.POST_CHART_LAYOUT, graphCircularLayout),
    e.registerLayout(graphForceLayout),
    e.registerCoordinateSystem('graphView', {
      dimensions: View.dimensions,
      create: createViewCoordSys
    }),
    e.registerAction(
      {
        type: 'focusNodeAdjacency',
        event: 'focusNodeAdjacency',
        update: 'series:focusNodeAdjacency'
      },
      function () {}
    ),
    e.registerAction(
      {
        type: 'unfocusNodeAdjacency',
        event: 'unfocusNodeAdjacency',
        update: 'series:unfocusNodeAdjacency'
      },
      function () {}
    ),
    e.registerAction(actionInfo$1, function (e, t) {
      t.eachComponent({ mainType: 'series', query: e }, function (t) {
        var i = updateCenterAndZoom(t.coordinateSystem, e)
        t.setCenter && t.setCenter(i.center), t.setZoom && t.setZoom(i.zoom)
      })
    })
}
var PointerShape = function () {
    ;(this.angle = 0), (this.width = 10), (this.r = 10), (this.x = 0), (this.y = 0)
  },
  PointerPath = (function (e) {
    function t(t) {
      var i = e.call(this, t) || this
      return (i.type = 'pointer'), i
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultShape = function () {
        return new PointerShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        var i = Math.cos,
          r = Math.sin,
          n = t.r,
          a = t.width,
          o = t.angle,
          s = t.x - i(o) * a * (a >= n / 3 ? 1 : 2),
          l = t.y - r(o) * a * (a >= n / 3 ? 1 : 2)
        ;(o = t.angle - Math.PI / 2),
          e.moveTo(s, l),
          e.lineTo(t.x + i(o) * a, t.y + r(o) * a),
          e.lineTo(t.x + i(t.angle) * n, t.y + r(t.angle) * n),
          e.lineTo(t.x - i(o) * a, t.y - r(o) * a),
          e.lineTo(s, l)
      }),
      t
    )
  })(Path)
function parsePosition(e, t) {
  var i = e.get('center'),
    r = t.getWidth(),
    n = t.getHeight(),
    a = Math.min(r, n)
  return {
    cx: parsePercent$1(i[0], t.getWidth()),
    cy: parsePercent$1(i[1], t.getHeight()),
    r: parsePercent$1(e.get('radius'), a / 2)
  }
}
function formatLabel(e, t) {
  var i = null == e ? '' : e + ''
  return (
    t &&
      ('string' == typeof t ? (i = t.replace('{value}', i)) : 'function' == typeof t && (i = t(e))),
    i
  )
}
var PI2$1 = 2 * Math.PI,
  GaugeView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i) {
        this.group.removeAll()
        var r = e.get(['axisLine', 'lineStyle', 'color']),
          n = parsePosition(e, i)
        this._renderMain(e, t, i, r, n), (this._data = e.getData())
      }),
      (t.prototype.dispose = function () {}),
      (t.prototype._renderMain = function (e, t, i, r, n) {
        for (
          var a = this.group,
            o = e.get('clockwise'),
            s = (-e.get('startAngle') / 180) * Math.PI,
            l = (-e.get('endAngle') / 180) * Math.PI,
            h = e.getModel('axisLine'),
            u = h.get('roundCap') ? SausagePath : Sector,
            p = h.get('show'),
            c = h.getModel('lineStyle'),
            d = c.get('width'),
            f = (l - s) % PI2$1 || l === s ? (l - s) % PI2$1 : PI2$1,
            m = s,
            g = 0;
          p && g < r.length;
          g++
        ) {
          var y = new u({
            shape: {
              startAngle: m,
              endAngle: (l = s + f * Math.min(Math.max(r[g][0], 0), 1)),
              cx: n.cx,
              cy: n.cy,
              clockwise: o,
              r0: n.r - d,
              r: n.r
            },
            silent: !0
          })
          y.setStyle({ fill: r[g][1] }),
            y.setStyle(c.getLineStyle(['color', 'width'])),
            a.add(y),
            (m = l)
        }
        var v = function (e) {
          if (e <= 0) return r[0][1]
          var t
          for (t = 0; t < r.length; t++)
            if (r[t][0] >= e && (0 === t ? 0 : r[t - 1][0]) < e) return r[t][1]
          return r[t - 1][1]
        }
        if (!o) {
          var _ = s
          ;(s = l), (l = _)
        }
        this._renderTicks(e, t, i, v, n, s, l, o, d),
          this._renderTitleAndDetail(e, t, i, v, n),
          this._renderAnchor(e, n),
          this._renderPointer(e, t, i, v, n, s, l, o, d)
      }),
      (t.prototype._renderTicks = function (e, t, i, r, n, a, o, s, l) {
        for (
          var h,
            u,
            p = this.group,
            c = n.cx,
            d = n.cy,
            f = n.r,
            m = +e.get('min'),
            g = +e.get('max'),
            y = e.getModel('splitLine'),
            v = e.getModel('axisTick'),
            _ = e.getModel('axisLabel'),
            x = e.get('splitNumber'),
            S = v.get('splitNumber'),
            b = parsePercent$1(y.get('length'), f),
            T = parsePercent$1(v.get('length'), f),
            A = a,
            w = (o - a) / x,
            M = w / S,
            C = y.getModel('lineStyle').getLineStyle(),
            P = v.getModel('lineStyle').getLineStyle(),
            E = y.get('distance'),
            I = 0;
          I <= x;
          I++
        ) {
          if (((h = Math.cos(A)), (u = Math.sin(A)), y.get('show'))) {
            var D = new Line$1({
              shape: {
                x1: h * (f - (L = E ? E + l : l)) + c,
                y1: u * (f - L) + d,
                x2: h * (f - b - L) + c,
                y2: u * (f - b - L) + d
              },
              style: C,
              silent: !0
            })
            'auto' === C.stroke && D.setStyle({ stroke: r(I / x) }), p.add(D)
          }
          if (_.get('show')) {
            var L = _.get('distance') + E,
              R = formatLabel(round$2((I / x) * (g - m) + m), _.get('formatter')),
              O = r(I / x)
            p.add(
              new ZRText({
                style: createTextStyle(
                  _,
                  {
                    text: R,
                    x: h * (f - b - L) + c,
                    y: u * (f - b - L) + d,
                    verticalAlign: u < -0.8 ? 'top' : u > 0.8 ? 'bottom' : 'middle',
                    align: h < -0.4 ? 'left' : h > 0.4 ? 'right' : 'center'
                  },
                  { inheritColor: O }
                ),
                silent: !0
              })
            )
          }
          if (v.get('show') && I !== x) {
            L = (L = v.get('distance')) ? L + l : l
            for (var k = 0; k <= S; k++) {
              ;(h = Math.cos(A)), (u = Math.sin(A))
              var $ = new Line$1({
                shape: {
                  x1: h * (f - L) + c,
                  y1: u * (f - L) + d,
                  x2: h * (f - T - L) + c,
                  y2: u * (f - T - L) + d
                },
                silent: !0,
                style: P
              })
              'auto' === P.stroke && $.setStyle({ stroke: r((I + k / S) / x) }), p.add($), (A += M)
            }
            A -= M
          } else A += w
        }
      }),
      (t.prototype._renderPointer = function (e, t, i, r, n, a, o, s, l) {
        var h = this.group,
          u = this._data,
          p = this._progressEls,
          c = [],
          d = e.get(['pointer', 'show']),
          f = e.getModel('progress'),
          m = f.get('show'),
          g = e.getData(),
          y = g.mapDimension('value'),
          v = +e.get('min'),
          _ = +e.get('max'),
          x = [v, _],
          S = [a, o]
        function b(t, i) {
          var r,
            a = g.getItemModel(t).getModel('pointer'),
            o = parsePercent$1(a.get('width'), n.r),
            s = parsePercent$1(a.get('length'), n.r),
            l = e.get(['pointer', 'icon']),
            h = a.get('offsetCenter'),
            u = parsePercent$1(h[0], n.r),
            p = parsePercent$1(h[1], n.r),
            c = a.get('keepAspect')
          return (
            ((r = l
              ? createSymbol$1(l, u - o / 2, p - s, o, s, null, c)
              : new PointerPath({
                  shape: { angle: -Math.PI / 2, width: o, r: s, x: u, y: p }
                })).rotation = -(i + Math.PI / 2)),
            (r.x = n.cx),
            (r.y = n.cy),
            r
          )
        }
        function T(e, t) {
          var i = f.get('roundCap') ? SausagePath : Sector,
            r = f.get('overlap'),
            o = r ? f.get('width') : l / g.count(),
            h = r ? n.r - o : n.r - (e + 1) * o,
            u = r ? n.r : n.r - e * o,
            p = new i({
              shape: { startAngle: a, endAngle: t, cx: n.cx, cy: n.cy, clockwise: s, r0: h, r: u }
            })
          return r && (p.z2 = _ - (g.get(y, e) % _)), p
        }
        ;(m || d) &&
          (g
            .diff(u)
            .add(function (t) {
              if (d) {
                var i = b(t, a)
                initProps(i, { rotation: -(linearMap$2(g.get(y, t), x, S, !0) + Math.PI / 2) }, e),
                  h.add(i),
                  g.setItemGraphicEl(t, i)
              }
              if (m) {
                var r = T(t, a),
                  n = f.get('clip')
                initProps(r, { shape: { endAngle: linearMap$2(g.get(y, t), x, S, n) } }, e),
                  h.add(r),
                  (c[t] = r)
              }
            })
            .update(function (t, i) {
              if (d) {
                var r = u.getItemGraphicEl(i),
                  n = r ? r.rotation : a,
                  o = b(t, n)
                ;(o.rotation = n),
                  updateProps$1(
                    o,
                    { rotation: -(linearMap$2(g.get(y, t), x, S, !0) + Math.PI / 2) },
                    e
                  ),
                  h.add(o),
                  g.setItemGraphicEl(t, o)
              }
              if (m) {
                var s = p[i],
                  l = T(t, s ? s.shape.endAngle : a),
                  v = f.get('clip')
                updateProps$1(l, { shape: { endAngle: linearMap$2(g.get(y, t), x, S, v) } }, e),
                  h.add(l),
                  (c[t] = l)
              }
            })
            .execute(),
          g.each(function (e) {
            var t = g.getItemModel(e),
              i = t.getModel('emphasis')
            if (d) {
              var n = g.getItemGraphicEl(e),
                a = g.getItemVisual(e, 'style'),
                o = a.fill
              if (n instanceof ZRImage) {
                var s = n.style
                n.useStyle(
                  extend$3({ image: s.image, x: s.x, y: s.y, width: s.width, height: s.height }, a)
                )
              } else n.useStyle(a), 'pointer' !== n.type && n.setColor(o)
              n.setStyle(t.getModel(['pointer', 'itemStyle']).getItemStyle()),
                'auto' === n.style.fill &&
                  n.setStyle('fill', r(linearMap$2(g.get(y, e), x, [0, 1], !0))),
                (n.z2EmphasisLift = 0),
                setStatesStylesFromModel(n, t),
                enableHoverEmphasis(n, i.get('focus'), i.get('blurScope'))
            }
            if (m) {
              var l = c[e]
              l.useStyle(g.getItemVisual(e, 'style')),
                l.setStyle(t.getModel(['progress', 'itemStyle']).getItemStyle()),
                (l.z2EmphasisLift = 0),
                setStatesStylesFromModel(l, t),
                enableHoverEmphasis(l, i.get('focus'), i.get('blurScope'))
            }
          }),
          (this._progressEls = c))
      }),
      (t.prototype._renderAnchor = function (e, t) {
        var i = e.getModel('anchor')
        if (i.get('show')) {
          var r = i.get('size'),
            n = i.get('icon'),
            a = i.get('offsetCenter'),
            o = i.get('keepAspect'),
            s = createSymbol$1(
              n,
              t.cx - r / 2 + parsePercent$1(a[0], t.r),
              t.cy - r / 2 + parsePercent$1(a[1], t.r),
              r,
              r,
              null,
              o
            )
          ;(s.z2 = i.get('showAbove') ? 1 : 0),
            s.setStyle(i.getModel('itemStyle').getItemStyle()),
            this.group.add(s)
        }
      }),
      (t.prototype._renderTitleAndDetail = function (e, t, i, r, n) {
        var a = this,
          o = e.getData(),
          s = o.mapDimension('value'),
          l = +e.get('min'),
          h = +e.get('max'),
          u = new Group$3(),
          p = [],
          c = [],
          d = e.isAnimationEnabled()
        o
          .diff(this._data)
          .add(function (e) {
            ;(p[e] = new ZRText({ silent: !0 })), (c[e] = new ZRText({ silent: !0 }))
          })
          .update(function (e, t) {
            ;(p[e] = a._titleEls[t]), (c[e] = a._detailEls[t])
          })
          .execute(),
          o.each(function (t) {
            var i = o.getItemModel(t),
              a = o.get(s, t),
              f = new Group$3(),
              m = r(linearMap$2(a, [l, h], [0, 1], !0)),
              g = i.getModel('title')
            if (g.get('show')) {
              var y = g.get('offsetCenter'),
                v = n.cx + parsePercent$1(y[0], n.r),
                _ = n.cy + parsePercent$1(y[1], n.r)
              ;(C = p[t]).attr({
                style: createTextStyle(
                  g,
                  { x: v, y: _, text: o.getName(t), align: 'center', verticalAlign: 'middle' },
                  { inheritColor: m }
                )
              }),
                f.add(C)
            }
            var x = i.getModel('detail')
            if (x.get('show')) {
              var S = x.get('offsetCenter'),
                b = n.cx + parsePercent$1(S[0], n.r),
                T = n.cy + parsePercent$1(S[1], n.r),
                A = parsePercent$1(x.get('width'), n.r),
                w = parsePercent$1(x.get('height'), n.r),
                M = e.get(['progress', 'show']) ? o.getItemVisual(t, 'style').fill : m,
                C = c[t],
                P = x.get('formatter')
              C.attr({
                style: createTextStyle(
                  x,
                  {
                    x: b,
                    y: T,
                    text: formatLabel(a, P),
                    width: isNaN(A) ? null : A,
                    height: isNaN(w) ? null : w,
                    align: 'center',
                    verticalAlign: 'middle'
                  },
                  { inheritColor: M }
                )
              }),
                setLabelValueAnimation(C, { normal: x }, a, function (e) {
                  return formatLabel(e, P)
                }),
                d &&
                  animateLabelValue(C, t, o, e, {
                    getFormattedLabel: function (e, t, i, r, n, o) {
                      return formatLabel(o ? o.interpolatedValue : a, P)
                    }
                  }),
                f.add(C)
            }
            u.add(f)
          }),
          this.group.add(u),
          (this._titleEls = p),
          (this._detailEls = c)
      }),
      (t.type = 'gauge'),
      t
    )
  })(ChartView),
  GaugeSeriesModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (
        (i.type = t.type),
        (i.visualStyleAccessPath = 'itemStyle'),
        (i.useColorPaletteOnData = !0),
        i
      )
    }
    return (
      __extends(t, e),
      (t.prototype.getInitialData = function (e, t) {
        return createListSimply(this, ['value'])
      }),
      (t.type = 'series.gauge'),
      (t.defaultOption = {
        zlevel: 0,
        z: 2,
        center: ['50%', '50%'],
        legendHoverLink: !0,
        radius: '75%',
        startAngle: 225,
        endAngle: -45,
        clockwise: !0,
        min: 0,
        max: 100,
        splitNumber: 10,
        axisLine: { show: !0, roundCap: !1, lineStyle: { color: [[1, '#E6EBF8']], width: 10 } },
        progress: { show: !1, overlap: !0, width: 10, roundCap: !1, clip: !0 },
        splitLine: {
          show: !0,
          length: 10,
          distance: 10,
          lineStyle: { color: '#63677A', width: 3, type: 'solid' }
        },
        axisTick: {
          show: !0,
          splitNumber: 5,
          length: 6,
          distance: 10,
          lineStyle: { color: '#63677A', width: 1, type: 'solid' }
        },
        axisLabel: { show: !0, distance: 15, color: '#464646', fontSize: 12 },
        pointer: {
          icon: null,
          offsetCenter: [0, 0],
          show: !0,
          length: '60%',
          width: 6,
          keepAspect: !1
        },
        anchor: {
          show: !1,
          showAbove: !1,
          size: 6,
          icon: 'circle',
          offsetCenter: [0, 0],
          keepAspect: !1,
          itemStyle: { color: '#fff', borderWidth: 0, borderColor: '#5470c6' }
        },
        title: {
          show: !0,
          offsetCenter: [0, '20%'],
          color: '#464646',
          fontSize: 16,
          valueAnimation: !1
        },
        detail: {
          show: !0,
          backgroundColor: 'rgba(0,0,0,0)',
          borderWidth: 0,
          borderColor: '#ccc',
          width: 100,
          height: null,
          padding: [5, 10],
          offsetCenter: [0, '40%'],
          color: '#464646',
          fontSize: 30,
          fontWeight: 'bold',
          lineHeight: 30,
          valueAnimation: !1
        }
      }),
      t
    )
  })(SeriesModel)
function install$E(e) {
  e.registerChartView(GaugeView), e.registerSeriesModel(GaugeSeriesModel)
}
var opacityAccessPath$1 = ['itemStyle', 'opacity'],
  FunnelPiece = (function (e) {
    function t(t, i) {
      var r = e.call(this) || this,
        n = r,
        a = new Polyline$1(),
        o = new ZRText()
      return n.setTextContent(o), r.setTextGuideLine(a), r.updateData(t, i, !0), r
    }
    return (
      __extends(t, e),
      (t.prototype.updateData = function (e, t, i) {
        var r = this,
          n = e.hostModel,
          a = e.getItemModel(t),
          o = e.getItemLayout(t),
          s = a.getModel('emphasis'),
          l = a.get(opacityAccessPath$1)
        ;(l = null == l ? 1 : l),
          r.useStyle(e.getItemVisual(t, 'style')),
          (r.style.lineJoin = 'round'),
          i
            ? (r.setShape({ points: o.points }),
              (r.style.opacity = 0),
              initProps(r, { style: { opacity: l } }, n, t))
            : updateProps$1(r, { style: { opacity: l }, shape: { points: o.points } }, n, t),
          setStatesStylesFromModel(r, a),
          this._updateLabel(e, t),
          enableHoverEmphasis(this, s.get('focus'), s.get('blurScope'))
      }),
      (t.prototype._updateLabel = function (e, t) {
        var i = this,
          r = this.getTextGuideLine(),
          n = i.getTextContent(),
          a = e.hostModel,
          o = e.getItemModel(t),
          s = e.getItemLayout(t).label,
          l = e.getItemVisual(t, 'style'),
          h = l.fill
        setLabelStyle(
          n,
          getLabelStatesModels(o),
          {
            labelFetcher: e.hostModel,
            labelDataIndex: t,
            defaultOpacity: l.opacity,
            defaultText: e.getName(t)
          },
          { normal: { align: s.textAlign, verticalAlign: s.verticalAlign } }
        ),
          i.setTextConfig({ local: !0, inside: !!s.inside, insideStroke: h, outsideFill: h })
        var u = s.linePoints
        r.setShape({ points: u }),
          (i.textGuideLineConfig = { anchor: u ? new Point(u[0][0], u[0][1]) : null }),
          updateProps$1(n, { style: { x: s.x, y: s.y } }, a, t),
          n.attr({ rotation: s.rotation, originX: s.x, originY: s.y, z2: 10 }),
          setLabelLineStyle(i, getLabelLineStatesModels(o), { stroke: h })
      }),
      t
    )
  })(Polygon),
  FunnelView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.ignoreLabelLineUpdate = !0), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i) {
        var r = e.getData(),
          n = this._data,
          a = this.group
        r
          .diff(n)
          .add(function (e) {
            var t = new FunnelPiece(r, e)
            r.setItemGraphicEl(e, t), a.add(t)
          })
          .update(function (e, t) {
            var i = n.getItemGraphicEl(t)
            i.updateData(r, e), a.add(i), r.setItemGraphicEl(e, i)
          })
          .remove(function (t) {
            removeElementWithFadeOut(n.getItemGraphicEl(t), e, t)
          })
          .execute(),
          (this._data = r)
      }),
      (t.prototype.remove = function () {
        this.group.removeAll(), (this._data = null)
      }),
      (t.prototype.dispose = function () {}),
      (t.type = 'funnel'),
      t
    )
  })(ChartView),
  FunnelSeriesModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.useColorPaletteOnData = !0), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (t) {
        e.prototype.init.apply(this, arguments),
          (this.legendVisualProvider = new LegendVisualProvider(
            bind$2(this.getData, this),
            bind$2(this.getRawData, this)
          )),
          this._defaultLabelLine(t)
      }),
      (t.prototype.getInitialData = function (e, t) {
        return createListSimply(this, {
          coordDimensions: ['value'],
          encodeDefaulter: curry$1(makeSeriesEncodeForNameBased, this)
        })
      }),
      (t.prototype._defaultLabelLine = function (e) {
        defaultEmphasis(e, 'labelLine', ['show'])
        var t = e.labelLine,
          i = e.emphasis.labelLine
        ;(t.show = t.show && e.label.show), (i.show = i.show && e.emphasis.label.show)
      }),
      (t.prototype.getDataParams = function (t) {
        var i = this.getData(),
          r = e.prototype.getDataParams.call(this, t),
          n = i.mapDimension('value'),
          a = i.getSum(n)
        return (
          (r.percent = a ? +((i.get(n, t) / a) * 100).toFixed(2) : 0), r.$vars.push('percent'), r
        )
      }),
      (t.type = 'series.funnel'),
      (t.defaultOption = {
        zlevel: 0,
        z: 2,
        legendHoverLink: !0,
        left: 80,
        top: 60,
        right: 80,
        bottom: 60,
        minSize: '0%',
        maxSize: '100%',
        sort: 'descending',
        orient: 'vertical',
        gap: 0,
        funnelAlign: 'center',
        label: { show: !0, position: 'outer' },
        labelLine: { show: !0, length: 20, lineStyle: { width: 1 } },
        itemStyle: { borderColor: '#fff', borderWidth: 1 },
        emphasis: { label: { show: !0 } },
        select: { itemStyle: { borderColor: '#212121' } }
      }),
      t
    )
  })(SeriesModel)
function getViewRect$2(e, t) {
  return getLayoutRect(e.getBoxLayoutParams(), { width: t.getWidth(), height: t.getHeight() })
}
function getSortedIndices(e, t) {
  for (
    var i = e.mapDimension('value'),
      r = e.mapArray(i, function (e) {
        return e
      }),
      n = [],
      a = 'ascending' === t,
      o = 0,
      s = e.count();
    o < s;
    o++
  )
    n[o] = o
  return (
    'function' == typeof t
      ? n.sort(t)
      : 'none' !== t &&
        n.sort(function (e, t) {
          return a ? r[e] - r[t] : r[t] - r[e]
        }),
    n
  )
}
function labelLayout(e) {
  var t = e.hostModel.get('orient')
  e.each(function (i) {
    var r,
      n,
      a,
      o,
      s = e.getItemModel(i),
      l = s.getModel('label').get('position'),
      h = s.getModel('labelLine'),
      u = e.getItemLayout(i),
      p = u.points,
      c =
        'inner' === l ||
        'inside' === l ||
        'center' === l ||
        'insideLeft' === l ||
        'insideRight' === l
    if (c)
      'insideLeft' === l
        ? ((n = (p[0][0] + p[3][0]) / 2 + 5), (a = (p[0][1] + p[3][1]) / 2), (r = 'left'))
        : 'insideRight' === l
        ? ((n = (p[1][0] + p[2][0]) / 2 - 5), (a = (p[1][1] + p[2][1]) / 2), (r = 'right'))
        : ((n = (p[0][0] + p[1][0] + p[2][0] + p[3][0]) / 4),
          (a = (p[0][1] + p[1][1] + p[2][1] + p[3][1]) / 4),
          (r = 'center')),
        (o = [
          [n, a],
          [n, a]
        ])
    else {
      var d = void 0,
        f = void 0,
        m = void 0,
        g = void 0,
        y = h.get('length')
      'left' === l
        ? ((d = (p[3][0] + p[0][0]) / 2),
          (f = (p[3][1] + p[0][1]) / 2),
          (n = (m = d - y) - 5),
          (r = 'right'))
        : 'right' === l
        ? ((d = (p[1][0] + p[2][0]) / 2),
          (f = (p[1][1] + p[2][1]) / 2),
          (n = (m = d + y) + 5),
          (r = 'left'))
        : 'top' === l
        ? ((d = (p[3][0] + p[0][0]) / 2),
          (a = (g = (f = (p[3][1] + p[0][1]) / 2) - y) - 5),
          (r = 'center'))
        : 'bottom' === l
        ? ((d = (p[1][0] + p[2][0]) / 2),
          (a = (g = (f = (p[1][1] + p[2][1]) / 2) + y) + 5),
          (r = 'center'))
        : 'rightTop' === l
        ? ((d = 'horizontal' === t ? p[3][0] : p[1][0]),
          (f = 'horizontal' === t ? p[3][1] : p[1][1]),
          'horizontal' === t
            ? ((a = (g = f - y) - 5), (r = 'center'))
            : ((n = (m = d + y) + 5), (r = 'top')))
        : 'rightBottom' === l
        ? ((d = p[2][0]),
          (f = p[2][1]),
          'horizontal' === t
            ? ((a = (g = f + y) + 5), (r = 'center'))
            : ((n = (m = d + y) + 5), (r = 'bottom')))
        : 'leftTop' === l
        ? ((d = p[0][0]),
          (f = 'horizontal' === t ? p[0][1] : p[1][1]),
          'horizontal' === t
            ? ((a = (g = f - y) - 5), (r = 'center'))
            : ((n = (m = d - y) - 5), (r = 'right')))
        : 'leftBottom' === l
        ? ((d = 'horizontal' === t ? p[1][0] : p[3][0]),
          (f = 'horizontal' === t ? p[1][1] : p[2][1]),
          'horizontal' === t
            ? ((a = (g = f + y) + 5), (r = 'center'))
            : ((n = (m = d - y) - 5), (r = 'right')))
        : ((d = (p[1][0] + p[2][0]) / 2),
          (f = (p[1][1] + p[2][1]) / 2),
          'horizontal' === t
            ? ((a = (g = f + y) + 5), (r = 'center'))
            : ((n = (m = d + y) + 5), (r = 'left'))),
        'horizontal' === t ? (n = m = d) : (a = g = f),
        (o = [
          [d, f],
          [m, g]
        ])
    }
    u.label = { linePoints: o, x: n, y: a, verticalAlign: 'middle', textAlign: r, inside: c }
  })
}
function funnelLayout(e, t) {
  e.eachSeriesByType('funnel', function (e) {
    var i = e.getData(),
      r = i.mapDimension('value'),
      n = e.get('sort'),
      a = getViewRect$2(e, t),
      o = e.get('orient'),
      s = a.width,
      l = a.height,
      h = getSortedIndices(i, n),
      u = a.x,
      p = a.y,
      c =
        'horizontal' === o
          ? [parsePercent$1(e.get('minSize'), l), parsePercent$1(e.get('maxSize'), l)]
          : [parsePercent$1(e.get('minSize'), s), parsePercent$1(e.get('maxSize'), s)],
      d = i.getDataExtent(r),
      f = e.get('min'),
      m = e.get('max')
    null == f && (f = Math.min(d[0], 0)), null == m && (m = d[1])
    var g = e.get('funnelAlign'),
      y = e.get('gap'),
      v = (('horizontal' === o ? s : l) - y * (i.count() - 1)) / i.count(),
      _ = function (e, t) {
        if ('horizontal' === o) {
          var n = linearMap$2(i.get(r, e) || 0, [f, m], c, !0),
            a = void 0
          switch (g) {
            case 'top':
              a = p
              break
            case 'center':
              a = p + (l - n) / 2
              break
            case 'bottom':
              a = p + (l - n)
          }
          return [
            [t, a],
            [t, a + n]
          ]
        }
        var h,
          d = linearMap$2(i.get(r, e) || 0, [f, m], c, !0)
        switch (g) {
          case 'left':
            h = u
            break
          case 'center':
            h = u + (s - d) / 2
            break
          case 'right':
            h = u + s - d
        }
        return [
          [h, t],
          [h + d, t]
        ]
      }
    'ascending' === n &&
      ((v = -v), (y = -y), 'horizontal' === o ? (u += s) : (p += l), (h = h.reverse()))
    for (var x = 0; x < h.length; x++) {
      var S = h[x],
        b = h[x + 1],
        T = i.getItemModel(S)
      if ('horizontal' === o) {
        var A = T.get(['itemStyle', 'width'])
        null == A ? (A = v) : ((A = parsePercent$1(A, s)), 'ascending' === n && (A = -A))
        var w = _(S, u),
          M = _(b, u + A)
        ;(u += A + y), i.setItemLayout(S, { points: w.concat(M.slice().reverse()) })
      } else {
        var C = T.get(['itemStyle', 'height'])
        null == C ? (C = v) : ((C = parsePercent$1(C, l)), 'ascending' === n && (C = -C))
        ;(w = _(S, p)), (M = _(b, p + C))
        ;(p += C + y), i.setItemLayout(S, { points: w.concat(M.slice().reverse()) })
      }
    }
    labelLayout(i)
  })
}
function install$D(e) {
  e.registerChartView(FunnelView),
    e.registerSeriesModel(FunnelSeriesModel),
    e.registerLayout(funnelLayout),
    e.registerProcessor(dataFilter$1('funnel'))
}
var DEFAULT_SMOOTH = 0.3,
  ParallelView$1 = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i._dataGroup = new Group$3()), (i._initialized = !1), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function () {
        this.group.add(this._dataGroup)
      }),
      (t.prototype.render = function (e, t, i, r) {
        var n = this._dataGroup,
          a = e.getData(),
          o = this._data,
          s = e.coordinateSystem,
          l = s.dimensions,
          h = makeSeriesScope(e)
        if (
          (a
            .diff(o)
            .add(function (e) {
              updateElCommon(addEl(a, n, e, l, s), a, e, h)
            })
            .update(function (t, i) {
              var r = o.getItemGraphicEl(i),
                n = createLinePoints(a, t, l, s)
              a.setItemGraphicEl(t, r),
                updateProps$1(r, { shape: { points: n } }, e, t),
                updateElCommon(r, a, t, h)
            })
            .remove(function (e) {
              var t = o.getItemGraphicEl(e)
              n.remove(t)
            })
            .execute(),
          !this._initialized)
        ) {
          this._initialized = !0
          var u = createGridClipShape$2(s, e, function () {
            setTimeout(function () {
              n.removeClipPath()
            })
          })
          n.setClipPath(u)
        }
        this._data = a
      }),
      (t.prototype.incrementalPrepareRender = function (e, t, i) {
        ;(this._initialized = !0), (this._data = null), this._dataGroup.removeAll()
      }),
      (t.prototype.incrementalRender = function (e, t, i) {
        for (
          var r = t.getData(),
            n = t.coordinateSystem,
            a = n.dimensions,
            o = makeSeriesScope(t),
            s = e.start;
          s < e.end;
          s++
        ) {
          var l = addEl(r, this._dataGroup, s, a, n)
          ;(l.incremental = !0), updateElCommon(l, r, s, o)
        }
      }),
      (t.prototype.remove = function () {
        this._dataGroup && this._dataGroup.removeAll(), (this._data = null)
      }),
      (t.type = 'parallel'),
      t
    )
  })(ChartView)
function createGridClipShape$2(e, t, i) {
  var r = e.model,
    n = e.getRect(),
    a = new Rect$2({ shape: { x: n.x, y: n.y, width: n.width, height: n.height } }),
    o = 'horizontal' === r.get('layout') ? 'width' : 'height'
  return a.setShape(o, 0), initProps(a, { shape: { width: n.width, height: n.height } }, t, i), a
}
function createLinePoints(e, t, i, r) {
  for (var n = [], a = 0; a < i.length; a++) {
    var o = i[a],
      s = e.get(e.mapDimension(o), t)
    isEmptyValue(s, r.getAxis(o).type) || n.push(r.dataToPoint(s, o))
  }
  return n
}
function addEl(e, t, i, r, n) {
  var a = createLinePoints(e, i, r, n),
    o = new Polyline$1({ shape: { points: a }, z2: 10 })
  return t.add(o), e.setItemGraphicEl(i, o), o
}
function makeSeriesScope(e) {
  var t = e.get('smooth', !0)
  return !0 === t && (t = DEFAULT_SMOOTH), eqNaN((t = numericToNumber(t))) && (t = 0), { smooth: t }
}
function updateElCommon(e, t, i, r) {
  e.useStyle(t.getItemVisual(i, 'style')), (e.style.fill = null), e.setShape('smooth', r.smooth)
  var n = t.getItemModel(i),
    a = n.getModel('emphasis')
  setStatesStylesFromModel(e, n, 'lineStyle'),
    enableHoverEmphasis(e, a.get('focus'), a.get('blurScope'))
}
function isEmptyValue(e, t) {
  return 'category' === t ? null == e : null == e || isNaN(e)
}
var ParallelSeriesModel = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (
      (i.type = t.type), (i.visualStyleAccessPath = 'lineStyle'), (i.visualDrawType = 'stroke'), i
    )
  }
  return (
    __extends(t, e),
    (t.prototype.getInitialData = function (e, t) {
      return createListFromArray(this.getSource(), this, {
        useEncodeDefaulter: bind$2(makeDefaultEncode, null, this)
      })
    }),
    (t.prototype.getRawIndicesByActiveState = function (e) {
      var t = this.coordinateSystem,
        i = this.getData(),
        r = []
      return (
        t.eachActiveState(i, function (t, n) {
          e === t && r.push(i.getRawIndex(n))
        }),
        r
      )
    }),
    (t.type = 'series.parallel'),
    (t.dependencies = ['parallel']),
    (t.defaultOption = {
      zlevel: 0,
      z: 2,
      coordinateSystem: 'parallel',
      parallelIndex: 0,
      label: { show: !1 },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: { width: 1, opacity: 0.45, type: 'solid' },
      emphasis: { label: { show: !1 } },
      progressive: 500,
      smooth: !1,
      animationEasing: 'linear'
    }),
    t
  )
})(SeriesModel)
function makeDefaultEncode(e) {
  var t = e.ecModel.getComponent('parallel', e.get('parallelIndex'))
  if (t) {
    var i = {}
    return (
      each$i(t.dimensions, function (e) {
        var t = convertDimNameToNumber(e)
        i[e] = t
      }),
      i
    )
  }
}
function convertDimNameToNumber(e) {
  return +e.replace('dim', '')
}
var opacityAccessPath = ['lineStyle', 'opacity'],
  parallelVisual = {
    seriesType: 'parallel',
    reset: function (e, t) {
      var i = e.coordinateSystem,
        r = {
          normal: e.get(['lineStyle', 'opacity']),
          active: e.get('activeOpacity'),
          inactive: e.get('inactiveOpacity')
        }
      return {
        progress: function (e, t) {
          i.eachActiveState(
            t,
            function (e, i) {
              var n = r[e]
              if ('normal' === e && t.hasItemOption) {
                var a = t.getItemModel(i).get(opacityAccessPath, !0)
                null != a && (n = a)
              }
              t.ensureUniqueItemVisual(i, 'style').opacity = n
            },
            e.start,
            e.end
          )
        }
      }
    }
  }
function parallelPreprocessor(e) {
  createParallelIfNeeded(e), mergeAxisOptionFromParallel(e)
}
function createParallelIfNeeded(e) {
  if (!e.parallel) {
    var t = !1
    each$i(e.series, function (e) {
      e && 'parallel' === e.type && (t = !0)
    }),
      t && (e.parallel = [{}])
  }
}
function mergeAxisOptionFromParallel(e) {
  each$i(normalizeToArray(e.parallelAxis), function (t) {
    if (isObject$7(t)) {
      var i = t.parallelIndex || 0,
        r = normalizeToArray(e.parallel)[i]
      r && r.parallelAxisDefault && merge(t, r.parallelAxisDefault, !1)
    }
  })
}
var CLICK_THRESHOLD = 5,
  ParallelView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i) {
        ;(this._model = e),
          (this._api = i),
          this._handlers ||
            ((this._handlers = {}),
            each$i(
              handlers$1,
              function (e, t) {
                i.getZr().on(t, (this._handlers[t] = bind$2(e, this)))
              },
              this
            )),
          createOrUpdate(this, '_throttledDispatchExpand', e.get('axisExpandRate'), 'fixRate')
      }),
      (t.prototype.dispose = function (e, t) {
        each$i(this._handlers, function (e, i) {
          t.getZr().off(i, e)
        }),
          (this._handlers = null)
      }),
      (t.prototype._throttledDispatchExpand = function (e) {
        this._dispatchExpand(e)
      }),
      (t.prototype._dispatchExpand = function (e) {
        e && this._api.dispatchAction(extend$3({ type: 'parallelAxisExpand' }, e))
      }),
      (t.type = 'parallel'),
      t
    )
  })(ComponentView),
  handlers$1 = {
    mousedown: function (e) {
      checkTrigger(this, 'click') && (this._mouseDownPoint = [e.offsetX, e.offsetY])
    },
    mouseup: function (e) {
      var t = this._mouseDownPoint
      if (checkTrigger(this, 'click') && t) {
        var i = [e.offsetX, e.offsetY]
        if (Math.pow(t[0] - i[0], 2) + Math.pow(t[1] - i[1], 2) > CLICK_THRESHOLD) return
        var r = this._model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY])
        'none' !== r.behavior && this._dispatchExpand({ axisExpandWindow: r.axisExpandWindow })
      }
      this._mouseDownPoint = null
    },
    mousemove: function (e) {
      if (!this._mouseDownPoint && checkTrigger(this, 'mousemove')) {
        var t = this._model,
          i = t.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]),
          r = i.behavior
        'jump' === r && this._throttledDispatchExpand.debounceNextCall(t.get('axisExpandDebounce')),
          this._throttledDispatchExpand(
            'none' === r
              ? null
              : {
                  axisExpandWindow: i.axisExpandWindow,
                  animation: 'jump' === r ? null : { duration: 0 }
                }
          )
      }
    }
  }
function checkTrigger(e, t) {
  var i = e._model
  return i.get('axisExpandable') && i.get('axisExpandTriggerOn') === t
}
var ParallelModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function () {
        e.prototype.init.apply(this, arguments), this.mergeOption({})
      }),
      (t.prototype.mergeOption = function (e) {
        var t = this.option
        e && merge(t, e, !0), this._initDimensions()
      }),
      (t.prototype.contains = function (e, t) {
        var i = e.get('parallelIndex')
        return null != i && t.getComponent('parallel', i) === this
      }),
      (t.prototype.setAxisExpand = function (e) {
        each$i(
          [
            'axisExpandable',
            'axisExpandCenter',
            'axisExpandCount',
            'axisExpandWidth',
            'axisExpandWindow'
          ],
          function (t) {
            e.hasOwnProperty(t) && (this.option[t] = e[t])
          },
          this
        )
      }),
      (t.prototype._initDimensions = function () {
        var e = (this.dimensions = []),
          t = (this.parallelAxisIndex = [])
        each$i(
          filter$1(
            this.ecModel.queryComponents({ mainType: 'parallelAxis' }),
            function (e) {
              return (e.get('parallelIndex') || 0) === this.componentIndex
            },
            this
          ),
          function (i) {
            e.push('dim' + i.get('dim')), t.push(i.componentIndex)
          }
        )
      }),
      (t.type = 'parallel'),
      (t.dependencies = ['parallelAxis']),
      (t.layoutMode = 'box'),
      (t.defaultOption = {
        zlevel: 0,
        z: 0,
        left: 80,
        top: 60,
        right: 80,
        bottom: 60,
        layout: 'horizontal',
        axisExpandable: !1,
        axisExpandCenter: null,
        axisExpandCount: 0,
        axisExpandWidth: 50,
        axisExpandRate: 17,
        axisExpandDebounce: 50,
        axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
        axisExpandTriggerOn: 'click',
        parallelAxisDefault: null
      }),
      t
    )
  })(ComponentModel),
  ParallelAxis = (function (e) {
    function t(t, i, r, n, a) {
      var o = e.call(this, t, i, r) || this
      return (o.type = n || 'value'), (o.axisIndex = a), o
    }
    return (
      __extends(t, e),
      (t.prototype.isHorizontal = function () {
        return 'horizontal' !== this.coordinateSystem.getModel().get('layout')
      }),
      t
    )
  })(Axis)
function sliderMove(e, t, i, r, n, a) {
  e = e || 0
  var o = i[1] - i[0]
  if (
    (null != n && (n = restrict$1(n, [0, o])),
    null != a && (a = Math.max(a, null != n ? n : 0)),
    'all' === r)
  ) {
    var s = Math.abs(t[1] - t[0])
    ;(s = restrict$1(s, [0, o])), (n = a = restrict$1(s, [n, a])), (r = 0)
  }
  ;(t[0] = restrict$1(t[0], i)), (t[1] = restrict$1(t[1], i))
  var l = getSpanSign(t, r)
  t[r] += e
  var h,
    u = n || 0,
    p = i.slice()
  return (
    l.sign < 0 ? (p[0] += u) : (p[1] -= u),
    (t[r] = restrict$1(t[r], p)),
    (h = getSpanSign(t, r)),
    null != n && (h.sign !== l.sign || h.span < n) && (t[1 - r] = t[r] + l.sign * n),
    (h = getSpanSign(t, r)),
    null != a && h.span > a && (t[1 - r] = t[r] + h.sign * a),
    t
  )
}
function getSpanSign(e, t) {
  var i = e[t] - e[1 - t]
  return { span: Math.abs(i), sign: i > 0 ? -1 : i < 0 ? 1 : t ? -1 : 1 }
}
function restrict$1(e, t) {
  return Math.min(null != t[1] ? t[1] : 1 / 0, Math.max(null != t[0] ? t[0] : -1 / 0, e))
}
var each$c = each$i,
  mathMin$2 = Math.min,
  mathMax$2 = Math.max,
  mathFloor = Math.floor,
  mathCeil = Math.ceil,
  round = round$2,
  PI$1 = Math.PI,
  Parallel = (function () {
    function e(e, t, i) {
      ;(this.type = 'parallel'),
        (this._axesMap = createHashMap()),
        (this._axesLayout = {}),
        (this.dimensions = e.dimensions),
        (this._model = e),
        this._init(e, t, i)
    }
    return (
      (e.prototype._init = function (e, t, i) {
        var r = e.dimensions,
          n = e.parallelAxisIndex
        each$c(
          r,
          function (e, i) {
            var r = n[i],
              a = t.getComponent('parallelAxis', r),
              o = this._axesMap.set(
                e,
                new ParallelAxis(e, createScaleByModel$1(a), [0, 0], a.get('type'), r)
              ),
              s = 'category' === o.type
            ;(o.onBand = s && a.get('boundaryGap')),
              (o.inverse = a.get('inverse')),
              (a.axis = o),
              (o.model = a),
              (o.coordinateSystem = a.coordinateSystem = this)
          },
          this
        )
      }),
      (e.prototype.update = function (e, t) {
        this._updateAxesFromSeries(this._model, e)
      }),
      (e.prototype.containPoint = function (e) {
        var t = this._makeLayoutInfo(),
          i = t.axisBase,
          r = t.layoutBase,
          n = t.pixelDimIndex,
          a = e[1 - n],
          o = e[n]
        return a >= i && a <= i + t.axisLength && o >= r && o <= r + t.layoutLength
      }),
      (e.prototype.getModel = function () {
        return this._model
      }),
      (e.prototype._updateAxesFromSeries = function (e, t) {
        t.eachSeries(function (i) {
          if (e.contains(i, t)) {
            var r = i.getData()
            each$c(
              this.dimensions,
              function (e) {
                var t = this._axesMap.get(e)
                t.scale.unionExtentFromData(r, r.mapDimension(e)), niceScaleExtent(t.scale, t.model)
              },
              this
            )
          }
        }, this)
      }),
      (e.prototype.resize = function (e, t) {
        ;(this._rect = getLayoutRect(e.getBoxLayoutParams(), {
          width: t.getWidth(),
          height: t.getHeight()
        })),
          this._layoutAxes()
      }),
      (e.prototype.getRect = function () {
        return this._rect
      }),
      (e.prototype._makeLayoutInfo = function () {
        var e,
          t = this._model,
          i = this._rect,
          r = ['x', 'y'],
          n = ['width', 'height'],
          a = t.get('layout'),
          o = 'horizontal' === a ? 0 : 1,
          s = i[n[o]],
          l = [0, s],
          h = this.dimensions.length,
          u = restrict(t.get('axisExpandWidth'), l),
          p = restrict(t.get('axisExpandCount') || 0, [0, h]),
          c = t.get('axisExpandable') && h > 3 && h > p && p > 1 && u > 0 && s > 0,
          d = t.get('axisExpandWindow')
        d
          ? ((e = restrict(d[1] - d[0], l)), (d[1] = d[0] + e))
          : ((e = restrict(u * (p - 1), l)),
            ((d = [u * (t.get('axisExpandCenter') || mathFloor(h / 2)) - e / 2])[1] = d[0] + e))
        var f = (s - e) / (h - p)
        f < 3 && (f = 0)
        var m = [mathFloor(round(d[0] / u, 1)) + 1, mathCeil(round(d[1] / u, 1)) - 1],
          g = (f / u) * d[0]
        return {
          layout: a,
          pixelDimIndex: o,
          layoutBase: i[r[o]],
          layoutLength: s,
          axisBase: i[r[1 - o]],
          axisLength: i[n[1 - o]],
          axisExpandable: c,
          axisExpandWidth: u,
          axisCollapseWidth: f,
          axisExpandWindow: d,
          axisCount: h,
          winInnerIndices: m,
          axisExpandWindow0Pos: g
        }
      }),
      (e.prototype._layoutAxes = function () {
        var e = this._rect,
          t = this._axesMap,
          i = this.dimensions,
          r = this._makeLayoutInfo(),
          n = r.layout
        t.each(function (e) {
          var t = [0, r.axisLength],
            i = e.inverse ? 1 : 0
          e.setExtent(t[i], t[1 - i])
        }),
          each$c(
            i,
            function (t, i) {
              var a = (r.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(i, r),
                o = {
                  horizontal: { x: a.position, y: r.axisLength },
                  vertical: { x: 0, y: a.position }
                },
                s = { horizontal: PI$1 / 2, vertical: 0 },
                l = [o[n].x + e.x, o[n].y + e.y],
                h = s[n],
                u = create$1()
              rotate(u, u, h),
                translate$1(u, u, l),
                (this._axesLayout[t] = {
                  position: l,
                  rotation: h,
                  transform: u,
                  axisNameAvailableWidth: a.axisNameAvailableWidth,
                  axisLabelShow: a.axisLabelShow,
                  nameTruncateMaxWidth: a.nameTruncateMaxWidth,
                  tickDirection: 1,
                  labelDirection: 1
                })
            },
            this
          )
      }),
      (e.prototype.getAxis = function (e) {
        return this._axesMap.get(e)
      }),
      (e.prototype.dataToPoint = function (e, t) {
        return this.axisCoordToPoint(this._axesMap.get(t).dataToCoord(e), t)
      }),
      (e.prototype.eachActiveState = function (e, t, i, r) {
        null == i && (i = 0), null == r && (r = e.count())
        var n = this._axesMap,
          a = this.dimensions,
          o = [],
          s = []
        each$i(a, function (t) {
          o.push(e.mapDimension(t)), s.push(n.get(t).model)
        })
        for (var l = this.hasAxisBrushed(), h = i; h < r; h++) {
          var u = void 0
          if (l) {
            u = 'active'
            for (var p = e.getValues(o, h), c = 0, d = a.length; c < d; c++) {
              if ('inactive' === s[c].getActiveState(p[c])) {
                u = 'inactive'
                break
              }
            }
          } else u = 'normal'
          t(u, h)
        }
      }),
      (e.prototype.hasAxisBrushed = function () {
        for (var e = this.dimensions, t = this._axesMap, i = !1, r = 0, n = e.length; r < n; r++)
          'normal' !== t.get(e[r]).model.getActiveState() && (i = !0)
        return i
      }),
      (e.prototype.axisCoordToPoint = function (e, t) {
        return applyTransform([e, 0], this._axesLayout[t].transform)
      }),
      (e.prototype.getAxisLayout = function (e) {
        return clone$3(this._axesLayout[e])
      }),
      (e.prototype.getSlidedAxisExpandWindow = function (e) {
        var t = this._makeLayoutInfo(),
          i = t.pixelDimIndex,
          r = t.axisExpandWindow.slice(),
          n = r[1] - r[0],
          a = [0, t.axisExpandWidth * (t.axisCount - 1)]
        if (!this.containPoint(e)) return { behavior: 'none', axisExpandWindow: r }
        var o,
          s = e[i] - t.layoutBase - t.axisExpandWindow0Pos,
          l = 'slide',
          h = t.axisCollapseWidth,
          u = this._model.get('axisExpandSlideTriggerArea'),
          p = null != u[0]
        if (h)
          p && h && s < n * u[0]
            ? ((l = 'jump'), (o = s - n * u[2]))
            : p && h && s > n * (1 - u[0])
            ? ((l = 'jump'), (o = s - n * (1 - u[2])))
            : (o = s - n * u[1]) >= 0 && (o = s - n * (1 - u[1])) <= 0 && (o = 0),
            (o *= t.axisExpandWidth / h) ? sliderMove(o, r, a, 'all') : (l = 'none')
        else {
          var c = r[1] - r[0]
          ;((r = [mathMax$2(0, (a[1] * s) / c - c / 2)])[1] = mathMin$2(a[1], r[0] + c)),
            (r[0] = r[1] - c)
        }
        return { axisExpandWindow: r, behavior: l }
      }),
      e
    )
  })()
function restrict(e, t) {
  return mathMin$2(mathMax$2(e, t[0]), t[1])
}
function layoutAxisWithoutExpand(e, t) {
  var i = t.layoutLength / (t.axisCount - 1)
  return { position: i * e, axisNameAvailableWidth: i, axisLabelShow: !0 }
}
function layoutAxisWithExpand(e, t) {
  var i,
    r,
    n = t.layoutLength,
    a = t.axisExpandWidth,
    o = t.axisCount,
    s = t.axisCollapseWidth,
    l = t.winInnerIndices,
    h = s,
    u = !1
  return (
    e < l[0]
      ? ((i = e * s), (r = s))
      : e <= l[1]
      ? ((i = t.axisExpandWindow0Pos + e * a - t.axisExpandWindow[0]), (h = a), (u = !0))
      : ((i = n - (o - 1 - e) * s), (r = s)),
    { position: i, axisNameAvailableWidth: h, axisLabelShow: u, nameTruncateMaxWidth: r }
  )
}
function createParallelCoordSys(e, t) {
  var i = []
  return (
    e.eachComponent('parallel', function (r, n) {
      var a = new Parallel(r, e, t)
      ;(a.name = 'parallel_' + n),
        a.resize(r, t),
        (r.coordinateSystem = a),
        (a.model = r),
        i.push(a)
    }),
    e.eachSeries(function (e) {
      if ('parallel' === e.get('coordinateSystem')) {
        var t = e.getReferringComponents('parallel', SINGLE_REFERRING).models[0]
        e.coordinateSystem = t.coordinateSystem
      }
    }),
    i
  )
}
var parallelCoordSysCreator = { create: createParallelCoordSys },
  ParallelAxisModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.activeIntervals = []), i
    }
    return (
      __extends(t, e),
      (t.prototype.getAreaSelectStyle = function () {
        return makeStyleMapper([
          ['fill', 'color'],
          ['lineWidth', 'borderWidth'],
          ['stroke', 'borderColor'],
          ['width', 'width'],
          ['opacity', 'opacity']
        ])(this.getModel('areaSelectStyle'))
      }),
      (t.prototype.setActiveIntervals = function (e) {
        var t = (this.activeIntervals = clone$3(e))
        if (t) for (var i = t.length - 1; i >= 0; i--) asc$2(t[i])
      }),
      (t.prototype.getActiveState = function (e) {
        var t = this.activeIntervals
        if (!t.length) return 'normal'
        if (null == e || isNaN(+e)) return 'inactive'
        if (1 === t.length) {
          var i = t[0]
          if (i[0] <= e && e <= i[1]) return 'active'
        } else
          for (var r = 0, n = t.length; r < n; r++)
            if (t[r][0] <= e && e <= t[r][1]) return 'active'
        return 'inactive'
      }),
      t
    )
  })(ComponentModel)
mixin(ParallelAxisModel, AxisModelCommonMixin)
var BRUSH_PANEL_GLOBAL = !0,
  mathMin$1 = Math.min,
  mathMax$1 = Math.max,
  mathPow = Math.pow,
  COVER_Z = 1e4,
  UNSELECT_THRESHOLD = 6,
  MIN_RESIZE_LINE_WIDTH = 6,
  MUTEX_RESOURCE_KEY = 'globalPan',
  DIRECTION_MAP = { w: [0, 0], e: [0, 1], n: [1, 0], s: [1, 1] },
  CURSOR_MAP = {
    w: 'ew',
    e: 'ew',
    n: 'ns',
    s: 'ns',
    ne: 'nesw',
    sw: 'nesw',
    nw: 'nwse',
    se: 'nwse'
  },
  DEFAULT_BRUSH_OPT = {
    brushStyle: { lineWidth: 2, stroke: 'rgba(210,219,238,0.3)', fill: '#D2DBEE' },
    transformable: !0,
    brushMode: 'single',
    removeOnClick: !1
  },
  baseUID = 0,
  BrushController = (function (e) {
    function t(t) {
      var i = e.call(this) || this
      return (
        (i._track = []),
        (i._covers = []),
        (i._handlers = {}),
        (i._zr = t),
        (i.group = new Group$3()),
        (i._uid = 'brushController_' + baseUID++),
        each$i(
          pointerHandlers,
          function (e, t) {
            this._handlers[t] = bind$2(e, this)
          },
          i
        ),
        i
      )
    }
    return (
      __extends(t, e),
      (t.prototype.enableBrush = function (e) {
        return (
          this._brushType && this._doDisableBrush(), e.brushType && this._doEnableBrush(e), this
        )
      }),
      (t.prototype._doEnableBrush = function (e) {
        var t = this._zr
        this._enableGlobalPan || take(t, MUTEX_RESOURCE_KEY, this._uid),
          each$i(this._handlers, function (e, i) {
            t.on(i, e)
          }),
          (this._brushType = e.brushType),
          (this._brushOption = merge(clone$3(DEFAULT_BRUSH_OPT), e, !0))
      }),
      (t.prototype._doDisableBrush = function () {
        var e = this._zr
        release(e, MUTEX_RESOURCE_KEY, this._uid),
          each$i(this._handlers, function (t, i) {
            e.off(i, t)
          }),
          (this._brushType = this._brushOption = null)
      }),
      (t.prototype.setPanels = function (e) {
        if (e && e.length) {
          var t = (this._panels = {})
          each$i(e, function (e) {
            t[e.panelId] = clone$3(e)
          })
        } else this._panels = null
        return this
      }),
      (t.prototype.mount = function (e) {
        ;(e = e || {}), (this._enableGlobalPan = e.enableGlobalPan)
        var t = this.group
        return (
          this._zr.add(t),
          t.attr({
            x: e.x || 0,
            y: e.y || 0,
            rotation: e.rotation || 0,
            scaleX: e.scaleX || 1,
            scaleY: e.scaleY || 1
          }),
          (this._transform = t.getLocalTransform()),
          this
        )
      }),
      (t.prototype.updateCovers = function (e) {
        e = map$1(e, function (e) {
          return merge(clone$3(DEFAULT_BRUSH_OPT), e, !0)
        })
        var t = this._covers,
          i = (this._covers = []),
          r = this,
          n = this._creatingCover
        return (
          new DataDiffer(
            t,
            e,
            function (e, t) {
              return a(e.__brushOption, t)
            },
            a
          )
            .add(o)
            .update(o)
            .remove(function (e) {
              t[e] !== n && r.group.remove(t[e])
            })
            .execute(),
          this
        )
        function a(e, t) {
          return (null != e.id ? e.id : '\0-brush-index-' + t) + '-' + e.brushType
        }
        function o(a, o) {
          var s = e[a]
          if (null != o && t[o] === n) i[a] = t[o]
          else {
            var l = (i[a] =
              null != o ? ((t[o].__brushOption = s), t[o]) : endCreating(r, createCover(r, s)))
            updateCoverAfterCreation(r, l)
          }
        }
      }),
      (t.prototype.unmount = function () {
        return this.enableBrush(!1), clearCovers(this), this._zr.remove(this.group), this
      }),
      (t.prototype.dispose = function () {
        this.unmount(), this.off()
      }),
      t
    )
  })(Eventful)
function createCover(e, t) {
  var i = coverRenderers[t.brushType].createCover(e, t)
  return (i.__brushOption = t), updateZ$1(i, t), e.group.add(i), i
}
function endCreating(e, t) {
  var i = getCoverRenderer(t)
  return i.endCreating && (i.endCreating(e, t), updateZ$1(t, t.__brushOption)), t
}
function updateCoverShape(e, t) {
  var i = t.__brushOption
  getCoverRenderer(t).updateCoverShape(e, t, i.range, i)
}
function updateZ$1(e, t) {
  var i = t.z
  null == i && (i = COVER_Z),
    e.traverse(function (e) {
      ;(e.z = i), (e.z2 = i)
    })
}
function updateCoverAfterCreation(e, t) {
  getCoverRenderer(t).updateCommon(e, t), updateCoverShape(e, t)
}
function getCoverRenderer(e) {
  return coverRenderers[e.__brushOption.brushType]
}
function getPanelByPoint(e, t, i) {
  var r,
    n = e._panels
  if (!n) return BRUSH_PANEL_GLOBAL
  var a = e._transform
  return (
    each$i(n, function (e) {
      e.isTargetByCursor(t, i, a) && (r = e)
    }),
    r
  )
}
function getPanelByCover(e, t) {
  var i = e._panels
  if (!i) return BRUSH_PANEL_GLOBAL
  var r = t.__brushOption.panelId
  return null != r ? i[r] : BRUSH_PANEL_GLOBAL
}
function clearCovers(e) {
  var t = e._covers,
    i = t.length
  return (
    each$i(
      t,
      function (t) {
        e.group.remove(t)
      },
      e
    ),
    (t.length = 0),
    !!i
  )
}
function trigger$1(e, t) {
  var i = map$1(e._covers, function (e) {
    var t = e.__brushOption,
      i = clone$3(t.range)
    return { brushType: t.brushType, panelId: t.panelId, range: i }
  })
  e.trigger('brush', { areas: i, isEnd: !!t.isEnd, removeOnClick: !!t.removeOnClick })
}
function shouldShowCover(e) {
  var t = e._track
  if (!t.length) return !1
  var i = t[t.length - 1],
    r = t[0],
    n = i[0] - r[0],
    a = i[1] - r[1]
  return mathPow(n * n + a * a, 0.5) > UNSELECT_THRESHOLD
}
function getTrackEnds(e) {
  var t = e.length - 1
  return t < 0 && (t = 0), [e[0], e[t]]
}
function createBaseRectCover(e, t, i, r) {
  var n = new Group$3()
  return (
    n.add(
      new Rect$2({
        name: 'main',
        style: makeStyle(i),
        silent: !0,
        draggable: !0,
        cursor: 'move',
        drift: curry$1(driftRect, e, t, n, ['n', 's', 'w', 'e']),
        ondragend: curry$1(trigger$1, t, { isEnd: !0 })
      })
    ),
    each$i(r, function (i) {
      n.add(
        new Rect$2({
          name: i.join(''),
          style: { opacity: 0 },
          draggable: !0,
          silent: !0,
          invisible: !0,
          drift: curry$1(driftRect, e, t, n, i),
          ondragend: curry$1(trigger$1, t, { isEnd: !0 })
        })
      )
    }),
    n
  )
}
function updateBaseRect(e, t, i, r) {
  var n = r.brushStyle.lineWidth || 0,
    a = mathMax$1(n, MIN_RESIZE_LINE_WIDTH),
    o = i[0][0],
    s = i[1][0],
    l = o - n / 2,
    h = s - n / 2,
    u = i[0][1],
    p = i[1][1],
    c = u - a + n / 2,
    d = p - a + n / 2,
    f = u - o,
    m = p - s,
    g = f + n,
    y = m + n
  updateRectShape(e, t, 'main', o, s, f, m),
    r.transformable &&
      (updateRectShape(e, t, 'w', l, h, a, y),
      updateRectShape(e, t, 'e', c, h, a, y),
      updateRectShape(e, t, 'n', l, h, g, a),
      updateRectShape(e, t, 's', l, d, g, a),
      updateRectShape(e, t, 'nw', l, h, a, a),
      updateRectShape(e, t, 'ne', c, h, a, a),
      updateRectShape(e, t, 'sw', l, d, a, a),
      updateRectShape(e, t, 'se', c, d, a, a))
}
function updateCommon$1(e, t) {
  var i = t.__brushOption,
    r = i.transformable,
    n = t.childAt(0)
  n.useStyle(makeStyle(i)),
    n.attr({ silent: !r, cursor: r ? 'move' : 'default' }),
    each$i(
      [['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']],
      function (i) {
        var n = t.childOfName(i.join('')),
          a = 1 === i.length ? getGlobalDirection1(e, i[0]) : getGlobalDirection2(e, i)
        n && n.attr({ silent: !r, invisible: !r, cursor: r ? CURSOR_MAP[a] + '-resize' : null })
      }
    )
}
function updateRectShape(e, t, i, r, n, a, o) {
  var s = t.childOfName(i)
  s &&
    s.setShape(
      pointsToRect(
        clipByPanel(e, t, [
          [r, n],
          [r + a, n + o]
        ])
      )
    )
}
function makeStyle(e) {
  return defaults$1({ strokeNoScale: !0 }, e.brushStyle)
}
function formatRectRange(e, t, i, r) {
  var n = [mathMin$1(e, i), mathMin$1(t, r)],
    a = [mathMax$1(e, i), mathMax$1(t, r)]
  return [
    [n[0], a[0]],
    [n[1], a[1]]
  ]
}
function getTransform(e) {
  return getTransform$1(e.group)
}
function getGlobalDirection1(e, t) {
  return { left: 'w', right: 'e', top: 'n', bottom: 's' }[
    transformDirection({ w: 'left', e: 'right', n: 'top', s: 'bottom' }[t], getTransform(e))
  ]
}
function getGlobalDirection2(e, t) {
  var i = [getGlobalDirection1(e, t[0]), getGlobalDirection1(e, t[1])]
  return ('e' === i[0] || 'w' === i[0]) && i.reverse(), i.join('')
}
function driftRect(e, t, i, r, n, a) {
  var o = i.__brushOption,
    s = e.toRectRange(o.range),
    l = toLocalDelta(t, n, a)
  each$i(r, function (e) {
    var t = DIRECTION_MAP[e]
    s[t[0]][t[1]] += l[t[0]]
  }),
    (o.range = e.fromRectRange(formatRectRange(s[0][0], s[1][0], s[0][1], s[1][1]))),
    updateCoverAfterCreation(t, i),
    trigger$1(t, { isEnd: !1 })
}
function driftPolygon(e, t, i, r) {
  var n = t.__brushOption.range,
    a = toLocalDelta(e, i, r)
  each$i(n, function (e) {
    ;(e[0] += a[0]), (e[1] += a[1])
  }),
    updateCoverAfterCreation(e, t),
    trigger$1(e, { isEnd: !1 })
}
function toLocalDelta(e, t, i) {
  var r = e.group,
    n = r.transformCoordToLocal(t, i),
    a = r.transformCoordToLocal(0, 0)
  return [n[0] - a[0], n[1] - a[1]]
}
function clipByPanel(e, t, i) {
  var r = getPanelByCover(e, t)
  return r && r !== BRUSH_PANEL_GLOBAL ? r.clipPath(i, e._transform) : clone$3(i)
}
function pointsToRect(e) {
  var t = mathMin$1(e[0][0], e[1][0]),
    i = mathMin$1(e[0][1], e[1][1])
  return {
    x: t,
    y: i,
    width: mathMax$1(e[0][0], e[1][0]) - t,
    height: mathMax$1(e[0][1], e[1][1]) - i
  }
}
function resetCursor(e, t, i) {
  if (e._brushType && !isOutsideZrArea(e, t.offsetX, t.offsetY)) {
    var r = e._zr,
      n = e._covers,
      a = getPanelByPoint(e, t, i)
    if (!e._dragging)
      for (var o = 0; o < n.length; o++) {
        var s = n[o].__brushOption
        if (
          a &&
          (a === BRUSH_PANEL_GLOBAL || s.panelId === a.panelId) &&
          coverRenderers[s.brushType].contain(n[o], i[0], i[1])
        )
          return
      }
    a && r.setCursorStyle('crosshair')
  }
}
function preventDefault(e) {
  var t = e.event
  t.preventDefault && t.preventDefault()
}
function mainShapeContain(e, t, i) {
  return e.childOfName('main').contain(t, i)
}
function updateCoverByMouse(e, t, i, r) {
  var n,
    a = e._creatingCover,
    o = e._creatingPanel,
    s = e._brushOption
  if ((e._track.push(i.slice()), shouldShowCover(e) || a)) {
    if (o && !a) {
      'single' === s.brushMode && clearCovers(e)
      var l = clone$3(s)
      ;(l.brushType = determineBrushType(l.brushType, o)),
        (l.panelId = o === BRUSH_PANEL_GLOBAL ? null : o.panelId),
        (a = e._creatingCover = createCover(e, l)),
        e._covers.push(a)
    }
    if (a) {
      var h = coverRenderers[determineBrushType(e._brushType, o)]
      ;(a.__brushOption.range = h.getCreatingRange(clipByPanel(e, a, e._track))),
        r && (endCreating(e, a), h.updateCommon(e, a)),
        updateCoverShape(e, a),
        (n = { isEnd: r })
    }
  } else
    r &&
      'single' === s.brushMode &&
      s.removeOnClick &&
      getPanelByPoint(e, t, i) &&
      clearCovers(e) &&
      (n = { isEnd: r, removeOnClick: !0 })
  return n
}
function determineBrushType(e, t) {
  return 'auto' === e ? t.defaultBrushType : e
}
var pointerHandlers = {
  mousedown: function (e) {
    if (this._dragging) handleDragEnd(this, e)
    else if (!e.target || !e.target.draggable) {
      preventDefault(e)
      var t = this.group.transformCoordToLocal(e.offsetX, e.offsetY)
      ;(this._creatingCover = null),
        (this._creatingPanel = getPanelByPoint(this, e, t)) &&
          ((this._dragging = !0), (this._track = [t.slice()]))
    }
  },
  mousemove: function (e) {
    var t = e.offsetX,
      i = e.offsetY,
      r = this.group.transformCoordToLocal(t, i)
    if ((resetCursor(this, e, r), this._dragging)) {
      preventDefault(e)
      var n = updateCoverByMouse(this, e, r, !1)
      n && trigger$1(this, n)
    }
  },
  mouseup: function (e) {
    handleDragEnd(this, e)
  }
}
function handleDragEnd(e, t) {
  if (e._dragging) {
    preventDefault(t)
    var i = t.offsetX,
      r = t.offsetY,
      n = e.group.transformCoordToLocal(i, r),
      a = updateCoverByMouse(e, t, n, !0)
    ;(e._dragging = !1), (e._track = []), (e._creatingCover = null), a && trigger$1(e, a)
  }
}
function isOutsideZrArea(e, t, i) {
  var r = e._zr
  return t < 0 || t > r.getWidth() || i < 0 || i > r.getHeight()
}
var coverRenderers = {
  lineX: getLineRenderer(0),
  lineY: getLineRenderer(1),
  rect: {
    createCover: function (e, t) {
      function i(e) {
        return e
      }
      return createBaseRectCover({ toRectRange: i, fromRectRange: i }, e, t, [
        ['w'],
        ['e'],
        ['n'],
        ['s'],
        ['s', 'e'],
        ['s', 'w'],
        ['n', 'e'],
        ['n', 'w']
      ])
    },
    getCreatingRange: function (e) {
      var t = getTrackEnds(e)
      return formatRectRange(t[1][0], t[1][1], t[0][0], t[0][1])
    },
    updateCoverShape: function (e, t, i, r) {
      updateBaseRect(e, t, i, r)
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  },
  polygon: {
    createCover: function (e, t) {
      var i = new Group$3()
      return i.add(new Polyline$1({ name: 'main', style: makeStyle(t), silent: !0 })), i
    },
    getCreatingRange: function (e) {
      return e
    },
    endCreating: function (e, t) {
      t.remove(t.childAt(0)),
        t.add(
          new Polygon({
            name: 'main',
            draggable: !0,
            drift: curry$1(driftPolygon, e, t),
            ondragend: curry$1(trigger$1, e, { isEnd: !0 })
          })
        )
    },
    updateCoverShape: function (e, t, i, r) {
      t.childAt(0).setShape({ points: clipByPanel(e, t, i) })
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  }
}
function getLineRenderer(e) {
  return {
    createCover: function (t, i) {
      return createBaseRectCover(
        {
          toRectRange: function (t) {
            var i = [t, [0, 100]]
            return e && i.reverse(), i
          },
          fromRectRange: function (t) {
            return t[e]
          }
        },
        t,
        i,
        [
          [['w'], ['e']],
          [['n'], ['s']]
        ][e]
      )
    },
    getCreatingRange: function (t) {
      var i = getTrackEnds(t)
      return [mathMin$1(i[0][e], i[1][e]), mathMax$1(i[0][e], i[1][e])]
    },
    updateCoverShape: function (t, i, r, n) {
      var a,
        o = getPanelByCover(t, i)
      if (o !== BRUSH_PANEL_GLOBAL && o.getLinearBrushOtherExtent)
        a = o.getLinearBrushOtherExtent(e)
      else {
        var s = t._zr
        a = [0, [s.getWidth(), s.getHeight()][1 - e]]
      }
      var l = [r, a]
      e && l.reverse(), updateBaseRect(t, i, l, n)
    },
    updateCommon: updateCommon$1,
    contain: mainShapeContain
  }
}
function makeRectPanelClipPath(e) {
  return (
    (e = normalizeRect(e)),
    function (t) {
      return clipPointsByRect(t, e)
    }
  )
}
function makeLinearBrushOtherExtent(e, t) {
  return (
    (e = normalizeRect(e)),
    function (i) {
      var r = null != t ? t : i,
        n = r ? e.width : e.height,
        a = r ? e.x : e.y
      return [a, a + (n || 0)]
    }
  )
}
function makeRectIsTargetByCursor(e, t, i) {
  var r = normalizeRect(e)
  return function (e, n) {
    return r.contain(n[0], n[1]) && !onIrrelevantElement(e, t, i)
  }
}
function normalizeRect(e) {
  return BoundingRect.create(e)
}
var elementList$1 = ['axisLine', 'axisTickLabel', 'axisName'],
  ParallelAxisView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (t, i) {
        e.prototype.init.apply(this, arguments),
          (this._brushController = new BrushController(i.getZr())).on(
            'brush',
            bind$2(this._onBrush, this)
          )
      }),
      (t.prototype.render = function (e, t, i, r) {
        if (!fromAxisAreaSelect(e, t, r)) {
          ;(this.axisModel = e), (this.api = i), this.group.removeAll()
          var n = this._axisGroup
          if (((this._axisGroup = new Group$3()), this.group.add(this._axisGroup), e.get('show'))) {
            var a = getCoordSysModel(e, t),
              o = a.coordinateSystem,
              s = e.getAreaSelectStyle(),
              l = s.width,
              h = e.axis.dim,
              u = extend$3({ strokeContainThreshold: l }, o.getAxisLayout(h)),
              p = new AxisBuilder(e, u)
            each$i(elementList$1, p.add, p),
              this._axisGroup.add(p.getGroup()),
              this._refreshBrushController(u, s, e, a, l, i),
              groupTransition(n, this._axisGroup, e)
          }
        }
      }),
      (t.prototype._refreshBrushController = function (e, t, i, r, n, a) {
        var o = i.axis.getExtent(),
          s = o[1] - o[0],
          l = Math.min(30, 0.1 * Math.abs(s)),
          h = BoundingRect.create({ x: o[0], y: -n / 2, width: s, height: n })
        ;(h.x -= l),
          (h.width += 2 * l),
          this._brushController
            .mount({
              enableGlobalPan: !0,
              rotation: e.rotation,
              x: e.position[0],
              y: e.position[1]
            })
            .setPanels([
              {
                panelId: 'pl',
                clipPath: makeRectPanelClipPath(h),
                isTargetByCursor: makeRectIsTargetByCursor(h, a, r),
                getLinearBrushOtherExtent: makeLinearBrushOtherExtent(h, 0)
              }
            ])
            .enableBrush({ brushType: 'lineX', brushStyle: t, removeOnClick: !0 })
            .updateCovers(getCoverInfoList(i))
      }),
      (t.prototype._onBrush = function (e) {
        var t = e.areas,
          i = this.axisModel,
          r = i.axis,
          n = map$1(t, function (e) {
            return [r.coordToData(e.range[0], !0), r.coordToData(e.range[1], !0)]
          })
        ;(!i.option.realtime === e.isEnd || e.removeOnClick) &&
          this.api.dispatchAction({ type: 'axisAreaSelect', parallelAxisId: i.id, intervals: n })
      }),
      (t.prototype.dispose = function () {
        this._brushController.dispose()
      }),
      (t.type = 'parallelAxis'),
      t
    )
  })(ComponentView)
function fromAxisAreaSelect(e, t, i) {
  return (
    i &&
    'axisAreaSelect' === i.type &&
    t.findComponents({ mainType: 'parallelAxis', query: i })[0] === e
  )
}
function getCoverInfoList(e) {
  var t = e.axis
  return map$1(e.activeIntervals, function (e) {
    return {
      brushType: 'lineX',
      panelId: 'pl',
      range: [t.dataToCoord(e[0], !0), t.dataToCoord(e[1], !0)]
    }
  })
}
function getCoordSysModel(e, t) {
  return t.getComponent('parallel', e.get('parallelIndex'))
}
var actionInfo = { type: 'axisAreaSelect', event: 'axisAreaSelected' }
function installParallelActions(e) {
  e.registerAction(actionInfo, function (e, t) {
    t.eachComponent({ mainType: 'parallelAxis', query: e }, function (t) {
      t.axis.model.setActiveIntervals(e.intervals)
    })
  }),
    e.registerAction('parallelAxisExpand', function (e, t) {
      t.eachComponent({ mainType: 'parallel', query: e }, function (t) {
        t.setAxisExpand(e)
      })
    })
}
var defaultAxisOption = {
  type: 'value',
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: 'rgba(160,197,232)',
    color: 'rgba(160,197,232)',
    opacity: 0.3
  },
  realtime: !0,
  z: 10
}
function install$C(e) {
  e.registerComponentView(ParallelView),
    e.registerComponentModel(ParallelModel),
    e.registerCoordinateSystem('parallel', parallelCoordSysCreator),
    e.registerPreprocessor(parallelPreprocessor),
    e.registerComponentModel(ParallelAxisModel),
    e.registerComponentView(ParallelAxisView),
    axisModelCreator(e, 'parallel', ParallelAxisModel, defaultAxisOption),
    installParallelActions(e)
}
function install$B(e) {
  use(install$C),
    e.registerChartView(ParallelView$1),
    e.registerSeriesModel(ParallelSeriesModel),
    e.registerVisual(e.PRIORITY.VISUAL.BRUSH, parallelVisual)
}
var SankeyPathShape = function () {
    ;(this.x1 = 0),
      (this.y1 = 0),
      (this.x2 = 0),
      (this.y2 = 0),
      (this.cpx1 = 0),
      (this.cpy1 = 0),
      (this.cpx2 = 0),
      (this.cpy2 = 0),
      (this.extent = 0)
  },
  SankeyPath = (function (e) {
    function t(t) {
      return e.call(this, t) || this
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultShape = function () {
        return new SankeyPathShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        var i = t.extent
        e.moveTo(t.x1, t.y1),
          e.bezierCurveTo(t.cpx1, t.cpy1, t.cpx2, t.cpy2, t.x2, t.y2),
          'vertical' === t.orient
            ? (e.lineTo(t.x2 + i, t.y2),
              e.bezierCurveTo(t.cpx2 + i, t.cpy2, t.cpx1 + i, t.cpy1, t.x1 + i, t.y1))
            : (e.lineTo(t.x2, t.y2 + i),
              e.bezierCurveTo(t.cpx2, t.cpy2 + i, t.cpx1, t.cpy1 + i, t.x1, t.y1 + i)),
          e.closePath()
      }),
      (t.prototype.highlight = function () {
        enterEmphasis(this)
      }),
      (t.prototype.downplay = function () {
        leaveEmphasis(this)
      }),
      t
    )
  })(Path),
  SankeyView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i._focusAdjacencyDisabled = !1), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i) {
        var r = this,
          n = e.getGraph(),
          a = this.group,
          o = e.layoutInfo,
          s = o.width,
          l = o.height,
          h = e.getData(),
          u = e.getData('edge'),
          p = e.get('orient')
        ;(this._model = e),
          a.removeAll(),
          (a.x = o.x),
          (a.y = o.y),
          n.eachEdge(function (t) {
            var i = new SankeyPath(),
              r = getECData(i)
            ;(r.dataIndex = t.dataIndex), (r.seriesIndex = e.seriesIndex), (r.dataType = 'edge')
            var n,
              o,
              h,
              c,
              d,
              f,
              m,
              g,
              y = t.getModel(),
              v = y.getModel('lineStyle'),
              _ = v.get('curveness'),
              x = t.node1.getLayout(),
              S = t.node1.getModel(),
              b = S.get('localX'),
              T = S.get('localY'),
              A = t.node2.getLayout(),
              w = t.node2.getModel(),
              M = w.get('localX'),
              C = w.get('localY'),
              P = t.getLayout()
            switch (
              ((i.shape.extent = Math.max(1, P.dy)),
              (i.shape.orient = p),
              'vertical' === p
                ? ((n = (null != b ? b * s : x.x) + P.sy),
                  (o = (null != T ? T * l : x.y) + x.dy),
                  (h = (null != M ? M * s : A.x) + P.ty),
                  (d = n),
                  (f = o * (1 - _) + (c = null != C ? C * l : A.y) * _),
                  (m = h),
                  (g = o * _ + c * (1 - _)))
                : ((n = (null != b ? b * s : x.x) + x.dx),
                  (o = (null != T ? T * l : x.y) + P.sy),
                  (d = n * (1 - _) + (h = null != M ? M * s : A.x) * _),
                  (f = o),
                  (m = n * _ + h * (1 - _)),
                  (g = c = (null != C ? C * l : A.y) + P.ty)),
              i.setShape({ x1: n, y1: o, x2: h, y2: c, cpx1: d, cpy1: f, cpx2: m, cpy2: g }),
              i.useStyle(v.getItemStyle()),
              i.style.fill)
            ) {
              case 'source':
                ;(i.style.fill = t.node1.getVisual('color')),
                  (i.style.decal = t.node1.getVisual('style').decal)
                break
              case 'target':
                ;(i.style.fill = t.node2.getVisual('color')),
                  (i.style.decal = t.node2.getVisual('style').decal)
                break
              case 'gradient':
                var E = t.node1.getVisual('color'),
                  I = t.node2.getVisual('color')
                'string' == typeof E &&
                  'string' == typeof I &&
                  (i.style.fill = new LinearGradient(0, 0, 1, 0, [
                    { color: E, offset: 0 },
                    { color: I, offset: 1 }
                  ]))
            }
            var D = y.getModel('emphasis')
            setStatesStylesFromModel(i, y, 'lineStyle', function (e) {
              return e.getItemStyle()
            }),
              a.add(i),
              u.setItemGraphicEl(t.dataIndex, i)
            var L = D.get('focus')
            enableHoverEmphasis(
              i,
              'adjacency' === L ? t.getAdjacentDataIndices() : L,
              D.get('blurScope')
            ),
              (getECData(i).dataType = 'edge')
          }),
          n.eachNode(function (t) {
            var i = t.getLayout(),
              r = t.getModel(),
              n = r.get('localX'),
              o = r.get('localY'),
              u = r.getModel('emphasis'),
              p = new Rect$2({
                shape: {
                  x: null != n ? n * s : i.x,
                  y: null != o ? o * l : i.y,
                  width: i.dx,
                  height: i.dy
                },
                style: r.getModel('itemStyle').getItemStyle(),
                z2: 10
              })
            setLabelStyle(p, getLabelStatesModels(r), {
              labelFetcher: e,
              labelDataIndex: t.dataIndex,
              defaultText: t.id
            }),
              (p.disableLabelAnimation = !0),
              p.setStyle('fill', t.getVisual('color')),
              p.setStyle('decal', t.getVisual('style').decal),
              setStatesStylesFromModel(p, r),
              a.add(p),
              h.setItemGraphicEl(t.dataIndex, p),
              (getECData(p).dataType = 'node')
            var c = u.get('focus')
            enableHoverEmphasis(
              p,
              'adjacency' === c ? t.getAdjacentDataIndices() : c,
              u.get('blurScope')
            )
          }),
          h.eachItemGraphicEl(function (t, n) {
            h.getItemModel(n).get('draggable') &&
              ((t.drift = function (t, a) {
                ;(r._focusAdjacencyDisabled = !0),
                  (this.shape.x += t),
                  (this.shape.y += a),
                  this.dirty(),
                  i.dispatchAction({
                    type: 'dragNode',
                    seriesId: e.id,
                    dataIndex: h.getRawIndex(n),
                    localX: this.shape.x / s,
                    localY: this.shape.y / l
                  })
              }),
              (t.ondragend = function () {
                r._focusAdjacencyDisabled = !1
              }),
              (t.draggable = !0),
              (t.cursor = 'move'))
          }),
          !this._data &&
            e.isAnimationEnabled() &&
            a.setClipPath(
              createGridClipShape$1(a.getBoundingRect(), e, function () {
                a.removeClipPath()
              })
            ),
          (this._data = e.getData())
      }),
      (t.prototype.dispose = function () {}),
      (t.type = 'sankey'),
      t
    )
  })(ChartView)
function createGridClipShape$1(e, t, i) {
  var r = new Rect$2({ shape: { x: e.x - 10, y: e.y - 10, width: 0, height: e.height + 20 } })
  return initProps(r, { shape: { width: e.width + 20 } }, t, i), r
}
var SankeySeriesModel = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), i
  }
  return (
    __extends(t, e),
    (t.prototype.getInitialData = function (e, t) {
      var i = e.edges || e.links,
        r = e.data || e.nodes,
        n = e.levels
      this.levelModels = []
      for (var a = this.levelModels, o = 0; o < n.length; o++)
        null != n[o].depth && n[o].depth >= 0 && (a[n[o].depth] = new Model(n[o], this, t))
      if (r && i)
        return createGraphFromNodeEdge(r, i, this, !0, function (e, t) {
          e.wrapMethod('getItemModel', function (e, t) {
            var i = e.parentModel,
              r = i.getData().getItemLayout(t)
            if (r) {
              var n = r.depth,
                a = i.levelModels[n]
              a && (e.parentModel = a)
            }
            return e
          }),
            t.wrapMethod('getItemModel', function (e, t) {
              var i = e.parentModel,
                r = i.getGraph().getEdgeByIndex(t).node1.getLayout()
              if (r) {
                var n = r.depth,
                  a = i.levelModels[n]
                a && (e.parentModel = a)
              }
              return e
            })
        }).data
    }),
    (t.prototype.setNodePosition = function (e, t) {
      var i = this.option.data[e]
      ;(i.localX = t[0]), (i.localY = t[1])
    }),
    (t.prototype.getGraph = function () {
      return this.getData().graph
    }),
    (t.prototype.getEdgeData = function () {
      return this.getGraph().edgeData
    }),
    (t.prototype.formatTooltip = function (e, t, i) {
      function r(e) {
        return isNaN(e) || null == e
      }
      if ('edge' === i) {
        var n = this.getDataParams(e, i),
          a = n.data,
          o = n.value
        return createTooltipMarkup('nameValue', {
          name: a.source + ' -- ' + a.target,
          value: o,
          noValue: r(o)
        })
      }
      var s = this.getGraph().getNodeByIndex(e).getLayout().value,
        l = this.getDataParams(e, i).data.name
      return createTooltipMarkup('nameValue', {
        name: null != l ? l + '' : null,
        value: s,
        noValue: r(s)
      })
    }),
    (t.prototype.optionUpdated = function () {}),
    (t.prototype.getDataParams = function (t, i) {
      var r = e.prototype.getDataParams.call(this, t, i)
      if (null == r.value && 'node' === i) {
        var n = this.getGraph().getNodeByIndex(t).getLayout().value
        r.value = n
      }
      return r
    }),
    (t.type = 'series.sankey'),
    (t.defaultOption = {
      zlevel: 0,
      z: 2,
      coordinateSystem: 'view',
      left: '5%',
      top: '5%',
      right: '20%',
      bottom: '5%',
      orient: 'horizontal',
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      label: { show: !0, position: 'right', fontSize: 12 },
      levels: [],
      nodeAlign: 'justify',
      lineStyle: { color: '#314656', opacity: 0.2, curveness: 0.5 },
      emphasis: { label: { show: !0 }, lineStyle: { opacity: 0.5 } },
      select: { itemStyle: { borderColor: '#212121' } },
      animationEasing: 'linear',
      animationDuration: 1e3
    }),
    t
  )
})(SeriesModel)
function sankeyLayout(e, t) {
  e.eachSeriesByType('sankey', function (e) {
    var i = e.get('nodeWidth'),
      r = e.get('nodeGap'),
      n = getViewRect$1(e, t)
    e.layoutInfo = n
    var a = n.width,
      o = n.height,
      s = e.getGraph(),
      l = s.nodes,
      h = s.edges
    computeNodeValues(l),
      layoutSankey(
        l,
        h,
        i,
        r,
        a,
        o,
        0 !==
          filter$1(l, function (e) {
            return 0 === e.getLayout().value
          }).length
          ? 0
          : e.get('layoutIterations'),
        e.get('orient'),
        e.get('nodeAlign')
      )
  })
}
function getViewRect$1(e, t) {
  return getLayoutRect(e.getBoxLayoutParams(), { width: t.getWidth(), height: t.getHeight() })
}
function layoutSankey(e, t, i, r, n, a, o, s, l) {
  computeNodeBreadths(e, t, i, n, a, s, l),
    computeNodeDepths(e, t, a, n, r, o, s),
    computeEdgeDepths(e, s)
}
function computeNodeValues(e) {
  each$i(e, function (e) {
    var t = sum(e.outEdges, getEdgeValue),
      i = sum(e.inEdges, getEdgeValue),
      r = e.getValue() || 0,
      n = Math.max(t, i, r)
    e.setLayout({ value: n }, !0)
  })
}
function computeNodeBreadths(e, t, i, r, n, a, o) {
  for (var s = [], l = [], h = [], u = [], p = 0, c = 0; c < t.length; c++) s[c] = 1
  for (c = 0; c < e.length; c++) (l[c] = e[c].inEdges.length), 0 === l[c] && h.push(e[c])
  for (var d = -1; h.length; ) {
    for (var f = 0; f < h.length; f++) {
      var m = h[f],
        g = m.hostGraph.data.getRawDataItem(m.dataIndex),
        y = null != g.depth && g.depth >= 0
      y && g.depth > d && (d = g.depth),
        m.setLayout({ depth: y ? g.depth : p }, !0),
        'vertical' === a ? m.setLayout({ dy: i }, !0) : m.setLayout({ dx: i }, !0)
      for (var v = 0; v < m.outEdges.length; v++) {
        var _ = m.outEdges[v]
        s[t.indexOf(_)] = 0
        var x = _.node2
        0 == --l[e.indexOf(x)] && u.indexOf(x) < 0 && u.push(x)
      }
    }
    ++p, (h = u), (u = [])
  }
  for (c = 0; c < s.length; c++)
    if (1 === s[c]) throw new Error('Sankey is a DAG, the original data has cycle!')
  var S = d > p - 1 ? d : p - 1
  o && 'left' !== o && adjustNodeWithNodeAlign(e, o, a, S),
    scaleNodeBreadths(e, 'vertical' === a ? (n - i) / S : (r - i) / S, a)
}
function isNodeDepth(e) {
  var t = e.hostGraph.data.getRawDataItem(e.dataIndex)
  return null != t.depth && t.depth >= 0
}
function adjustNodeWithNodeAlign(e, t, i, r) {
  if ('right' === t) {
    for (var n = [], a = e, o = 0; a.length; ) {
      for (var s = 0; s < a.length; s++) {
        var l = a[s]
        l.setLayout({ skNodeHeight: o }, !0)
        for (var h = 0; h < l.inEdges.length; h++) {
          var u = l.inEdges[h]
          n.indexOf(u.node1) < 0 && n.push(u.node1)
        }
      }
      ;(a = n), (n = []), ++o
    }
    each$i(e, function (e) {
      isNodeDepth(e) || e.setLayout({ depth: Math.max(0, r - e.getLayout().skNodeHeight) }, !0)
    })
  } else 'justify' === t && moveSinksRight(e, r)
}
function moveSinksRight(e, t) {
  each$i(e, function (e) {
    isNodeDepth(e) || e.outEdges.length || e.setLayout({ depth: t }, !0)
  })
}
function scaleNodeBreadths(e, t, i) {
  each$i(e, function (e) {
    var r = e.getLayout().depth * t
    'vertical' === i ? e.setLayout({ y: r }, !0) : e.setLayout({ x: r }, !0)
  })
}
function computeNodeDepths(e, t, i, r, n, a, o) {
  var s = prepareNodesByBreadth(e, o)
  initializeNodeDepth(s, t, i, r, n, o), resolveCollisions(s, n, i, r, o)
  for (var l = 1; a > 0; a--)
    relaxRightToLeft(s, (l *= 0.99), o),
      resolveCollisions(s, n, i, r, o),
      relaxLeftToRight(s, l, o),
      resolveCollisions(s, n, i, r, o)
}
function prepareNodesByBreadth(e, t) {
  var i = [],
    r = 'vertical' === t ? 'y' : 'x',
    n = groupData(e, function (e) {
      return e.getLayout()[r]
    })
  return (
    n.keys.sort(function (e, t) {
      return e - t
    }),
    each$i(n.keys, function (e) {
      i.push(n.buckets.get(e))
    }),
    i
  )
}
function initializeNodeDepth(e, t, i, r, n, a) {
  var o = 1 / 0
  each$i(e, function (e) {
    var t = e.length,
      s = 0
    each$i(e, function (e) {
      s += e.getLayout().value
    })
    var l = 'vertical' === a ? (r - (t - 1) * n) / s : (i - (t - 1) * n) / s
    l < o && (o = l)
  }),
    each$i(e, function (e) {
      each$i(e, function (e, t) {
        var i = e.getLayout().value * o
        'vertical' === a
          ? (e.setLayout({ x: t }, !0), e.setLayout({ dx: i }, !0))
          : (e.setLayout({ y: t }, !0), e.setLayout({ dy: i }, !0))
      })
    }),
    each$i(t, function (e) {
      var t = +e.getValue() * o
      e.setLayout({ dy: t }, !0)
    })
}
function resolveCollisions(e, t, i, r, n) {
  var a = 'vertical' === n ? 'x' : 'y'
  each$i(e, function (e) {
    var o, s, l
    e.sort(function (e, t) {
      return e.getLayout()[a] - t.getLayout()[a]
    })
    for (var h = 0, u = e.length, p = 'vertical' === n ? 'dx' : 'dy', c = 0; c < u; c++)
      (l = h - (s = e[c]).getLayout()[a]) > 0 &&
        ((o = s.getLayout()[a] + l),
        'vertical' === n ? s.setLayout({ x: o }, !0) : s.setLayout({ y: o }, !0)),
        (h = s.getLayout()[a] + s.getLayout()[p] + t)
    if ((l = h - t - ('vertical' === n ? r : i)) > 0) {
      ;(o = s.getLayout()[a] - l),
        'vertical' === n ? s.setLayout({ x: o }, !0) : s.setLayout({ y: o }, !0),
        (h = o)
      for (c = u - 2; c >= 0; --c)
        (l = (s = e[c]).getLayout()[a] + s.getLayout()[p] + t - h) > 0 &&
          ((o = s.getLayout()[a] - l),
          'vertical' === n ? s.setLayout({ x: o }, !0) : s.setLayout({ y: o }, !0)),
          (h = s.getLayout()[a])
    }
  })
}
function relaxRightToLeft(e, t, i) {
  each$i(e.slice().reverse(), function (e) {
    each$i(e, function (e) {
      if (e.outEdges.length) {
        var r = sum(e.outEdges, weightedTarget, i) / sum(e.outEdges, getEdgeValue)
        if (isNaN(r)) {
          var n = e.outEdges.length
          r = n ? sum(e.outEdges, centerTarget, i) / n : 0
        }
        if ('vertical' === i) {
          var a = e.getLayout().x + (r - center(e, i)) * t
          e.setLayout({ x: a }, !0)
        } else {
          var o = e.getLayout().y + (r - center(e, i)) * t
          e.setLayout({ y: o }, !0)
        }
      }
    })
  })
}
function weightedTarget(e, t) {
  return center(e.node2, t) * e.getValue()
}
function centerTarget(e, t) {
  return center(e.node2, t)
}
function weightedSource(e, t) {
  return center(e.node1, t) * e.getValue()
}
function centerSource(e, t) {
  return center(e.node1, t)
}
function center(e, t) {
  return 'vertical' === t
    ? e.getLayout().x + e.getLayout().dx / 2
    : e.getLayout().y + e.getLayout().dy / 2
}
function getEdgeValue(e) {
  return e.getValue()
}
function sum(e, t, i) {
  for (var r = 0, n = e.length, a = -1; ++a < n; ) {
    var o = +t(e[a], i)
    isNaN(o) || (r += o)
  }
  return r
}
function relaxLeftToRight(e, t, i) {
  each$i(e, function (e) {
    each$i(e, function (e) {
      if (e.inEdges.length) {
        var r = sum(e.inEdges, weightedSource, i) / sum(e.inEdges, getEdgeValue)
        if (isNaN(r)) {
          var n = e.inEdges.length
          r = n ? sum(e.inEdges, centerSource, i) / n : 0
        }
        if ('vertical' === i) {
          var a = e.getLayout().x + (r - center(e, i)) * t
          e.setLayout({ x: a }, !0)
        } else {
          var o = e.getLayout().y + (r - center(e, i)) * t
          e.setLayout({ y: o }, !0)
        }
      }
    })
  })
}
function computeEdgeDepths(e, t) {
  var i = 'vertical' === t ? 'x' : 'y'
  each$i(e, function (e) {
    e.outEdges.sort(function (e, t) {
      return e.node2.getLayout()[i] - t.node2.getLayout()[i]
    }),
      e.inEdges.sort(function (e, t) {
        return e.node1.getLayout()[i] - t.node1.getLayout()[i]
      })
  }),
    each$i(e, function (e) {
      var t = 0,
        i = 0
      each$i(e.outEdges, function (e) {
        e.setLayout({ sy: t }, !0), (t += e.getLayout().dy)
      }),
        each$i(e.inEdges, function (e) {
          e.setLayout({ ty: i }, !0), (i += e.getLayout().dy)
        })
    })
}
function sankeyVisual(e) {
  e.eachSeriesByType('sankey', function (e) {
    var t = e.getGraph().nodes
    if (t.length) {
      var i = 1 / 0,
        r = -1 / 0
      each$i(t, function (e) {
        var t = e.getLayout().value
        t < i && (i = t), t > r && (r = t)
      }),
        each$i(t, function (t) {
          var n = new VisualMapping({
              type: 'color',
              mappingMethod: 'linear',
              dataExtent: [i, r],
              visual: e.get('color')
            }).mapValueToVisual(t.getLayout().value),
            a = t.getModel().get(['itemStyle', 'color'])
          null != a
            ? (t.setVisual('color', a), t.setVisual('style', { fill: a }))
            : (t.setVisual('color', n), t.setVisual('style', { fill: n }))
        })
    }
  })
}
function install$A(e) {
  e.registerChartView(SankeyView),
    e.registerSeriesModel(SankeySeriesModel),
    e.registerLayout(sankeyLayout),
    e.registerVisual(sankeyVisual),
    e.registerAction({ type: 'dragNode', event: 'dragnode', update: 'update' }, function (e, t) {
      t.eachComponent({ mainType: 'series', subType: 'sankey', query: e }, function (t) {
        t.setNodePosition(e.dataIndex, [e.localX, e.localY])
      })
    })
}
var WhiskerBoxCommonMixin = (function () {
    function e() {}
    return (
      (e.prototype.getInitialData = function (e, t) {
        var i,
          r,
          n = t.getComponent('xAxis', this.get('xAxisIndex')),
          a = t.getComponent('yAxis', this.get('yAxisIndex')),
          o = n.get('type'),
          s = a.get('type')
        'category' === o
          ? ((e.layout = 'horizontal'), (i = n.getOrdinalMeta()), (r = !0))
          : 'category' === s
          ? ((e.layout = 'vertical'), (i = a.getOrdinalMeta()), (r = !0))
          : (e.layout = e.layout || 'horizontal')
        var l = ['x', 'y'],
          h = 'horizontal' === e.layout ? 0 : 1,
          u = (this._baseAxisDim = l[h]),
          p = l[1 - h],
          c = [n, a],
          d = c[h].get('type'),
          f = c[1 - h].get('type'),
          m = e.data
        if (m && r) {
          var g = []
          each$i(m, function (e, t) {
            var i
            isArray$1(e)
              ? ((i = e.slice()), e.unshift(t))
              : isArray$1(e.value)
              ? ((i = e.value.slice()), e.value.unshift(t))
              : (i = e),
              g.push(i)
          }),
            (e.data = g)
        }
        var y = this.defaultValueDimensions,
          v = [
            {
              name: u,
              type: getDimensionTypeByAxis(d),
              ordinalMeta: i,
              otherDims: { tooltip: !1, itemName: 0 },
              dimsDef: ['base']
            },
            { name: p, type: getDimensionTypeByAxis(f), dimsDef: y.slice() }
          ]
        return createListSimply(this, {
          coordDimensions: v,
          dimensionsCount: y.length + 1,
          encodeDefaulter: curry$1(makeSeriesEncodeForAxisCoordSys, v, this)
        })
      }),
      (e.prototype.getBaseAxis = function () {
        var e = this._baseAxisDim
        return this.ecModel.getComponent(e + 'Axis', this.get(e + 'AxisIndex')).axis
      }),
      e
    )
  })(),
  BoxplotSeriesModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (
        (i.type = t.type),
        (i.defaultValueDimensions = [
          { name: 'min', defaultTooltip: !0 },
          { name: 'Q1', defaultTooltip: !0 },
          { name: 'median', defaultTooltip: !0 },
          { name: 'Q3', defaultTooltip: !0 },
          { name: 'max', defaultTooltip: !0 }
        ]),
        (i.visualDrawType = 'stroke'),
        i
      )
    }
    return (
      __extends(t, e),
      (t.type = 'series.boxplot'),
      (t.dependencies = ['xAxis', 'yAxis', 'grid']),
      (t.defaultOption = {
        zlevel: 0,
        z: 2,
        coordinateSystem: 'cartesian2d',
        legendHoverLink: !0,
        layout: null,
        boxWidth: [7, 50],
        itemStyle: { color: '#fff', borderWidth: 1 },
        emphasis: {
          scale: !0,
          itemStyle: {
            borderWidth: 2,
            shadowBlur: 5,
            shadowOffsetX: 1,
            shadowOffsetY: 1,
            shadowColor: 'rgba(0,0,0,0.2)'
          }
        },
        animationDuration: 800
      }),
      t
    )
  })(SeriesModel)
mixin(BoxplotSeriesModel, WhiskerBoxCommonMixin, !0)
var BoxplotView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i) {
        var r = e.getData(),
          n = this.group,
          a = this._data
        this._data || n.removeAll()
        var o = 'horizontal' === e.get('layout') ? 1 : 0
        r
          .diff(a)
          .add(function (e) {
            if (r.hasValue(e)) {
              var t = createNormalBox$1(r.getItemLayout(e), r, e, o, !0)
              r.setItemGraphicEl(e, t), n.add(t)
            }
          })
          .update(function (e, t) {
            var i = a.getItemGraphicEl(t)
            if (r.hasValue(e)) {
              var s = r.getItemLayout(e)
              i ? updateNormalBoxData(s, i, r, e) : (i = createNormalBox$1(s, r, e, o)),
                n.add(i),
                r.setItemGraphicEl(e, i)
            } else n.remove(i)
          })
          .remove(function (e) {
            var t = a.getItemGraphicEl(e)
            t && n.remove(t)
          })
          .execute(),
          (this._data = r)
      }),
      (t.prototype.remove = function (e) {
        var t = this.group,
          i = this._data
        ;(this._data = null),
          i &&
            i.eachItemGraphicEl(function (e) {
              e && t.remove(e)
            })
      }),
      (t.type = 'boxplot'),
      t
    )
  })(ChartView),
  BoxPathShape = function () {},
  BoxPath = (function (e) {
    function t(t) {
      var i = e.call(this, t) || this
      return (i.type = 'boxplotBoxPath'), i
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultShape = function () {
        return new BoxPathShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        var i = t.points,
          r = 0
        for (e.moveTo(i[r][0], i[r][1]), r++; r < 4; r++) e.lineTo(i[r][0], i[r][1])
        for (e.closePath(); r < i.length; r++)
          e.moveTo(i[r][0], i[r][1]), r++, e.lineTo(i[r][0], i[r][1])
      }),
      t
    )
  })(Path)
function createNormalBox$1(e, t, i, r, n) {
  var a = e.ends,
    o = new BoxPath({ shape: { points: n ? transInit$1(a, r, e) : a } })
  return updateNormalBoxData(e, o, t, i, n), o
}
function updateNormalBoxData(e, t, i, r, n) {
  var a = i.hostModel
  ;(0, graphic[n ? 'initProps' : 'updateProps'])(t, { shape: { points: e.ends } }, a, r),
    t.useStyle(i.getItemVisual(r, 'style')),
    (t.style.strokeNoScale = !0),
    (t.z2 = 100)
  var o = i.getItemModel(r)
  setStatesStylesFromModel(t, o),
    enableHoverEmphasis(t, o.get(['emphasis', 'focus']), o.get(['emphasis', 'blurScope']))
}
function transInit$1(e, t, i) {
  return map$1(e, function (e) {
    return ((e = e.slice())[t] = i.initBaseline), e
  })
}
function boxplotVisual(e, t) {}
var each$b = each$i
function boxplotLayout(e) {
  var t = groupSeriesByAxis(e)
  each$b(t, function (e) {
    var t = e.seriesModels
    t.length &&
      (calculateBase(e),
      each$b(t, function (t, i) {
        layoutSingleSeries(t, e.boxOffsetList[i], e.boxWidthList[i])
      }))
  })
}
function groupSeriesByAxis(e) {
  var t = [],
    i = []
  return (
    e.eachSeriesByType('boxplot', function (e) {
      var r = e.getBaseAxis(),
        n = indexOf$1(i, r)
      n < 0 && ((n = i.length), (i[n] = r), (t[n] = { axis: r, seriesModels: [] })),
        t[n].seriesModels.push(e)
    }),
    t
  )
}
function calculateBase(e) {
  var t,
    i,
    r = e.axis,
    n = e.seriesModels,
    a = n.length,
    o = (e.boxWidthList = []),
    s = (e.boxOffsetList = []),
    l = []
  if ('category' === r.type) i = r.getBandWidth()
  else {
    var h = 0
    each$b(n, function (e) {
      h = Math.max(h, e.getData().count())
    }),
      (t = r.getExtent()),
      Math.abs(t[1] - t[0])
  }
  each$b(n, function (e) {
    var t = e.get('boxWidth')
    isArray$1(t) || (t = [t, t]),
      l.push([parsePercent$1(t[0], i) || 0, parsePercent$1(t[1], i) || 0])
  })
  var u = 0.8 * i - 2,
    p = (u / a) * 0.3,
    c = (u - p * (a - 1)) / a,
    d = c / 2 - u / 2
  each$b(n, function (e, t) {
    s.push(d), (d += p + c), o.push(Math.min(Math.max(c, l[t][0]), l[t][1]))
  })
}
function layoutSingleSeries(e, t, i) {
  var r = e.coordinateSystem,
    n = e.getData(),
    a = i / 2,
    o = 'horizontal' === e.get('layout') ? 0 : 1,
    s = 1 - o,
    l = ['x', 'y'],
    h = n.mapDimension(l[o]),
    u = n.mapDimensionsAll(l[s])
  if (!(null == h || u.length < 5))
    for (var p = 0; p < n.count(); p++) {
      var c = n.get(h, p),
        d = _(c, u[2], p),
        f = _(c, u[0], p),
        m = _(c, u[1], p),
        g = _(c, u[3], p),
        y = _(c, u[4], p),
        v = []
      x(v, m, !1),
        x(v, g, !0),
        v.push(f, m, y, g),
        S(v, f),
        S(v, y),
        S(v, d),
        n.setItemLayout(p, { initBaseline: d[s], ends: v })
    }
  function _(e, i, a) {
    var l,
      h = n.get(i, a),
      u = []
    return (
      (u[o] = e),
      (u[s] = h),
      isNaN(e) || isNaN(h) ? (l = [NaN, NaN]) : ((l = r.dataToPoint(u))[o] += t),
      l
    )
  }
  function x(e, t, i) {
    var r = t.slice(),
      n = t.slice()
    ;(r[o] += a), (n[o] -= a), i ? e.push(r, n) : e.push(n, r)
  }
  function S(e, t) {
    var i = t.slice(),
      r = t.slice()
    ;(i[o] -= a), (r[o] += a), e.push(i, r)
  }
}
function prepareBoxplotData(e, t) {
  for (
    var i = [], r = [], n = (t = t || {}).boundIQR, a = 'none' === n || 0 === n, o = 0;
    o < e.length;
    o++
  ) {
    var s = asc$2(e[o].slice()),
      l = quantile(s, 0.25),
      h = quantile(s, 0.5),
      u = quantile(s, 0.75),
      p = s[0],
      c = s[s.length - 1],
      d = (null == n ? 1.5 : n) * (u - l),
      f = a ? p : Math.max(p, l - d),
      m = a ? c : Math.min(c, u + d),
      g = t.itemNameFormatter,
      y = isFunction$1(g) ? g({ value: o }) : isString(g) ? g.replace('{value}', o + '') : o + ''
    i.push([y, f, l, h, u, m])
    for (var v = 0; v < s.length; v++) {
      var _ = s[v]
      if (_ < f || _ > m) {
        var x = [y, _]
        r.push(x)
      }
    }
  }
  return { boxData: i, outliers: r }
}
var boxplotTransform = {
  type: 'echarts:boxplot',
  transform: function (e) {
    var t = e.upstream
    if (t.sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS) {
      throwError('')
    }
    var i = prepareBoxplotData(t.getRawData(), e.config)
    return [
      { dimensions: ['ItemName', 'Low', 'Q1', 'Q2', 'Q3', 'High'], data: i.boxData },
      { data: i.outliers }
    ]
  }
}
function install$z(e) {
  e.registerSeriesModel(BoxplotSeriesModel),
    e.registerChartView(BoxplotView),
    e.registerVisual(boxplotVisual),
    e.registerLayout(boxplotLayout),
    e.registerTransform(boxplotTransform)
}
var SKIP_PROPS = ['color', 'borderColor'],
  CandlestickView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i) {
        this.group.removeClipPath(),
          this._updateDrawMode(e),
          this._isLargeDraw ? this._renderLarge(e) : this._renderNormal(e)
      }),
      (t.prototype.incrementalPrepareRender = function (e, t, i) {
        this._clear(), this._updateDrawMode(e)
      }),
      (t.prototype.incrementalRender = function (e, t, i, r) {
        this._isLargeDraw ? this._incrementalRenderLarge(e, t) : this._incrementalRenderNormal(e, t)
      }),
      (t.prototype._updateDrawMode = function (e) {
        var t = e.pipelineContext.large
        ;(null != this._isLargeDraw && t === this._isLargeDraw) ||
          ((this._isLargeDraw = t), this._clear())
      }),
      (t.prototype._renderNormal = function (e) {
        var t = e.getData(),
          i = this._data,
          r = this.group,
          n = t.getLayout('isSimpleBox'),
          a = e.get('clip', !0),
          o = e.coordinateSystem,
          s = o.getArea && o.getArea()
        this._data || r.removeAll(),
          t
            .diff(i)
            .add(function (i) {
              if (t.hasValue(i)) {
                var o = t.getItemLayout(i)
                if (a && isNormalBoxClipped(s, o)) return
                var l = createNormalBox(o, i, !0)
                initProps(l, { shape: { points: o.ends } }, e, i),
                  setBoxCommon(l, t, i, n),
                  r.add(l),
                  t.setItemGraphicEl(i, l)
              }
            })
            .update(function (o, l) {
              var h = i.getItemGraphicEl(l)
              if (t.hasValue(o)) {
                var u = t.getItemLayout(o)
                a && isNormalBoxClipped(s, u)
                  ? r.remove(h)
                  : (h
                      ? updateProps$1(h, { shape: { points: u.ends } }, e, o)
                      : (h = createNormalBox(u)),
                    setBoxCommon(h, t, o, n),
                    r.add(h),
                    t.setItemGraphicEl(o, h))
              } else r.remove(h)
            })
            .remove(function (e) {
              var t = i.getItemGraphicEl(e)
              t && r.remove(t)
            })
            .execute(),
          (this._data = t)
      }),
      (t.prototype._renderLarge = function (e) {
        this._clear(), createLarge(e, this.group)
        var t = e.get('clip', !0) ? createClipPath(e.coordinateSystem, !1, e) : null
        t ? this.group.setClipPath(t) : this.group.removeClipPath()
      }),
      (t.prototype._incrementalRenderNormal = function (e, t) {
        for (var i, r = t.getData(), n = r.getLayout('isSimpleBox'); null != (i = e.next()); ) {
          var a = createNormalBox(r.getItemLayout(i))
          setBoxCommon(a, r, i, n), (a.incremental = !0), this.group.add(a)
        }
      }),
      (t.prototype._incrementalRenderLarge = function (e, t) {
        createLarge(t, this.group, !0)
      }),
      (t.prototype.remove = function (e) {
        this._clear()
      }),
      (t.prototype._clear = function () {
        this.group.removeAll(), (this._data = null)
      }),
      (t.type = 'candlestick'),
      t
    )
  })(ChartView),
  NormalBoxPathShape = function () {},
  NormalBoxPath = (function (e) {
    function t(t) {
      var i = e.call(this, t) || this
      return (i.type = 'normalCandlestickBox'), i
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultShape = function () {
        return new NormalBoxPathShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        var i = t.points
        this.__simpleBox
          ? (e.moveTo(i[4][0], i[4][1]), e.lineTo(i[6][0], i[6][1]))
          : (e.moveTo(i[0][0], i[0][1]),
            e.lineTo(i[1][0], i[1][1]),
            e.lineTo(i[2][0], i[2][1]),
            e.lineTo(i[3][0], i[3][1]),
            e.closePath(),
            e.moveTo(i[4][0], i[4][1]),
            e.lineTo(i[5][0], i[5][1]),
            e.moveTo(i[6][0], i[6][1]),
            e.lineTo(i[7][0], i[7][1]))
      }),
      t
    )
  })(Path)
function createNormalBox(e, t, i) {
  var r = e.ends
  return new NormalBoxPath({ shape: { points: i ? transInit(r, e) : r }, z2: 100 })
}
function isNormalBoxClipped(e, t) {
  for (var i = !0, r = 0; r < t.ends.length; r++)
    if (e.contain(t.ends[r][0], t.ends[r][1])) {
      i = !1
      break
    }
  return i
}
function setBoxCommon(e, t, i, r) {
  var n = t.getItemModel(i)
  e.useStyle(t.getItemVisual(i, 'style')),
    (e.style.strokeNoScale = !0),
    (e.__simpleBox = r),
    setStatesStylesFromModel(e, n)
}
function transInit(e, t) {
  return map$1(e, function (e) {
    return ((e = e.slice())[1] = t.initBaseline), e
  })
}
var LargeBoxPathShape = function () {},
  LargeBoxPath = (function (e) {
    function t(t) {
      var i = e.call(this, t) || this
      return (i.type = 'largeCandlestickBox'), i
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultShape = function () {
        return new LargeBoxPathShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        for (var i = t.points, r = 0; r < i.length; )
          if (this.__sign === i[r++]) {
            var n = i[r++]
            e.moveTo(n, i[r++]), e.lineTo(n, i[r++])
          } else r += 3
      }),
      t
    )
  })(Path)
function createLarge(e, t, i) {
  var r = e.getData().getLayout('largePoints'),
    n = new LargeBoxPath({ shape: { points: r }, __sign: 1 })
  t.add(n)
  var a = new LargeBoxPath({ shape: { points: r }, __sign: -1 })
  t.add(a),
    setLargeStyle(1, n, e),
    setLargeStyle(-1, a, e),
    i && ((n.incremental = !0), (a.incremental = !0))
}
function setLargeStyle(e, t, i, r) {
  var n =
      i.get(['itemStyle', e > 0 ? 'borderColor' : 'borderColor0']) ||
      i.get(['itemStyle', e > 0 ? 'color' : 'color0']),
    a = i.getModel('itemStyle').getItemStyle(SKIP_PROPS)
  t.useStyle(a), (t.style.fill = null), (t.style.stroke = n)
}
var CandlestickSeriesModel = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (
      (i.type = t.type),
      (i.defaultValueDimensions = [
        { name: 'open', defaultTooltip: !0 },
        { name: 'close', defaultTooltip: !0 },
        { name: 'lowest', defaultTooltip: !0 },
        { name: 'highest', defaultTooltip: !0 }
      ]),
      i
    )
  }
  return (
    __extends(t, e),
    (t.prototype.getShadowDim = function () {
      return 'open'
    }),
    (t.prototype.brushSelector = function (e, t, i) {
      var r = t.getItemLayout(e)
      return r && i.rect(r.brushRect)
    }),
    (t.type = 'series.candlestick'),
    (t.dependencies = ['xAxis', 'yAxis', 'grid']),
    (t.defaultOption = {
      zlevel: 0,
      z: 2,
      coordinateSystem: 'cartesian2d',
      legendHoverLink: !0,
      layout: null,
      clip: !0,
      itemStyle: {
        color: '#eb5454',
        color0: '#47b262',
        borderColor: '#eb5454',
        borderColor0: '#47b262',
        borderWidth: 1
      },
      emphasis: { scale: !0, itemStyle: { borderWidth: 2 } },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: !0,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: 'mod',
      animationEasing: 'linear',
      animationDuration: 300
    }),
    t
  )
})(SeriesModel)
function candlestickPreprocessor(e) {
  e &&
    isArray$1(e.series) &&
    each$i(e.series, function (e) {
      isObject$7(e) && 'k' === e.type && (e.type = 'candlestick')
    })
}
mixin(CandlestickSeriesModel, WhiskerBoxCommonMixin, !0)
var positiveBorderColorQuery = ['itemStyle', 'borderColor'],
  negativeBorderColorQuery = ['itemStyle', 'borderColor0'],
  positiveColorQuery = ['itemStyle', 'color'],
  negativeColorQuery = ['itemStyle', 'color0'],
  candlestickVisual = {
    seriesType: 'candlestick',
    plan: createRenderPlanner(),
    performRawSeries: !0,
    reset: function (e, t) {
      function i(e, t) {
        return t.get(e > 0 ? positiveColorQuery : negativeColorQuery)
      }
      function r(e, t) {
        return t.get(e > 0 ? positiveBorderColorQuery : negativeBorderColorQuery)
      }
      if (!t.isSeriesFiltered(e))
        return (
          !e.pipelineContext.large && {
            progress: function (e, t) {
              for (var n; null != (n = e.next()); ) {
                var a = t.getItemModel(n),
                  o = t.getItemLayout(n).sign,
                  s = a.getItemStyle()
                ;(s.fill = i(o, a)),
                  (s.stroke = r(o, a) || s.fill),
                  extend$3(t.ensureUniqueItemVisual(n, 'style'), s)
              }
            }
          }
        )
    }
  },
  LargeArr = 'undefined' != typeof Float32Array ? Float32Array : Array,
  candlestickLayout = {
    seriesType: 'candlestick',
    plan: createRenderPlanner(),
    reset: function (e) {
      var t = e.coordinateSystem,
        i = e.getData(),
        r = calculateCandleWidth(e, i),
        n = ['x', 'y'],
        a = i.mapDimension(n[0]),
        o = i.mapDimensionsAll(n[1]),
        s = o[0],
        l = o[1],
        h = o[2],
        u = o[3]
      if ((i.setLayout({ candleWidth: r, isSimpleBox: r <= 1.3 }), !(null == a || o.length < 4)))
        return {
          progress: e.pipelineContext.large
            ? function (e, i) {
                var r,
                  n,
                  o = new LargeArr(4 * e.count),
                  p = 0,
                  c = [],
                  d = []
                for (; null != (n = e.next()); ) {
                  var f = i.get(a, n),
                    m = i.get(s, n),
                    g = i.get(l, n),
                    y = i.get(h, n),
                    v = i.get(u, n)
                  isNaN(f) || isNaN(y) || isNaN(v)
                    ? ((o[p++] = NaN), (p += 3))
                    : ((o[p++] = getSign(i, n, m, g, l)),
                      (c[0] = f),
                      (c[1] = y),
                      (r = t.dataToPoint(c, null, d)),
                      (o[p++] = r ? r[0] : NaN),
                      (o[p++] = r ? r[1] : NaN),
                      (c[1] = v),
                      (r = t.dataToPoint(c, null, d)),
                      (o[p++] = r ? r[1] : NaN))
                }
                i.setLayout('largePoints', o)
              }
            : function (e, i) {
                var n
                for (; null != (n = e.next()); ) {
                  var o = i.get(a, n),
                    p = i.get(s, n),
                    c = i.get(l, n),
                    d = i.get(h, n),
                    f = i.get(u, n),
                    m = Math.min(p, c),
                    g = Math.max(p, c),
                    y = b(m, o),
                    v = b(g, o),
                    _ = b(d, o),
                    x = b(f, o),
                    S = []
                  T(S, v, 0),
                    T(S, y, 1),
                    S.push(w(x), w(v), w(_), w(y)),
                    i.setItemLayout(n, {
                      sign: getSign(i, n, p, c, l),
                      initBaseline: p > c ? v[1] : y[1],
                      ends: S,
                      brushRect: A(d, f, o)
                    })
                }
                function b(e, i) {
                  var r = []
                  return (
                    (r[0] = i), (r[1] = e), isNaN(i) || isNaN(e) ? [NaN, NaN] : t.dataToPoint(r)
                  )
                }
                function T(e, t, i) {
                  var n = t.slice(),
                    a = t.slice()
                  ;(n[0] = subPixelOptimize(n[0] + r / 2, 1, !1)),
                    (a[0] = subPixelOptimize(a[0] - r / 2, 1, !0)),
                    i ? e.push(n, a) : e.push(a, n)
                }
                function A(e, t, i) {
                  var n = b(e, i),
                    a = b(t, i)
                  return (
                    (n[0] -= r / 2),
                    (a[0] -= r / 2),
                    { x: n[0], y: n[1], width: r, height: a[1] - n[1] }
                  )
                }
                function w(e) {
                  return (e[0] = subPixelOptimize(e[0], 1)), e
                }
              }
        }
    }
  }
function getSign(e, t, i, r, n) {
  return i > r ? -1 : i < r ? 1 : t > 0 ? (e.get(n, t - 1) <= r ? 1 : -1) : 1
}
function calculateCandleWidth(e, t) {
  var i,
    r = e.getBaseAxis(),
    n =
      'category' === r.type
        ? r.getBandWidth()
        : ((i = r.getExtent()), Math.abs(i[1] - i[0]) / t.count()),
    a = parsePercent$1(retrieve2(e.get('barMaxWidth'), n), n),
    o = parsePercent$1(retrieve2(e.get('barMinWidth'), 1), n),
    s = e.get('barWidth')
  return null != s ? parsePercent$1(s, n) : Math.max(Math.min(n / 2, a), o)
}
function install$y(e) {
  e.registerChartView(CandlestickView),
    e.registerSeriesModel(CandlestickSeriesModel),
    e.registerPreprocessor(candlestickPreprocessor),
    e.registerVisual(candlestickVisual),
    e.registerLayout(candlestickLayout)
}
var EFFECT_RIPPLE_NUMBER = 3
function normalizeSymbolSize(e) {
  return isArray$1(e) || (e = [+e, +e]), e
}
function updateRipplePath(e, t) {
  var i = t.rippleEffectColor || t.color
  e.eachChild(function (e) {
    e.attr({
      z: t.z,
      zlevel: t.zlevel,
      style: {
        stroke: 'stroke' === t.brushType ? i : null,
        fill: 'fill' === t.brushType ? i : null
      }
    })
  })
}
var EffectSymbol = (function (e) {
    function t(t, i) {
      var r = e.call(this) || this,
        n = new Symbol$1(t, i),
        a = new Group$3()
      return r.add(n), r.add(a), r.updateData(t, i), r
    }
    return (
      __extends(t, e),
      (t.prototype.stopEffectAnimation = function () {
        this.childAt(1).removeAll()
      }),
      (t.prototype.startEffectAnimation = function (e) {
        for (
          var t = e.symbolType, i = e.color, r = this.childAt(1), n = 0;
          n < EFFECT_RIPPLE_NUMBER;
          n++
        ) {
          var a = createSymbol$1(t, -1, -1, 2, 2, i)
          a.attr({ style: { strokeNoScale: !0 }, z2: 99, silent: !0, scaleX: 0.5, scaleY: 0.5 })
          var o = (-n / EFFECT_RIPPLE_NUMBER) * e.period + e.effectOffset
          a
            .animate('', !0)
            .when(e.period, { scaleX: e.rippleScale / 2, scaleY: e.rippleScale / 2 })
            .delay(o)
            .start(),
            a.animateStyle(!0).when(e.period, { opacity: 0 }).delay(o).start(),
            r.add(a)
        }
        updateRipplePath(r, e)
      }),
      (t.prototype.updateEffectAnimation = function (e) {
        for (
          var t = this._effectCfg,
            i = this.childAt(1),
            r = ['symbolType', 'period', 'rippleScale'],
            n = 0;
          n < r.length;
          n++
        ) {
          var a = r[n]
          if (t[a] !== e[a]) return this.stopEffectAnimation(), void this.startEffectAnimation(e)
        }
        updateRipplePath(i, e)
      }),
      (t.prototype.highlight = function () {
        enterEmphasis(this)
      }),
      (t.prototype.downplay = function () {
        leaveEmphasis(this)
      }),
      (t.prototype.updateData = function (e, t) {
        var i = this,
          r = e.hostModel
        this.childAt(0).updateData(e, t)
        var n = this.childAt(1),
          a = e.getItemModel(t),
          o = e.getItemVisual(t, 'symbol'),
          s = normalizeSymbolSize(e.getItemVisual(t, 'symbolSize')),
          l = e.getItemVisual(t, 'style'),
          h = l && l.fill
        n.setScale(s),
          n.traverse(function (e) {
            e.setStyle('fill', h)
          })
        var u = e.getItemVisual(t, 'symbolOffset')
        u &&
          (isArray$1(u) || (u = [u, u]),
          (n.x = parsePercent$1(u[0], s[0])),
          (n.y = parsePercent$1(retrieve2(u[1], u[0]) || 0, s[1])))
        var p = e.getItemVisual(t, 'symbolRotate')
        n.rotation = ((p || 0) * Math.PI) / 180 || 0
        var c = {}
        ;(c.showEffectOn = r.get('showEffectOn')),
          (c.rippleScale = a.get(['rippleEffect', 'scale'])),
          (c.brushType = a.get(['rippleEffect', 'brushType'])),
          (c.period = 1e3 * a.get(['rippleEffect', 'period'])),
          (c.effectOffset = t / e.count()),
          (c.z = r.getShallow('z') || 0),
          (c.zlevel = r.getShallow('zlevel') || 0),
          (c.symbolType = o),
          (c.color = h),
          (c.rippleEffectColor = a.get(['rippleEffect', 'color'])),
          this.off('mouseover').off('mouseout').off('emphasis').off('normal'),
          'render' === c.showEffectOn
            ? (this._effectCfg ? this.updateEffectAnimation(c) : this.startEffectAnimation(c),
              (this._effectCfg = c))
            : ((this._effectCfg = null),
              this.stopEffectAnimation(),
              (this.onHoverStateChange = function (e) {
                'emphasis' === e
                  ? 'render' !== c.showEffectOn && i.startEffectAnimation(c)
                  : 'normal' === e && 'render' !== c.showEffectOn && i.stopEffectAnimation()
              })),
          (this._effectCfg = c),
          enableHoverEmphasis(this)
      }),
      (t.prototype.fadeOut = function (e) {
        this.off('mouseover').off('mouseout'), e && e()
      }),
      t
    )
  })(Group$3),
  EffectScatterView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function () {
        this._symbolDraw = new SymbolDraw(EffectSymbol)
      }),
      (t.prototype.render = function (e, t, i) {
        var r = e.getData(),
          n = this._symbolDraw
        n.updateData(r, { clipShape: this._getClipShape(e) }), this.group.add(n.group)
      }),
      (t.prototype._getClipShape = function (e) {
        var t = e.coordinateSystem,
          i = t && t.getArea && t.getArea()
        return e.get('clip', !0) ? i : null
      }),
      (t.prototype.updateTransform = function (e, t, i) {
        var r = e.getData()
        this.group.dirty()
        var n = pointsLayout('').reset(e, t, i)
        n.progress && n.progress({ start: 0, end: r.count(), count: r.count() }, r),
          this._symbolDraw.updateLayout()
      }),
      (t.prototype._updateGroupTransform = function (e) {
        var t = e.coordinateSystem
        t &&
          t.getRoamTransform &&
          ((this.group.transform = clone$1(t.getRoamTransform())), this.group.decomposeTransform())
      }),
      (t.prototype.remove = function (e, t) {
        this._symbolDraw && this._symbolDraw.remove(!0)
      }),
      (t.type = 'effectScatter'),
      t
    )
  })(ChartView),
  EffectScatterSeriesModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.hasSymbolVisual = !0), i
    }
    return (
      __extends(t, e),
      (t.prototype.getInitialData = function (e, t) {
        return createListFromArray(this.getSource(), this, { useEncodeDefaulter: !0 })
      }),
      (t.prototype.brushSelector = function (e, t, i) {
        return i.point(t.getItemLayout(e))
      }),
      (t.type = 'series.effectScatter'),
      (t.dependencies = ['grid', 'polar']),
      (t.defaultOption = {
        coordinateSystem: 'cartesian2d',
        zlevel: 0,
        z: 2,
        legendHoverLink: !0,
        effectType: 'ripple',
        progressive: 0,
        showEffectOn: 'render',
        clip: !0,
        rippleEffect: { period: 4, scale: 2.5, brushType: 'fill' },
        symbolSize: 10
      }),
      t
    )
  })(SeriesModel)
function install$x(e) {
  e.registerChartView(EffectScatterView),
    e.registerSeriesModel(EffectScatterSeriesModel),
    e.registerLayout(pointsLayout('effectScatter'))
}
var EffectLine = (function (e) {
    function t(t, i, r) {
      var n = e.call(this) || this
      return n.add(n.createLine(t, i, r)), n._updateEffectSymbol(t, i), n
    }
    return (
      __extends(t, e),
      (t.prototype.createLine = function (e, t, i) {
        return new Line(e, t, i)
      }),
      (t.prototype._updateEffectSymbol = function (e, t) {
        var i = e.getItemModel(t).getModel('effect'),
          r = i.get('symbolSize'),
          n = i.get('symbol')
        isArray$1(r) || (r = [r, r])
        var a = e.getItemVisual(t, 'style'),
          o = i.get('color') || (a && a.stroke),
          s = this.childAt(1)
        this._symbolType !== n &&
          (this.remove(s),
          ((s = createSymbol$1(n, -0.5, -0.5, 1, 1, o)).z2 = 100),
          (s.culling = !0),
          this.add(s)),
          s &&
            (s.setStyle('shadowColor', o),
            s.setStyle(i.getItemStyle(['color'])),
            (s.scaleX = r[0]),
            (s.scaleY = r[1]),
            s.setColor(o),
            (this._symbolType = n),
            (this._symbolScale = r),
            this._updateEffectAnimation(e, i, t))
      }),
      (t.prototype._updateEffectAnimation = function (e, t, i) {
        var r = this.childAt(1)
        if (r) {
          var n = this,
            a = e.getItemLayout(i),
            o = 1e3 * t.get('period'),
            s = t.get('loop'),
            l = t.get('constantSpeed'),
            h = retrieve(t.get('delay'), function (t) {
              return ((t / e.count()) * o) / 3
            })
          if (
            ((r.ignore = !0),
            this._updateAnimationPoints(r, a),
            l > 0 && (o = (this._getLineLength(r) / l) * 1e3),
            (o !== this._period || s !== this._loop) && (r.stopAnimation(), o > 0))
          ) {
            var u = void 0
            ;(u = 'function' == typeof h ? h(i) : h), r.__t > 0 && (u = -o * r.__t), (r.__t = 0)
            var p = r
              .animate('', s)
              .when(o, { __t: 1 })
              .delay(u)
              .during(function () {
                n._updateSymbolPosition(r)
              })
            s ||
              p.done(function () {
                n.remove(r)
              }),
              p.start()
          }
          ;(this._period = o), (this._loop = s)
        }
      }),
      (t.prototype._getLineLength = function (e) {
        return dist$1(e.__p1, e.__cp1) + dist$1(e.__cp1, e.__p2)
      }),
      (t.prototype._updateAnimationPoints = function (e, t) {
        ;(e.__p1 = t[0]),
          (e.__p2 = t[1]),
          (e.__cp1 = t[2] || [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2])
      }),
      (t.prototype.updateData = function (e, t, i) {
        this.childAt(0).updateData(e, t, i), this._updateEffectSymbol(e, t)
      }),
      (t.prototype._updateSymbolPosition = function (e) {
        var t = e.__p1,
          i = e.__p2,
          r = e.__cp1,
          n = e.__t,
          a = [e.x, e.y],
          o = a.slice(),
          s = quadraticAt$1,
          l = quadraticDerivativeAt
        ;(a[0] = s(t[0], r[0], i[0], n)), (a[1] = s(t[1], r[1], i[1], n))
        var h = l(t[0], r[0], i[0], n),
          u = l(t[1], r[1], i[1], n)
        ;(e.rotation = -Math.atan2(u, h) - Math.PI / 2),
          ('line' !== this._symbolType &&
            'rect' !== this._symbolType &&
            'roundRect' !== this._symbolType) ||
            (void 0 !== e.__lastT && e.__lastT < e.__t
              ? ((e.scaleY = 1.05 * dist$1(o, a)),
                1 === n && ((a[0] = o[0] + (a[0] - o[0]) / 2), (a[1] = o[1] + (a[1] - o[1]) / 2)))
              : 1 === e.__lastT
              ? (e.scaleY = 2 * dist$1(t, a))
              : (e.scaleY = this._symbolScale[1])),
          (e.__lastT = e.__t),
          (e.ignore = !1),
          (e.x = a[0]),
          (e.y = a[1])
      }),
      (t.prototype.updateLayout = function (e, t) {
        this.childAt(0).updateLayout(e, t)
        var i = e.getItemModel(t).getModel('effect')
        this._updateEffectAnimation(e, i, t)
      }),
      t
    )
  })(Group$3),
  Polyline = (function (e) {
    function t(t, i, r) {
      var n = e.call(this) || this
      return n._createPolyline(t, i, r), n
    }
    return (
      __extends(t, e),
      (t.prototype._createPolyline = function (e, t, i) {
        var r = e.getItemLayout(t),
          n = new Polyline$1({ shape: { points: r } })
        this.add(n), this._updateCommonStl(e, t, i)
      }),
      (t.prototype.updateData = function (e, t, i) {
        var r = e.hostModel
        updateProps$1(this.childAt(0), { shape: { points: e.getItemLayout(t) } }, r, t),
          this._updateCommonStl(e, t, i)
      }),
      (t.prototype._updateCommonStl = function (e, t, i) {
        var r = this.childAt(0),
          n = e.getItemModel(t),
          a = i && i.emphasisLineStyle
        ;(i && !e.hasItemOption) || (a = n.getModel(['emphasis', 'lineStyle']).getLineStyle()),
          r.useStyle(e.getItemVisual(t, 'style')),
          (r.style.fill = null),
          (r.style.strokeNoScale = !0),
          (r.ensureState('emphasis').style = a),
          enableHoverEmphasis(this)
      }),
      (t.prototype.updateLayout = function (e, t) {
        this.childAt(0).setShape('points', e.getItemLayout(t))
      }),
      t
    )
  })(Group$3),
  EffectPolyline = (function (e) {
    function t() {
      var t = (null !== e && e.apply(this, arguments)) || this
      return (t._lastFrame = 0), (t._lastFramePercent = 0), t
    }
    return (
      __extends(t, e),
      (t.prototype.createLine = function (e, t, i) {
        return new Polyline(e, t, i)
      }),
      (t.prototype._updateAnimationPoints = function (e, t) {
        this._points = t
        for (var i = [0], r = 0, n = 1; n < t.length; n++) {
          var a = t[n - 1],
            o = t[n]
          ;(r += dist$1(a, o)), i.push(r)
        }
        if (0 !== r) {
          for (n = 0; n < i.length; n++) i[n] /= r
          ;(this._offsets = i), (this._length = r)
        } else this._length = 0
      }),
      (t.prototype._getLineLength = function () {
        return this._length
      }),
      (t.prototype._updateSymbolPosition = function (e) {
        var t = e.__t,
          i = this._points,
          r = this._offsets,
          n = i.length
        if (r) {
          var a,
            o = this._lastFrame
          if (t < this._lastFramePercent) {
            for (a = Math.min(o + 1, n - 1); a >= 0 && !(r[a] <= t); a--);
            a = Math.min(a, n - 2)
          } else {
            for (a = o; a < n && !(r[a] > t); a++);
            a = Math.min(a - 1, n - 2)
          }
          var s = (t - r[a]) / (r[a + 1] - r[a]),
            l = i[a],
            h = i[a + 1]
          ;(e.x = l[0] * (1 - s) + s * h[0]), (e.y = l[1] * (1 - s) + s * h[1])
          var u = h[0] - l[0],
            p = h[1] - l[1]
          ;(e.rotation = -Math.atan2(p, u) - Math.PI / 2),
            (this._lastFrame = a),
            (this._lastFramePercent = t),
            (e.ignore = !1)
        }
      }),
      t
    )
  })(EffectLine),
  LargeLinesPathShape = function () {
    ;(this.polyline = !1), (this.curveness = 0), (this.segs = [])
  },
  LargeLinesPath = (function (e) {
    function t(t) {
      return e.call(this, t) || this
    }
    return (
      __extends(t, e),
      (t.prototype.getDefaultStyle = function () {
        return { stroke: '#000', fill: null }
      }),
      (t.prototype.getDefaultShape = function () {
        return new LargeLinesPathShape()
      }),
      (t.prototype.buildPath = function (e, t) {
        var i = t.segs,
          r = t.curveness
        if (t.polyline)
          for (var n = 0; n < i.length; ) {
            var a = i[n++]
            if (a > 0) {
              e.moveTo(i[n++], i[n++])
              for (var o = 1; o < a; o++) e.lineTo(i[n++], i[n++])
            }
          }
        else
          for (n = 0; n < i.length; ) {
            var s = i[n++],
              l = i[n++],
              h = i[n++],
              u = i[n++]
            if ((e.moveTo(s, l), r > 0)) {
              var p = (s + h) / 2 - (l - u) * r,
                c = (l + u) / 2 - (h - s) * r
              e.quadraticCurveTo(p, c, h, u)
            } else e.lineTo(h, u)
          }
      }),
      (t.prototype.findDataIndex = function (e, t) {
        var i = this.shape,
          r = i.segs,
          n = i.curveness,
          a = this.style.lineWidth
        if (i.polyline)
          for (var o = 0, s = 0; s < r.length; ) {
            var l = r[s++]
            if (l > 0)
              for (var h = r[s++], u = r[s++], p = 1; p < l; p++) {
                if (containStroke$4(h, u, (c = r[s++]), (d = r[s++]), a, e, t)) return o
              }
            o++
          }
        else
          for (o = 0, s = 0; s < r.length; ) {
            ;(h = r[s++]), (u = r[s++])
            var c = r[s++],
              d = r[s++]
            if (n > 0) {
              if (
                containStroke$2(
                  h,
                  u,
                  (h + c) / 2 - (u - d) * n,
                  (u + d) / 2 - (c - h) * n,
                  c,
                  d,
                  a,
                  e,
                  t
                )
              )
                return o
            } else if (containStroke$4(h, u, c, d, a, e, t)) return o
            o++
          }
        return -1
      }),
      t
    )
  })(Path),
  LargeLineDraw = (function () {
    function e() {
      this.group = new Group$3()
    }
    return (
      (e.prototype.isPersistent = function () {
        return !this._incremental
      }),
      (e.prototype.updateData = function (e) {
        this.group.removeAll()
        var t = new LargeLinesPath({ rectHover: !0, cursor: 'default' })
        t.setShape({ segs: e.getLayout('linesPoints') }),
          this._setCommon(t, e),
          this.group.add(t),
          (this._incremental = null)
      }),
      (e.prototype.incrementalPrepareUpdate = function (e) {
        this.group.removeAll(),
          this._clearIncremental(),
          e.count() > 5e5
            ? (this._incremental ||
                (this._incremental = new IncrementalDisplayable({ silent: !0 })),
              this.group.add(this._incremental))
            : (this._incremental = null)
      }),
      (e.prototype.incrementalUpdate = function (e, t) {
        var i = new LargeLinesPath()
        i.setShape({ segs: t.getLayout('linesPoints') }),
          this._setCommon(i, t, !!this._incremental),
          this._incremental
            ? this._incremental.addDisplayable(i, !0)
            : ((i.rectHover = !0),
              (i.cursor = 'default'),
              (i.__startIndex = e.start),
              this.group.add(i))
      }),
      (e.prototype.remove = function () {
        this._clearIncremental(), (this._incremental = null), this.group.removeAll()
      }),
      (e.prototype._setCommon = function (e, t, i) {
        var r = t.hostModel
        e.setShape({ polyline: r.get('polyline'), curveness: r.get(['lineStyle', 'curveness']) }),
          e.useStyle(r.getModel('lineStyle').getLineStyle()),
          (e.style.strokeNoScale = !0)
        var n = t.getVisual('style')
        if ((n && n.stroke && e.setStyle('stroke', n.stroke), e.setStyle('fill', null), !i)) {
          var a = getECData(e)
          ;(a.seriesIndex = r.seriesIndex),
            e.on('mousemove', function (t) {
              a.dataIndex = null
              var i = e.findDataIndex(t.offsetX, t.offsetY)
              i > 0 && (a.dataIndex = i + e.__startIndex)
            })
        }
      }),
      (e.prototype._clearIncremental = function () {
        var e = this._incremental
        e && e.clearDisplaybles()
      }),
      e
    )
  })(),
  linesLayout = {
    seriesType: 'lines',
    plan: createRenderPlanner(),
    reset: function (e) {
      var t = e.coordinateSystem,
        i = e.get('polyline'),
        r = e.pipelineContext.large
      return {
        progress: function (n, a) {
          var o = []
          if (r) {
            var s = void 0,
              l = n.end - n.start
            if (i) {
              for (var h = 0, u = n.start; u < n.end; u++) h += e.getLineCoordsCount(u)
              s = new Float32Array(l + 2 * h)
            } else s = new Float32Array(4 * l)
            var p = 0,
              c = []
            for (u = n.start; u < n.end; u++) {
              var d = e.getLineCoords(u, o)
              i && (s[p++] = d)
              for (var f = 0; f < d; f++)
                (c = t.dataToPoint(o[f], !1, c)), (s[p++] = c[0]), (s[p++] = c[1])
            }
            a.setLayout('linesPoints', s)
          } else
            for (u = n.start; u < n.end; u++) {
              var m = a.getItemModel(u),
                g = ((d = e.getLineCoords(u, o)), [])
              if (i) for (var y = 0; y < d; y++) g.push(t.dataToPoint(o[y]))
              else {
                ;(g[0] = t.dataToPoint(o[0])), (g[1] = t.dataToPoint(o[1]))
                var v = m.get(['lineStyle', 'curveness'])
                ;+v &&
                  (g[2] = [
                    (g[0][0] + g[1][0]) / 2 - (g[0][1] - g[1][1]) * v,
                    (g[0][1] + g[1][1]) / 2 - (g[1][0] - g[0][0]) * v
                  ])
              }
              a.setItemLayout(u, g)
            }
        }
      }
    }
  },
  LinesView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i) {
        var r = e.getData(),
          n = this._updateLineDraw(r, e),
          a = e.get('zlevel'),
          o = e.get(['effect', 'trailLength']),
          s = i.getZr(),
          l = 'svg' === s.painter.getType()
        l || s.painter.getLayer(a).clear(!0),
          null == this._lastZlevel || l || s.configLayer(this._lastZlevel, { motionBlur: !1 }),
          this._showEffect(e) &&
            o &&
            (l ||
              s.configLayer(a, {
                motionBlur: !0,
                lastFrameAlpha: Math.max(Math.min(o / 10 + 0.9, 1), 0)
              })),
          n.updateData(r)
        var h = e.get('clip', !0) && createClipPath(e.coordinateSystem, !1, e)
        h ? this.group.setClipPath(h) : this.group.removeClipPath(),
          (this._lastZlevel = a),
          (this._finished = !0)
      }),
      (t.prototype.incrementalPrepareRender = function (e, t, i) {
        var r = e.getData()
        this._updateLineDraw(r, e).incrementalPrepareUpdate(r),
          this._clearLayer(i),
          (this._finished = !1)
      }),
      (t.prototype.incrementalRender = function (e, t, i) {
        this._lineDraw.incrementalUpdate(e, t.getData()),
          (this._finished = e.end === t.getData().count())
      }),
      (t.prototype.updateTransform = function (e, t, i) {
        var r = e.getData(),
          n = e.pipelineContext
        if (!this._finished || n.large || n.progressiveRender) return { update: !0 }
        var a = linesLayout.reset(e, t, i)
        a.progress && a.progress({ start: 0, end: r.count(), count: r.count() }, r),
          this._lineDraw.updateLayout(),
          this._clearLayer(i)
      }),
      (t.prototype._updateLineDraw = function (e, t) {
        var i = this._lineDraw,
          r = this._showEffect(t),
          n = !!t.get('polyline'),
          a = t.pipelineContext.large
        return (
          (i && r === this._hasEffet && n === this._isPolyline && a === this._isLargeDraw) ||
            (i && i.remove(),
            (i = this._lineDraw =
              a
                ? new LargeLineDraw()
                : new LineDraw(n ? (r ? EffectPolyline : Polyline) : r ? EffectLine : Line)),
            (this._hasEffet = r),
            (this._isPolyline = n),
            (this._isLargeDraw = a),
            this.group.removeAll()),
          this.group.add(i.group),
          i
        )
      }),
      (t.prototype._showEffect = function (e) {
        return !!e.get(['effect', 'show'])
      }),
      (t.prototype._clearLayer = function (e) {
        var t = e.getZr()
        'svg' === t.painter.getType() ||
          null == this._lastZlevel ||
          t.painter.getLayer(this._lastZlevel).clear(!0)
      }),
      (t.prototype.remove = function (e, t) {
        this._lineDraw && this._lineDraw.remove(), (this._lineDraw = null), this._clearLayer(t)
      }),
      (t.type = 'lines'),
      t
    )
  })(ChartView),
  Uint32Arr = 'undefined' == typeof Uint32Array ? Array : Uint32Array,
  Float64Arr = 'undefined' == typeof Float64Array ? Array : Float64Array
function compatEc2(e) {
  var t = e.data
  t &&
    t[0] &&
    t[0][0] &&
    t[0][0].coord &&
    (e.data = map$1(t, function (e) {
      var t = { coords: [e[0].coord, e[1].coord] }
      return (
        e[0].name && (t.fromName = e[0].name),
        e[1].name && (t.toName = e[1].name),
        mergeAll([t, e[0], e[1]])
      )
    }))
}
var LinesSeriesModel = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (
      (i.type = t.type), (i.visualStyleAccessPath = 'lineStyle'), (i.visualDrawType = 'stroke'), i
    )
  }
  return (
    __extends(t, e),
    (t.prototype.init = function (t) {
      ;(t.data = t.data || []), compatEc2(t)
      var i = this._processFlatCoordsArray(t.data)
      ;(this._flatCoords = i.flatCoords),
        (this._flatCoordsOffset = i.flatCoordsOffset),
        i.flatCoords && (t.data = new Float32Array(i.count)),
        e.prototype.init.apply(this, arguments)
    }),
    (t.prototype.mergeOption = function (t) {
      if ((compatEc2(t), t.data)) {
        var i = this._processFlatCoordsArray(t.data)
        ;(this._flatCoords = i.flatCoords),
          (this._flatCoordsOffset = i.flatCoordsOffset),
          i.flatCoords && (t.data = new Float32Array(i.count))
      }
      e.prototype.mergeOption.apply(this, arguments)
    }),
    (t.prototype.appendData = function (e) {
      var t = this._processFlatCoordsArray(e.data)
      t.flatCoords &&
        (this._flatCoords
          ? ((this._flatCoords = concatArray(this._flatCoords, t.flatCoords)),
            (this._flatCoordsOffset = concatArray(this._flatCoordsOffset, t.flatCoordsOffset)))
          : ((this._flatCoords = t.flatCoords), (this._flatCoordsOffset = t.flatCoordsOffset)),
        (e.data = new Float32Array(t.count))),
        this.getRawData().appendData(e.data)
    }),
    (t.prototype._getCoordsFromItemModel = function (e) {
      var t = this.getData().getItemModel(e)
      return t.option instanceof Array ? t.option : t.getShallow('coords')
    }),
    (t.prototype.getLineCoordsCount = function (e) {
      return this._flatCoordsOffset
        ? this._flatCoordsOffset[2 * e + 1]
        : this._getCoordsFromItemModel(e).length
    }),
    (t.prototype.getLineCoords = function (e, t) {
      if (this._flatCoordsOffset) {
        for (
          var i = this._flatCoordsOffset[2 * e], r = this._flatCoordsOffset[2 * e + 1], n = 0;
          n < r;
          n++
        )
          (t[n] = t[n] || []),
            (t[n][0] = this._flatCoords[i + 2 * n]),
            (t[n][1] = this._flatCoords[i + 2 * n + 1])
        return r
      }
      var a = this._getCoordsFromItemModel(e)
      for (n = 0; n < a.length; n++) (t[n] = t[n] || []), (t[n][0] = a[n][0]), (t[n][1] = a[n][1])
      return a.length
    }),
    (t.prototype._processFlatCoordsArray = function (e) {
      var t = 0
      if ((this._flatCoords && (t = this._flatCoords.length), 'number' == typeof e[0])) {
        for (
          var i = e.length, r = new Uint32Arr(i), n = new Float64Arr(i), a = 0, o = 0, s = 0, l = 0;
          l < i;

        ) {
          s++
          var h = e[l++]
          ;(r[o++] = a + t), (r[o++] = h)
          for (var u = 0; u < h; u++) {
            var p = e[l++],
              c = e[l++]
            ;(n[a++] = p), (n[a++] = c)
          }
        }
        return { flatCoordsOffset: new Uint32Array(r.buffer, 0, o), flatCoords: n, count: s }
      }
      return { flatCoordsOffset: null, flatCoords: null, count: e.length }
    }),
    (t.prototype.getInitialData = function (e, t) {
      var i = new List(['value'], this)
      return (
        (i.hasItemOption = !1),
        i.initData(e.data, [], function (e, t, r, n) {
          if (e instanceof Array) return NaN
          i.hasItemOption = !0
          var a = e.value
          return null != a ? (a instanceof Array ? a[n] : a) : void 0
        }),
        i
      )
    }),
    (t.prototype.formatTooltip = function (e, t, i) {
      var r = this.getData().getItemModel(e),
        n = r.get('name')
      if (n) return n
      var a = r.get('fromName'),
        o = r.get('toName'),
        s = []
      return (
        null != a && s.push(a),
        null != o && s.push(o),
        createTooltipMarkup('nameValue', { name: s.join(' > ') })
      )
    }),
    (t.prototype.preventIncremental = function () {
      return !!this.get(['effect', 'show'])
    }),
    (t.prototype.getProgressive = function () {
      var e = this.option.progressive
      return null == e ? (this.option.large ? 1e4 : this.get('progressive')) : e
    }),
    (t.prototype.getProgressiveThreshold = function () {
      var e = this.option.progressiveThreshold
      return null == e ? (this.option.large ? 2e4 : this.get('progressiveThreshold')) : e
    }),
    (t.type = 'series.lines'),
    (t.dependencies = ['grid', 'polar', 'geo', 'calendar']),
    (t.defaultOption = {
      coordinateSystem: 'geo',
      zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ['none', 'none'],
      symbolSize: [10, 10],
      geoIndex: 0,
      effect: {
        show: !1,
        period: 4,
        constantSpeed: 0,
        symbol: 'circle',
        symbolSize: 3,
        loop: !0,
        trailLength: 0.2
      },
      large: !1,
      largeThreshold: 2e3,
      polyline: !1,
      clip: !0,
      label: { show: !1, position: 'end' },
      lineStyle: { opacity: 0.5 }
    }),
    t
  )
})(SeriesModel)
function normalize(e) {
  return e instanceof Array || (e = [e, e]), e
}
var linesVisual = {
  seriesType: 'lines',
  reset: function (e) {
    var t = normalize(e.get('symbol')),
      i = normalize(e.get('symbolSize')),
      r = e.getData()
    return (
      r.setVisual('fromSymbol', t && t[0]),
      r.setVisual('toSymbol', t && t[1]),
      r.setVisual('fromSymbolSize', i && i[0]),
      r.setVisual('toSymbolSize', i && i[1]),
      {
        dataEach: r.hasItemOption
          ? function (e, t) {
              var i = e.getItemModel(t),
                r = normalize(i.getShallow('symbol', !0)),
                n = normalize(i.getShallow('symbolSize', !0))
              r[0] && e.setItemVisual(t, 'fromSymbol', r[0]),
                r[1] && e.setItemVisual(t, 'toSymbol', r[1]),
                n[0] && e.setItemVisual(t, 'fromSymbolSize', n[0]),
                n[1] && e.setItemVisual(t, 'toSymbolSize', n[1])
            }
          : null
      }
    )
  }
}
function install$w(e) {
  e.registerChartView(LinesView),
    e.registerSeriesModel(LinesSeriesModel),
    e.registerLayout(linesLayout),
    e.registerVisual(linesVisual)
}
var GRADIENT_LEVELS = 256,
  HeatmapLayer = (function () {
    function e() {
      ;(this.blurSize = 30),
        (this.pointSize = 20),
        (this.maxOpacity = 1),
        (this.minOpacity = 0),
        (this._gradientPixels = { inRange: null, outOfRange: null })
      var e = createCanvas()
      this.canvas = e
    }
    return (
      (e.prototype.update = function (e, t, i, r, n, a) {
        var o = this._getBrush(),
          s = this._getGradient(n, 'inRange'),
          l = this._getGradient(n, 'outOfRange'),
          h = this.pointSize + this.blurSize,
          u = this.canvas,
          p = u.getContext('2d'),
          c = e.length
        ;(u.width = t), (u.height = i)
        for (var d = 0; d < c; ++d) {
          var f = e[d],
            m = f[0],
            g = f[1],
            y = r(f[2])
          ;(p.globalAlpha = y), p.drawImage(o, m - h, g - h)
        }
        if (!u.width || !u.height) return u
        for (
          var v = p.getImageData(0, 0, u.width, u.height),
            _ = v.data,
            x = 0,
            S = _.length,
            b = this.minOpacity,
            T = this.maxOpacity - b;
          x < S;

        ) {
          y = _[x + 3] / 256
          var A = 4 * Math.floor(y * (GRADIENT_LEVELS - 1))
          if (y > 0) {
            var w = a(y) ? s : l
            y > 0 && (y = y * T + b),
              (_[x++] = w[A]),
              (_[x++] = w[A + 1]),
              (_[x++] = w[A + 2]),
              (_[x++] = w[A + 3] * y * 256)
          } else x += 4
        }
        return p.putImageData(v, 0, 0), u
      }),
      (e.prototype._getBrush = function () {
        var e = this._brushCanvas || (this._brushCanvas = createCanvas()),
          t = this.pointSize + this.blurSize,
          i = 2 * t
        ;(e.width = i), (e.height = i)
        var r = e.getContext('2d')
        return (
          r.clearRect(0, 0, i, i),
          (r.shadowOffsetX = i),
          (r.shadowBlur = this.blurSize),
          (r.shadowColor = '#000'),
          r.beginPath(),
          r.arc(-t, t, this.pointSize, 0, 2 * Math.PI, !0),
          r.closePath(),
          r.fill(),
          e
        )
      }),
      (e.prototype._getGradient = function (e, t) {
        for (
          var i = this._gradientPixels,
            r = i[t] || (i[t] = new Uint8ClampedArray(1024)),
            n = [0, 0, 0, 0],
            a = 0,
            o = 0;
          o < 256;
          o++
        )
          e[t](o / 255, !0, n), (r[a++] = n[0]), (r[a++] = n[1]), (r[a++] = n[2]), (r[a++] = n[3])
        return r
      }),
      e
    )
  })()
function getIsInPiecewiseRange(e, t, i) {
  var r = e[1] - e[0],
    n = (t = map$1(t, function (t) {
      return { interval: [(t.interval[0] - e[0]) / r, (t.interval[1] - e[0]) / r] }
    })).length,
    a = 0
  return function (e) {
    var r
    for (r = a; r < n; r++) {
      if ((o = t[r].interval)[0] <= e && e <= o[1]) {
        a = r
        break
      }
    }
    if (r === n)
      for (r = a - 1; r >= 0; r--) {
        var o
        if ((o = t[r].interval)[0] <= e && e <= o[1]) {
          a = r
          break
        }
      }
    return r >= 0 && r < n && i[r]
  }
}
function getIsInContinuousRange(e, t) {
  var i = e[1] - e[0]
  return (
    (t = [(t[0] - e[0]) / i, (t[1] - e[0]) / i]),
    function (e) {
      return e >= t[0] && e <= t[1]
    }
  )
}
function isGeoCoordSys(e) {
  var t = e.dimensions
  return 'lng' === t[0] && 'lat' === t[1]
}
var HeatmapView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i) {
        var r
        t.eachComponent('visualMap', function (t) {
          t.eachTargetSeries(function (i) {
            i === e && (r = t)
          })
        }),
          this.group.removeAll(),
          (this._incrementalDisplayable = null)
        var n = e.coordinateSystem
        'cartesian2d' === n.type || 'calendar' === n.type
          ? this._renderOnCartesianAndCalendar(e, i, 0, e.getData().count())
          : isGeoCoordSys(n) && this._renderOnGeo(n, e, r, i)
      }),
      (t.prototype.incrementalPrepareRender = function (e, t, i) {
        this.group.removeAll()
      }),
      (t.prototype.incrementalRender = function (e, t, i, r) {
        var n = t.coordinateSystem
        n &&
          (isGeoCoordSys(n)
            ? this.render(t, i, r)
            : this._renderOnCartesianAndCalendar(t, r, e.start, e.end, !0))
      }),
      (t.prototype._renderOnCartesianAndCalendar = function (e, t, i, r, n) {
        var a,
          o,
          s,
          l,
          h = e.coordinateSystem
        if (isCoordinateSystemType(h, 'cartesian2d')) {
          var u = h.getAxis('x'),
            p = h.getAxis('y')
          ;(a = u.getBandWidth()),
            (o = p.getBandWidth()),
            (s = u.scale.getExtent()),
            (l = p.scale.getExtent())
        }
        for (
          var c = this.group,
            d = e.getData(),
            f = e.getModel(['emphasis', 'itemStyle']).getItemStyle(),
            m = e.getModel(['blur', 'itemStyle']).getItemStyle(),
            g = e.getModel(['select', 'itemStyle']).getItemStyle(),
            y = getLabelStatesModels(e),
            v = e.get(['emphasis', 'focus']),
            _ = e.get(['emphasis', 'blurScope']),
            x = isCoordinateSystemType(h, 'cartesian2d')
              ? [d.mapDimension('x'), d.mapDimension('y'), d.mapDimension('value')]
              : [d.mapDimension('time'), d.mapDimension('value')],
            S = i;
          S < r;
          S++
        ) {
          var b = void 0,
            T = d.getItemVisual(S, 'style')
          if (isCoordinateSystemType(h, 'cartesian2d')) {
            var A = d.get(x[0], S),
              w = d.get(x[1], S)
            if (isNaN(d.get(x[2], S)) || A < s[0] || A > s[1] || w < l[0] || w > l[1]) continue
            var M = h.dataToPoint([A, w])
            b = new Rect$2({
              shape: {
                x: Math.floor(Math.round(M[0]) - a / 2),
                y: Math.floor(Math.round(M[1]) - o / 2),
                width: Math.ceil(a),
                height: Math.ceil(o)
              },
              style: T
            })
          } else {
            if (isNaN(d.get(x[1], S))) continue
            b = new Rect$2({ z2: 1, shape: h.dataToRect([d.get(x[0], S)]).contentShape, style: T })
          }
          var C = d.getItemModel(S)
          if (d.hasItemOption) {
            var P = C.getModel('emphasis')
            ;(f = P.getModel('itemStyle').getItemStyle()),
              (m = C.getModel(['blur', 'itemStyle']).getItemStyle()),
              (g = C.getModel(['select', 'itemStyle']).getItemStyle()),
              (v = P.get('focus')),
              (_ = P.get('blurScope')),
              (y = getLabelStatesModels(C))
          }
          var E = e.getRawValue(S),
            I = '-'
          E && null != E[2] && (I = E[2] + ''),
            setLabelStyle(b, y, {
              labelFetcher: e,
              labelDataIndex: S,
              defaultOpacity: T.opacity,
              defaultText: I
            }),
            (b.ensureState('emphasis').style = f),
            (b.ensureState('blur').style = m),
            (b.ensureState('select').style = g),
            enableHoverEmphasis(b, v, _),
            (b.incremental = n),
            n && (b.states.emphasis.hoverLayer = !0),
            c.add(b),
            d.setItemGraphicEl(S, b)
        }
      }),
      (t.prototype._renderOnGeo = function (e, t, i, r) {
        var n = i.targetVisuals.inRange,
          a = i.targetVisuals.outOfRange,
          o = t.getData(),
          s = this._hmLayer || this._hmLayer || new HeatmapLayer()
        ;(s.blurSize = t.get('blurSize')),
          (s.pointSize = t.get('pointSize')),
          (s.minOpacity = t.get('minOpacity')),
          (s.maxOpacity = t.get('maxOpacity'))
        var l = e.getViewRect().clone(),
          h = e.getRoamTransform()
        l.applyTransform(h)
        var u = Math.max(l.x, 0),
          p = Math.max(l.y, 0),
          c = Math.min(l.width + l.x, r.getWidth()),
          d = Math.min(l.height + l.y, r.getHeight()),
          f = c - u,
          m = d - p,
          g = [o.mapDimension('lng'), o.mapDimension('lat'), o.mapDimension('value')],
          y = o.mapArray(g, function (t, i, r) {
            var n = e.dataToPoint([t, i])
            return (n[0] -= u), (n[1] -= p), n.push(r), n
          }),
          v = i.getExtent(),
          _ =
            'visualMap.continuous' === i.type
              ? getIsInContinuousRange(v, i.option.range)
              : getIsInPiecewiseRange(v, i.getPieceList(), i.option.selected)
        s.update(
          y,
          f,
          m,
          n.color.getNormalizer(),
          { inRange: n.color.getColorMapper(), outOfRange: a.color.getColorMapper() },
          _
        )
        var x = new ZRImage({
          style: { width: f, height: m, x: u, y: p, image: s.canvas },
          silent: !0
        })
        this.group.add(x)
      }),
      (t.type = 'heatmap'),
      t
    )
  })(ChartView),
  HeatmapSeriesModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.getInitialData = function (e, t) {
        return createListFromArray(this.getSource(), this, { generateCoord: 'value' })
      }),
      (t.prototype.preventIncremental = function () {
        var e = CoordinateSystemManager.get(this.get('coordinateSystem'))
        if (e && e.dimensions) return 'lng' === e.dimensions[0] && 'lat' === e.dimensions[1]
      }),
      (t.type = 'series.heatmap'),
      (t.dependencies = ['grid', 'geo', 'calendar']),
      (t.defaultOption = {
        coordinateSystem: 'cartesian2d',
        zlevel: 0,
        z: 2,
        geoIndex: 0,
        blurSize: 30,
        pointSize: 20,
        maxOpacity: 1,
        minOpacity: 0,
        select: { itemStyle: { borderColor: '#212121' } }
      }),
      t
    )
  })(SeriesModel)
function install$v(e) {
  e.registerChartView(HeatmapView), e.registerSeriesModel(HeatmapSeriesModel)
}
var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'borderWidth'],
  LAYOUT_ATTRS = [
    { xy: 'x', wh: 'width', index: 0, posDesc: ['left', 'right'] },
    { xy: 'y', wh: 'height', index: 1, posDesc: ['top', 'bottom'] }
  ],
  pathForLineWidth = new Circle(),
  PictorialBarView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i) {
        var r = this.group,
          n = e.getData(),
          a = this._data,
          o = e.coordinateSystem,
          s = o.getBaseAxis().isHorizontal(),
          l = o.master.getRect(),
          h = {
            ecSize: { width: i.getWidth(), height: i.getHeight() },
            seriesModel: e,
            coordSys: o,
            coordSysExtent: [
              [l.x, l.x + l.width],
              [l.y, l.y + l.height]
            ],
            isHorizontal: s,
            valueDim: LAYOUT_ATTRS[+s],
            categoryDim: LAYOUT_ATTRS[1 - +s]
          }
        return (
          n
            .diff(a)
            .add(function (e) {
              if (n.hasValue(e)) {
                var t = getItemModel(n, e),
                  i = getSymbolMeta(n, e, t, h),
                  a = createBar(n, h, i)
                n.setItemGraphicEl(e, a), r.add(a), updateCommon(a, h, i)
              }
            })
            .update(function (e, t) {
              var i = a.getItemGraphicEl(t)
              if (n.hasValue(e)) {
                var o = getItemModel(n, e),
                  s = getSymbolMeta(n, e, o, h),
                  l = getShapeStr(n, s)
                i &&
                  l !== i.__pictorialShapeStr &&
                  (r.remove(i), n.setItemGraphicEl(e, null), (i = null)),
                  i ? updateBar(i, h, s) : (i = createBar(n, h, s, !0)),
                  n.setItemGraphicEl(e, i),
                  (i.__pictorialSymbolMeta = s),
                  r.add(i),
                  updateCommon(i, h, s)
              } else r.remove(i)
            })
            .remove(function (e) {
              var t = a.getItemGraphicEl(e)
              t && removeBar(a, e, t.__pictorialSymbolMeta.animationModel, t)
            })
            .execute(),
          (this._data = n),
          this.group
        )
      }),
      (t.prototype.remove = function (e, t) {
        var i = this.group,
          r = this._data
        e.get('animation')
          ? r &&
            r.eachItemGraphicEl(function (t) {
              removeBar(r, getECData(t).dataIndex, e, t)
            })
          : i.removeAll()
      }),
      (t.type = 'pictorialBar'),
      t
    )
  })(ChartView)
function getSymbolMeta(e, t, i, r) {
  var n = e.getItemLayout(t),
    a = i.get('symbolRepeat'),
    o = i.get('symbolClip'),
    s = i.get('symbolPosition') || 'start',
    l = ((i.get('symbolRotate') || 0) * Math.PI) / 180 || 0,
    h = i.get('symbolPatternSize') || 2,
    u = i.isAnimationEnabled(),
    p = {
      dataIndex: t,
      layout: n,
      itemModel: i,
      symbolType: e.getItemVisual(t, 'symbol') || 'circle',
      style: e.getItemVisual(t, 'style'),
      symbolClip: o,
      symbolRepeat: a,
      symbolRepeatDirection: i.get('symbolRepeatDirection'),
      symbolPatternSize: h,
      rotation: l,
      animationModel: u ? i : null,
      hoverScale: u && i.get(['emphasis', 'scale']),
      z2: i.getShallow('z', !0) || 0
    }
  prepareBarLength(i, a, n, r, p),
    prepareSymbolSize(e, t, n, a, o, p.boundingLength, p.pxSign, h, r, p),
    prepareLineWidth(i, p.symbolScale, l, r, p)
  var c = p.symbolSize,
    d = i.get('symbolOffset')
  return (
    isArray$1(d) && (d = [parsePercent$1(d[0], c[0]), parsePercent$1(d[1], c[1])]),
    prepareLayoutInfo(
      i,
      c,
      n,
      a,
      o,
      d,
      s,
      p.valueLineWidth,
      p.boundingLength,
      p.repeatCutLength,
      r,
      p
    ),
    p
  )
}
function prepareBarLength(e, t, i, r, n) {
  var a,
    o = r.valueDim,
    s = e.get('symbolBoundingData'),
    l = r.coordSys.getOtherAxis(r.coordSys.getBaseAxis()),
    h = l.toGlobalCoord(l.dataToCoord(0)),
    u = 1 - +(i[o.wh] <= 0)
  if (isArray$1(s)) {
    var p = [convertToCoordOnAxis(l, s[0]) - h, convertToCoordOnAxis(l, s[1]) - h]
    p[1] < p[0] && p.reverse(), (a = p[u])
  } else
    a = null != s ? convertToCoordOnAxis(l, s) - h : t ? r.coordSysExtent[o.index][u] - h : i[o.wh]
  ;(n.boundingLength = a),
    t && (n.repeatCutLength = i[o.wh]),
    (n.pxSign = a > 0 ? 1 : a < 0 ? -1 : 0)
}
function convertToCoordOnAxis(e, t) {
  return e.toGlobalCoord(e.dataToCoord(e.scale.parse(t)))
}
function prepareSymbolSize(e, t, i, r, n, a, o, s, l, h) {
  var u,
    p = l.valueDim,
    c = l.categoryDim,
    d = Math.abs(i[c.wh]),
    f = e.getItemVisual(t, 'symbolSize')
  ;((u = isArray$1(f) ? f.slice() : null == f ? ['100%', '100%'] : [f, f])[c.index] =
    parsePercent$1(u[c.index], d)),
    (u[p.index] = parsePercent$1(u[p.index], r ? d : Math.abs(a))),
    (h.symbolSize = u),
    ((h.symbolScale = [u[0] / s, u[1] / s])[p.index] *= (l.isHorizontal ? -1 : 1) * o)
}
function prepareLineWidth(e, t, i, r, n) {
  var a = e.get(BAR_BORDER_WIDTH_QUERY) || 0
  a &&
    (pathForLineWidth.attr({ scaleX: t[0], scaleY: t[1], rotation: i }),
    pathForLineWidth.updateTransform(),
    (a /= pathForLineWidth.getLineScale()),
    (a *= t[r.valueDim.index])),
    (n.valueLineWidth = a)
}
function prepareLayoutInfo(e, t, i, r, n, a, o, s, l, h, u, p) {
  var c = u.categoryDim,
    d = u.valueDim,
    f = p.pxSign,
    m = Math.max(t[d.index] + s, 0),
    g = m
  if (r) {
    var y = Math.abs(l),
      v = retrieve(e.get('symbolMargin'), '15%') + '',
      _ = !1
    v.lastIndexOf('!') === v.length - 1 && ((_ = !0), (v = v.slice(0, v.length - 1)))
    var x = parsePercent$1(v, t[d.index]),
      S = Math.max(m + 2 * x, 0),
      b = _ ? 0 : 2 * x,
      T = isNumeric(r),
      A = T ? r : toIntTimes((y + b) / S)
    ;(S = m + 2 * (x = (y - A * m) / 2 / (_ ? A : A - 1))),
      (b = _ ? 0 : 2 * x),
      T || 'fixed' === r || (A = h ? toIntTimes((Math.abs(h) + b) / S) : 0),
      (g = A * S - b),
      (p.repeatTimes = A),
      (p.symbolMargin = x)
  }
  var w = f * (g / 2),
    M = (p.pathPosition = [])
  ;(M[c.index] = i[c.wh] / 2),
    (M[d.index] = 'start' === o ? w : 'end' === o ? l - w : l / 2),
    a && ((M[0] += a[0]), (M[1] += a[1]))
  var C = (p.bundlePosition = [])
  ;(C[c.index] = i[c.xy]), (C[d.index] = i[d.xy])
  var P = (p.barRectShape = extend$3({}, i))
  ;(P[d.wh] = f * Math.max(Math.abs(i[d.wh]), Math.abs(M[d.index] + w))), (P[c.wh] = i[c.wh])
  var E = (p.clipShape = {})
  ;(E[c.xy] = -i[c.xy]), (E[c.wh] = u.ecSize[c.wh]), (E[d.xy] = 0), (E[d.wh] = i[d.wh])
}
function createPath(e) {
  var t = e.symbolPatternSize,
    i = createSymbol$1(e.symbolType, -t / 2, -t / 2, t, t)
  return i.attr({ culling: !0 }), 'image' !== i.type && i.setStyle({ strokeNoScale: !0 }), i
}
function createOrUpdateRepeatSymbols(e, t, i, r) {
  var n = e.__pictorialBundle,
    a = i.symbolSize,
    o = i.valueLineWidth,
    s = i.pathPosition,
    l = t.valueDim,
    h = i.repeatTimes || 0,
    u = 0,
    p = a[t.valueDim.index] + o + 2 * i.symbolMargin
  for (
    eachPath(e, function (e) {
      ;(e.__pictorialAnimationIndex = u),
        (e.__pictorialRepeatTimes = h),
        u < h
          ? updateAttr(e, null, f(u), i, r)
          : updateAttr(e, null, { scaleX: 0, scaleY: 0 }, i, r, function () {
              n.remove(e)
            }),
        u++
    });
    u < h;
    u++
  ) {
    var c = createPath(i)
    ;(c.__pictorialAnimationIndex = u), (c.__pictorialRepeatTimes = h), n.add(c)
    var d = f(u)
    updateAttr(
      c,
      { x: d.x, y: d.y, scaleX: 0, scaleY: 0 },
      { scaleX: d.scaleX, scaleY: d.scaleY, rotation: d.rotation },
      i,
      r
    )
  }
  function f(e) {
    var t = s.slice(),
      r = i.pxSign,
      n = e
    return (
      ('start' === i.symbolRepeatDirection ? r > 0 : r < 0) && (n = h - 1 - e),
      (t[l.index] = p * (n - h / 2 + 0.5) + s[l.index]),
      { x: t[0], y: t[1], scaleX: i.symbolScale[0], scaleY: i.symbolScale[1], rotation: i.rotation }
    )
  }
}
function createOrUpdateSingleSymbol(e, t, i, r) {
  var n = e.__pictorialBundle,
    a = e.__pictorialMainPath
  a
    ? updateAttr(
        a,
        null,
        {
          x: i.pathPosition[0],
          y: i.pathPosition[1],
          scaleX: i.symbolScale[0],
          scaleY: i.symbolScale[1],
          rotation: i.rotation
        },
        i,
        r
      )
    : ((a = e.__pictorialMainPath = createPath(i)),
      n.add(a),
      updateAttr(
        a,
        { x: i.pathPosition[0], y: i.pathPosition[1], scaleX: 0, scaleY: 0, rotation: i.rotation },
        { scaleX: i.symbolScale[0], scaleY: i.symbolScale[1] },
        i,
        r
      ))
}
function createOrUpdateBarRect(e, t, i) {
  var r = extend$3({}, t.barRectShape),
    n = e.__pictorialBarRect
  n
    ? updateAttr(n, null, { shape: r }, t, i)
    : ((n = e.__pictorialBarRect =
        new Rect$2({
          z2: 2,
          shape: r,
          silent: !0,
          style: { stroke: 'transparent', fill: 'transparent', lineWidth: 0 }
        })),
      e.add(n))
}
function createOrUpdateClip(e, t, i, r) {
  if (i.symbolClip) {
    var n = e.__pictorialClipPath,
      a = extend$3({}, i.clipShape),
      o = t.valueDim,
      s = i.animationModel,
      l = i.dataIndex
    if (n) updateProps$1(n, { shape: a }, s, l)
    else {
      ;(a[o.wh] = 0),
        (n = new Rect$2({ shape: a })),
        e.__pictorialBundle.setClipPath(n),
        (e.__pictorialClipPath = n)
      var h = {}
      ;(h[o.wh] = i.clipShape[o.wh]),
        graphic[r ? 'updateProps' : 'initProps'](n, { shape: h }, s, l)
    }
  }
}
function getItemModel(e, t) {
  var i = e.getItemModel(t)
  return (
    (i.getAnimationDelayParams = getAnimationDelayParams),
    (i.isAnimationEnabled = isAnimationEnabled),
    i
  )
}
function getAnimationDelayParams(e) {
  return { index: e.__pictorialAnimationIndex, count: e.__pictorialRepeatTimes }
}
function isAnimationEnabled() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow('animation')
}
function createBar(e, t, i, r) {
  var n = new Group$3(),
    a = new Group$3()
  return (
    n.add(a),
    (n.__pictorialBundle = a),
    (a.x = i.bundlePosition[0]),
    (a.y = i.bundlePosition[1]),
    i.symbolRepeat ? createOrUpdateRepeatSymbols(n, t, i) : createOrUpdateSingleSymbol(n, t, i),
    createOrUpdateBarRect(n, i, r),
    createOrUpdateClip(n, t, i, r),
    (n.__pictorialShapeStr = getShapeStr(e, i)),
    (n.__pictorialSymbolMeta = i),
    n
  )
}
function updateBar(e, t, i) {
  var r = i.animationModel,
    n = i.dataIndex
  updateProps$1(e.__pictorialBundle, { x: i.bundlePosition[0], y: i.bundlePosition[1] }, r, n),
    i.symbolRepeat
      ? createOrUpdateRepeatSymbols(e, t, i, !0)
      : createOrUpdateSingleSymbol(e, t, i, !0),
    createOrUpdateBarRect(e, i, !0),
    createOrUpdateClip(e, t, i, !0)
}
function removeBar(e, t, i, r) {
  var n = r.__pictorialBarRect
  n && n.removeTextContent()
  var a = []
  eachPath(r, function (e) {
    a.push(e)
  }),
    r.__pictorialMainPath && a.push(r.__pictorialMainPath),
    r.__pictorialClipPath && (i = null),
    each$i(a, function (e) {
      removeElement(e, { scaleX: 0, scaleY: 0 }, i, t, function () {
        r.parent && r.parent.remove(r)
      })
    }),
    e.setItemGraphicEl(t, null)
}
function getShapeStr(e, t) {
  return [e.getItemVisual(t.dataIndex, 'symbol') || 'none', !!t.symbolRepeat, !!t.symbolClip].join(
    ':'
  )
}
function eachPath(e, t, i) {
  each$i(e.__pictorialBundle.children(), function (r) {
    r !== e.__pictorialBarRect && t.call(i, r)
  })
}
function updateAttr(e, t, i, r, n, a) {
  t && e.attr(t),
    r.symbolClip && !n
      ? i && e.attr(i)
      : i && graphic[n ? 'updateProps' : 'initProps'](e, i, r.animationModel, r.dataIndex, a)
}
function updateCommon(e, t, i) {
  var r = i.dataIndex,
    n = i.itemModel,
    a = n.getModel('emphasis'),
    o = a.getModel('itemStyle').getItemStyle(),
    s = n.getModel(['blur', 'itemStyle']).getItemStyle(),
    l = n.getModel(['select', 'itemStyle']).getItemStyle(),
    h = n.getShallow('cursor'),
    u = a.get('focus'),
    p = a.get('blurScope'),
    c = a.get('scale')
  eachPath(e, function (e) {
    if (e instanceof ZRImage) {
      var t = e.style
      e.useStyle(
        extend$3({ image: t.image, x: t.x, y: t.y, width: t.width, height: t.height }, i.style)
      )
    } else e.useStyle(i.style)
    var r = e.ensureState('emphasis')
    ;(r.style = o),
      c && ((r.scaleX = 1.1 * e.scaleX), (r.scaleY = 1.1 * e.scaleY)),
      (e.ensureState('blur').style = s),
      (e.ensureState('select').style = l),
      h && (e.cursor = h),
      (e.z2 = i.z2)
  })
  var d = t.valueDim.posDesc[+(i.boundingLength > 0)]
  setLabelStyle(e.__pictorialBarRect, getLabelStatesModels(n), {
    labelFetcher: t.seriesModel,
    labelDataIndex: r,
    defaultText: getDefaultLabel(t.seriesModel.getData(), r),
    inheritColor: i.style.fill,
    defaultOpacity: i.style.opacity,
    defaultOutsidePosition: d
  }),
    enableHoverEmphasis(e, u, p)
}
function toIntTimes(e) {
  var t = Math.round(e)
  return Math.abs(e - t) < 1e-4 ? t : Math.ceil(e)
}
var PictorialBarSeriesModel = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), (i.hasSymbolVisual = !0), (i.defaultSymbol = 'roundRect'), i
  }
  return (
    __extends(t, e),
    (t.prototype.getInitialData = function (t) {
      return (t.stack = null), e.prototype.getInitialData.apply(this, arguments)
    }),
    (t.type = 'series.pictorialBar'),
    (t.dependencies = ['grid']),
    (t.defaultOption = inheritDefaultOption(BaseBarSeriesModel.defaultOption, {
      symbol: 'circle',
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: !1,
      symbolRepeatDirection: 'end',
      symbolClip: !1,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: '-100%',
      progressive: 0,
      emphasis: { scale: !1 },
      select: { itemStyle: { borderColor: '#212121' } }
    })),
    t
  )
})(BaseBarSeriesModel)
function install$u(e) {
  e.registerChartView(PictorialBarView),
    e.registerSeriesModel(PictorialBarSeriesModel),
    e.registerLayout(curry$1(layout$3, 'pictorialBar'))
}
var ThemeRiverView = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), (i._layers = []), i
  }
  return (
    __extends(t, e),
    (t.prototype.render = function (e, t, i) {
      var r = e.getData(),
        n = this,
        a = this.group,
        o = e.getLayerSeries(),
        s = r.getLayout('layoutInfo'),
        l = s.rect,
        h = s.boundaryGap
      function u(e) {
        return e.name
      }
      ;(a.x = 0), (a.y = l.y + h[0])
      var p = new DataDiffer(this._layersSeries || [], o, u, u),
        c = []
      function d(t, i, s) {
        var l = n._layers
        if ('remove' !== t) {
          for (var h, u, p = [], d = [], f = o[i].indices, m = 0; m < f.length; m++) {
            var g = r.getItemLayout(f[m]),
              y = g.x,
              v = g.y0,
              _ = g.y
            p.push(y, v), d.push(y, v + _), (h = r.getItemVisual(f[m], 'style'))
          }
          var x = r.getItemLayout(f[0]),
            S = e.getModel('label').get('margin'),
            b = e.getModel('emphasis')
          if ('add' === t) {
            var T = (c[i] = new Group$3())
            ;(u = new ECPolygon({
              shape: {
                points: p,
                stackedOnPoints: d,
                smooth: 0.4,
                stackedOnSmooth: 0.4,
                smoothConstraint: !1
              },
              z2: 0
            })),
              T.add(u),
              a.add(T),
              e.isAnimationEnabled() &&
                u.setClipPath(
                  createGridClipShape(u.getBoundingRect(), e, function () {
                    u.removeClipPath()
                  })
                )
          } else {
            T = l[s]
            ;(u = T.childAt(0)),
              a.add(T),
              (c[i] = T),
              updateProps$1(u, { shape: { points: p, stackedOnPoints: d } }, e)
          }
          setLabelStyle(
            u,
            getLabelStatesModels(e),
            { labelDataIndex: f[m - 1], defaultText: r.getName(f[m - 1]), inheritColor: h.fill },
            { normal: { verticalAlign: 'middle' } }
          ),
            u.setTextConfig({ position: null, local: !0 })
          var A = u.getTextContent()
          A && ((A.x = x.x - S), (A.y = x.y0 + x.y / 2)),
            u.useStyle(h),
            r.setItemGraphicEl(i, u),
            setStatesStylesFromModel(u, e),
            enableHoverEmphasis(u, b.get('focus'), b.get('blurScope'))
        } else a.remove(l[i])
      }
      p
        .add(bind$2(d, this, 'add'))
        .update(bind$2(d, this, 'update'))
        .remove(bind$2(d, this, 'remove'))
        .execute(),
        (this._layersSeries = o),
        (this._layers = c)
    }),
    (t.type = 'themeRiver'),
    t
  )
})(ChartView)
function createGridClipShape(e, t, i) {
  var r = new Rect$2({ shape: { x: e.x - 10, y: e.y - 10, width: 0, height: e.height + 20 } })
  return (
    initProps(r, { shape: { x: e.x - 50, width: e.width + 100, height: e.height + 20 } }, t, i), r
  )
}
var DATA_NAME_INDEX = 2,
  ThemeRiverSeriesModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.useColorPaletteOnData = !0), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (t) {
        e.prototype.init.apply(this, arguments),
          (this.legendVisualProvider = new LegendVisualProvider(
            bind$2(this.getData, this),
            bind$2(this.getRawData, this)
          ))
      }),
      (t.prototype.fixData = function (e) {
        var t = e.length,
          i = {},
          r = groupData(e, function (e) {
            return i.hasOwnProperty(e[0] + '') || (i[e[0] + ''] = -1), e[2]
          }),
          n = []
        r.buckets.each(function (e, t) {
          n.push({ name: t, dataList: e })
        })
        for (var a = n.length, o = 0; o < a; ++o) {
          for (var s = n[o].name, l = 0; l < n[o].dataList.length; ++l) {
            var h = n[o].dataList[l][0] + ''
            i[h] = o
          }
          for (var h in i)
            i.hasOwnProperty(h) && i[h] !== o && ((i[h] = o), (e[t] = [h, 0, s]), t++)
        }
        return e
      }),
      (t.prototype.getInitialData = function (e, t) {
        for (
          var i = this.getReferringComponents('singleAxis', SINGLE_REFERRING).models[0].get('type'),
            r = filter$1(e.data, function (e) {
              return void 0 !== e[2]
            }),
            n = this.fixData(r || []),
            a = [],
            o = (this.nameMap = createHashMap()),
            s = 0,
            l = 0;
          l < n.length;
          ++l
        )
          a.push(n[l][DATA_NAME_INDEX]),
            o.get(n[l][DATA_NAME_INDEX]) || (o.set(n[l][DATA_NAME_INDEX], s), s++)
        var h = createDimensions(n, {
            coordDimensions: ['single'],
            dimensionsDefine: [
              { name: 'time', type: getDimensionTypeByAxis(i) },
              { name: 'value', type: 'float' },
              { name: 'name', type: 'ordinal' }
            ],
            encodeDefine: { single: 0, value: 1, itemName: 2 }
          }),
          u = new List(h, this)
        return u.initData(n), u
      }),
      (t.prototype.getLayerSeries = function () {
        for (var e = this.getData(), t = e.count(), i = [], r = 0; r < t; ++r) i[r] = r
        var n = e.mapDimension('single'),
          a = groupData(i, function (t) {
            return e.get('name', t)
          }),
          o = []
        return (
          a.buckets.each(function (t, i) {
            t.sort(function (t, i) {
              return e.get(n, t) - e.get(n, i)
            }),
              o.push({ name: i, indices: t })
          }),
          o
        )
      }),
      (t.prototype.getAxisTooltipData = function (e, t, i) {
        isArray$1(e) || (e = e ? [e] : [])
        for (
          var r, n = this.getData(), a = this.getLayerSeries(), o = [], s = a.length, l = 0;
          l < s;
          ++l
        ) {
          for (var h = Number.MAX_VALUE, u = -1, p = a[l].indices.length, c = 0; c < p; ++c) {
            var d = n.get(e[0], a[l].indices[c]),
              f = Math.abs(d - t)
            f <= h && ((r = d), (h = f), (u = a[l].indices[c]))
          }
          o.push(u)
        }
        return { dataIndices: o, nestestValue: r }
      }),
      (t.prototype.formatTooltip = function (e, t, i) {
        var r = this.getData()
        return createTooltipMarkup('nameValue', {
          name: r.getName(e),
          value: r.get(r.mapDimension('value'), e)
        })
      }),
      (t.type = 'series.themeRiver'),
      (t.dependencies = ['singleAxis']),
      (t.defaultOption = {
        zlevel: 0,
        z: 2,
        coordinateSystem: 'singleAxis',
        boundaryGap: ['10%', '10%'],
        singleAxisIndex: 0,
        animationEasing: 'linear',
        label: { margin: 4, show: !0, position: 'left', fontSize: 11 },
        emphasis: { label: { show: !0 } }
      }),
      t
    )
  })(SeriesModel)
function themeRiverLayout(e, t) {
  e.eachSeriesByType('themeRiver', function (e) {
    var t = e.getData(),
      i = e.coordinateSystem,
      r = {},
      n = i.getRect()
    r.rect = n
    var a = e.get('boundaryGap'),
      o = i.getAxis()
    ;((r.boundaryGap = a), 'horizontal' === o.orient)
      ? ((a[0] = parsePercent$1(a[0], n.height)),
        (a[1] = parsePercent$1(a[1], n.height)),
        doThemeRiverLayout(t, e, n.height - a[0] - a[1]))
      : ((a[0] = parsePercent$1(a[0], n.width)),
        (a[1] = parsePercent$1(a[1], n.width)),
        doThemeRiverLayout(t, e, n.width - a[0] - a[1]))
    t.setLayout('layoutInfo', r)
  })
}
function doThemeRiverLayout(e, t, i) {
  if (e.count())
    for (
      var r,
        n = t.coordinateSystem,
        a = t.getLayerSeries(),
        o = e.mapDimension('single'),
        s = e.mapDimension('value'),
        l = map$1(a, function (t) {
          return map$1(t.indices, function (t) {
            var i = n.dataToPoint(e.get(o, t))
            return (i[1] = e.get(s, t)), i
          })
        }),
        h = computeBaseline(l),
        u = h.y0,
        p = i / h.max,
        c = a.length,
        d = a[0].indices.length,
        f = 0;
      f < d;
      ++f
    ) {
      ;(r = u[f] * p),
        e.setItemLayout(a[0].indices[f], { layerIndex: 0, x: l[0][f][0], y0: r, y: l[0][f][1] * p })
      for (var m = 1; m < c; ++m)
        (r += l[m - 1][f][1] * p),
          e.setItemLayout(a[m].indices[f], {
            layerIndex: m,
            x: l[m][f][0],
            y0: r,
            y: l[m][f][1] * p
          })
    }
}
function computeBaseline(e) {
  for (var t = e.length, i = e[0].length, r = [], n = [], a = 0, o = 0; o < i; ++o) {
    for (var s = 0, l = 0; l < t; ++l) s += e[l][o][1]
    s > a && (a = s), r.push(s)
  }
  for (var h = 0; h < i; ++h) n[h] = (a - r[h]) / 2
  a = 0
  for (var u = 0; u < i; ++u) {
    var p = r[u] + n[u]
    p > a && (a = p)
  }
  return { y0: n, max: a }
}
function install$t(e) {
  e.registerChartView(ThemeRiverView),
    e.registerSeriesModel(ThemeRiverSeriesModel),
    e.registerLayout(themeRiverLayout),
    e.registerProcessor(dataFilter$1('themeRiver'))
}
var DEFAULT_SECTOR_Z = 2,
  DEFAULT_TEXT_Z = 4,
  SunburstPiece = (function (e) {
    function t(t, i, r, n) {
      var a = e.call(this) || this
      ;(a.z2 = DEFAULT_SECTOR_Z),
        (a.textConfig = { inside: !0 }),
        (getECData(a).seriesIndex = i.seriesIndex)
      var o = new ZRText({ z2: DEFAULT_TEXT_Z, silent: t.getModel().get(['label', 'silent']) })
      return a.setTextContent(o), a.updateData(!0, t, i, r, n), a
    }
    return (
      __extends(t, e),
      (t.prototype.updateData = function (e, t, i, r, n) {
        ;(this.node = t), (t.piece = this), (i = i || this._seriesModel), (r = r || this._ecModel)
        var a = this
        getECData(a).dataIndex = t.dataIndex
        var o = t.getModel(),
          s = o.getModel('emphasis'),
          l = t.getLayout(),
          h = extend$3({}, l)
        h.label = null
        var u = t.getVisual('style')
        u.lineJoin = 'bevel'
        var p = t.getVisual('decal')
        p && (u.decal = createOrUpdatePatternFromDecal(p, n))
        var c = getSectorCornerRadius(o.getModel('itemStyle'), h)
        extend$3(h, c),
          each$i(SPECIAL_STATES, function (e) {
            var t = a.ensureState(e),
              i = o.getModel([e, 'itemStyle'])
            t.style = i.getItemStyle()
            var r = getSectorCornerRadius(i, h)
            r && (t.shape = r)
          }),
          e
            ? (a.setShape(h),
              (a.shape.r = l.r0),
              updateProps$1(a, { shape: { r: l.r } }, i, t.dataIndex))
            : updateProps$1(a, { shape: h }, i),
          a.useStyle(u),
          this._updateLabel(i)
        var d = o.getShallow('cursor')
        d && a.attr('cursor', d),
          (this._seriesModel = i || this._seriesModel),
          (this._ecModel = r || this._ecModel)
        var f = s.get('focus')
        enableHoverEmphasis(
          this,
          'ancestor' === f
            ? t.getAncestorsIndices()
            : 'descendant' === f
            ? t.getDescendantIndices()
            : f,
          s.get('blurScope')
        )
      }),
      (t.prototype._updateLabel = function (e) {
        var t = this,
          i = this.node.getModel(),
          r = i.getModel('label'),
          n = this.node.getLayout(),
          a = n.endAngle - n.startAngle,
          o = (n.startAngle + n.endAngle) / 2,
          s = Math.cos(o),
          l = Math.sin(o),
          h = this,
          u = h.getTextContent(),
          p = this.node.dataIndex,
          c = (r.get('minAngle') / 180) * Math.PI,
          d = r.get('show') && !(null != c && Math.abs(a) < c)
        function f(e, t) {
          var i = e.get(t)
          return null == i ? r.get(t) : i
        }
        ;(u.ignore = !d),
          each$i(DISPLAY_STATES, function (r) {
            var a = 'normal' === r ? i.getModel('label') : i.getModel([r, 'label']),
              c = 'normal' === r,
              d = c ? u : u.ensureState(r),
              m = e.getFormattedLabel(p, r)
            c && (m = m || t.node.name),
              (d.style = createTextStyle(a, {}, null, 'normal' !== r, !0)),
              m && (d.style.text = m)
            var g = a.get('show')
            null == g || c || (d.ignore = !g)
            var y,
              v = f(a, 'position'),
              _ = c ? h : h.states[r],
              x = _.style.fill
            _.textConfig = {
              outsideFill: 'inherit' === a.get('color') ? x : null,
              inside: 'outside' !== v
            }
            var S = f(a, 'distance') || 0,
              b = f(a, 'align')
            'outside' === v
              ? ((y = n.r + S), (b = o > Math.PI / 2 ? 'right' : 'left'))
              : b && 'center' !== b
              ? 'left' === b
                ? ((y = n.r0 + S), o > Math.PI / 2 && (b = 'right'))
                : 'right' === b && ((y = n.r - S), o > Math.PI / 2 && (b = 'left'))
              : ((y = (n.r + n.r0) / 2), (b = 'center')),
              (d.style.align = b),
              (d.style.verticalAlign = f(a, 'verticalAlign') || 'middle'),
              (d.x = y * s + n.cx),
              (d.y = y * l + n.cy)
            var T = f(a, 'rotate'),
              A = 0
            'radial' === T
              ? (A = -o) < -Math.PI / 2 && (A += Math.PI)
              : 'tangential' === T
              ? (A = Math.PI / 2 - o) > Math.PI / 2
                ? (A -= Math.PI)
                : A < -Math.PI / 2 && (A += Math.PI)
              : 'number' == typeof T && (A = (T * Math.PI) / 180),
              (d.rotation = A)
          }),
          u.dirtyStyle()
      }),
      t
    )
  })(Sector),
  ROOT_TO_NODE_ACTION = 'sunburstRootToNode',
  HIGHLIGHT_ACTION = 'sunburstHighlight',
  UNHIGHLIGHT_ACTION = 'sunburstUnhighlight'
function installSunburstAction(e) {
  e.registerAction({ type: ROOT_TO_NODE_ACTION, update: 'updateView' }, function (e, t) {
    t.eachComponent({ mainType: 'series', subType: 'sunburst', query: e }, function (t, i) {
      var r = retrieveTargetInfo(e, [ROOT_TO_NODE_ACTION], t)
      if (r) {
        var n = t.getViewRoot()
        n && (e.direction = aboveViewRoot(n, r.node) ? 'rollUp' : 'drillDown'),
          t.resetViewRoot(r.node)
      }
    })
  }),
    e.registerAction({ type: HIGHLIGHT_ACTION, update: 'none' }, function (e, t, i) {
      ;(e = extend$3({}, e)),
        t.eachComponent({ mainType: 'series', subType: 'sunburst', query: e }, function (t) {
          var i = retrieveTargetInfo(e, [HIGHLIGHT_ACTION], t)
          i && (e.dataIndex = i.node.dataIndex)
        }),
        i.dispatchAction(extend$3(e, { type: 'highlight' }))
    }),
    e.registerAction({ type: UNHIGHLIGHT_ACTION, update: 'updateView' }, function (e, t, i) {
      ;(e = extend$3({}, e)), i.dispatchAction(extend$3(e, { type: 'downplay' }))
    })
}
var SunburstView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i, r) {
        var n = this
        ;(this.seriesModel = e), (this.api = i), (this.ecModel = t)
        var a = e.getData(),
          o = a.tree.root,
          s = e.getViewRoot(),
          l = this.group,
          h = e.get('renderLabelForZeroData'),
          u = []
        s.eachNode(function (e) {
          u.push(e)
        })
        var p,
          c,
          d = this._oldChildren || []
        !(function (r, n) {
          if (0 === r.length && 0 === n.length) return
          function s(e) {
            return e.getId()
          }
          function u(s, u) {
            !(function (r, n) {
              h || !r || r.getValue() || (r = null)
              if (r !== o && n !== o)
                if (n && n.piece)
                  r
                    ? (n.piece.updateData(!1, r, e, t, i), a.setItemGraphicEl(r.dataIndex, n.piece))
                    : (function (e) {
                        if (!e) return
                        e.piece && (l.remove(e.piece), (e.piece = null))
                      })(n)
                else if (r) {
                  var s = new SunburstPiece(r, e, t, i)
                  l.add(s), a.setItemGraphicEl(r.dataIndex, s)
                }
            })(null == s ? null : r[s], null == u ? null : n[u])
          }
          new DataDiffer(n, r, s, s).add(u).update(u).remove(curry$1(u, null)).execute()
        })(u, d),
          (p = o),
          (c = s).depth > 0
            ? (n.virtualPiece
                ? n.virtualPiece.updateData(!1, p, e, t, i)
                : ((n.virtualPiece = new SunburstPiece(p, e, t, i)), l.add(n.virtualPiece)),
              c.piece.off('click'),
              n.virtualPiece.on('click', function (e) {
                n._rootToNode(c.parentNode)
              }))
            : n.virtualPiece && (l.remove(n.virtualPiece), (n.virtualPiece = null)),
          this._initEvents(),
          (this._oldChildren = u)
      }),
      (t.prototype._initEvents = function () {
        var e = this
        this.group.off('click'),
          this.group.on('click', function (t) {
            var i = !1
            e.seriesModel.getViewRoot().eachNode(function (r) {
              if (!i && r.piece && r.piece === t.target) {
                var n = r.getModel().get('nodeClick')
                if ('rootToNode' === n) e._rootToNode(r)
                else if ('link' === n) {
                  var a = r.getModel(),
                    o = a.get('link')
                  if (o) windowOpen(o, a.get('target', !0) || '_blank')
                }
                i = !0
              }
            })
          })
      }),
      (t.prototype._rootToNode = function (e) {
        e !== this.seriesModel.getViewRoot() &&
          this.api.dispatchAction({
            type: ROOT_TO_NODE_ACTION,
            from: this.uid,
            seriesId: this.seriesModel.id,
            targetNode: e
          })
      }),
      (t.prototype.containPoint = function (e, t) {
        var i = t.getData().getItemLayout(0)
        if (i) {
          var r = e[0] - i.cx,
            n = e[1] - i.cy,
            a = Math.sqrt(r * r + n * n)
          return a <= i.r && a >= i.r0
        }
      }),
      (t.type = 'sunburst'),
      t
    )
  })(ChartView),
  SunburstSeriesModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.ignoreStyleOnData = !0), i
    }
    return (
      __extends(t, e),
      (t.prototype.getInitialData = function (e, t) {
        var i = { name: e.name, children: e.data }
        completeTreeValue(i)
        var r = map$1(
            e.levels || [],
            function (e) {
              return new Model(e, this, t)
            },
            this
          ),
          n = Tree.createTree(i, this, function (e) {
            e.wrapMethod('getItemModel', function (e, t) {
              var i = n.getNodeByDataIndex(t),
                a = r[i.depth]
              return a && (e.parentModel = a), e
            })
          })
        return n.data
      }),
      (t.prototype.optionUpdated = function () {
        this.resetViewRoot()
      }),
      (t.prototype.getDataParams = function (t) {
        var i = e.prototype.getDataParams.apply(this, arguments),
          r = this.getData().tree.getNodeByDataIndex(t)
        return (i.treePathInfo = wrapTreePathInfo(r, this)), i
      }),
      (t.prototype.getViewRoot = function () {
        return this._viewRoot
      }),
      (t.prototype.resetViewRoot = function (e) {
        e ? (this._viewRoot = e) : (e = this._viewRoot)
        var t = this.getRawData().tree.root
        ;(e && (e === t || t.contains(e))) || (this._viewRoot = t)
      }),
      (t.prototype.enableAriaDecal = function () {
        enableAriaDecalForTree(this)
      }),
      (t.type = 'series.sunburst'),
      (t.defaultOption = {
        zlevel: 0,
        z: 2,
        center: ['50%', '50%'],
        radius: [0, '75%'],
        clockwise: !0,
        startAngle: 90,
        minAngle: 0,
        stillShowZeroSum: !0,
        nodeClick: 'rootToNode',
        renderLabelForZeroData: !1,
        label: {
          rotate: 'radial',
          show: !0,
          opacity: 1,
          align: 'center',
          position: 'inside',
          distance: 5,
          silent: !0
        },
        itemStyle: {
          borderWidth: 1,
          borderColor: 'white',
          borderType: 'solid',
          shadowBlur: 0,
          shadowColor: 'rgba(0, 0, 0, 0.2)',
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          opacity: 1
        },
        emphasis: { focus: 'descendant' },
        blur: { itemStyle: { opacity: 0.2 }, label: { opacity: 0.1 } },
        animationType: 'expansion',
        animationDuration: 1e3,
        animationDurationUpdate: 500,
        data: [],
        levels: [],
        sort: 'desc'
      }),
      t
    )
  })(SeriesModel)
function completeTreeValue(e) {
  var t = 0
  each$i(e.children, function (e) {
    completeTreeValue(e)
    var i = e.value
    isArray$1(i) && (i = i[0]), (t += i)
  })
  var i = e.value
  isArray$1(i) && (i = i[0]),
    (null == i || isNaN(i)) && (i = t),
    i < 0 && (i = 0),
    isArray$1(e.value) ? (e.value[0] = i) : (e.value = i)
}
var RADIAN = Math.PI / 180
function sunburstLayout(e, t, i) {
  t.eachSeriesByType(e, function (e) {
    var t = e.get('center'),
      r = e.get('radius')
    isArray$1(r) || (r = [0, r]), isArray$1(t) || (t = [t, t])
    var n = i.getWidth(),
      a = i.getHeight(),
      o = Math.min(n, a),
      s = parsePercent$1(t[0], n),
      l = parsePercent$1(t[1], a),
      h = parsePercent$1(r[0], o / 2),
      u = parsePercent$1(r[1], o / 2),
      p = -e.get('startAngle') * RADIAN,
      c = e.get('minAngle') * RADIAN,
      d = e.getData().tree.root,
      f = e.getViewRoot(),
      m = f.depth,
      g = e.get('sort')
    null != g && initChildren(f, g)
    var y = 0
    each$i(f.children, function (e) {
      !isNaN(e.getValue()) && y++
    })
    var v = f.getValue(),
      _ = (Math.PI / (v || y)) * 2,
      x = f.depth > 0,
      S = f.height - (x ? -1 : 1),
      b = (u - h) / (S || 1),
      T = e.get('clockwise'),
      A = e.get('stillShowZeroSum'),
      w = T ? 1 : -1,
      M = function (e, t) {
        if (e) {
          var i = t
          if (e !== d) {
            var r = e.getValue(),
              n = 0 === v && A ? _ : r * _
            n < c && (n = c), (i = t + w * n)
            var a = e.depth - m - (x ? -1 : 1),
              u = h + b * a,
              p = h + b * (a + 1),
              f = e.getModel()
            null != f.get('r0') && (u = parsePercent$1(f.get('r0'), o / 2)),
              null != f.get('r') && (p = parsePercent$1(f.get('r'), o / 2)),
              e.setLayout({
                angle: n,
                startAngle: t,
                endAngle: i,
                clockwise: T,
                cx: s,
                cy: l,
                r0: u,
                r: p
              })
          }
          if (e.children && e.children.length) {
            var g = 0
            each$i(e.children, function (e) {
              g += M(e, t + g)
            })
          }
          return i - t
        }
      }
    if (x) {
      var C = h,
        P = h + b,
        E = 2 * Math.PI
      d.setLayout({
        angle: E,
        startAngle: p,
        endAngle: p + E,
        clockwise: T,
        cx: s,
        cy: l,
        r0: C,
        r: P
      })
    }
    M(f, p)
  })
}
function initChildren(e, t) {
  var i = e.children || []
  ;(e.children = sort(i, t)),
    i.length &&
      each$i(e.children, function (e) {
        initChildren(e, t)
      })
}
function sort(e, t) {
  if ('function' == typeof t) {
    var i = map$1(e, function (e, t) {
      var i = e.getValue()
      return {
        params: {
          depth: e.depth,
          height: e.height,
          dataIndex: e.dataIndex,
          getValue: function () {
            return i
          }
        },
        index: t
      }
    })
    return (
      i.sort(function (e, i) {
        return t(e.params, i.params)
      }),
      map$1(i, function (t) {
        return e[t.index]
      })
    )
  }
  var r = 'asc' === t
  return e.sort(function (e, t) {
    var i = (e.getValue() - t.getValue()) * (r ? 1 : -1)
    return 0 === i ? (e.dataIndex - t.dataIndex) * (r ? -1 : 1) : i
  })
}
function sunburstVisual(e) {
  var t = {}
  e.eachSeriesByType('sunburst', function (e) {
    var i = e.getData(),
      r = i.tree
    r.eachNode(function (n) {
      var a = n.getModel().getModel('itemStyle').getItemStyle()
      a.fill ||
        (a.fill = (function (e, i, r) {
          for (var n = e; n && n.depth > 1; ) n = n.parentNode
          var a = i.getColorFromPalette(n.name || n.dataIndex + '', t)
          return (
            e.depth > 1 && 'string' == typeof a && (a = lift(a, ((e.depth - 1) / (r - 1)) * 0.5)), a
          )
        })(n, e, r.root.height)),
        extend$3(i.ensureUniqueItemVisual(n.dataIndex, 'style'), a)
    })
  })
}
function install$s(e) {
  e.registerChartView(SunburstView),
    e.registerSeriesModel(SunburstSeriesModel),
    e.registerLayout(curry$1(sunburstLayout, 'sunburst')),
    e.registerProcessor(curry$1(dataFilter$1, 'sunburst')),
    e.registerVisual(sunburstVisual),
    installSunburstAction(e)
}
function dataToCoordSize$3(e, t) {
  return (
    (t = t || [0, 0]),
    map$1(
      ['x', 'y'],
      function (i, r) {
        var n = this.getAxis(i),
          a = t[r],
          o = e[r] / 2
        return 'category' === n.type
          ? n.getBandWidth()
          : Math.abs(n.dataToCoord(a - o) - n.dataToCoord(a + o))
      },
      this
    )
  )
}
function cartesianPrepareCustom(e) {
  var t = e.master.getRect()
  return {
    coordSys: { type: 'cartesian2d', x: t.x, y: t.y, width: t.width, height: t.height },
    api: {
      coord: function (t) {
        return e.dataToPoint(t)
      },
      size: bind$2(dataToCoordSize$3, e)
    }
  }
}
function dataToCoordSize$2(e, t) {
  return (
    (t = t || [0, 0]),
    map$1(
      [0, 1],
      function (i) {
        var r = t[i],
          n = e[i] / 2,
          a = [],
          o = []
        return (
          (a[i] = r - n),
          (o[i] = r + n),
          (a[1 - i] = o[1 - i] = t[1 - i]),
          Math.abs(this.dataToPoint(a)[i] - this.dataToPoint(o)[i])
        )
      },
      this
    )
  )
}
function geoPrepareCustom(e) {
  var t = e.getBoundingRect()
  return {
    coordSys: { type: 'geo', x: t.x, y: t.y, width: t.width, height: t.height, zoom: e.getZoom() },
    api: {
      coord: function (t) {
        return e.dataToPoint(t)
      },
      size: bind$2(dataToCoordSize$2, e)
    }
  }
}
function dataToCoordSize$1(e, t) {
  var i = this.getAxis(),
    r = t instanceof Array ? t[0] : t,
    n = (e instanceof Array ? e[0] : e) / 2
  return 'category' === i.type
    ? i.getBandWidth()
    : Math.abs(i.dataToCoord(r - n) - i.dataToCoord(r + n))
}
function singlePrepareCustom(e) {
  var t = e.getRect()
  return {
    coordSys: { type: 'singleAxis', x: t.x, y: t.y, width: t.width, height: t.height },
    api: {
      coord: function (t) {
        return e.dataToPoint(t)
      },
      size: bind$2(dataToCoordSize$1, e)
    }
  }
}
function dataToCoordSize(e, t) {
  return (
    (t = t || [0, 0]),
    map$1(
      ['Radius', 'Angle'],
      function (i, r) {
        var n = this['get' + i + 'Axis'](),
          a = t[r],
          o = e[r] / 2,
          s =
            'category' === n.type
              ? n.getBandWidth()
              : Math.abs(n.dataToCoord(a - o) - n.dataToCoord(a + o))
        return 'Angle' === i && (s = (s * Math.PI) / 180), s
      },
      this
    )
  )
}
function polarPrepareCustom(e) {
  var t = e.getRadiusAxis(),
    i = e.getAngleAxis(),
    r = t.getExtent()
  return (
    r[0] > r[1] && r.reverse(),
    {
      coordSys: { type: 'polar', cx: e.cx, cy: e.cy, r: r[1], r0: r[0] },
      api: {
        coord: function (r) {
          var n = t.dataToRadius(r[0]),
            a = i.dataToAngle(r[1]),
            o = e.coordToPoint([n, a])
          return o.push(n, (a * Math.PI) / 180), o
        },
        size: bind$2(dataToCoordSize, e)
      }
    }
  )
}
function calendarPrepareCustom(e) {
  var t = e.getRect(),
    i = e.getRangeInfo()
  return {
    coordSys: {
      type: 'calendar',
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
      cellWidth: e.getCellWidth(),
      cellHeight: e.getCellHeight(),
      rangeInfo: { start: i.start, end: i.end, weeks: i.weeks, dayCount: i.allDay }
    },
    api: {
      coord: function (t, i) {
        return e.dataToPoint(t, i)
      }
    }
  }
}
function isEC4CompatibleStyle(e, t, i, r) {
  return (
    e &&
    (e.legacy ||
      (!1 !== e.legacy && !i && !r && 'tspan' !== t && ('text' === t || hasOwn(e, 'text'))))
  )
}
function convertFromEC4CompatibleStyle(e, t, i) {
  var r,
    n,
    a,
    o = e
  if ('text' === t) a = o
  else {
    ;(a = {}),
      hasOwn(o, 'text') && (a.text = o.text),
      hasOwn(o, 'rich') && (a.rich = o.rich),
      hasOwn(o, 'textFill') && (a.fill = o.textFill),
      hasOwn(o, 'textStroke') && (a.stroke = o.textStroke),
      (n = { type: 'text', style: a, silent: !0 }),
      (r = {})
    var s = hasOwn(o, 'textPosition')
    i ? (r.position = s ? o.textPosition : 'inside') : s && (r.position = o.textPosition),
      hasOwn(o, 'textPosition') && (r.position = o.textPosition),
      hasOwn(o, 'textOffset') && (r.offset = o.textOffset),
      hasOwn(o, 'textRotation') && (r.rotation = o.textRotation),
      hasOwn(o, 'textDistance') && (r.distance = o.textDistance)
  }
  return (
    convertEC4CompatibleRichItem(a, e),
    each$i(a.rich, function (e) {
      convertEC4CompatibleRichItem(e, e)
    }),
    { textConfig: r, textContent: n }
  )
}
function convertEC4CompatibleRichItem(e, t) {
  t &&
    ((t.font = t.textFont || t.font),
    hasOwn(t, 'textStrokeWidth') && (e.lineWidth = t.textStrokeWidth),
    hasOwn(t, 'textAlign') && (e.align = t.textAlign),
    hasOwn(t, 'textVerticalAlign') && (e.verticalAlign = t.textVerticalAlign),
    hasOwn(t, 'textLineHeight') && (e.lineHeight = t.textLineHeight),
    hasOwn(t, 'textWidth') && (e.width = t.textWidth),
    hasOwn(t, 'textHeight') && (e.height = t.textHeight),
    hasOwn(t, 'textBackgroundColor') && (e.backgroundColor = t.textBackgroundColor),
    hasOwn(t, 'textPadding') && (e.padding = t.textPadding),
    hasOwn(t, 'textBorderColor') && (e.borderColor = t.textBorderColor),
    hasOwn(t, 'textBorderWidth') && (e.borderWidth = t.textBorderWidth),
    hasOwn(t, 'textBorderRadius') && (e.borderRadius = t.textBorderRadius),
    hasOwn(t, 'textBoxShadowColor') && (e.shadowColor = t.textBoxShadowColor),
    hasOwn(t, 'textBoxShadowBlur') && (e.shadowBlur = t.textBoxShadowBlur),
    hasOwn(t, 'textBoxShadowOffsetX') && (e.shadowOffsetX = t.textBoxShadowOffsetX),
    hasOwn(t, 'textBoxShadowOffsetY') && (e.shadowOffsetY = t.textBoxShadowOffsetY))
}
function convertToEC4StyleForCustomSerise(e, t, i) {
  var r = e
  ;(r.textPosition = r.textPosition || i.position || 'inside'),
    null != i.offset && (r.textOffset = i.offset),
    null != i.rotation && (r.textRotation = i.rotation),
    null != i.distance && (r.textDistance = i.distance)
  var n = r.textPosition.indexOf('inside') >= 0,
    a = e.fill || '#000'
  convertToEC4RichItem(r, t)
  var o = null == r.textFill
  return (
    n
      ? o &&
        ((r.textFill = i.insideFill || '#fff'),
        !r.textStroke && i.insideStroke && (r.textStroke = i.insideStroke),
        !r.textStroke && (r.textStroke = a),
        null == r.textStrokeWidth && (r.textStrokeWidth = 2))
      : (o && (r.textFill = e.fill || i.outsideFill || '#000'),
        !r.textStroke && i.outsideStroke && (r.textStroke = i.outsideStroke)),
    (r.text = t.text),
    (r.rich = t.rich),
    each$i(t.rich, function (e) {
      convertToEC4RichItem(e, e)
    }),
    r
  )
}
function convertToEC4RichItem(e, t) {
  t &&
    (hasOwn(t, 'fill') && (e.textFill = t.fill),
    hasOwn(t, 'stroke') && (e.textStroke = t.fill),
    hasOwn(t, 'lineWidth') && (e.textStrokeWidth = t.lineWidth),
    hasOwn(t, 'font') && (e.font = t.font),
    hasOwn(t, 'fontStyle') && (e.fontStyle = t.fontStyle),
    hasOwn(t, 'fontWeight') && (e.fontWeight = t.fontWeight),
    hasOwn(t, 'fontSize') && (e.fontSize = t.fontSize),
    hasOwn(t, 'fontFamily') && (e.fontFamily = t.fontFamily),
    hasOwn(t, 'align') && (e.textAlign = t.align),
    hasOwn(t, 'verticalAlign') && (e.textVerticalAlign = t.verticalAlign),
    hasOwn(t, 'lineHeight') && (e.textLineHeight = t.lineHeight),
    hasOwn(t, 'width') && (e.textWidth = t.width),
    hasOwn(t, 'height') && (e.textHeight = t.height),
    hasOwn(t, 'backgroundColor') && (e.textBackgroundColor = t.backgroundColor),
    hasOwn(t, 'padding') && (e.textPadding = t.padding),
    hasOwn(t, 'borderColor') && (e.textBorderColor = t.borderColor),
    hasOwn(t, 'borderWidth') && (e.textBorderWidth = t.borderWidth),
    hasOwn(t, 'borderRadius') && (e.textBorderRadius = t.borderRadius),
    hasOwn(t, 'shadowColor') && (e.textBoxShadowColor = t.shadowColor),
    hasOwn(t, 'shadowBlur') && (e.textBoxShadowBlur = t.shadowBlur),
    hasOwn(t, 'shadowOffsetX') && (e.textBoxShadowOffsetX = t.shadowOffsetX),
    hasOwn(t, 'shadowOffsetY') && (e.textBoxShadowOffsetY = t.shadowOffsetY),
    hasOwn(t, 'textShadowColor') && (e.textShadowColor = t.textShadowColor),
    hasOwn(t, 'textShadowBlur') && (e.textShadowBlur = t.textShadowBlur),
    hasOwn(t, 'textShadowOffsetX') && (e.textShadowOffsetX = t.textShadowOffsetX),
    hasOwn(t, 'textShadowOffsetY') && (e.textShadowOffsetY = t.textShadowOffsetY))
}
var CMD = PathProxy.CMD,
  PI2 = 2 * Math.PI,
  PROP_XY = ['x', 'y'],
  PROP_WH = ['width', 'height'],
  tmpArr = []
function aroundEqual(e, t) {
  return Math.abs(e - t) < 1e-5
}
function pathToBezierCurves(e) {
  var t,
    i,
    r,
    n,
    a,
    o,
    s,
    l,
    h,
    u,
    p,
    c,
    d,
    f,
    m,
    g,
    y,
    v,
    _,
    x,
    S,
    b,
    T,
    A,
    w = e.data,
    M = e.len(),
    C = [],
    P = 0,
    E = 0,
    I = 0,
    D = 0
  function L(e, i) {
    t && t.length > 2 && C.push(t), (t = [e, i])
  }
  function R(e, i, r, n) {
    ;(aroundEqual(e, r) && aroundEqual(i, n)) || t.push(e, i, r, n, r, n)
  }
  for (var O = 0; O < M; ) {
    var k = w[O++],
      $ = 1 === O
    switch (
      ($ &&
        ((I = P = w[O]),
        (D = E = w[O + 1]),
        (k !== CMD.L && k !== CMD.C && k !== CMD.Q) || (t = [I, D])),
      k)
    ) {
      case CMD.M:
        ;(P = I = w[O++]), (E = D = w[O++]), L(I, D)
        break
      case CMD.L:
        R(P, E, (i = w[O++]), (r = w[O++])), (P = i), (E = r)
        break
      case CMD.C:
        t.push(w[O++], w[O++], w[O++], w[O++], (P = w[O++]), (E = w[O++]))
        break
      case CMD.Q:
        ;(i = w[O++]),
          (r = w[O++]),
          (n = w[O++]),
          (a = w[O++]),
          t.push(
            P + (2 / 3) * (i - P),
            E + (2 / 3) * (r - E),
            n + (2 / 3) * (i - n),
            a + (2 / 3) * (r - a),
            n,
            a
          ),
          (P = n),
          (E = a)
        break
      case CMD.A:
        var N = w[O++],
          F = w[O++],
          B = w[O++],
          V = w[O++],
          z = w[O++],
          G = w[O++] + z
        O += 1
        var H = !w[O++]
        ;(i = Math.cos(z) * B + N),
          (r = Math.sin(z) * V + F),
          $ ? L((I = i), (D = r)) : R(P, E, i, r),
          (P = Math.cos(G) * B + N),
          (E = Math.sin(G) * V + F)
        for (var U = ((H ? -1 : 1) * Math.PI) / 2, Y = z; H ? Y > G : Y < G; Y += U) {
          var W = H ? Math.max(Y + U, G) : Math.min(Y + U, G)
          ;(o = Y),
            (s = W),
            (l = N),
            (h = F),
            (u = B),
            (p = V),
            (c = void 0),
            (d = void 0),
            (f = void 0),
            (m = void 0),
            (g = void 0),
            (y = void 0),
            (v = void 0),
            (_ = void 0),
            (x = void 0),
            (S = void 0),
            (b = void 0),
            (T = void 0),
            (A = void 0),
            (c = Math.abs(s - o)),
            (d = (4 * Math.tan(c / 4)) / 3),
            (f = s < o ? -1 : 1),
            (m = Math.cos(o)),
            (g = Math.sin(o)),
            (y = Math.cos(s)),
            (v = Math.sin(s)),
            (_ = m * u + l),
            (x = g * p + h),
            (S = y * u + l),
            (b = v * p + h),
            (T = u * d * f),
            (A = p * d * f),
            t.push(_ - T * g, x + A * m, S + T * v, b - A * y, S, b)
        }
        break
      case CMD.R:
        ;(I = P = w[O++]),
          (D = E = w[O++]),
          (i = I + w[O++]),
          (r = D + w[O++]),
          L(i, D),
          R(i, D, i, r),
          R(i, r, I, r),
          R(I, r, I, D),
          R(I, D, i, D)
        break
      case CMD.Z:
        t && R(P, E, I, D), (P = I), (E = D)
    }
  }
  return t && t.length > 2 && C.push(t), C
}
function alignSubpath(e, t) {
  var i = e.length,
    r = t.length
  if (i === r) return [e, t]
  for (
    var n = i < r ? e : t,
      a = Math.min(i, r),
      o = Math.abs(r - i) / 6,
      s = (a - 2) / 6,
      l = Math.ceil(o / s) + 1,
      h = [n[0], n[1]],
      u = o,
      p = [],
      c = [],
      d = 2;
    d < a;

  ) {
    var f = n[d - 2],
      m = n[d - 1],
      g = n[d++],
      y = n[d++],
      v = n[d++],
      _ = n[d++],
      x = n[d++],
      S = n[d++]
    if (u <= 0) h.push(g, y, v, _, x, S)
    else {
      for (var b = Math.min(u, l - 1) + 1, T = 1; T <= b; T++) {
        var A = T / b
        cubicSubdivide(f, g, v, x, A, p),
          cubicSubdivide(m, y, _, S, A, c),
          (f = p[3]),
          (m = c[3]),
          h.push(p[1], c[1], p[2], c[2], f, m),
          (g = p[5]),
          (y = c[5]),
          (v = p[6]),
          (_ = c[6])
      }
      u -= b - 1
    }
  }
  return n === e ? [h, t] : [e, h]
}
function createSubpath(e, t) {
  for (var i = e.length, r = e[i - 2], n = e[i - 1], a = [], o = 0; o < t.length; )
    (a[o++] = r), (a[o++] = n)
  return a
}
function alignBezierCurves(e, t) {
  for (var i, r, n, a = [], o = [], s = 0; s < Math.max(e.length, t.length); s++) {
    var l = e[s],
      h = t[s],
      u = void 0,
      p = void 0
    l
      ? h
        ? ((r = u = (i = alignSubpath(l, h))[0]), (n = p = i[1]))
        : ((p = createSubpath(n || l, l)), (u = l))
      : ((u = createSubpath(r || h, h)), (p = h)),
      a.push(u),
      o.push(p)
  }
  return [a, o]
}
function centroid(e) {
  for (var t = 0, i = 0, r = 0, n = e.length, a = 0, o = n - 2; a < n; o = a, a += 2) {
    var s = e[o],
      l = e[o + 1],
      h = e[a],
      u = e[a + 1],
      p = s * u - h * l
    ;(t += p), (i += (s + h) * p), (r += (l + u) * p)
  }
  return 0 === t ? [e[0] || 0, e[1] || 0] : [i / t / 3, r / t / 3, t]
}
function findBestRingOffset(e, t, i, r) {
  for (var n = (e.length - 2) / 6, a = 1 / 0, o = 0, s = e.length, l = s - 2, h = 0; h < n; h++) {
    for (var u = 6 * h, p = 0, c = 0; c < s; c += 2) {
      var d = 0 === c ? u : ((u + c - 2) % l) + 2,
        f = e[d] - i[0],
        m = e[d + 1] - i[1],
        g = t[c] - r[0] - f,
        y = t[c + 1] - r[1] - m
      p += g * g + y * y
    }
    p < a && ((a = p), (o = h))
  }
  return o
}
function reverse(e) {
  for (var t = [], i = e.length, r = 0; r < i; r += 2)
    (t[r] = e[i - r - 2]), (t[r + 1] = e[i - r - 1])
  return t
}
function findBestMorphingRotation(e, t, i, r) {
  for (var n, a = [], o = 0; o < e.length; o++) {
    var s = e[o],
      l = t[o],
      h = centroid(s),
      u = centroid(l)
    null == n && (n = h[2] < 0 != u[2] < 0)
    var p = [],
      c = [],
      d = 0,
      f = 1 / 0,
      m = [],
      g = s.length
    n && (s = reverse(s))
    for (var y = 6 * findBestRingOffset(s, l, h, u), v = g - 2, _ = 0; _ < v; _ += 2) {
      var x = ((y + _) % v) + 2
      ;(p[_ + 2] = s[x] - h[0]), (p[_ + 3] = s[x + 1] - h[1])
    }
    if (((p[0] = s[y] - h[0]), (p[1] = s[y + 1] - h[1]), i > 0))
      for (var S = r / i, b = -r / 2; b <= r / 2; b += S) {
        var T = Math.sin(b),
          A = Math.cos(b),
          w = 0
        for (_ = 0; _ < s.length; _ += 2) {
          var M = p[_],
            C = p[_ + 1],
            P = l[_] - u[0],
            E = l[_ + 1] - u[1],
            I = P * A - E * T,
            D = P * T + E * A
          ;(m[_] = I), (m[_ + 1] = D)
          var L = I - M,
            R = D - C
          w += L * L + R * R
        }
        if (w < f) {
          ;(f = w), (d = b)
          for (var O = 0; O < m.length; O++) c[O] = m[O]
        }
      }
    else for (var k = 0; k < g; k += 2) (c[k] = l[k] - u[0]), (c[k + 1] = l[k + 1] - u[1])
    a.push({ from: p, to: c, fromCp: h, toCp: u, rotation: -d })
  }
  return a
}
function morphPath(e, t, i) {
  var r, n
  if (!e || !t) return t
  !e.path && e.createPathProxy(),
    (r = e.path).beginPath(),
    e.buildPath(r, e.shape),
    !t.path && t.createPathProxy(),
    (n = t.path) === r && (n = new PathProxy(!1)),
    n.beginPath(),
    isIndividualMorphingPath(t) ? t.__oldBuildPath(n, t.shape) : t.buildPath(n, t.shape)
  var a = alignBezierCurves(pathToBezierCurves(r), pathToBezierCurves(n)),
    o = findBestMorphingRotation(a[0], a[1], 10, Math.PI)
  becomeIndividualMorphingPath(t, o, 0)
  var s = i && i.done,
    l = i && i.aborted,
    h = i && i.during
  return (
    t.animateTo(
      { __morphT: 1 },
      defaults$1(
        {
          during: function (e) {
            t.dirtyShape(), h && h(e)
          },
          done: function () {
            restoreIndividualMorphingPath(t), t.createPathProxy(), t.dirtyShape(), s && s()
          },
          aborted: function () {
            l && l()
          }
        },
        i
      )
    ),
    t
  )
}
function morphingPathBuildPath(e) {
  for (
    var t = this.__morphingData, i = this.__morphT, r = 1 - i, n = [], a = 0;
    a < t.length;
    a++
  ) {
    var o = t[a],
      s = o.from,
      l = o.to,
      h = o.rotation * i,
      u = o.fromCp,
      p = o.toCp,
      c = Math.sin(h),
      d = Math.cos(h)
    lerp(n, u, p, i)
    for (var f = 0; f < s.length; f += 2) {
      var m = s[f],
        g = s[f + 1],
        y = m * r + l[f] * i,
        v = g * r + l[f + 1] * i
      ;(tmpArr[f] = y * d - v * c + n[0]), (tmpArr[f + 1] = y * c + v * d + n[1])
    }
    for (f = 0; f < s.length; )
      0 === f && e.moveTo(tmpArr[f++], tmpArr[f++]),
        e.bezierCurveTo(
          tmpArr[f++],
          tmpArr[f++],
          tmpArr[f++],
          tmpArr[f++],
          tmpArr[f++],
          tmpArr[f++]
        )
  }
}
function becomeIndividualMorphingPath(e, t, i) {
  if (isIndividualMorphingPath(e)) updateIndividualMorphingPath(e, t, i)
  else {
    var r = e
    ;(r.__oldBuildPath = r.buildPath),
      (r.buildPath = morphingPathBuildPath),
      updateIndividualMorphingPath(r, t, i)
  }
}
function updateIndividualMorphingPath(e, t, i) {
  ;(e.__morphingData = t), (e.__morphT = i)
}
function restoreIndividualMorphingPath(e) {
  isIndividualMorphingPath(e) &&
    ((e.buildPath = e.__oldBuildPath), (e.__oldBuildPath = e.__morphingData = null))
}
function isIndividualMorphingPath(e) {
  return null != e.__oldBuildPath
}
function isCombiningPath(e) {
  return !!e.__combiningSubList
}
function isInAnyMorphing(e) {
  return isIndividualMorphingPath(e) || isCombiningPath(e)
}
function combine(e, t, i, r) {
  for (var n = [], a = 0, o = 0; o < e.length; o++) {
    var s = e[o]
    if (isCombiningPath(s)) {
      for (var l = s.__combiningSubList, h = 0; h < l.length; h++) n.push(l[h])
      a += l.length
    } else n.push(s), a++
  }
  if (a) {
    var u = i ? i.dividingMethod : null,
      p = divideShape(t, a, u)
    assert$1(p.length === a)
    var c = i && i.done,
      d = i && i.aborted,
      f = i && i.during,
      m = 0,
      g = !1,
      y = defaults$1(
        {
          during: function (e) {
            f && f(e)
          },
          done: function () {
            ++m === p.length && (restoreCombiningPath(t), c && c())
          },
          aborted: function () {
            g || ((g = !0), d && d())
          }
        },
        i
      )
    for (o = 0; o < a; o++) {
      var v = n[o],
        _ = p[o]
      r && r(t, _, !0), morphPath(v, _, y)
    }
    return becomeCombiningPath(t, p), { fromIndividuals: n, toIndividuals: p, count: a }
  }
}
function becomeCombiningPath(e, t) {
  if (isCombiningPath(e)) updateCombiningPathSubList(e, t)
  else {
    var i = e
    updateCombiningPathSubList(i, t),
      (i.__oldAddSelfToZr = e.addSelfToZr),
      (i.__oldRemoveSelfFromZr = e.removeSelfFromZr),
      (i.addSelfToZr = combiningAddSelfToZr),
      (i.removeSelfFromZr = combiningRemoveSelfFromZr),
      (i.__oldBuildPath = i.buildPath),
      (i.buildPath = noop$1),
      (i.childrenRef = combiningChildrenRef)
  }
}
function restoreCombiningPath(e) {
  if (isCombiningPath(e)) {
    var t = e
    updateCombiningPathSubList(t, null),
      (t.addSelfToZr = t.__oldAddSelfToZr),
      (t.removeSelfFromZr = t.__oldRemoveSelfFromZr),
      (t.buildPath = t.__oldBuildPath),
      (t.childrenRef =
        t.__combiningSubList =
        t.__oldAddSelfToZr =
        t.__oldRemoveSelfFromZr =
        t.__oldBuildPath =
          null)
  }
}
function updateCombiningPathSubList(e, t) {
  if (e.__combiningSubList !== t) {
    if ((combiningPathSubListAddRemoveWithZr(e, 'removeSelfFromZr'), (e.__combiningSubList = t), t))
      for (var i = 0; i < t.length; i++) t[i].parent = e
    combiningPathSubListAddRemoveWithZr(e, 'addSelfToZr')
  }
}
function combiningAddSelfToZr(e) {
  this.__oldAddSelfToZr(e), combiningPathSubListAddRemoveWithZr(this, 'addSelfToZr')
}
function combiningPathSubListAddRemoveWithZr(e, t) {
  var i = e.__combiningSubList,
    r = e.__zr
  if (i && r)
    for (var n = 0; n < i.length; n++) {
      i[n][t](r)
    }
}
function combiningRemoveSelfFromZr(e) {
  this.__oldRemoveSelfFromZr(e)
  for (var t = this.__combiningSubList, i = 0; i < t.length; i++) {
    t[i].removeSelfFromZr(e)
  }
}
function combiningChildrenRef() {
  return this.__combiningSubList
}
function separate(e, t, i, r) {
  var n,
    a = t.length,
    o = i ? i.dividingMethod : null,
    s = !1
  if (isCombiningPath(e)) {
    var l = e.__combiningSubList
    l.length === a ? (n = l) : ((n = divideShape(e, a, o)), (s = !0))
  } else (n = divideShape(e, a, o)), (s = !0)
  assert$1(n.length === a)
  for (var h = 0; h < a; h++) s && r && r(e, n[h], !1), morphPath(n[h], t[h], i)
  return { fromIndividuals: n, toIndividuals: t, count: a }
}
function divideShape(e, t, i) {
  return 'duplicate' === i ? duplicateShape(e, t) : splitShape(e, t)
}
function splitShape(e, t) {
  var i = []
  if (t <= 0) return i
  if (1 === t) return duplicateShape(e, t)
  if (e instanceof Rect$2)
    for (
      var r = (p = e.shape).height > p.width ? 1 : 0,
        n = PROP_WH[r],
        a = PROP_XY[r],
        o = p[n] / t,
        s = p[a],
        l = 0;
      l < t;
      l++, s += o
    ) {
      var h = { x: p.x, y: p.y, width: p.width, height: p.height }
      ;(h[a] = s), (h[n] = l < t - 1 ? o : p[a] + p[n] - s)
      var u = new Rect$2({ shape: h })
      i.push(u)
    }
  else {
    if (!(e instanceof Sector)) return duplicateShape(e, t)
    var p,
      c = (p = e.shape).clockwise,
      d = p.startAngle,
      f = p.endAngle,
      m = (normalizeRadian(d, p.endAngle, c) - d) / t,
      g = d
    for (l = 0; l < t; l++, g += m) {
      u = new Sector({
        shape: {
          cx: p.cx,
          cy: p.cy,
          r: p.r,
          r0: p.r0,
          clockwise: c,
          startAngle: g,
          endAngle: l === t - 1 ? f : g + m
        }
      })
      i.push(u)
    }
  }
  return i
}
function duplicateShape(e, t) {
  var i = []
  if (t <= 0) return i
  for (var r = e.constructor, n = 0; n < t; n++) {
    var a = new r({ shape: clone$3(e.shape) })
    i.push(a)
  }
  return i
}
function normalizeRadian(e, t, i) {
  return t + PI2 * Math[i ? 'ceil' : 'floor']((e - t) / PI2)
}
var inner$c = makeInner(),
  TRANSFORM_PROPS = { x: 1, y: 1, scaleX: 1, scaleY: 1, originX: 1, originY: 1, rotation: 1 }
keys(TRANSFORM_PROPS).join(', ')
var STYLE_VISUAL_TYPE = { color: 'fill', borderColor: 'stroke' },
  NON_STYLE_VISUAL_PROPS = {
    symbol: 1,
    symbolSize: 1,
    symbolKeepAspect: 1,
    legendIcon: 1,
    visualMeta: 1,
    liftZ: 1,
    decal: 1
  },
  EMPHASIS = 'emphasis',
  NORMAL = 'normal',
  BLUR = 'blur',
  SELECT = 'select',
  STATES = [NORMAL, EMPHASIS, BLUR, SELECT],
  PATH_ITEM_STYLE = {
    normal: ['itemStyle'],
    emphasis: [EMPHASIS, 'itemStyle'],
    blur: [BLUR, 'itemStyle'],
    select: [SELECT, 'itemStyle']
  },
  PATH_LABEL = {
    normal: ['label'],
    emphasis: [EMPHASIS, 'label'],
    blur: [BLUR, 'label'],
    select: [SELECT, 'label']
  },
  GROUP_DIFF_PREFIX = 'e\0\0',
  attachedTxInfoTmp = { normal: {}, emphasis: {}, blur: {}, select: {} },
  LEGACY_TRANSFORM_PROPS = {
    position: ['x', 'y'],
    scale: ['scaleX', 'scaleY'],
    origin: ['originX', 'originY']
  },
  tmpTransformable = new Transformable(),
  prepareCustoms = {
    cartesian2d: cartesianPrepareCustom,
    geo: geoPrepareCustom,
    singleAxis: singlePrepareCustom,
    polar: polarPrepareCustom,
    calendar: calendarPrepareCustom
  },
  CustomSeriesModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.optionUpdated = function () {
        ;(this.currentZLevel = this.get('zlevel', !0)), (this.currentZ = this.get('z', !0))
      }),
      (t.prototype.getInitialData = function (e, t) {
        return createListFromArray(this.getSource(), this)
      }),
      (t.prototype.getDataParams = function (t, i, r) {
        var n = e.prototype.getDataParams.call(this, t, i)
        return r && (n.info = inner$c(r).info), n
      }),
      (t.type = 'series.custom'),
      (t.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar']),
      (t.defaultOption = {
        coordinateSystem: 'cartesian2d',
        zlevel: 0,
        z: 2,
        legendHoverLink: !0,
        clip: !1
      }),
      t
    )
  })(SeriesModel),
  CustomSeriesView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i, r) {
        var n = this._data,
          a = e.getData(),
          o = this.group,
          s = makeRenderItem(e, a, t, i)
        n || o.removeAll()
        var l = e.__transientTransitionOpt
        if (!l || (null != l.from && null != l.to)) {
          var h = new MorphPreparation(e, l),
            u = l ? 'multiple' : 'oneToOne'
          new DataDiffer(
            n ? n.getIndices() : [],
            a.getIndices(),
            createGetKey(n, u, l && l.from),
            createGetKey(a, u, l && l.to),
            null,
            u
          )
            .add(function (t) {
              createOrUpdateItem(i, null, t, s(t, r), e, o, a, null)
            })
            .remove(function (t) {
              doRemoveEl(n.getItemGraphicEl(t), e, o)
            })
            .update(function (t, l) {
              h.reset('oneToOne')
              var u = n.getItemGraphicEl(l)
              h.findAndAddFrom(u),
                h.hasFrom() && (removeElementDirectly(u, o), (u = null)),
                createOrUpdateItem(i, u, t, s(t, r), e, o, a, h),
                h.applyMorphing()
            })
            .updateManyToOne(function (t, l) {
              h.reset('manyToOne')
              for (var u = 0; u < l.length; u++) {
                var p = n.getItemGraphicEl(l[u])
                h.findAndAddFrom(p), removeElementDirectly(p, o)
              }
              createOrUpdateItem(i, null, t, s(t, r), e, o, a, h), h.applyMorphing()
            })
            .updateOneToMany(function (t, l) {
              h.reset('oneToMany')
              var u = t.length,
                p = n.getItemGraphicEl(l)
              h.findAndAddFrom(p), removeElementDirectly(p, o)
              for (var c = 0; c < u; c++) createOrUpdateItem(i, null, t[c], s(t[c], r), e, o, a, h)
              h.applyMorphing()
            })
            .execute()
        } else
          n &&
            n.each(function (t) {
              doRemoveEl(n.getItemGraphicEl(t), e, o)
            }),
            a.each(function (t) {
              createOrUpdateItem(i, null, t, s(t, r), e, o, a, null)
            })
        var p = e.get('clip', !0) ? createClipPath(e.coordinateSystem, !1, e) : null
        p ? o.setClipPath(p) : o.removeClipPath(), (this._data = a)
      }),
      (t.prototype.incrementalPrepareRender = function (e, t, i) {
        this.group.removeAll(), (this._data = null)
      }),
      (t.prototype.incrementalRender = function (e, t, i, r, n) {
        var a = t.getData(),
          o = makeRenderItem(t, a, i, r)
        function s(e) {
          e.isGroup || ((e.incremental = !0), (e.ensureState('emphasis').hoverLayer = !0))
        }
        for (var l = e.start; l < e.end; l++) {
          var h = createOrUpdateItem(null, null, l, o(l, n), t, this.group, a, null)
          h && h.traverse(s)
        }
      }),
      (t.prototype.filterForExposedEvent = function (e, t, i, r) {
        var n = t.element
        if (null == n || i.name === n) return !0
        for (; (i = i.__hostTarget || i.parent) && i !== this.group; ) if (i.name === n) return !0
        return !1
      }),
      (t.type = 'custom'),
      t
    )
  })(ChartView)
function createGetKey(e, t, i) {
  if (e) {
    if ('oneToOne' === t)
      return function (t, i) {
        return e.getId(i)
      }
    var r = e.getDimension(i),
      n = e.getDimensionInfo(r)
    if (!n) {
      throwError('')
    }
    var a = n.ordinalMeta
    return function (t, i) {
      var n = e.get(r, i)
      return a && (n = a.categories[n]), null == n || eqNaN(n) ? t + '' : '_ec_' + n
    }
  }
}
function createEl$1(e) {
  var t,
    i = e.type
  if ('path' === i) {
    var r = e.shape,
      n =
        null != r.width && null != r.height
          ? { x: r.x || 0, y: r.y || 0, width: r.width, height: r.height }
          : null,
      a = getPathData(r)
    ;(t = makePath(a, null, n, r.layout || 'center')), (inner$c(t).customPathData = a)
  } else if ('image' === i) (t = new ZRImage({})), (inner$c(t).customImagePath = e.style.image)
  else if ('text' === i) t = new ZRText({})
  else if ('group' === i) t = new Group$3()
  else {
    if ('compoundPath' === i) throw new Error('"compoundPath" is not supported yet.')
    var o = getShapeClass(i)
    if (!o) {
      throwError('')
    }
    t = new o()
  }
  return (
    (inner$c(t).customGraphicType = i),
    (t.name = e.name),
    (t.z2EmphasisLift = 1),
    (t.z2SelectLift = 1),
    t
  )
}
function updateElNormal(e, t, i, r, n, a, o, s, l, h) {
  var u = {},
    p = {},
    c = t.isGroup ? null : t
  !i && prepareShapeOrExtraTransitionFrom('shape', t, null, n, u, l),
    prepareShapeOrExtraAllPropsFinal('shape', n, p),
    !i && prepareShapeOrExtraTransitionFrom('extra', t, null, n, u, l),
    prepareShapeOrExtraAllPropsFinal('extra', n, p),
    !i && prepareTransformTransitionFrom(t, null, n, u, l),
    prepareTransformAllPropsFinal(n, p)
  var d = o && o.normal.cfg
  if ((d && t.setTextConfig(d), 'text' === t.type && a)) {
    var f = a
    hasOwn(f, 'textFill') && (f.fill = f.textFill),
      hasOwn(f, 'textStroke') && (f.stroke = f.textStroke)
  }
  if (a) {
    var m = void 0,
      g = isPath(t) ? a.decal : null
    e && g && ((g.dirty = !0), (m = createOrUpdatePatternFromDecal(g, e))), (a.__decalPattern = m)
  }
  return (
    !i && prepareStyleTransitionFrom(t, null, n, a, u, l),
    c && hasOwn(n, 'invisible') && (c.invisible = n.invisible),
    i || (applyPropsFinal(t, p, a), applyTransitionFrom(t, r, n, s, u, l)),
    hasOwn(n, 'silent') && (t.silent = n.silent),
    hasOwn(n, 'ignore') && (t.ignore = n.ignore),
    h || (hasOwn(n, 'info') && (inner$c(t).info = n.info)),
    a ? t.dirty() : t.markRedraw(),
    i ? p : null
  )
}
function applyPropsFinal(e, t, i) {
  var r = e.isGroup ? null : e
  if (r && i) {
    var n = i.__decalPattern,
      a = void 0
    n && ((a = i.decal), (i.decal = n)), r.useStyle(i), n && (i.decal = a)
    for (var o = r.animators, s = 0; s < o.length; s++) {
      var l = o[s]
      'style' === l.targetName && l.changeTarget(r.style)
    }
  }
  t && e.attr(t)
}
function applyTransitionFrom(e, t, i, r, n, a) {
  if (n) {
    var o = i.during
    inner$c(e).userDuring = o
    var s = {
      dataIndex: t,
      isFrom: !0,
      during: o ? bind$2(duringCall, { el: e, userDuring: o }) : null
    }
    a ? initProps(e, n, r, s) : updateProps$1(e, n, r, s)
  }
}
function prepareShapeOrExtraTransitionFrom(e, t, i, r, n, a) {
  var o = r[e]
  if (o) {
    var s,
      l = t[e],
      h = o.enterFrom
    if (a && h) {
      !s && (s = n[e] = {})
      for (var u = keys(h), p = 0; p < u.length; p++) {
        s[(_ = u[p])] = h[_]
      }
    }
    if (!a && l && (null == i || 'shape' !== e))
      if (o.transition) {
        !s && (s = n[e] = {})
        var c = normalizeToArray(o.transition)
        for (p = 0; p < c.length; p++) {
          var d = l[(_ = c[p])]
          s[_] = d
        }
      } else if (indexOf$1(r.transition, e) >= 0) {
        !s && (s = n[e] = {})
        var f = keys(l)
        for (p = 0; p < f.length; p++) {
          d = l[(_ = f[p])]
          isNonStyleTransitionEnabled(o[_], d) && (s[_] = d)
        }
      }
    var m = o.leaveTo
    if (m) {
      var g = getOrCreateLeaveToPropsFromEl(t),
        y = g[e] || (g[e] = {}),
        v = keys(m)
      for (p = 0; p < v.length; p++) {
        var _
        y[(_ = v[p])] = m[_]
      }
    }
  }
}
function prepareShapeOrExtraAllPropsFinal(e, t, i) {
  var r = t[e]
  if (r)
    for (var n = (i[e] = {}), a = keys(r), o = 0; o < a.length; o++) {
      var s = a[o]
      n[s] = cloneValue(r[s])
    }
}
function prepareTransformTransitionFrom(e, t, i, r, n) {
  var a = i.enterFrom
  if (n && a)
    for (var o = keys(a), s = 0; s < o.length; s++) {
      r[(f = o[s])] = a[f]
    }
  if (!n)
    if (t) {
      var l = calcOldElLocalTransformBasedOnNewElParent(t, e)
      setTransformPropToTransitionFrom(r, 'x', l),
        setTransformPropToTransitionFrom(r, 'y', l),
        setTransformPropToTransitionFrom(r, 'scaleX', l),
        setTransformPropToTransitionFrom(r, 'scaleY', l),
        setTransformPropToTransitionFrom(r, 'originX', l),
        setTransformPropToTransitionFrom(r, 'originY', l),
        setTransformPropToTransitionFrom(r, 'rotation', l)
    } else if (i.transition) {
      var h = normalizeToArray(i.transition)
      for (s = 0; s < h.length; s++) {
        if ('style' !== (f = h[s]) && 'shape' !== f && 'extra' !== f) {
          var u = e[f]
          r[f] = u
        }
      }
    } else setTransformPropToTransitionFrom(r, 'x', e), setTransformPropToTransitionFrom(r, 'y', e)
  var p = i.leaveTo
  if (p) {
    var c = getOrCreateLeaveToPropsFromEl(e),
      d = keys(p)
    for (s = 0; s < d.length; s++) {
      var f
      c[(f = d[s])] = p[f]
    }
  }
}
function prepareTransformAllPropsFinal(e, t) {
  setLagecyTransformProp(e, t, 'position'),
    setLagecyTransformProp(e, t, 'scale'),
    setLagecyTransformProp(e, t, 'origin'),
    setTransformProp(e, t, 'x'),
    setTransformProp(e, t, 'y'),
    setTransformProp(e, t, 'scaleX'),
    setTransformProp(e, t, 'scaleY'),
    setTransformProp(e, t, 'originX'),
    setTransformProp(e, t, 'originY'),
    setTransformProp(e, t, 'rotation')
}
function prepareStyleTransitionFrom(e, t, i, r, n, a) {
  if (r) {
    var o,
      s = (t || e).style,
      l = r.enterFrom
    if (a && l) {
      var h = keys(l)
      !o && (o = n.style = {})
      for (var u = 0; u < h.length; u++) {
        o[(x = h[u])] = l[x]
      }
    }
    if (!a && s)
      if (r.transition) {
        var p = normalizeToArray(r.transition)
        !o && (o = n.style = {})
        for (u = 0; u < p.length; u++) {
          var c = s[(x = p[u])]
          o[x] = c
        }
      } else if (e.getAnimationStyleProps && indexOf$1(i.transition, 'style') >= 0) {
        var d = e.getAnimationStyleProps(),
          f = d ? d.style : null
        if (f) {
          !o && (o = n.style = {})
          var m = keys(r)
          for (u = 0; u < m.length; u++) {
            if (f[(x = m[u])]) {
              c = s[x]
              o[x] = c
            }
          }
        }
      }
    var g = r.leaveTo
    if (g) {
      var y = keys(g),
        v = getOrCreateLeaveToPropsFromEl(e),
        _ = v.style || (v.style = {})
      for (u = 0; u < y.length; u++) {
        var x
        _[(x = y[u])] = g[x]
      }
    }
  }
}
function calcOldElLocalTransformBasedOnNewElParent(e, t) {
  if (!e || e === t || e.parent === t.parent) return e
  var i = tmpTransformable.transform || (tmpTransformable.transform = identity([])),
    r = e.getComputedTransform()
  r ? copy(i, r) : identity(i)
  var n = t.parent
  return (
    n && n.getComputedTransform(),
    (tmpTransformable.originX = e.originX),
    (tmpTransformable.originY = e.originY),
    (tmpTransformable.parent = n),
    tmpTransformable.decomposeTransform(),
    tmpTransformable
  )
}
function isNonStyleTransitionEnabled(e, t) {
  return isArrayLike(e) ? e !== t : null != e && isFinite(e)
}
function getOrCreateLeaveToPropsFromEl(e) {
  var t = inner$c(e)
  return t.leaveToProps || (t.leaveToProps = {})
}
var tmpDuringScope = {},
  customDuringAPI = {
    setTransform: function (e, t) {
      return (tmpDuringScope.el[e] = t), this
    },
    getTransform: function (e) {
      return tmpDuringScope.el[e]
    },
    setShape: function (e, t) {
      return (
        ((tmpDuringScope.el.shape || (tmpDuringScope.el.shape = {}))[e] = t),
        (tmpDuringScope.isShapeDirty = !0),
        this
      )
    },
    getShape: function (e) {
      var t = tmpDuringScope.el.shape
      if (t) return t[e]
    },
    setStyle: function (e, t) {
      var i = tmpDuringScope.el.style
      return i && ((i[e] = t), (tmpDuringScope.isStyleDirty = !0)), this
    },
    getStyle: function (e) {
      var t = tmpDuringScope.el.style
      if (t) return t[e]
    },
    setExtra: function (e, t) {
      return ((tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {}))[e] = t), this
    },
    getExtra: function (e) {
      var t = tmpDuringScope.el.extra
      if (t) return t[e]
    }
  }
function duringCall() {
  var e = this,
    t = e.el
  if (t) {
    var i = inner$c(t).userDuring,
      r = e.userDuring
    i === r
      ? ((tmpDuringScope.el = t),
        (tmpDuringScope.isShapeDirty = !1),
        (tmpDuringScope.isStyleDirty = !1),
        r(customDuringAPI),
        tmpDuringScope.isShapeDirty && t.dirtyShape && t.dirtyShape(),
        tmpDuringScope.isStyleDirty && t.dirtyStyle && t.dirtyStyle())
      : (e.el = e.userDuring = null)
  }
}
function updateElOnState(e, t, i, r, n, a, o) {
  var s = t.isGroup ? null : t,
    l = n && n[e].cfg
  if (s) {
    var h = s.ensureState(e)
    if (!1 === r) {
      var u = s.getState(e)
      u && (u.style = null)
    } else h.style = r || null
    l && (h.textConfig = l), setDefaultStateProxy(s)
  }
}
function updateZ(e, t, i, r) {
  if (!e.isGroup) {
    var n = e,
      a = i.currentZ,
      o = i.currentZLevel
    ;(n.z = a), (n.zlevel = o)
    var s = t.z2
    null != s && (n.z2 = s || 0)
    for (var l = 0; l < STATES.length; l++) updateZForEachState(n, t, STATES[l])
  }
}
function updateZForEachState(e, t, i) {
  var r = i === NORMAL,
    n = r ? t : retrieveStateOption(t, i),
    a = n ? n.z2 : null
  null != a && ((r ? e : e.ensureState(i)).z2 = a || 0)
}
function setLagecyTransformProp(e, t, i, r) {
  var n = e[i],
    a = LEGACY_TRANSFORM_PROPS[i]
  n && (r ? ((t[a[0]] = r[a[0]]), (t[a[1]] = r[a[1]])) : ((t[a[0]] = n[0]), (t[a[1]] = n[1])))
}
function setTransformProp(e, t, i, r) {
  null != e[i] && (t[i] = r ? r[i] : e[i])
}
function setTransformPropToTransitionFrom(e, t, i) {
  i && (e[t] = i[t])
}
function makeRenderItem(e, t, i, r) {
  var n = e.get('renderItem'),
    a = e.coordinateSystem,
    o = {}
  a && (o = a.prepareCustoms ? a.prepareCustoms(a) : prepareCustoms[a.type](a))
  for (
    var s,
      l,
      h = defaults$1(
        {
          getWidth: r.getWidth,
          getHeight: r.getHeight,
          getZr: r.getZr,
          getDevicePixelRatio: r.getDevicePixelRatio,
          value: function (e, i) {
            return null == i && (i = s), t.get(t.getDimension(e || 0), i)
          },
          style: function (i, r) {
            null == r && (r = s)
            var n = t.getItemVisual(r, 'style'),
              a = n && n.fill,
              o = n && n.opacity,
              l = v(r, NORMAL).getItemStyle()
            null != a && (l.fill = a), null != o && (l.opacity = o)
            var h = { inheritColor: isString(a) ? a : '#000' },
              u = _(r, NORMAL),
              p = createTextStyle(u, null, h, !1, !0)
            p.text = u.getShallow('show')
              ? retrieve2(e.getFormattedLabel(r, NORMAL), getDefaultLabel(t, r))
              : null
            var c = createTextConfig(u, h, !1)
            return (
              S(i, l),
              (l = convertToEC4StyleForCustomSerise(l, p, c)),
              i && x(l, i),
              (l.legacy = !0),
              l
            )
          },
          ordinalRawValue: function (e, i) {
            null == i && (i = s)
            var r = t.getDimensionInfo(e || 0)
            if (!r) return
            var n = t.get(r.name, i),
              a = r && r.ordinalMeta
            return a ? a.categories[n] : n
          },
          styleEmphasis: function (i, r) {
            null == r && (r = s)
            var n = v(r, EMPHASIS).getItemStyle(),
              a = _(r, EMPHASIS),
              o = createTextStyle(a, null, null, !0, !0)
            o.text = a.getShallow('show')
              ? retrieve3(
                  e.getFormattedLabel(r, EMPHASIS),
                  e.getFormattedLabel(r, NORMAL),
                  getDefaultLabel(t, r)
                )
              : null
            var l = createTextConfig(a, null, !0)
            return (
              S(i, n),
              (n = convertToEC4StyleForCustomSerise(n, o, l)),
              i && x(n, i),
              (n.legacy = !0),
              n
            )
          },
          visual: function (e, i) {
            if ((null == i && (i = s), hasOwn(STYLE_VISUAL_TYPE, e))) {
              var r = t.getItemVisual(i, 'style')
              return r ? r[STYLE_VISUAL_TYPE[e]] : null
            }
            if (hasOwn(NON_STYLE_VISUAL_PROPS, e)) return t.getItemVisual(i, e)
          },
          barLayout: function (e) {
            if ('cartesian2d' === a.type) {
              return getLayoutOnAxis(defaults$1({ axis: a.getBaseAxis() }, e))
            }
          },
          currentSeriesIndices: function () {
            return i.getCurrentSeriesIndices()
          },
          font: function (e) {
            return getFont(e, i)
          }
        },
        o.api || {}
      ),
      u = {
        context: {},
        seriesId: e.id,
        seriesName: e.name,
        seriesIndex: e.seriesIndex,
        coordSys: o.coordSys,
        dataInsideLength: t.count(),
        encode: wrapEncodeDef(e.getData())
      },
      p = {},
      c = {},
      d = {},
      f = {},
      m = 0;
    m < STATES.length;
    m++
  ) {
    var g = STATES[m]
    ;(d[g] = e.getModel(PATH_ITEM_STYLE[g])), (f[g] = e.getModel(PATH_LABEL[g]))
  }
  function y(e) {
    return e === s ? l || (l = t.getItemModel(e)) : t.getItemModel(e)
  }
  function v(e, i) {
    return t.hasItemOption
      ? e === s
        ? p[i] || (p[i] = y(e).getModel(PATH_ITEM_STYLE[i]))
        : y(e).getModel(PATH_ITEM_STYLE[i])
      : d[i]
  }
  function _(e, i) {
    return t.hasItemOption
      ? e === s
        ? c[i] || (c[i] = y(e).getModel(PATH_LABEL[i]))
        : y(e).getModel(PATH_LABEL[i])
      : f[i]
  }
  return function (e, i) {
    return (
      (s = e),
      (l = null),
      (p = {}),
      (c = {}),
      n &&
        n(
          defaults$1(
            { dataIndexInside: e, dataIndex: t.getRawIndex(e), actionType: i ? i.type : null },
            u
          ),
          h
        )
    )
  }
  function x(e, t) {
    for (var i in t) hasOwn(t, i) && (e[i] = t[i])
  }
  function S(e, t) {
    e &&
      (e.textFill && (t.textFill = e.textFill), e.textPosition && (t.textPosition = e.textPosition))
  }
}
function wrapEncodeDef(e) {
  var t = {}
  return (
    each$i(e.dimensions, function (i, r) {
      var n = e.getDimensionInfo(i)
      if (!n.isExtraCoord) {
        var a = n.coordDim
        ;(t[a] = t[a] || [])[n.coordDimIndex] = r
      }
    }),
    t
  )
}
function createOrUpdateItem(e, t, i, r, n, a, o, s) {
  if (r)
    return (
      (t = doCreateOrUpdateEl(e, t, i, r, n, a, !0, s)) && o.setItemGraphicEl(i, t),
      t && enableHoverEmphasis(t, r.focus, r.blurScope),
      t
    )
  removeElementDirectly(t, a)
}
function doCreateOrUpdateEl(e, t, i, r, n, a, o, s) {
  var l = -1
  t && doesElNeedRecreate(t, r) && ((l = a.childrenRef().indexOf(t)), (t = null))
  var h = !t
  t ? t.clearStates() : (t = createEl$1(r))
  var u = (inner$c(t).canMorph = r.morph && isPath(t)) && s && s.hasFrom(),
    p = h && !u
  ;(attachedTxInfoTmp.normal.cfg =
    attachedTxInfoTmp.normal.conOpt =
    attachedTxInfoTmp.emphasis.cfg =
    attachedTxInfoTmp.emphasis.conOpt =
    attachedTxInfoTmp.blur.cfg =
    attachedTxInfoTmp.blur.conOpt =
    attachedTxInfoTmp.select.cfg =
    attachedTxInfoTmp.select.conOpt =
      null),
    (attachedTxInfoTmp.isLegacy = !1),
    doCreateOrUpdateAttachedTx(t, i, r, n, p, attachedTxInfoTmp),
    doCreateOrUpdateClipPath(t, i, r, n, p)
  var c = updateElNormal(e, t, u, i, r, r.style, attachedTxInfoTmp, n, p, !1)
  u && s.addTo(t, r, i, c)
  for (var d = 0; d < STATES.length; d++) {
    var f = STATES[d]
    if (f !== NORMAL) {
      var m = retrieveStateOption(r, f)
      updateElOnState(f, t, m, retrieveStyleOptionOnState(r, m, f), attachedTxInfoTmp)
    }
  }
  return (
    updateZ(t, r, n),
    'group' === r.type && mergeChildren(e, t, i, r, n, s),
    l >= 0 ? a.replaceAt(t, l) : a.add(t),
    t
  )
}
function doesElNeedRecreate(e, t) {
  var i = inner$c(e),
    r = t.type,
    n = t.shape,
    a = t.style
  return (
    (null != r && r !== i.customGraphicType) ||
    ('path' === r && hasOwnPathData(n) && getPathData(n) !== i.customPathData) ||
    ('image' === r && hasOwn(a, 'image') && a.image !== i.customImagePath)
  )
}
function doCreateOrUpdateClipPath(e, t, i, r, n) {
  var a = i.clipPath
  if (!1 === a) e && e.getClipPath() && e.removeClipPath()
  else if (a) {
    var o = e.getClipPath()
    o && doesElNeedRecreate(o, a) && (o = null),
      o || ((o = createEl$1(a)), e.setClipPath(o)),
      updateElNormal(null, o, null, t, a, null, null, r, n, !1)
  }
}
function doCreateOrUpdateAttachedTx(e, t, i, r, n, a) {
  if (!e.isGroup) {
    processTxInfo(i, null, a), processTxInfo(i, EMPHASIS, a)
    var o = a.normal.conOpt,
      s = a.emphasis.conOpt,
      l = a.blur.conOpt,
      h = a.select.conOpt
    if (null != o || null != s || null != h || null != l) {
      var u = e.getTextContent()
      if (!1 === o) u && e.removeTextContent()
      else {
        ;(o = a.normal.conOpt = o || { type: 'text' }),
          u ? u.clearStates() : ((u = createEl$1(o)), e.setTextContent(u))
        var p = o && o.style
        updateElNormal(null, u, null, t, o, p, null, r, n, !0)
        for (var c = 0; c < STATES.length; c++) {
          var d = STATES[c]
          if (d !== NORMAL) {
            var f = a[d].conOpt
            updateElOnState(d, u, f, retrieveStyleOptionOnState(o, f, d), null)
          }
        }
        p ? u.dirty() : u.markRedraw()
      }
    }
  }
}
function processTxInfo(e, t, i) {
  var r = t ? retrieveStateOption(e, t) : e,
    n = t ? retrieveStyleOptionOnState(e, r, EMPHASIS) : e.style,
    a = e.type,
    o = r ? r.textConfig : null,
    s = e.textContent,
    l = s ? (t ? retrieveStateOption(s, t) : s) : null
  if (n && (i.isLegacy || isEC4CompatibleStyle(n, a, !!o, !!l))) {
    i.isLegacy = !0
    var h = convertFromEC4CompatibleStyle(n, a, !t)
    !o && h.textConfig && (o = h.textConfig), !l && h.textContent && (l = h.textContent)
  }
  if (!t && l) {
    var u = l
    !u.type && (u.type = 'text')
  }
  var p = t ? i[t] : i.normal
  ;(p.cfg = o), (p.conOpt = l)
}
function retrieveStateOption(e, t) {
  return t ? (e ? e[t] : null) : e
}
function retrieveStyleOptionOnState(e, t, i) {
  var r = t && t.style
  return null == r && i === EMPHASIS && e && (r = e.styleEmphasis), r
}
function mergeChildren(e, t, i, r, n, a) {
  var o = r.children,
    s = o ? o.length : 0,
    l = r.$mergeChildren,
    h = 'byName' === l || r.diffChildrenByName,
    u = !1 === l
  if (s || h || u)
    if (h)
      diffGroupChildren({
        api: e,
        oldChildren: t.children() || [],
        newChildren: o || [],
        dataIndex: i,
        seriesModel: n,
        group: t,
        morphPreparation: a
      })
    else {
      u && t.removeAll()
      for (var p = 0; p < s; p++) o[p] && doCreateOrUpdateEl(e, t.childAt(p), i, o[p], n, t, !1, a)
      for (var c = t.childCount() - 1; c >= p; c--) doRemoveEl(t.childAt(c), n, t)
    }
}
function diffGroupChildren(e) {
  new DataDiffer(e.oldChildren, e.newChildren, getKey, getKey, e)
    .add(processAddUpdate)
    .update(processAddUpdate)
    .remove(processRemove)
    .execute()
}
function getKey(e, t) {
  var i = e && e.name
  return null != i ? i : GROUP_DIFF_PREFIX + t
}
function processAddUpdate(e, t) {
  var i = this.context,
    r = null != e ? i.newChildren[e] : null,
    n = null != t ? i.oldChildren[t] : null
  doCreateOrUpdateEl(i.api, n, i.dataIndex, r, i.seriesModel, i.group, !1, i.morphPreparation)
}
function processRemove(e) {
  var t = this.context
  doRemoveEl(t.oldChildren[e], t.seriesModel, t.group)
}
function doRemoveEl(e, t, i) {
  if (e) {
    var r = inner$c(e).leaveToProps
    r
      ? updateProps$1(e, r, t, {
          cb: function () {
            i.remove(e)
          }
        })
      : i.remove(e)
  }
}
function getPathData(e) {
  return e && (e.pathData || e.d)
}
function hasOwnPathData(e) {
  return e && (hasOwn(e, 'pathData') || hasOwn(e, 'd'))
}
function isPath(e) {
  return e && e instanceof Path
}
function removeElementDirectly(e, t) {
  e && t.remove(e)
}
var MorphPreparation = (function () {
  function e(e, t) {
    ;(this._fromList = []),
      (this._toList = []),
      (this._toElOptionList = []),
      (this._allPropsFinalList = []),
      (this._toDataIndices = []),
      (this._morphConfigList = []),
      (this._seriesModel = e),
      (this._transOpt = t)
  }
  return (
    (e.prototype.hasFrom = function () {
      return !!this._fromList.length
    }),
    (e.prototype.findAndAddFrom = function (e) {
      if (e && (inner$c(e).canMorph && this._fromList.push(e), e.isGroup))
        for (var t = e.childrenRef(), i = 0; i < t.length; i++) this.findAndAddFrom(t[i])
    }),
    (e.prototype.addTo = function (e, t, i, r) {
      e &&
        (this._toList.push(e),
        this._toElOptionList.push(t),
        this._toDataIndices.push(i),
        this._allPropsFinalList.push(r))
    }),
    (e.prototype.applyMorphing = function () {
      var e = this._type,
        t = this._fromList,
        i = this._toList.length,
        r = t.length
      if (r && i)
        if ('oneToOne' === e) for (var n = 0; n < i; n++) this._oneToOneForSingleTo(n, n)
        else if ('manyToOne' === e)
          for (var a = Math.max(1, Math.floor(r / i)), o = ((n = 0), 0); n < i; n++, o += a) {
            var s = n + 1 >= i ? r - o : a
            this._manyToOneForSingleTo(n, o >= r ? null : o, s)
          }
        else if ('oneToMany' === e)
          for (var l = Math.max(1, Math.floor(i / r)), h = 0, u = 0; h < i; h += l, u++) {
            var p = h + l >= i ? i - h : l
            this._oneToManyForSingleFrom(h, p, u >= r ? null : u)
          }
    }),
    (e.prototype._oneToOneForSingleTo = function (e, t) {
      var i = this._toList[e],
        r = this._toElOptionList[e],
        n = this._toDataIndices[e],
        a = this._allPropsFinalList[e],
        o = this._fromList[t],
        s = this._getOrCreateMorphConfig(n),
        l = s.duration
      if (o && isCombiningPath(o)) {
        if ((applyPropsFinal(i, a, r.style), l)) {
          var h = combine([o], i, s, copyPropsWhenDivided)
          this._processResultIndividuals(h, e, null)
        }
      } else {
        var u = l && o && (o !== i || isInAnyMorphing(o)) ? o : null,
          p = {}
        prepareShapeOrExtraTransitionFrom('shape', i, u, r, p, !1),
          prepareShapeOrExtraTransitionFrom('extra', i, u, r, p, !1),
          prepareTransformTransitionFrom(i, u, r, p, !1),
          prepareStyleTransitionFrom(i, u, r, r.style, p, !1),
          applyPropsFinal(i, a, r.style),
          u && morphPath(u, i, s),
          applyTransitionFrom(i, n, r, this._seriesModel, p, !1)
      }
    }),
    (e.prototype._manyToOneForSingleTo = function (e, t, i) {
      var r = this._toList[e],
        n = this._toElOptionList[e]
      applyPropsFinal(r, this._allPropsFinalList[e], n.style)
      var a = this._getOrCreateMorphConfig(this._toDataIndices[e])
      if (a.duration && null != t) {
        for (var o = [], s = t; s < i; s++) o.push(this._fromList[s])
        var l = combine(o, r, a, copyPropsWhenDivided)
        this._processResultIndividuals(l, e, null)
      }
    }),
    (e.prototype._oneToManyForSingleFrom = function (e, t, i) {
      for (
        var r = null == i ? null : this._fromList[i], n = this._toList, a = [], o = e;
        o < t;
        o++
      ) {
        var s = n[o]
        applyPropsFinal(s, this._allPropsFinalList[o], this._toElOptionList[o].style), a.push(s)
      }
      var l = this._getOrCreateMorphConfig(this._toDataIndices[e])
      if (l.duration && r) {
        var h = separate(r, a, l, copyPropsWhenDivided)
        this._processResultIndividuals(h, e, t)
      }
    }),
    (e.prototype._processResultIndividuals = function (e, t, i) {
      for (var r = null != i, n = 0; n < e.count; n++) {
        var a = e.fromIndividuals[n],
          o = e.toIndividuals[n],
          s = t + (r ? n : 0),
          l = this._toElOptionList[s],
          h = this._toDataIndices[s],
          u = {}
        prepareTransformTransitionFrom(o, a, l, u, !1),
          prepareStyleTransitionFrom(o, a, l, l.style, u, !1),
          applyTransitionFrom(o, h, l, this._seriesModel, u, !1)
      }
    }),
    (e.prototype._getOrCreateMorphConfig = function (e) {
      var t,
        i,
        r,
        n = this._morphConfigList,
        a = n[e]
      if (a) return a
      var o = this._seriesModel,
        s = this._transOpt
      if (o.isAnimationEnabled()) {
        var l = void 0
        if (o && o.ecModel) {
          var h = o.ecModel.getUpdatePayload()
          l = h && h.animation
        }
        if (l) (t = l.duration || 0), (i = l.easing || 'cubicOut'), (r = l.delay || 0)
        else {
          i = o.get('animationEasingUpdate')
          var u = o.get('animationDelayUpdate')
          r = isFunction$1(u) ? u(e) : u
          var p = o.get('animationDurationUpdate')
          t = isFunction$1(p) ? p(e) : p
        }
      }
      return (
        (a = {
          duration: t || 0,
          delay: r,
          easing: i,
          dividingMethod: s ? s.dividingMethod : null
        }),
        (n[e] = a),
        a
      )
    }),
    (e.prototype.reset = function (e) {
      ;(this._type = e),
        (this._fromList.length =
          this._toList.length =
          this._toElOptionList.length =
          this._allPropsFinalList.length =
          this._toDataIndices.length =
            0)
    }),
    e
  )
})()
function copyPropsWhenDivided(e, t, i) {
  ;(t.style = i ? clone$3(e.style) : e.style), (t.zlevel = e.zlevel), (t.z = e.z), (t.z2 = e.z2)
}
function install$r(e) {
  e.registerChartView(CustomSeriesView), e.registerSeriesModel(CustomSeriesModel)
}
var inner$b = makeInner(),
  clone = clone$3,
  bind$1 = bind$2,
  BaseAxisPointer = (function () {
    function e() {
      ;(this._dragging = !1), (this.animationThreshold = 15)
    }
    return (
      (e.prototype.render = function (e, t, i, r) {
        var n = t.get('value'),
          a = t.get('status')
        if (
          ((this._axisModel = e),
          (this._axisPointerModel = t),
          (this._api = i),
          r || this._lastValue !== n || this._lastStatus !== a)
        ) {
          ;(this._lastValue = n), (this._lastStatus = a)
          var o = this._group,
            s = this._handle
          if (!a || 'hide' === a) return o && o.hide(), void (s && s.hide())
          o && o.show(), s && s.show()
          var l = {}
          this.makeElOption(l, n, e, t, i)
          var h = l.graphicKey
          h !== this._lastGraphicKey && this.clear(i), (this._lastGraphicKey = h)
          var u = (this._moveAnimation = this.determineAnimation(e, t))
          if (o) {
            var p = curry$1(updateProps, t, u)
            this.updatePointerEl(o, l, p), this.updateLabelEl(o, l, p, t)
          } else
            (o = this._group = new Group$3()),
              this.createPointerEl(o, l, e, t),
              this.createLabelEl(o, l, e, t),
              i.getZr().add(o)
          updateMandatoryProps(o, t, !0), this._renderHandle(n)
        }
      }),
      (e.prototype.remove = function (e) {
        this.clear(e)
      }),
      (e.prototype.dispose = function (e) {
        this.clear(e)
      }),
      (e.prototype.determineAnimation = function (e, t) {
        var i = t.get('animation'),
          r = e.axis,
          n = 'category' === r.type,
          a = t.get('snap')
        if (!a && !n) return !1
        if ('auto' === i || null == i) {
          var o = this.animationThreshold
          if (n && r.getBandWidth() > o) return !0
          if (a) {
            var s = getAxisInfo$1(e).seriesDataCount,
              l = r.getExtent()
            return Math.abs(l[0] - l[1]) / s > o
          }
          return !1
        }
        return !0 === i
      }),
      (e.prototype.makeElOption = function (e, t, i, r, n) {}),
      (e.prototype.createPointerEl = function (e, t, i, r) {
        var n = t.pointer
        if (n) {
          var a = (inner$b(e).pointerEl = new graphic[n.type](clone(t.pointer)))
          e.add(a)
        }
      }),
      (e.prototype.createLabelEl = function (e, t, i, r) {
        if (t.label) {
          var n = (inner$b(e).labelEl = new ZRText(clone(t.label)))
          e.add(n), updateLabelShowHide(n, r)
        }
      }),
      (e.prototype.updatePointerEl = function (e, t, i) {
        var r = inner$b(e).pointerEl
        r && t.pointer && (r.setStyle(t.pointer.style), i(r, { shape: t.pointer.shape }))
      }),
      (e.prototype.updateLabelEl = function (e, t, i, r) {
        var n = inner$b(e).labelEl
        n &&
          (n.setStyle(t.label.style),
          i(n, { x: t.label.x, y: t.label.y }),
          updateLabelShowHide(n, r))
      }),
      (e.prototype._renderHandle = function (e) {
        if (!this._dragging && this.updateHandleTransform) {
          var t,
            i = this._axisPointerModel,
            r = this._api.getZr(),
            n = this._handle,
            a = i.getModel('handle'),
            o = i.get('status')
          if (!a.get('show') || !o || 'hide' === o)
            return n && r.remove(n), void (this._handle = null)
          this._handle ||
            ((t = !0),
            (n = this._handle =
              createIcon(a.get('icon'), {
                cursor: 'move',
                draggable: !0,
                onmousemove: function (e) {
                  stop(e.event)
                },
                onmousedown: bind$1(this._onHandleDragMove, this, 0, 0),
                drift: bind$1(this._onHandleDragMove, this),
                ondragend: bind$1(this._onHandleDragEnd, this)
              })),
            r.add(n)),
            updateMandatoryProps(n, i, !1),
            n.setStyle(
              a.getItemStyle(null, [
                'color',
                'borderColor',
                'borderWidth',
                'opacity',
                'shadowColor',
                'shadowBlur',
                'shadowOffsetX',
                'shadowOffsetY'
              ])
            )
          var s = a.get('size')
          isArray$1(s) || (s = [s, s]),
            (n.scaleX = s[0] / 2),
            (n.scaleY = s[1] / 2),
            createOrUpdate(this, '_doDispatchAxisPointer', a.get('throttle') || 0, 'fixRate'),
            this._moveHandleToValue(e, t)
        }
      }),
      (e.prototype._moveHandleToValue = function (e, t) {
        updateProps(
          this._axisPointerModel,
          !t && this._moveAnimation,
          this._handle,
          getHandleTransProps(this.getHandleTransform(e, this._axisModel, this._axisPointerModel))
        )
      }),
      (e.prototype._onHandleDragMove = function (e, t) {
        var i = this._handle
        if (i) {
          this._dragging = !0
          var r = this.updateHandleTransform(
            getHandleTransProps(i),
            [e, t],
            this._axisModel,
            this._axisPointerModel
          )
          ;(this._payloadInfo = r),
            i.stopAnimation(),
            i.attr(getHandleTransProps(r)),
            (inner$b(i).lastProp = null),
            this._doDispatchAxisPointer()
        }
      }),
      (e.prototype._doDispatchAxisPointer = function () {
        if (this._handle) {
          var e = this._payloadInfo,
            t = this._axisModel
          this._api.dispatchAction({
            type: 'updateAxisPointer',
            x: e.cursorPoint[0],
            y: e.cursorPoint[1],
            tooltipOption: e.tooltipOption,
            axesInfo: [{ axisDim: t.axis.dim, axisIndex: t.componentIndex }]
          })
        }
      }),
      (e.prototype._onHandleDragEnd = function () {
        if (((this._dragging = !1), this._handle)) {
          var e = this._axisPointerModel.get('value')
          this._moveHandleToValue(e), this._api.dispatchAction({ type: 'hideTip' })
        }
      }),
      (e.prototype.clear = function (e) {
        ;(this._lastValue = null), (this._lastStatus = null)
        var t = e.getZr(),
          i = this._group,
          r = this._handle
        t &&
          i &&
          ((this._lastGraphicKey = null),
          i && t.remove(i),
          r && t.remove(r),
          (this._group = null),
          (this._handle = null),
          (this._payloadInfo = null))
      }),
      (e.prototype.doClear = function () {}),
      (e.prototype.buildLabel = function (e, t, i) {
        return { x: e[(i = i || 0)], y: e[1 - i], width: t[i], height: t[1 - i] }
      }),
      e
    )
  })()
function updateProps(e, t, i, r) {
  propsEqual(inner$b(i).lastProp, r) ||
    ((inner$b(i).lastProp = r), t ? updateProps$1(i, r, e) : (i.stopAnimation(), i.attr(r)))
}
function propsEqual(e, t) {
  if (isObject$7(e) && isObject$7(t)) {
    var i = !0
    return (
      each$i(t, function (t, r) {
        i = i && propsEqual(e[r], t)
      }),
      !!i
    )
  }
  return e === t
}
function updateLabelShowHide(e, t) {
  e[t.get(['label', 'show']) ? 'show' : 'hide']()
}
function getHandleTransProps(e) {
  return { x: e.x || 0, y: e.y || 0, rotation: e.rotation || 0 }
}
function updateMandatoryProps(e, t, i) {
  var r = t.get('z'),
    n = t.get('zlevel')
  e &&
    e.traverse(function (e) {
      'group' !== e.type && (null != r && (e.z = r), null != n && (e.zlevel = n), (e.silent = i))
    })
}
function buildElStyle(e) {
  var t,
    i = e.get('type'),
    r = e.getModel(i + 'Style')
  return (
    'line' === i
      ? ((t = r.getLineStyle()).fill = null)
      : 'shadow' === i && ((t = r.getAreaStyle()).stroke = null),
    t
  )
}
function buildLabelElOption(e, t, i, r, n) {
  var a = getValueLabel(i.get('value'), t.axis, t.ecModel, i.get('seriesDataIndices'), {
      precision: i.get(['label', 'precision']),
      formatter: i.get(['label', 'formatter'])
    }),
    o = i.getModel('label'),
    s = normalizeCssArray(o.get('padding') || 0),
    l = o.getFont(),
    h = getBoundingRect(a, l),
    u = n.position,
    p = h.width + s[1] + s[3],
    c = h.height + s[0] + s[2],
    d = n.align
  'right' === d && (u[0] -= p), 'center' === d && (u[0] -= p / 2)
  var f = n.verticalAlign
  'bottom' === f && (u[1] -= c), 'middle' === f && (u[1] -= c / 2), confineInContainer(u, p, c, r)
  var m = o.get('backgroundColor')
  ;(m && 'auto' !== m) || (m = t.get(['axisLine', 'lineStyle', 'color'])),
    (e.label = {
      x: u[0],
      y: u[1],
      style: createTextStyle(o, {
        text: a,
        font: l,
        fill: o.getTextColor(),
        padding: s,
        backgroundColor: m
      }),
      z2: 10
    })
}
function confineInContainer(e, t, i, r) {
  var n = r.getWidth(),
    a = r.getHeight()
  ;(e[0] = Math.min(e[0] + t, n) - t),
    (e[1] = Math.min(e[1] + i, a) - i),
    (e[0] = Math.max(e[0], 0)),
    (e[1] = Math.max(e[1], 0))
}
function getValueLabel(e, t, i, r, n) {
  e = t.scale.parse(e)
  var a = t.scale.getLabel({ value: e }, { precision: n.precision }),
    o = n.formatter
  if (o) {
    var s = {
      value: getAxisRawValue(t, { value: e }),
      axisDimension: t.dim,
      axisIndex: t.index,
      seriesData: []
    }
    each$i(r, function (e) {
      var t = i.getSeriesByIndex(e.seriesIndex),
        r = e.dataIndexInside,
        n = t && t.getDataParams(r)
      n && s.seriesData.push(n)
    }),
      isString(o) ? (a = o.replace('{value}', a)) : isFunction$1(o) && (a = o(s))
  }
  return a
}
function getTransformedPosition(e, t, i) {
  var r = create$1()
  return (
    rotate(r, r, i.rotation),
    translate$1(r, r, i.position),
    applyTransform(
      [e.dataToCoord(t), (i.labelOffset || 0) + (i.labelDirection || 1) * (i.labelMargin || 0)],
      r
    )
  )
}
function buildCartesianSingleLabelElOption(e, t, i, r, n, a) {
  var o = AxisBuilder.innerTextLayout(i.rotation, 0, i.labelDirection)
  ;(i.labelMargin = n.get(['label', 'margin'])),
    buildLabelElOption(t, r, n, a, {
      position: getTransformedPosition(r.axis, e, i),
      align: o.textAlign,
      verticalAlign: o.textVerticalAlign
    })
}
function makeLineShape(e, t, i) {
  return { x1: e[(i = i || 0)], y1: e[1 - i], x2: t[i], y2: t[1 - i] }
}
function makeRectShape(e, t, i) {
  return { x: e[(i = i || 0)], y: e[1 - i], width: t[i], height: t[1 - i] }
}
function makeSectorShape(e, t, i, r, n, a) {
  return { cx: e, cy: t, r0: i, r: r, startAngle: n, endAngle: a, clockwise: !0 }
}
var CartesianAxisPointer = (function (e) {
  function t() {
    return (null !== e && e.apply(this, arguments)) || this
  }
  return (
    __extends(t, e),
    (t.prototype.makeElOption = function (e, t, i, r, n) {
      var a = i.axis,
        o = a.grid,
        s = r.get('type'),
        l = getCartesian(o, a).getOtherAxis(a).getGlobalExtent(),
        h = a.toGlobalCoord(a.dataToCoord(t, !0))
      if (s && 'none' !== s) {
        var u = buildElStyle(r),
          p = pointerShapeBuilder$2[s](a, h, l)
        ;(p.style = u), (e.graphicKey = p.type), (e.pointer = p)
      }
      buildCartesianSingleLabelElOption(t, e, layout$2(o.model, i), i, r, n)
    }),
    (t.prototype.getHandleTransform = function (e, t, i) {
      var r = layout$2(t.axis.grid.model, t, { labelInside: !1 })
      r.labelMargin = i.get(['handle', 'margin'])
      var n = getTransformedPosition(t.axis, e, r)
      return { x: n[0], y: n[1], rotation: r.rotation + (r.labelDirection < 0 ? Math.PI : 0) }
    }),
    (t.prototype.updateHandleTransform = function (e, t, i, r) {
      var n = i.axis,
        a = n.grid,
        o = n.getGlobalExtent(!0),
        s = getCartesian(a, n).getOtherAxis(n).getGlobalExtent(),
        l = 'x' === n.dim ? 0 : 1,
        h = [e.x, e.y]
      ;(h[l] += t[l]), (h[l] = Math.min(o[1], h[l])), (h[l] = Math.max(o[0], h[l]))
      var u = (s[1] + s[0]) / 2,
        p = [u, u]
      p[l] = h[l]
      return {
        x: h[0],
        y: h[1],
        rotation: e.rotation,
        cursorPoint: p,
        tooltipOption: [{ verticalAlign: 'middle' }, { align: 'center' }][l]
      }
    }),
    t
  )
})(BaseAxisPointer)
function getCartesian(e, t) {
  var i = {}
  return (i[t.dim + 'AxisIndex'] = t.index), e.getCartesian(i)
}
var pointerShapeBuilder$2 = {
  line: function (e, t, i) {
    return {
      type: 'Line',
      subPixelOptimize: !0,
      shape: makeLineShape([t, i[0]], [t, i[1]], getAxisDimIndex(e))
    }
  },
  shadow: function (e, t, i) {
    var r = Math.max(1, e.getBandWidth()),
      n = i[1] - i[0]
    return { type: 'Rect', shape: makeRectShape([t - r / 2, i[0]], [r, n], getAxisDimIndex(e)) }
  }
}
function getAxisDimIndex(e) {
  return 'x' === e.dim ? 0 : 1
}
var AxisPointerModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.type = 'axisPointer'),
      (t.defaultOption = {
        show: 'auto',
        zlevel: 0,
        z: 50,
        type: 'line',
        snap: !1,
        triggerTooltip: !0,
        value: null,
        status: null,
        link: [],
        animation: null,
        animationDurationUpdate: 200,
        lineStyle: { color: '#B9BEC9', width: 1, type: 'dashed' },
        shadowStyle: { color: 'rgba(210,219,238,0.2)' },
        label: {
          show: !0,
          formatter: null,
          precision: 'auto',
          margin: 3,
          color: '#fff',
          padding: [5, 7, 5, 7],
          backgroundColor: 'auto',
          borderColor: null,
          borderWidth: 0,
          borderRadius: 3
        },
        handle: {
          show: !1,
          icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',
          size: 45,
          margin: 50,
          color: '#333',
          shadowBlur: 3,
          shadowColor: '#aaa',
          shadowOffsetX: 0,
          shadowOffsetY: 2,
          throttle: 40
        }
      }),
      t
    )
  })(ComponentModel),
  inner$a = makeInner(),
  each$a = each$i
function register(e, t, i) {
  if (!env.node) {
    var r = t.getZr()
    inner$a(r).records || (inner$a(r).records = {}),
      initGlobalListeners(r, t),
      ((inner$a(r).records[e] || (inner$a(r).records[e] = {})).handler = i)
  }
}
function initGlobalListeners(e, t) {
  function i(i, r) {
    e.on(i, function (i) {
      var n = makeDispatchAction$1(t)
      each$a(inner$a(e).records, function (e) {
        e && r(e, i, n.dispatchAction)
      }),
        dispatchTooltipFinally(n.pendings, t)
    })
  }
  inner$a(e).initialized ||
    ((inner$a(e).initialized = !0),
    i('click', curry$1(doEnter, 'click')),
    i('mousemove', curry$1(doEnter, 'mousemove')),
    i('globalout', onLeave))
}
function dispatchTooltipFinally(e, t) {
  var i,
    r = e.showTip.length,
    n = e.hideTip.length
  r ? (i = e.showTip[r - 1]) : n && (i = e.hideTip[n - 1]),
    i && ((i.dispatchAction = null), t.dispatchAction(i))
}
function onLeave(e, t, i) {
  e.handler('leave', null, i)
}
function doEnter(e, t, i, r) {
  t.handler(e, i, r)
}
function makeDispatchAction$1(e) {
  var t = { showTip: [], hideTip: [] },
    i = function (r) {
      var n = t[r.type]
      n ? n.push(r) : ((r.dispatchAction = i), e.dispatchAction(r))
    }
  return { dispatchAction: i, pendings: t }
}
function unregister(e, t) {
  if (!env.node) {
    var i = t.getZr()
    ;(inner$a(i).records || {})[e] && (inner$a(i).records[e] = null)
  }
}
var AxisPointerView = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), i
  }
  return (
    __extends(t, e),
    (t.prototype.render = function (e, t, i) {
      var r = t.getComponent('tooltip'),
        n = e.get('triggerOn') || (r && r.get('triggerOn')) || 'mousemove|click'
      register('axisPointer', i, function (e, t, i) {
        'none' !== n &&
          ('leave' === e || n.indexOf(e) >= 0) &&
          i({ type: 'updateAxisPointer', currTrigger: e, x: t && t.offsetX, y: t && t.offsetY })
      })
    }),
    (t.prototype.remove = function (e, t) {
      unregister('axisPointer', t)
    }),
    (t.prototype.dispose = function (e, t) {
      unregister('axisPointer', t)
    }),
    (t.type = 'axisPointer'),
    t
  )
})(ComponentView)
function findPointFromSeries(e, t) {
  var i,
    r = [],
    n = e.seriesIndex
  if (null == n || !(i = t.getSeriesByIndex(n))) return { point: [] }
  var a = i.getData(),
    o = queryDataIndex(a, e)
  if (null == o || o < 0 || isArray$1(o)) return { point: [] }
  var s = a.getItemGraphicEl(o),
    l = i.coordinateSystem
  if (i.getTooltipPosition) r = i.getTooltipPosition(o) || []
  else if (l && l.dataToPoint)
    if (e.isStacked) {
      var h = l.getBaseAxis(),
        u = l.getOtherAxis(h).dim,
        p = h.dim,
        c = 'x' === u || 'radius' === u ? 1 : 0,
        d = a.mapDimension(p),
        f = []
      ;(f[c] = a.get(d, o)),
        (f[1 - c] = a.get(a.getCalculationInfo('stackResultDimension'), o)),
        (r = l.dataToPoint(f) || [])
    } else
      r =
        l.dataToPoint(
          a.getValues(
            map$1(l.dimensions, function (e) {
              return a.mapDimension(e)
            }),
            o
          )
        ) || []
  else if (s) {
    var m = s.getBoundingRect().clone()
    m.applyTransform(s.transform), (r = [m.x + m.width / 2, m.y + m.height / 2])
  }
  return { point: r, el: s }
}
var inner$9 = makeInner()
function axisTrigger(e, t, i) {
  var r = e.currTrigger,
    n = [e.x, e.y],
    a = e,
    o = e.dispatchAction || bind$2(i.dispatchAction, i),
    s = t.getComponent('axisPointer').coordSysAxesInfo
  if (s) {
    illegalPoint(n) &&
      (n = findPointFromSeries({ seriesIndex: a.seriesIndex, dataIndex: a.dataIndex }, t).point)
    var l = illegalPoint(n),
      h = a.axesInfo,
      u = s.axesInfo,
      p = 'leave' === r || illegalPoint(n),
      c = {},
      d = {},
      f = { list: [], map: {} },
      m = { showPointer: curry$1(showPointer, d), showTooltip: curry$1(showTooltip, f) }
    each$i(s.coordSysMap, function (e, t) {
      var i = l || e.containPoint(n)
      each$i(s.coordSysAxesInfo[t], function (e, t) {
        var r = e.axis,
          a = findInputAxisInfo(h, e)
        if (!p && i && (!h || a)) {
          var o = a && a.value
          null != o || l || (o = r.pointToData(n)), null != o && processOnAxis(e, o, m, !1, c)
        }
      })
    })
    var g = {}
    return (
      each$i(u, function (e, t) {
        var i = e.linkGroup
        i &&
          !d[t] &&
          each$i(i.axesInfo, function (t, r) {
            var n = d[r]
            if (t !== e && n) {
              var a = n.value
              i.mapper &&
                (a = e.axis.scale.parse(i.mapper(a, makeMapperParam(t), makeMapperParam(e)))),
                (g[e.key] = a)
            }
          })
      }),
      each$i(g, function (e, t) {
        processOnAxis(u[t], e, m, !0, c)
      }),
      updateModelActually(d, u, c),
      dispatchTooltipActually(f, n, e, o),
      dispatchHighDownActually(u, o, i),
      c
    )
  }
}
function processOnAxis(e, t, i, r, n) {
  var a = e.axis
  if (!a.scale.isBlank() && a.containData(t))
    if (e.involveSeries) {
      var o = buildPayloadsBySeries(t, e),
        s = o.payloadBatch,
        l = o.snapToValue
      s[0] && null == n.seriesIndex && extend$3(n, s[0]),
        !r && e.snap && a.containData(l) && null != l && (t = l),
        i.showPointer(e, t, s),
        i.showTooltip(e, o, l)
    } else i.showPointer(e, t)
}
function buildPayloadsBySeries(e, t) {
  var i = t.axis,
    r = i.dim,
    n = e,
    a = [],
    o = Number.MAX_VALUE,
    s = -1
  return (
    each$i(t.seriesModels, function (t, l) {
      var h,
        u,
        p = t.getData().mapDimensionsAll(r)
      if (t.getAxisTooltipData) {
        var c = t.getAxisTooltipData(p, e, i)
        ;(u = c.dataIndices), (h = c.nestestValue)
      } else {
        if (!(u = t.getData().indicesOfNearest(p[0], e, 'category' === i.type ? 0.5 : null)).length)
          return
        h = t.getData().get(p[0], u[0])
      }
      if (null != h && isFinite(h)) {
        var d = e - h,
          f = Math.abs(d)
        f <= o &&
          ((f < o || (d >= 0 && s < 0)) && ((o = f), (s = d), (n = h), (a.length = 0)),
          each$i(u, function (e) {
            a.push({
              seriesIndex: t.seriesIndex,
              dataIndexInside: e,
              dataIndex: t.getData().getRawIndex(e)
            })
          }))
      }
    }),
    { payloadBatch: a, snapToValue: n }
  )
}
function showPointer(e, t, i, r) {
  e[t.key] = { value: i, payloadBatch: r }
}
function showTooltip(e, t, i, r) {
  var n = i.payloadBatch,
    a = t.axis,
    o = a.model,
    s = t.axisPointerModel
  if (t.triggerTooltip && n.length) {
    var l = t.coordSys.model,
      h = makeKey(l),
      u = e.map[h]
    u ||
      ((u = e.map[h] =
        {
          coordSysId: l.id,
          coordSysIndex: l.componentIndex,
          coordSysType: l.type,
          coordSysMainType: l.mainType,
          dataByAxis: []
        }),
      e.list.push(u)),
      u.dataByAxis.push({
        axisDim: a.dim,
        axisIndex: o.componentIndex,
        axisType: o.type,
        axisId: o.id,
        value: r,
        valueLabelOpt: {
          precision: s.get(['label', 'precision']),
          formatter: s.get(['label', 'formatter'])
        },
        seriesDataIndices: n.slice()
      })
  }
}
function updateModelActually(e, t, i) {
  var r = (i.axesInfo = [])
  each$i(t, function (t, i) {
    var n = t.axisPointerModel.option,
      a = e[i]
    a
      ? (!t.useHandle && (n.status = 'show'),
        (n.value = a.value),
        (n.seriesDataIndices = (a.payloadBatch || []).slice()))
      : !t.useHandle && (n.status = 'hide'),
      'show' === n.status &&
        r.push({ axisDim: t.axis.dim, axisIndex: t.axis.model.componentIndex, value: n.value })
  })
}
function dispatchTooltipActually(e, t, i, r) {
  if (!illegalPoint(t) && e.list.length) {
    var n = ((e.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {}
    r({
      type: 'showTip',
      escapeConnect: !0,
      x: t[0],
      y: t[1],
      tooltipOption: i.tooltipOption,
      position: i.position,
      dataIndexInside: n.dataIndexInside,
      dataIndex: n.dataIndex,
      seriesIndex: n.seriesIndex,
      dataByCoordSys: e.list
    })
  } else r({ type: 'hideTip' })
}
function dispatchHighDownActually(e, t, i) {
  var r = i.getZr(),
    n = 'axisPointerLastHighlights',
    a = inner$9(r)[n] || {},
    o = (inner$9(r)[n] = {})
  each$i(e, function (e, t) {
    var i = e.axisPointerModel.option
    'show' === i.status &&
      each$i(i.seriesDataIndices, function (e) {
        var t = e.seriesIndex + ' | ' + e.dataIndex
        o[t] = e
      })
  })
  var s = [],
    l = []
  each$i(a, function (e, t) {
    !o[t] && l.push(e)
  }),
    each$i(o, function (e, t) {
      !a[t] && s.push(e)
    }),
    l.length && i.dispatchAction({ type: 'downplay', escapeConnect: !0, notBlur: !0, batch: l }),
    s.length && i.dispatchAction({ type: 'highlight', escapeConnect: !0, notBlur: !0, batch: s })
}
function findInputAxisInfo(e, t) {
  for (var i = 0; i < (e || []).length; i++) {
    var r = e[i]
    if (t.axis.dim === r.axisDim && t.axis.model.componentIndex === r.axisIndex) return r
  }
}
function makeMapperParam(e) {
  var t = e.axis.model,
    i = {},
    r = (i.axisDim = e.axis.dim)
  return (
    (i.axisIndex = i[r + 'AxisIndex'] = t.componentIndex),
    (i.axisName = i[r + 'AxisName'] = t.name),
    (i.axisId = i[r + 'AxisId'] = t.id),
    i
  )
}
function illegalPoint(e) {
  return !e || null == e[0] || isNaN(e[0]) || null == e[1] || isNaN(e[1])
}
function install$q(e) {
  AxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer),
    e.registerComponentModel(AxisPointerModel),
    e.registerComponentView(AxisPointerView),
    e.registerPreprocessor(function (e) {
      if (e) {
        ;(!e.axisPointer || 0 === e.axisPointer.length) && (e.axisPointer = {})
        var t = e.axisPointer.link
        t && !isArray$1(t) && (e.axisPointer.link = [t])
      }
    }),
    e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, function (e, t) {
      e.getComponent('axisPointer').coordSysAxesInfo = collect(e, t)
    }),
    e.registerAction(
      { type: 'updateAxisPointer', event: 'updateAxisPointer', update: ':updateAxisPointer' },
      axisTrigger
    )
}
function install$p(e) {
  use(install$N), use(install$q)
}
var PolarAxisPointer = (function (e) {
  function t() {
    return (null !== e && e.apply(this, arguments)) || this
  }
  return (
    __extends(t, e),
    (t.prototype.makeElOption = function (e, t, i, r, n) {
      var a = i.axis
      'angle' === a.dim && (this.animationThreshold = Math.PI / 18)
      var o = a.polar,
        s = o.getOtherAxis(a).getExtent(),
        l = a.dataToCoord(t),
        h = r.get('type')
      if (h && 'none' !== h) {
        var u = buildElStyle(r),
          p = pointerShapeBuilder$1[h](a, o, l, s)
        ;(p.style = u), (e.graphicKey = p.type), (e.pointer = p)
      }
      var c = r.get(['label', 'margin'])
      buildLabelElOption(e, i, r, n, getLabelPosition(t, i, r, o, c))
    }),
    t
  )
})(BaseAxisPointer)
function getLabelPosition(e, t, i, r, n) {
  var a = t.axis,
    o = a.dataToCoord(e),
    s = r.getAngleAxis().getExtent()[0]
  s = (s / 180) * Math.PI
  var l,
    h,
    u,
    p = r.getRadiusAxis().getExtent()
  if ('radius' === a.dim) {
    var c = create$1()
    rotate(c, c, s), translate$1(c, c, [r.cx, r.cy]), (l = applyTransform([o, -n], c))
    var d = t.getModel('axisLabel').get('rotate') || 0,
      f = AxisBuilder.innerTextLayout(s, (d * Math.PI) / 180, -1)
    ;(h = f.textAlign), (u = f.textVerticalAlign)
  } else {
    var m = p[1]
    l = r.coordToPoint([m + n, o])
    var g = r.cx,
      y = r.cy
    ;(h = Math.abs(l[0] - g) / m < 0.3 ? 'center' : l[0] > g ? 'left' : 'right'),
      (u = Math.abs(l[1] - y) / m < 0.3 ? 'middle' : l[1] > y ? 'top' : 'bottom')
  }
  return { position: l, align: h, verticalAlign: u }
}
var pointerShapeBuilder$1 = {
    line: function (e, t, i, r) {
      return 'angle' === e.dim
        ? {
            type: 'Line',
            shape: makeLineShape(t.coordToPoint([r[0], i]), t.coordToPoint([r[1], i]))
          }
        : { type: 'Circle', shape: { cx: t.cx, cy: t.cy, r: i } }
    },
    shadow: function (e, t, i, r) {
      var n = Math.max(1, e.getBandWidth()),
        a = Math.PI / 180
      return 'angle' === e.dim
        ? {
            type: 'Sector',
            shape: makeSectorShape(t.cx, t.cy, r[0], r[1], (-i - n / 2) * a, (n / 2 - i) * a)
          }
        : {
            type: 'Sector',
            shape: makeSectorShape(t.cx, t.cy, i - n / 2, i + n / 2, 0, 2 * Math.PI)
          }
    }
  },
  PolarModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.findAxisModel = function (e) {
        var t
        return (
          this.ecModel.eachComponent(
            e,
            function (e) {
              e.getCoordSysModel() === this && (t = e)
            },
            this
          ),
          t
        )
      }),
      (t.type = 'polar'),
      (t.dependencies = ['radiusAxis', 'angleAxis']),
      (t.defaultOption = { zlevel: 0, z: 0, center: ['50%', '50%'], radius: '80%' }),
      t
    )
  })(ComponentModel),
  PolarAxisModel = (function (e) {
    function t() {
      return (null !== e && e.apply(this, arguments)) || this
    }
    return (
      __extends(t, e),
      (t.prototype.getCoordSysModel = function () {
        return this.getReferringComponents('polar', SINGLE_REFERRING).models[0]
      }),
      (t.type = 'polarAxis'),
      t
    )
  })(ComponentModel)
mixin(PolarAxisModel, AxisModelCommonMixin)
var AngleAxisModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return __extends(t, e), (t.type = 'angleAxis'), t
  })(PolarAxisModel),
  RadiusAxisModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return __extends(t, e), (t.type = 'radiusAxis'), t
  })(PolarAxisModel),
  RadiusAxis = (function (e) {
    function t(t, i) {
      return e.call(this, 'radius', t, i) || this
    }
    return (
      __extends(t, e),
      (t.prototype.pointToData = function (e, t) {
        return this.polar.pointToData(e, t)['radius' === this.dim ? 0 : 1]
      }),
      t
    )
  })(Axis)
;(RadiusAxis.prototype.dataToRadius = Axis.prototype.dataToCoord),
  (RadiusAxis.prototype.radiusToData = Axis.prototype.coordToData)
var inner$8 = makeInner(),
  AngleAxis = (function (e) {
    function t(t, i) {
      return e.call(this, 'angle', t, i || [0, 360]) || this
    }
    return (
      __extends(t, e),
      (t.prototype.pointToData = function (e, t) {
        return this.polar.pointToData(e, t)['radius' === this.dim ? 0 : 1]
      }),
      (t.prototype.calculateCategoryInterval = function () {
        var e = this,
          t = e.getLabelModel(),
          i = e.scale,
          r = i.getExtent(),
          n = i.count()
        if (r[1] - r[0] < 1) return 0
        var a = r[0],
          o = e.dataToCoord(a + 1) - e.dataToCoord(a),
          s = Math.abs(o),
          l = getBoundingRect(null == a ? '' : a + '', t.getFont(), 'center', 'top'),
          h = Math.max(l.height, 7) / s
        isNaN(h) && (h = 1 / 0)
        var u = Math.max(0, Math.floor(h)),
          p = inner$8(e.model),
          c = p.lastAutoInterval,
          d = p.lastTickCount
        return (
          null != c && null != d && Math.abs(c - u) <= 1 && Math.abs(d - n) <= 1 && c > u
            ? (u = c)
            : ((p.lastTickCount = n), (p.lastAutoInterval = u)),
          u
        )
      }),
      t
    )
  })(Axis)
;(AngleAxis.prototype.dataToAngle = Axis.prototype.dataToCoord),
  (AngleAxis.prototype.angleToData = Axis.prototype.coordToData)
var Polar = (function () {
  function e(e) {
    ;(this.dimensions = ['radius', 'angle']),
      (this.type = 'polar'),
      (this.cx = 0),
      (this.cy = 0),
      (this._radiusAxis = new RadiusAxis()),
      (this._angleAxis = new AngleAxis()),
      (this.axisPointerEnabled = !0),
      (this.name = e || ''),
      (this._radiusAxis.polar = this._angleAxis.polar = this)
  }
  return (
    (e.prototype.containPoint = function (e) {
      var t = this.pointToCoord(e)
      return this._radiusAxis.contain(t[0]) && this._angleAxis.contain(t[1])
    }),
    (e.prototype.containData = function (e) {
      return this._radiusAxis.containData(e[0]) && this._angleAxis.containData(e[1])
    }),
    (e.prototype.getAxis = function (e) {
      return this['_' + e + 'Axis']
    }),
    (e.prototype.getAxes = function () {
      return [this._radiusAxis, this._angleAxis]
    }),
    (e.prototype.getAxesByScale = function (e) {
      var t = [],
        i = this._angleAxis,
        r = this._radiusAxis
      return i.scale.type === e && t.push(i), r.scale.type === e && t.push(r), t
    }),
    (e.prototype.getAngleAxis = function () {
      return this._angleAxis
    }),
    (e.prototype.getRadiusAxis = function () {
      return this._radiusAxis
    }),
    (e.prototype.getOtherAxis = function (e) {
      var t = this._angleAxis
      return e === t ? this._radiusAxis : t
    }),
    (e.prototype.getBaseAxis = function () {
      return (
        this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAngleAxis()
      )
    }),
    (e.prototype.getTooltipAxes = function (e) {
      var t = null != e && 'auto' !== e ? this.getAxis(e) : this.getBaseAxis()
      return { baseAxes: [t], otherAxes: [this.getOtherAxis(t)] }
    }),
    (e.prototype.dataToPoint = function (e, t) {
      return this.coordToPoint([
        this._radiusAxis.dataToRadius(e[0], t),
        this._angleAxis.dataToAngle(e[1], t)
      ])
    }),
    (e.prototype.pointToData = function (e, t) {
      var i = this.pointToCoord(e)
      return [this._radiusAxis.radiusToData(i[0], t), this._angleAxis.angleToData(i[1], t)]
    }),
    (e.prototype.pointToCoord = function (e) {
      var t = e[0] - this.cx,
        i = e[1] - this.cy,
        r = this.getAngleAxis(),
        n = r.getExtent(),
        a = Math.min(n[0], n[1]),
        o = Math.max(n[0], n[1])
      r.inverse ? (a = o - 360) : (o = a + 360)
      var s = Math.sqrt(t * t + i * i)
      ;(t /= s), (i /= s)
      for (var l = (Math.atan2(-i, t) / Math.PI) * 180, h = l < a ? 1 : -1; l < a || l > o; )
        l += 360 * h
      return [s, l]
    }),
    (e.prototype.coordToPoint = function (e) {
      var t = e[0],
        i = (e[1] / 180) * Math.PI
      return [Math.cos(i) * t + this.cx, -Math.sin(i) * t + this.cy]
    }),
    (e.prototype.getArea = function () {
      var e = this.getAngleAxis(),
        t = this.getRadiusAxis().getExtent().slice()
      t[0] > t[1] && t.reverse()
      var i = e.getExtent(),
        r = Math.PI / 180
      return {
        cx: this.cx,
        cy: this.cy,
        r0: t[0],
        r: t[1],
        startAngle: -i[0] * r,
        endAngle: -i[1] * r,
        clockwise: e.inverse,
        contain: function (e, t) {
          var i = e - this.cx,
            r = t - this.cy,
            n = i * i + r * r,
            a = this.r,
            o = this.r0
          return n <= a * a && n >= o * o
        }
      }
    }),
    (e.prototype.convertToPixel = function (e, t, i) {
      return getCoordSys$2(t) === this ? this.dataToPoint(i) : null
    }),
    (e.prototype.convertFromPixel = function (e, t, i) {
      return getCoordSys$2(t) === this ? this.pointToData(i) : null
    }),
    e
  )
})()
function getCoordSys$2(e) {
  var t = e.seriesModel,
    i = e.polarModel
  return (i && i.coordinateSystem) || (t && t.coordinateSystem)
}
function resizePolar(e, t, i) {
  var r = t.get('center'),
    n = i.getWidth(),
    a = i.getHeight()
  ;(e.cx = parsePercent$1(r[0], n)), (e.cy = parsePercent$1(r[1], a))
  var o = e.getRadiusAxis(),
    s = Math.min(n, a) / 2,
    l = t.get('radius')
  null == l ? (l = [0, '100%']) : isArray$1(l) || (l = [0, l])
  var h = [parsePercent$1(l[0], s), parsePercent$1(l[1], s)]
  o.inverse ? o.setExtent(h[1], h[0]) : o.setExtent(h[0], h[1])
}
function updatePolarScale(e, t) {
  var i = this,
    r = i.getAngleAxis(),
    n = i.getRadiusAxis()
  if (
    (r.scale.setExtent(1 / 0, -1 / 0),
    n.scale.setExtent(1 / 0, -1 / 0),
    e.eachSeries(function (e) {
      if (e.coordinateSystem === i) {
        var t = e.getData()
        each$i(getDataDimensionsOnAxis(t, 'radius'), function (e) {
          n.scale.unionExtentFromData(t, e)
        }),
          each$i(getDataDimensionsOnAxis(t, 'angle'), function (e) {
            r.scale.unionExtentFromData(t, e)
          })
      }
    }),
    niceScaleExtent(r.scale, r.model),
    niceScaleExtent(n.scale, n.model),
    'category' === r.type && !r.onBand)
  ) {
    var a = r.getExtent(),
      o = 360 / r.scale.count()
    r.inverse ? (a[1] += o) : (a[1] -= o), r.setExtent(a[0], a[1])
  }
}
function isAngleAxisModel(e) {
  return 'angleAxis' === e.mainType
}
function setAxis(e, t) {
  if (
    ((e.type = t.get('type')),
    (e.scale = createScaleByModel$1(t)),
    (e.onBand = t.get('boundaryGap') && 'category' === e.type),
    (e.inverse = t.get('inverse')),
    isAngleAxisModel(t))
  ) {
    e.inverse = e.inverse !== t.get('clockwise')
    var i = t.get('startAngle')
    e.setExtent(i, i + (e.inverse ? -360 : 360))
  }
  ;(t.axis = e), (e.model = t)
}
var polarCreator = {
    dimensions: Polar.prototype.dimensions,
    create: function (e, t) {
      var i = []
      return (
        e.eachComponent('polar', function (e, r) {
          var n = new Polar(r + '')
          n.update = updatePolarScale
          var a = n.getRadiusAxis(),
            o = n.getAngleAxis(),
            s = e.findAxisModel('radiusAxis'),
            l = e.findAxisModel('angleAxis')
          setAxis(a, s),
            setAxis(o, l),
            resizePolar(n, e, t),
            i.push(n),
            (e.coordinateSystem = n),
            (n.model = e)
        }),
        e.eachSeries(function (e) {
          if ('polar' === e.get('coordinateSystem')) {
            var t = e.getReferringComponents('polar', SINGLE_REFERRING).models[0]
            e.coordinateSystem = t.coordinateSystem
          }
        }),
        i
      )
    }
  },
  elementList = [
    'axisLine',
    'axisLabel',
    'axisTick',
    'minorTick',
    'splitLine',
    'minorSplitLine',
    'splitArea'
  ]
function getAxisLineShape(e, t, i) {
  t[1] > t[0] && (t = t.slice().reverse())
  var r = e.coordToPoint([t[0], i]),
    n = e.coordToPoint([t[1], i])
  return { x1: r[0], y1: r[1], x2: n[0], y2: n[1] }
}
function getRadiusIdx(e) {
  return e.getRadiusAxis().inverse ? 0 : 1
}
function fixAngleOverlap(e) {
  var t = e[0],
    i = e[e.length - 1]
  t && i && Math.abs(Math.abs(t.coord - i.coord) - 360) < 1e-4 && e.pop()
}
var AngleAxisView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.axisPointerClass = 'PolarAxisPointer'), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t) {
        if ((this.group.removeAll(), e.get('show'))) {
          var i = e.axis,
            r = i.polar,
            n = r.getRadiusAxis().getExtent(),
            a = i.getTicksCoords(),
            o = i.getMinorTicksCoords(),
            s = map$1(i.getViewLabels(), function (e) {
              e = clone$3(e)
              var t = i.scale,
                r = 'ordinal' === t.type ? t.getRawOrdinalNumber(e.tickValue) : e.tickValue
              return (e.coord = i.dataToCoord(r)), e
            })
          fixAngleOverlap(s),
            fixAngleOverlap(a),
            each$i(
              elementList,
              function (t) {
                !e.get([t, 'show']) ||
                  (i.scale.isBlank() && 'axisLine' !== t) ||
                  angelAxisElementsBuilders[t](this.group, e, r, a, o, n, s)
              },
              this
            )
        }
      }),
      (t.type = 'angleAxis'),
      t
    )
  })(AxisView),
  angelAxisElementsBuilders = {
    axisLine: function (e, t, i, r, n, a) {
      var o,
        s = t.getModel(['axisLine', 'lineStyle']),
        l = getRadiusIdx(i),
        h = l ? 0 : 1
      ;((o =
        0 === a[h]
          ? new Circle({
              shape: { cx: i.cx, cy: i.cy, r: a[l] },
              style: s.getLineStyle(),
              z2: 1,
              silent: !0
            })
          : new Ring({
              shape: { cx: i.cx, cy: i.cy, r: a[l], r0: a[h] },
              style: s.getLineStyle(),
              z2: 1,
              silent: !0
            })).style.fill = null),
        e.add(o)
    },
    axisTick: function (e, t, i, r, n, a) {
      var o = t.getModel('axisTick'),
        s = (o.get('inside') ? -1 : 1) * o.get('length'),
        l = a[getRadiusIdx(i)],
        h = map$1(r, function (e) {
          return new Line$1({ shape: getAxisLineShape(i, [l, l + s], e.coord) })
        })
      e.add(
        mergePath(h, {
          style: defaults$1(o.getModel('lineStyle').getLineStyle(), {
            stroke: t.get(['axisLine', 'lineStyle', 'color'])
          })
        })
      )
    },
    minorTick: function (e, t, i, r, n, a) {
      if (n.length) {
        for (
          var o = t.getModel('axisTick'),
            s = t.getModel('minorTick'),
            l = (o.get('inside') ? -1 : 1) * s.get('length'),
            h = a[getRadiusIdx(i)],
            u = [],
            p = 0;
          p < n.length;
          p++
        )
          for (var c = 0; c < n[p].length; c++)
            u.push(new Line$1({ shape: getAxisLineShape(i, [h, h + l], n[p][c].coord) }))
        e.add(
          mergePath(u, {
            style: defaults$1(
              s.getModel('lineStyle').getLineStyle(),
              defaults$1(o.getLineStyle(), { stroke: t.get(['axisLine', 'lineStyle', 'color']) })
            )
          })
        )
      }
    },
    axisLabel: function (e, t, i, r, n, a, o) {
      var s = t.getCategories(!0),
        l = t.getModel('axisLabel'),
        h = l.get('margin'),
        u = t.get('triggerEvent')
      each$i(
        o,
        function (r, n) {
          var o = l,
            p = r.tickValue,
            c = a[getRadiusIdx(i)],
            d = i.coordToPoint([c + h, r.coord]),
            f = i.cx,
            m = i.cy,
            g = Math.abs(d[0] - f) / c < 0.3 ? 'center' : d[0] > f ? 'left' : 'right',
            y = Math.abs(d[1] - m) / c < 0.3 ? 'middle' : d[1] > m ? 'top' : 'bottom'
          if (s && s[p]) {
            var v = s[p]
            isObject$7(v) && v.textStyle && (o = new Model(v.textStyle, l, l.ecModel))
          }
          var _ = new ZRText({
            silent: AxisBuilder.isLabelSilent(t),
            style: createTextStyle(o, {
              x: d[0],
              y: d[1],
              fill: o.getTextColor() || t.get(['axisLine', 'lineStyle', 'color']),
              text: r.formattedLabel,
              align: g,
              verticalAlign: y
            })
          })
          if ((e.add(_), u)) {
            var x = AxisBuilder.makeAxisEventDataBase(t)
            ;(x.targetType = 'axisLabel'), (x.value = r.rawLabel), (getECData(_).eventData = x)
          }
        },
        this
      )
    },
    splitLine: function (e, t, i, r, n, a) {
      var o = t.getModel('splitLine').getModel('lineStyle'),
        s = o.get('color'),
        l = 0
      s = s instanceof Array ? s : [s]
      for (var h = [], u = 0; u < r.length; u++) {
        var p = l++ % s.length
        ;(h[p] = h[p] || []), h[p].push(new Line$1({ shape: getAxisLineShape(i, a, r[u].coord) }))
      }
      for (u = 0; u < h.length; u++)
        e.add(
          mergePath(h[u], {
            style: defaults$1({ stroke: s[u % s.length] }, o.getLineStyle()),
            silent: !0,
            z: t.get('z')
          })
        )
    },
    minorSplitLine: function (e, t, i, r, n, a) {
      if (n.length) {
        for (
          var o = t.getModel('minorSplitLine').getModel('lineStyle'), s = [], l = 0;
          l < n.length;
          l++
        )
          for (var h = 0; h < n[l].length; h++)
            s.push(new Line$1({ shape: getAxisLineShape(i, a, n[l][h].coord) }))
        e.add(mergePath(s, { style: o.getLineStyle(), silent: !0, z: t.get('z') }))
      }
    },
    splitArea: function (e, t, i, r, n, a) {
      if (r.length) {
        var o = t.getModel('splitArea').getModel('areaStyle'),
          s = o.get('color'),
          l = 0
        s = s instanceof Array ? s : [s]
        for (
          var h = [],
            u = Math.PI / 180,
            p = -r[0].coord * u,
            c = Math.min(a[0], a[1]),
            d = Math.max(a[0], a[1]),
            f = t.get('clockwise'),
            m = 1,
            g = r.length;
          m <= g;
          m++
        ) {
          var y = m === g ? r[0].coord : r[m].coord,
            v = l++ % s.length
          ;(h[v] = h[v] || []),
            h[v].push(
              new Sector({
                shape: {
                  cx: i.cx,
                  cy: i.cy,
                  r0: c,
                  r: d,
                  startAngle: p,
                  endAngle: -y * u,
                  clockwise: f
                },
                silent: !0
              })
            ),
            (p = -y * u)
        }
        for (m = 0; m < h.length; m++)
          e.add(
            mergePath(h[m], {
              style: defaults$1({ fill: s[m % s.length] }, o.getAreaStyle()),
              silent: !0
            })
          )
      }
    }
  },
  axisBuilderAttrs$1 = ['axisLine', 'axisTickLabel', 'axisName'],
  selfBuilderAttrs$1 = ['splitLine', 'splitArea', 'minorSplitLine'],
  RadiusAxisView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.axisPointerClass = 'PolarAxisPointer'), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t) {
        if ((this.group.removeAll(), e.get('show'))) {
          var i = this._axisGroup,
            r = (this._axisGroup = new Group$3())
          this.group.add(r)
          var n = e.axis,
            a = n.polar,
            o = a.getAngleAxis(),
            s = n.getTicksCoords(),
            l = n.getMinorTicksCoords(),
            h = o.getExtent()[0],
            u = n.getExtent(),
            p = layoutAxis(a, e, h),
            c = new AxisBuilder(e, p)
          each$i(axisBuilderAttrs$1, c.add, c),
            r.add(c.getGroup()),
            groupTransition(i, r, e),
            each$i(
              selfBuilderAttrs$1,
              function (t) {
                e.get([t, 'show']) &&
                  !n.scale.isBlank() &&
                  axisElementBuilders$1[t](this.group, e, a, h, u, s, l)
              },
              this
            )
        }
      }),
      (t.type = 'radiusAxis'),
      t
    )
  })(AxisView),
  axisElementBuilders$1 = {
    splitLine: function (e, t, i, r, n, a) {
      var o = t.getModel('splitLine').getModel('lineStyle'),
        s = o.get('color'),
        l = 0
      s = s instanceof Array ? s : [s]
      for (var h = [], u = 0; u < a.length; u++) {
        var p = l++ % s.length
        ;(h[p] = h[p] || []),
          h[p].push(new Circle({ shape: { cx: i.cx, cy: i.cy, r: a[u].coord } }))
      }
      for (u = 0; u < h.length; u++)
        e.add(
          mergePath(h[u], {
            style: defaults$1({ stroke: s[u % s.length], fill: null }, o.getLineStyle()),
            silent: !0
          })
        )
    },
    minorSplitLine: function (e, t, i, r, n, a, o) {
      if (o.length) {
        for (
          var s = t.getModel('minorSplitLine').getModel('lineStyle'), l = [], h = 0;
          h < o.length;
          h++
        )
          for (var u = 0; u < o[h].length; u++)
            l.push(new Circle({ shape: { cx: i.cx, cy: i.cy, r: o[h][u].coord } }))
        e.add(mergePath(l, { style: defaults$1({ fill: null }, s.getLineStyle()), silent: !0 }))
      }
    },
    splitArea: function (e, t, i, r, n, a) {
      if (a.length) {
        var o = t.getModel('splitArea').getModel('areaStyle'),
          s = o.get('color'),
          l = 0
        s = s instanceof Array ? s : [s]
        for (var h = [], u = a[0].coord, p = 1; p < a.length; p++) {
          var c = l++ % s.length
          ;(h[c] = h[c] || []),
            h[c].push(
              new Sector({
                shape: {
                  cx: i.cx,
                  cy: i.cy,
                  r0: u,
                  r: a[p].coord,
                  startAngle: 0,
                  endAngle: 2 * Math.PI
                },
                silent: !0
              })
            ),
            (u = a[p].coord)
        }
        for (p = 0; p < h.length; p++)
          e.add(
            mergePath(h[p], {
              style: defaults$1({ fill: s[p % s.length] }, o.getAreaStyle()),
              silent: !0
            })
          )
      }
    }
  }
function layoutAxis(e, t, i) {
  return {
    position: [e.cx, e.cy],
    rotation: (i / 180) * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: t.getModel('axisLabel').get('rotate'),
    z2: 1
  }
}
function getSeriesStackId(e) {
  return e.get('stack') || '__ec_stack_' + e.seriesIndex
}
function getAxisKey(e, t) {
  return t.dim + e.model.componentIndex
}
function barLayoutPolar(e, t, i) {
  var r = {},
    n = calRadialBar(
      filter$1(t.getSeriesByType(e), function (e) {
        return !t.isSeriesFiltered(e) && e.coordinateSystem && 'polar' === e.coordinateSystem.type
      })
    )
  t.eachSeriesByType(e, function (e) {
    if ('polar' === e.coordinateSystem.type) {
      var t = e.getData(),
        i = e.coordinateSystem,
        a = i.getBaseAxis(),
        o = getAxisKey(i, a),
        s = getSeriesStackId(e),
        l = n[o][s],
        h = l.offset,
        u = l.width,
        p = i.getOtherAxis(a),
        c = e.coordinateSystem.cx,
        d = e.coordinateSystem.cy,
        f = e.get('barMinHeight') || 0,
        m = e.get('barMinAngle') || 0
      r[s] = r[s] || []
      for (
        var g = t.mapDimension(p.dim),
          y = t.mapDimension(a.dim),
          v = isDimensionStacked(t, g),
          _ = 'radius' !== a.dim || !e.get('roundCap', !0),
          x = p.dataToCoord(0),
          S = 0,
          b = t.count();
        S < b;
        S++
      ) {
        var T = t.get(g, S),
          A = t.get(y, S),
          w = T >= 0 ? 'p' : 'n',
          M = x
        v && (r[s][A] || (r[s][A] = { p: x, n: x }), (M = r[s][A][w]))
        var C = void 0,
          P = void 0,
          E = void 0,
          I = void 0
        if ('radius' === p.dim) {
          var D = p.dataToCoord(T) - x,
            L = a.dataToCoord(A)
          Math.abs(D) < f && (D = (D < 0 ? -1 : 1) * f),
            (C = M),
            (P = M + D),
            (I = (E = L - h) - u),
            v && (r[s][A][w] = P)
        } else {
          var R = p.dataToCoord(T, _) - x,
            O = a.dataToCoord(A)
          Math.abs(R) < m && (R = (R < 0 ? -1 : 1) * m),
            (P = (C = O + h) + u),
            (E = M),
            (I = M + R),
            v && (r[s][A][w] = I)
        }
        t.setItemLayout(S, {
          cx: c,
          cy: d,
          r0: C,
          r: P,
          startAngle: (-E * Math.PI) / 180,
          endAngle: (-I * Math.PI) / 180
        })
      }
    }
  })
}
function calRadialBar(e) {
  var t = {}
  each$i(e, function (e, i) {
    var r = e.getData(),
      n = e.coordinateSystem,
      a = n.getBaseAxis(),
      o = getAxisKey(n, a),
      s = a.getExtent(),
      l = 'category' === a.type ? a.getBandWidth() : Math.abs(s[1] - s[0]) / r.count(),
      h = t[o] || {
        bandWidth: l,
        remainedWidth: l,
        autoWidthCount: 0,
        categoryGap: '20%',
        gap: '30%',
        stacks: {}
      },
      u = h.stacks
    t[o] = h
    var p = getSeriesStackId(e)
    u[p] || h.autoWidthCount++, (u[p] = u[p] || { width: 0, maxWidth: 0 })
    var c = parsePercent$1(e.get('barWidth'), l),
      d = parsePercent$1(e.get('barMaxWidth'), l),
      f = e.get('barGap'),
      m = e.get('barCategoryGap')
    c &&
      !u[p].width &&
      ((c = Math.min(h.remainedWidth, c)), (u[p].width = c), (h.remainedWidth -= c)),
      d && (u[p].maxWidth = d),
      null != f && (h.gap = f),
      null != m && (h.categoryGap = m)
  })
  var i = {}
  return (
    each$i(t, function (e, t) {
      i[t] = {}
      var r = e.stacks,
        n = e.bandWidth,
        a = parsePercent$1(e.categoryGap, n),
        o = parsePercent$1(e.gap, 1),
        s = e.remainedWidth,
        l = e.autoWidthCount,
        h = (s - a) / (l + (l - 1) * o)
      ;(h = Math.max(h, 0)),
        each$i(r, function (e, t) {
          var i = e.maxWidth
          i &&
            i < h &&
            ((i = Math.min(i, s)),
            e.width && (i = Math.min(i, e.width)),
            (s -= i),
            (e.width = i),
            l--)
        }),
        (h = (s - a) / (l + (l - 1) * o)),
        (h = Math.max(h, 0))
      var u,
        p = 0
      each$i(r, function (e, t) {
        e.width || (e.width = h), (u = e), (p += e.width * (1 + o))
      }),
        u && (p -= u.width * o)
      var c = -p / 2
      each$i(r, function (e, r) {
        ;(i[t][r] = i[t][r] || { offset: c, width: e.width }), (c += e.width * (1 + o))
      })
    }),
    i
  )
}
var angleAxisExtraOption = {
    startAngle: 90,
    clockwise: !0,
    splitNumber: 12,
    axisLabel: { rotate: 0 }
  },
  radiusAxisExtraOption = { splitNumber: 5 },
  PolarView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return __extends(t, e), (t.type = 'polar'), t
  })(ComponentView)
function install$o(e) {
  use(install$q),
    AxisView.registerAxisPointerClass('PolarAxisPointer', PolarAxisPointer),
    e.registerCoordinateSystem('polar', polarCreator),
    e.registerComponentModel(PolarModel),
    e.registerComponentView(PolarView),
    axisModelCreator(e, 'angle', AngleAxisModel, angleAxisExtraOption),
    axisModelCreator(e, 'radius', RadiusAxisModel, radiusAxisExtraOption),
    e.registerComponentView(AngleAxisView),
    e.registerComponentView(RadiusAxisView),
    e.registerLayout(curry$1(barLayoutPolar, 'bar'))
}
function layout$1(e, t) {
  t = t || {}
  var i = e.coordinateSystem,
    r = e.axis,
    n = {},
    a = r.position,
    o = r.orient,
    s = i.getRect(),
    l = [s.x, s.x + s.width, s.y, s.y + s.height],
    h = { horizontal: { top: l[2], bottom: l[3] }, vertical: { left: l[0], right: l[1] } }
  n.position = [
    'vertical' === o ? h.vertical[a] : l[0],
    'horizontal' === o ? h.horizontal[a] : l[3]
  ]
  n.rotation = (Math.PI / 2) * { horizontal: 0, vertical: 1 }[o]
  ;(n.labelDirection =
    n.tickDirection =
    n.nameDirection =
      { top: -1, bottom: 1, right: 1, left: -1 }[a]),
    e.get(['axisTick', 'inside']) && (n.tickDirection = -n.tickDirection),
    retrieve(t.labelInside, e.get(['axisLabel', 'inside'])) &&
      (n.labelDirection = -n.labelDirection)
  var u = t.rotate
  return (
    null == u && (u = e.get(['axisLabel', 'rotate'])),
    (n.labelRotation = 'top' === a ? -u : u),
    (n.z2 = 1),
    n
  )
}
var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'],
  selfBuilderAttrs = ['splitArea', 'splitLine'],
  SingleAxisView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.axisPointerClass = 'SingleAxisPointer'), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (t, i, r, n) {
        var a = this.group
        a.removeAll()
        var o = this._axisGroup
        this._axisGroup = new Group$3()
        var s = layout$1(t),
          l = new AxisBuilder(t, s)
        each$i(axisBuilderAttrs, l.add, l),
          a.add(this._axisGroup),
          a.add(l.getGroup()),
          each$i(
            selfBuilderAttrs,
            function (e) {
              t.get([e, 'show']) && axisElementBuilders[e](this, this.group, this._axisGroup, t)
            },
            this
          ),
          groupTransition(o, this._axisGroup, t),
          e.prototype.render.call(this, t, i, r, n)
      }),
      (t.prototype.remove = function () {
        rectCoordAxisHandleRemove(this)
      }),
      (t.type = 'singleAxis'),
      t
    )
  })(AxisView),
  axisElementBuilders = {
    splitLine: function (e, t, i, r) {
      var n = r.axis
      if (!n.scale.isBlank()) {
        var a = r.getModel('splitLine'),
          o = a.getModel('lineStyle'),
          s = o.get('color')
        s = s instanceof Array ? s : [s]
        for (
          var l = r.coordinateSystem.getRect(),
            h = n.isHorizontal(),
            u = [],
            p = 0,
            c = n.getTicksCoords({ tickModel: a }),
            d = [],
            f = [],
            m = 0;
          m < c.length;
          ++m
        ) {
          var g = n.toGlobalCoord(c[m].coord)
          h
            ? ((d[0] = g), (d[1] = l.y), (f[0] = g), (f[1] = l.y + l.height))
            : ((d[0] = l.x), (d[1] = g), (f[0] = l.x + l.width), (f[1] = g))
          var y = p++ % s.length
          ;(u[y] = u[y] || []),
            u[y].push(
              new Line$1({
                subPixelOptimize: !0,
                shape: { x1: d[0], y1: d[1], x2: f[0], y2: f[1] },
                silent: !0
              })
            )
        }
        var v = o.getLineStyle(['color'])
        for (m = 0; m < u.length; ++m)
          t.add(mergePath(u[m], { style: defaults$1({ stroke: s[m % s.length] }, v), silent: !0 }))
      }
    },
    splitArea: function (e, t, i, r) {
      rectCoordAxisBuildSplitArea(e, i, r, r)
    }
  },
  SingleAxisModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.getCoordSysModel = function () {
        return this
      }),
      (t.type = 'singleAxis'),
      (t.layoutMode = 'box'),
      (t.defaultOption = {
        left: '5%',
        top: '5%',
        right: '5%',
        bottom: '5%',
        type: 'value',
        position: 'bottom',
        orient: 'horizontal',
        axisLine: { show: !0, lineStyle: { width: 1, type: 'solid' } },
        tooltip: { show: !0 },
        axisTick: { show: !0, length: 6, lineStyle: { width: 1 } },
        axisLabel: { show: !0, interval: 'auto' },
        splitLine: { show: !0, lineStyle: { type: 'dashed', opacity: 0.2 } }
      }),
      t
    )
  })(ComponentModel)
mixin(SingleAxisModel, AxisModelCommonMixin.prototype)
var SingleAxis = (function (e) {
    function t(t, i, r, n, a) {
      var o = e.call(this, t, i, r) || this
      return (o.type = n || 'value'), (o.position = a || 'bottom'), o
    }
    return (
      __extends(t, e),
      (t.prototype.isHorizontal = function () {
        var e = this.position
        return 'top' === e || 'bottom' === e
      }),
      (t.prototype.pointToData = function (e, t) {
        return this.coordinateSystem.pointToData(e)[0]
      }),
      t
    )
  })(Axis),
  Single = (function () {
    function e(e, t, i) {
      ;(this.type = 'single'),
        (this.dimension = 'single'),
        (this.dimensions = ['single']),
        (this.axisPointerEnabled = !0),
        (this.model = e),
        this._init(e, t, i)
    }
    return (
      (e.prototype._init = function (e, t, i) {
        var r = this.dimension,
          n = new SingleAxis(r, createScaleByModel$1(e), [0, 0], e.get('type'), e.get('position')),
          a = 'category' === n.type
        ;(n.onBand = a && e.get('boundaryGap')),
          (n.inverse = e.get('inverse')),
          (n.orient = e.get('orient')),
          (e.axis = n),
          (n.model = e),
          (n.coordinateSystem = this),
          (this._axis = n)
      }),
      (e.prototype.update = function (e, t) {
        e.eachSeries(function (e) {
          if (e.coordinateSystem === this) {
            var t = e.getData()
            each$i(
              t.mapDimensionsAll(this.dimension),
              function (e) {
                this._axis.scale.unionExtentFromData(t, e)
              },
              this
            ),
              niceScaleExtent(this._axis.scale, this._axis.model)
          }
        }, this)
      }),
      (e.prototype.resize = function (e, t) {
        ;(this._rect = getLayoutRect(
          {
            left: e.get('left'),
            top: e.get('top'),
            right: e.get('right'),
            bottom: e.get('bottom'),
            width: e.get('width'),
            height: e.get('height')
          },
          { width: t.getWidth(), height: t.getHeight() }
        )),
          this._adjustAxis()
      }),
      (e.prototype.getRect = function () {
        return this._rect
      }),
      (e.prototype._adjustAxis = function () {
        var e = this._rect,
          t = this._axis,
          i = t.isHorizontal(),
          r = i ? [0, e.width] : [0, e.height],
          n = t.reverse ? 1 : 0
        t.setExtent(r[n], r[1 - n]), this._updateAxisTransform(t, i ? e.x : e.y)
      }),
      (e.prototype._updateAxisTransform = function (e, t) {
        var i = e.getExtent(),
          r = i[0] + i[1],
          n = e.isHorizontal()
        ;(e.toGlobalCoord = n
          ? function (e) {
              return e + t
            }
          : function (e) {
              return r - e + t
            }),
          (e.toLocalCoord = n
            ? function (e) {
                return e - t
              }
            : function (e) {
                return r - e + t
              })
      }),
      (e.prototype.getAxis = function () {
        return this._axis
      }),
      (e.prototype.getBaseAxis = function () {
        return this._axis
      }),
      (e.prototype.getAxes = function () {
        return [this._axis]
      }),
      (e.prototype.getTooltipAxes = function () {
        return { baseAxes: [this.getAxis()], otherAxes: [] }
      }),
      (e.prototype.containPoint = function (e) {
        var t = this.getRect(),
          i = this.getAxis()
        return 'horizontal' === i.orient
          ? i.contain(i.toLocalCoord(e[0])) && e[1] >= t.y && e[1] <= t.y + t.height
          : i.contain(i.toLocalCoord(e[1])) && e[0] >= t.y && e[0] <= t.y + t.height
      }),
      (e.prototype.pointToData = function (e) {
        var t = this.getAxis()
        return [t.coordToData(t.toLocalCoord(e['horizontal' === t.orient ? 0 : 1]))]
      }),
      (e.prototype.dataToPoint = function (e) {
        var t = this.getAxis(),
          i = this.getRect(),
          r = [],
          n = 'horizontal' === t.orient ? 0 : 1
        return (
          e instanceof Array && (e = e[0]),
          (r[n] = t.toGlobalCoord(t.dataToCoord(+e))),
          (r[1 - n] = 0 === n ? i.y + i.height / 2 : i.x + i.width / 2),
          r
        )
      }),
      (e.prototype.convertToPixel = function (e, t, i) {
        return getCoordSys$1(t) === this ? this.dataToPoint(i) : null
      }),
      (e.prototype.convertFromPixel = function (e, t, i) {
        return getCoordSys$1(t) === this ? this.pointToData(i) : null
      }),
      e
    )
  })()
function getCoordSys$1(e) {
  var t = e.seriesModel,
    i = e.singleAxisModel
  return (i && i.coordinateSystem) || (t && t.coordinateSystem)
}
function create(e, t) {
  var i = []
  return (
    e.eachComponent('singleAxis', function (r, n) {
      var a = new Single(r, e, t)
      ;(a.name = 'single_' + n), a.resize(r, t), (r.coordinateSystem = a), i.push(a)
    }),
    e.eachSeries(function (e) {
      if ('singleAxis' === e.get('coordinateSystem')) {
        var t = e.getReferringComponents('singleAxis', SINGLE_REFERRING).models[0]
        e.coordinateSystem = t && t.coordinateSystem
      }
    }),
    i
  )
}
var singleCreator = { create: create, dimensions: Single.prototype.dimensions },
  XY$1 = ['x', 'y'],
  WH$1 = ['width', 'height'],
  SingleAxisPointer = (function (e) {
    function t() {
      return (null !== e && e.apply(this, arguments)) || this
    }
    return (
      __extends(t, e),
      (t.prototype.makeElOption = function (e, t, i, r, n) {
        var a = i.axis,
          o = a.coordinateSystem,
          s = getGlobalExtent(o, 1 - getPointDimIndex(a)),
          l = o.dataToPoint(t)[0],
          h = r.get('type')
        if (h && 'none' !== h) {
          var u = buildElStyle(r),
            p = pointerShapeBuilder[h](a, l, s)
          ;(p.style = u), (e.graphicKey = p.type), (e.pointer = p)
        }
        buildCartesianSingleLabelElOption(t, e, layout$1(i), i, r, n)
      }),
      (t.prototype.getHandleTransform = function (e, t, i) {
        var r = layout$1(t, { labelInside: !1 })
        r.labelMargin = i.get(['handle', 'margin'])
        var n = getTransformedPosition(t.axis, e, r)
        return { x: n[0], y: n[1], rotation: r.rotation + (r.labelDirection < 0 ? Math.PI : 0) }
      }),
      (t.prototype.updateHandleTransform = function (e, t, i, r) {
        var n = i.axis,
          a = n.coordinateSystem,
          o = getPointDimIndex(n),
          s = getGlobalExtent(a, o),
          l = [e.x, e.y]
        ;(l[o] += t[o]), (l[o] = Math.min(s[1], l[o])), (l[o] = Math.max(s[0], l[o]))
        var h = getGlobalExtent(a, 1 - o),
          u = (h[1] + h[0]) / 2,
          p = [u, u]
        return (
          (p[o] = l[o]),
          {
            x: l[0],
            y: l[1],
            rotation: e.rotation,
            cursorPoint: p,
            tooltipOption: { verticalAlign: 'middle' }
          }
        )
      }),
      t
    )
  })(BaseAxisPointer),
  pointerShapeBuilder = {
    line: function (e, t, i) {
      return {
        type: 'Line',
        subPixelOptimize: !0,
        shape: makeLineShape([t, i[0]], [t, i[1]], getPointDimIndex(e))
      }
    },
    shadow: function (e, t, i) {
      var r = e.getBandWidth(),
        n = i[1] - i[0]
      return { type: 'Rect', shape: makeRectShape([t - r / 2, i[0]], [r, n], getPointDimIndex(e)) }
    }
  }
function getPointDimIndex(e) {
  return e.isHorizontal() ? 0 : 1
}
function getGlobalExtent(e, t) {
  var i = e.getRect()
  return [i[XY$1[t]], i[XY$1[t]] + i[WH$1[t]]]
}
var SingleView = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), i
  }
  return __extends(t, e), (t.type = 'single'), t
})(ComponentView)
function install$n(e) {
  use(install$q),
    AxisView.registerAxisPointerClass('SingleAxisPointer', SingleAxisPointer),
    e.registerComponentView(SingleView),
    e.registerComponentView(SingleAxisView),
    e.registerComponentModel(SingleAxisModel),
    axisModelCreator(e, 'single', SingleAxisModel, SingleAxisModel.defaultOption),
    e.registerCoordinateSystem('single', singleCreator)
}
var CalendarModel = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), i
  }
  return (
    __extends(t, e),
    (t.prototype.init = function (t, i, r) {
      var n = getLayoutParams(t)
      e.prototype.init.apply(this, arguments), mergeAndNormalizeLayoutParams$1(t, n)
    }),
    (t.prototype.mergeOption = function (t) {
      e.prototype.mergeOption.apply(this, arguments),
        mergeAndNormalizeLayoutParams$1(this.option, t)
    }),
    (t.prototype.getCellSize = function () {
      return this.option.cellSize
    }),
    (t.type = 'calendar'),
    (t.defaultOption = {
      zlevel: 0,
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      orient: 'horizontal',
      splitLine: { show: !0, lineStyle: { color: '#000', width: 1, type: 'solid' } },
      itemStyle: { color: '#fff', borderWidth: 1, borderColor: '#ccc' },
      dayLabel: {
        show: !0,
        firstDay: 0,
        position: 'start',
        margin: '50%',
        nameMap: 'en',
        color: '#000'
      },
      monthLabel: {
        show: !0,
        position: 'start',
        margin: 5,
        align: 'center',
        nameMap: 'en',
        formatter: null,
        color: '#000'
      },
      yearLabel: {
        show: !0,
        position: null,
        margin: 30,
        formatter: null,
        color: '#ccc',
        fontFamily: 'sans-serif',
        fontWeight: 'bolder',
        fontSize: 20
      }
    }),
    t
  )
})(ComponentModel)
function mergeAndNormalizeLayoutParams$1(e, t) {
  var i,
    r = e.cellSize
  1 === (i = isArray$1(r) ? r : (e.cellSize = [r, r])).length && (i[1] = i[0])
  var n = map$1([0, 1], function (e) {
    return sizeCalculable(t, e) && (i[e] = 'auto'), null != i[e] && 'auto' !== i[e]
  })
  mergeLayoutParam(e, t, { type: 'box', ignoreSize: n })
}
var MONTH_TEXT = {
    EN: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    CN: [
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      '',
      ''
    ]
  },
  WEEK_TEXT = {
    EN: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
    CN: ['', '', '', '', '', '', '']
  },
  CalendarView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i) {
        var r = this.group
        r.removeAll()
        var n = e.coordinateSystem,
          a = n.getRangeInfo(),
          o = n.getOrient()
        this._renderDayRect(e, a, r),
          this._renderLines(e, a, o, r),
          this._renderYearText(e, a, o, r),
          this._renderMonthText(e, o, r),
          this._renderWeekText(e, a, o, r)
      }),
      (t.prototype._renderDayRect = function (e, t, i) {
        for (
          var r = e.coordinateSystem,
            n = e.getModel('itemStyle').getItemStyle(),
            a = r.getCellWidth(),
            o = r.getCellHeight(),
            s = t.start.time;
          s <= t.end.time;
          s = r.getNextNDay(s, 1).time
        ) {
          var l = r.dataToRect([s], !1).tl,
            h = new Rect$2({
              shape: { x: l[0], y: l[1], width: a, height: o },
              cursor: 'default',
              style: n
            })
          i.add(h)
        }
      }),
      (t.prototype._renderLines = function (e, t, i, r) {
        var n = this,
          a = e.coordinateSystem,
          o = e.getModel(['splitLine', 'lineStyle']).getLineStyle(),
          s = e.get(['splitLine', 'show']),
          l = o.lineWidth
        ;(this._tlpoints = []),
          (this._blpoints = []),
          (this._firstDayOfMonth = []),
          (this._firstDayPoints = [])
        for (var h = t.start, u = 0; h.time <= t.end.time; u++) {
          c(h.formatedDate), 0 === u && (h = a.getDateInfo(t.start.y + '-' + t.start.m))
          var p = h.date
          p.setMonth(p.getMonth() + 1), (h = a.getDateInfo(p))
        }
        function c(t) {
          n._firstDayOfMonth.push(a.getDateInfo(t)),
            n._firstDayPoints.push(a.dataToRect([t], !1).tl)
          var l = n._getLinePointsOfOneWeek(e, t, i)
          n._tlpoints.push(l[0]), n._blpoints.push(l[l.length - 1]), s && n._drawSplitline(l, o, r)
        }
        c(a.getNextNDay(t.end.time, 1).formatedDate),
          s && this._drawSplitline(n._getEdgesPoints(n._tlpoints, l, i), o, r),
          s && this._drawSplitline(n._getEdgesPoints(n._blpoints, l, i), o, r)
      }),
      (t.prototype._getEdgesPoints = function (e, t, i) {
        var r = [e[0].slice(), e[e.length - 1].slice()],
          n = 'horizontal' === i ? 0 : 1
        return (r[0][n] = r[0][n] - t / 2), (r[1][n] = r[1][n] + t / 2), r
      }),
      (t.prototype._drawSplitline = function (e, t, i) {
        var r = new Polyline$1({ z2: 20, shape: { points: e }, style: t })
        i.add(r)
      }),
      (t.prototype._getLinePointsOfOneWeek = function (e, t, i) {
        for (var r = e.coordinateSystem, n = r.getDateInfo(t), a = [], o = 0; o < 7; o++) {
          var s = r.getNextNDay(n.time, o),
            l = r.dataToRect([s.time], !1)
          ;(a[2 * s.day] = l.tl), (a[2 * s.day + 1] = l['horizontal' === i ? 'bl' : 'tr'])
        }
        return a
      }),
      (t.prototype._formatterLabel = function (e, t) {
        return 'string' == typeof e && e
          ? formatTplSimple(e, t)
          : 'function' == typeof e
          ? e(t)
          : t.nameMap
      }),
      (t.prototype._yearTextPositionControl = function (e, t, i, r, n) {
        var a = t[0],
          o = t[1],
          s = ['center', 'bottom']
        'bottom' === r
          ? ((o += n), (s = ['center', 'top']))
          : 'left' === r
          ? (a -= n)
          : 'right' === r
          ? ((a += n), (s = ['center', 'top']))
          : (o -= n)
        var l = 0
        return (
          ('left' !== r && 'right' !== r) || (l = Math.PI / 2),
          { rotation: l, x: a, y: o, style: { align: s[0], verticalAlign: s[1] } }
        )
      }),
      (t.prototype._renderYearText = function (e, t, i, r) {
        var n = e.getModel('yearLabel')
        if (n.get('show')) {
          var a = n.get('margin'),
            o = n.get('position')
          o || (o = 'horizontal' !== i ? 'top' : 'left')
          var s = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]],
            l = (s[0][0] + s[1][0]) / 2,
            h = (s[0][1] + s[1][1]) / 2,
            u = 'horizontal' === i ? 0 : 1,
            p = {
              top: [l, s[u][1]],
              bottom: [l, s[1 - u][1]],
              left: [s[1 - u][0], h],
              right: [s[u][0], h]
            },
            c = t.start.y
          ;+t.end.y > +t.start.y && (c = c + '-' + t.end.y)
          var d = n.get('formatter'),
            f = { start: t.start.y, end: t.end.y, nameMap: c },
            m = this._formatterLabel(d, f),
            g = new ZRText({ z2: 30, style: createTextStyle(n, { text: m }) })
          g.attr(this._yearTextPositionControl(g, p[o], i, o, a)), r.add(g)
        }
      }),
      (t.prototype._monthTextPositionControl = function (e, t, i, r, n) {
        var a = 'left',
          o = 'top',
          s = e[0],
          l = e[1]
        return (
          'horizontal' === i
            ? ((l += n), t && (a = 'center'), 'start' === r && (o = 'bottom'))
            : ((s += n), t && (o = 'middle'), 'start' === r && (a = 'right')),
          { x: s, y: l, align: a, verticalAlign: o }
        )
      }),
      (t.prototype._renderMonthText = function (e, t, i) {
        var r = e.getModel('monthLabel')
        if (r.get('show')) {
          var n = r.get('nameMap'),
            a = r.get('margin'),
            o = r.get('position'),
            s = r.get('align'),
            l = [this._tlpoints, this._blpoints]
          isString(n) && (n = MONTH_TEXT[n.toUpperCase()] || [])
          var h = 'start' === o ? 0 : 1,
            u = 'horizontal' === t ? 0 : 1
          a = 'start' === o ? -a : a
          for (var p = 'center' === s, c = 0; c < l[h].length - 1; c++) {
            var d = l[h][c].slice(),
              f = this._firstDayOfMonth[c]
            if (p) {
              var m = this._firstDayPoints[c]
              d[u] = (m[u] + l[0][c + 1][u]) / 2
            }
            var g = r.get('formatter'),
              y = n[+f.m - 1],
              v = { yyyy: f.y, yy: (f.y + '').slice(2), MM: f.m, M: +f.m, nameMap: y },
              _ = this._formatterLabel(g, v),
              x = new ZRText({
                z2: 30,
                style: extend$3(
                  createTextStyle(r, { text: _ }),
                  this._monthTextPositionControl(d, p, t, o, a)
                )
              })
            i.add(x)
          }
        }
      }),
      (t.prototype._weekTextPositionControl = function (e, t, i, r, n) {
        var a = 'center',
          o = 'middle',
          s = e[0],
          l = e[1],
          h = 'start' === i
        return (
          'horizontal' === t
            ? ((s = s + r + ((h ? 1 : -1) * n[0]) / 2), (a = h ? 'right' : 'left'))
            : ((l = l + r + ((h ? 1 : -1) * n[1]) / 2), (o = h ? 'bottom' : 'top')),
          { x: s, y: l, align: a, verticalAlign: o }
        )
      }),
      (t.prototype._renderWeekText = function (e, t, i, r) {
        var n = e.getModel('dayLabel')
        if (n.get('show')) {
          var a = e.coordinateSystem,
            o = n.get('position'),
            s = n.get('nameMap'),
            l = n.get('margin'),
            h = a.getFirstDayOfWeek()
          isString(s) && (s = WEEK_TEXT[s.toUpperCase()] || [])
          var u = a.getNextNDay(t.end.time, 7 - t.lweek).time,
            p = [a.getCellWidth(), a.getCellHeight()]
          ;(l = parsePercent$1(l, Math.min(p[1], p[0]))),
            'start' === o && ((u = a.getNextNDay(t.start.time, -(7 + t.fweek)).time), (l = -l))
          for (var c = 0; c < 7; c++) {
            var d,
              f = a.getNextNDay(u, c),
              m = a.dataToRect([f.time], !1).center
            d = Math.abs((c + h) % 7)
            var g = new ZRText({
              z2: 30,
              style: extend$3(
                createTextStyle(n, { text: s[d] }),
                this._weekTextPositionControl(m, i, o, l, p)
              )
            })
            r.add(g)
          }
        }
      }),
      (t.type = 'calendar'),
      t
    )
  })(ComponentView),
  PROXIMATE_ONE_DAY = 864e5,
  Calendar = (function () {
    function e(t, i, r) {
      ;(this.type = 'calendar'),
        (this.dimensions = e.dimensions),
        (this.getDimensionsInfo = e.getDimensionsInfo),
        (this._model = t)
    }
    return (
      (e.getDimensionsInfo = function () {
        return [{ name: 'time', type: 'time' }, 'value']
      }),
      (e.prototype.getRangeInfo = function () {
        return this._rangeInfo
      }),
      (e.prototype.getModel = function () {
        return this._model
      }),
      (e.prototype.getRect = function () {
        return this._rect
      }),
      (e.prototype.getCellWidth = function () {
        return this._sw
      }),
      (e.prototype.getCellHeight = function () {
        return this._sh
      }),
      (e.prototype.getOrient = function () {
        return this._orient
      }),
      (e.prototype.getFirstDayOfWeek = function () {
        return this._firstDayOfWeek
      }),
      (e.prototype.getDateInfo = function (e) {
        var t = (e = parseDate(e)).getFullYear(),
          i = e.getMonth() + 1,
          r = i < 10 ? '0' + i : '' + i,
          n = e.getDate(),
          a = n < 10 ? '0' + n : '' + n,
          o = e.getDay()
        return {
          y: t + '',
          m: r,
          d: a,
          day: (o = Math.abs((o + 7 - this.getFirstDayOfWeek()) % 7)),
          time: e.getTime(),
          formatedDate: t + '-' + r + '-' + a,
          date: e
        }
      }),
      (e.prototype.getNextNDay = function (e, t) {
        return (
          0 === (t = t || 0) || (e = new Date(this.getDateInfo(e).time)).setDate(e.getDate() + t),
          this.getDateInfo(e)
        )
      }),
      (e.prototype.update = function (e, t) {
        ;(this._firstDayOfWeek = +this._model.getModel('dayLabel').get('firstDay')),
          (this._orient = this._model.get('orient')),
          (this._lineWidth = this._model.getModel('itemStyle').getItemStyle().lineWidth || 0),
          (this._rangeInfo = this._getRangeInfo(this._initRangeOption()))
        var i = this._rangeInfo.weeks || 1,
          r = ['width', 'height'],
          n = this._model.getCellSize().slice(),
          a = this._model.getBoxLayoutParams(),
          o = 'horizontal' === this._orient ? [i, 7] : [7, i]
        each$i([0, 1], function (e) {
          h(n, e) && (a[r[e]] = n[e] * o[e])
        })
        var s = { width: t.getWidth(), height: t.getHeight() },
          l = (this._rect = getLayoutRect(a, s))
        function h(e, t) {
          return null != e[t] && 'auto' !== e[t]
        }
        each$i([0, 1], function (e) {
          h(n, e) || (n[e] = l[r[e]] / o[e])
        }),
          (this._sw = n[0]),
          (this._sh = n[1])
      }),
      (e.prototype.dataToPoint = function (e, t) {
        isArray$1(e) && (e = e[0]), null == t && (t = !0)
        var i = this.getDateInfo(e),
          r = this._rangeInfo,
          n = i.formatedDate
        if (t && !(i.time >= r.start.time && i.time < r.end.time + PROXIMATE_ONE_DAY))
          return [NaN, NaN]
        var a = i.day,
          o = this._getRangeInfo([r.start.time, n]).nthWeek
        return 'vertical' === this._orient
          ? [this._rect.x + a * this._sw + this._sw / 2, this._rect.y + o * this._sh + this._sh / 2]
          : [this._rect.x + o * this._sw + this._sw / 2, this._rect.y + a * this._sh + this._sh / 2]
      }),
      (e.prototype.pointToData = function (e) {
        var t = this.pointToDate(e)
        return t && t.time
      }),
      (e.prototype.dataToRect = function (e, t) {
        var i = this.dataToPoint(e, t)
        return {
          contentShape: {
            x: i[0] - (this._sw - this._lineWidth) / 2,
            y: i[1] - (this._sh - this._lineWidth) / 2,
            width: this._sw - this._lineWidth,
            height: this._sh - this._lineWidth
          },
          center: i,
          tl: [i[0] - this._sw / 2, i[1] - this._sh / 2],
          tr: [i[0] + this._sw / 2, i[1] - this._sh / 2],
          br: [i[0] + this._sw / 2, i[1] + this._sh / 2],
          bl: [i[0] - this._sw / 2, i[1] + this._sh / 2]
        }
      }),
      (e.prototype.pointToDate = function (e) {
        var t = Math.floor((e[0] - this._rect.x) / this._sw) + 1,
          i = Math.floor((e[1] - this._rect.y) / this._sh) + 1,
          r = this._rangeInfo.range
        return 'vertical' === this._orient
          ? this._getDateByWeeksAndDay(i, t - 1, r)
          : this._getDateByWeeksAndDay(t, i - 1, r)
      }),
      (e.prototype.convertToPixel = function (e, t, i) {
        var r = getCoordSys(t)
        return r === this ? r.dataToPoint(i) : null
      }),
      (e.prototype.convertFromPixel = function (e, t, i) {
        var r = getCoordSys(t)
        return r === this ? r.pointToData(i) : null
      }),
      (e.prototype.containPoint = function (e) {
        return console.warn('Not implemented.'), !1
      }),
      (e.prototype._initRangeOption = function () {
        var e,
          t = this._model.get('range')
        if ((isArray$1(t) && 1 === t.length && (t = t[0]), isArray$1(t))) e = t
        else {
          var i = t.toString()
          if (
            (/^\d{4}$/.test(i) && (e = [i + '-01-01', i + '-12-31']),
            /^\d{4}[\/|-]\d{1,2}$/.test(i))
          ) {
            var r = this.getDateInfo(i),
              n = r.date
            n.setMonth(n.getMonth() + 1)
            var a = this.getNextNDay(n, -1)
            e = [r.formatedDate, a.formatedDate]
          }
          ;/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(i) && (e = [i, i])
        }
        if (!e) return t
        var o = this._getRangeInfo(e)
        return o.start.time > o.end.time && e.reverse(), e
      }),
      (e.prototype._getRangeInfo = function (e) {
        var t,
          i = [this.getDateInfo(e[0]), this.getDateInfo(e[1])]
        i[0].time > i[1].time && ((t = !0), i.reverse())
        var r =
            Math.floor(i[1].time / PROXIMATE_ONE_DAY) -
            Math.floor(i[0].time / PROXIMATE_ONE_DAY) +
            1,
          n = new Date(i[0].time),
          a = n.getDate(),
          o = i[1].date.getDate()
        n.setDate(a + r - 1)
        var s = n.getDate()
        if (s !== o)
          for (
            var l = n.getTime() - i[1].time > 0 ? 1 : -1;
            (s = n.getDate()) !== o && (n.getTime() - i[1].time) * l > 0;

          )
            (r -= l), n.setDate(s - l)
        var h = Math.floor((r + i[0].day + 6) / 7),
          u = t ? 1 - h : h - 1
        return (
          t && i.reverse(),
          {
            range: [i[0].formatedDate, i[1].formatedDate],
            start: i[0],
            end: i[1],
            allDay: r,
            weeks: h,
            nthWeek: u,
            fweek: i[0].day,
            lweek: i[1].day
          }
        )
      }),
      (e.prototype._getDateByWeeksAndDay = function (e, t, i) {
        var r = this._getRangeInfo(i)
        if (e > r.weeks || (0 === e && t < r.fweek) || (e === r.weeks && t > r.lweek)) return null
        var n = 7 * (e - 1) - r.fweek + t,
          a = new Date(r.start.time)
        return a.setDate(+r.start.d + n), this.getDateInfo(a)
      }),
      (e.create = function (t, i) {
        var r = []
        return (
          t.eachComponent('calendar', function (n) {
            var a = new e(n, t, i)
            r.push(a), (n.coordinateSystem = a)
          }),
          t.eachSeries(function (e) {
            'calendar' === e.get('coordinateSystem') &&
              (e.coordinateSystem = r[e.get('calendarIndex') || 0])
          }),
          r
        )
      }),
      (e.dimensions = ['time', 'value']),
      e
    )
  })()
function getCoordSys(e) {
  var t = e.calendarModel,
    i = e.seriesModel
  return t ? t.coordinateSystem : i ? i.coordinateSystem : null
}
function install$m(e) {
  e.registerComponentModel(CalendarModel),
    e.registerComponentView(CalendarView),
    e.registerCoordinateSystem('calendar', Calendar)
}
var inner$7 = makeInner(),
  _nonShapeGraphicElements = {
    path: null,
    compoundPath: null,
    group: Group$3,
    image: ZRImage,
    text: ZRText
  },
  preprocessor = function (e) {
    var t = e.graphic
    isArray$1(t)
      ? t[0] && t[0].elements
        ? (e.graphic = [e.graphic[0]])
        : (e.graphic = [{ elements: t }])
      : t && !t.elements && (e.graphic = [{ elements: [t] }])
  },
  GraphicComponentModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.preventAutoZ = !0), i
    }
    return (
      __extends(t, e),
      (t.prototype.mergeOption = function (t, i) {
        var r = this.option.elements
        ;(this.option.elements = null),
          e.prototype.mergeOption.call(this, t, i),
          (this.option.elements = r)
      }),
      (t.prototype.optionUpdated = function (e, t) {
        var i = this.option,
          r = (t ? i : e).elements,
          n = (i.elements = t ? [] : i.elements),
          a = []
        this._flatten(r, a, null)
        var o = mappingToExists(n, a, 'normalMerge'),
          s = (this._elOptionsToUpdate = [])
        each$i(
          o,
          function (e, t) {
            var i = e.newOption
            i &&
              (s.push(i),
              setKeyInfoToNewElOption(e, i),
              mergeNewElOptionToExist(n, t, i),
              setLayoutInfoToExist(n[t], i))
          },
          this
        )
        for (var l = n.length - 1; l >= 0; l--) null == n[l] ? n.splice(l, 1) : delete n[l].$action
      }),
      (t.prototype._flatten = function (e, t, i) {
        each$i(
          e,
          function (e) {
            if (e) {
              i && (e.parentOption = i), t.push(e)
              var r = e.children
              'group' === e.type && r && this._flatten(r, t, e), delete e.children
            }
          },
          this
        )
      }),
      (t.prototype.useElOptionsToUpdate = function () {
        var e = this._elOptionsToUpdate
        return (this._elOptionsToUpdate = null), e
      }),
      (t.type = 'graphic'),
      (t.defaultOption = { elements: [] }),
      t
    )
  })(ComponentModel),
  GraphicComponentView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function () {
        this._elMap = createHashMap()
      }),
      (t.prototype.render = function (e, t, i) {
        e !== this._lastGraphicModel && this._clear(),
          (this._lastGraphicModel = e),
          this._updateElements(e),
          this._relocate(e, i)
      }),
      (t.prototype._updateElements = function (e) {
        var t = e.useElOptionsToUpdate()
        if (t) {
          var i = this._elMap,
            r = this.group
          each$i(t, function (t) {
            var n = convertOptionIdName(t.id, null),
              a = null != n ? i.get(n) : null,
              o = convertOptionIdName(t.parentId, null),
              s = null != o ? i.get(o) : r,
              l = t.type,
              h = t.style
            'text' === l &&
              h &&
              t.hv &&
              t.hv[1] &&
              (h.textVerticalAlign = h.textBaseline = h.verticalAlign = h.align = null)
            var u = t.textContent,
              p = t.textConfig
            if (h && isEC4CompatibleStyle(h, l, !!p, !!u)) {
              var c = convertFromEC4CompatibleStyle(h, l, !0)
              !p && c.textConfig && (p = t.textConfig = c.textConfig),
                !u && c.textContent && (u = c.textContent)
            }
            var d = getCleanedElOption(t),
              f = t.$action || 'merge'
            'merge' === f
              ? a
                ? a.attr(d)
                : createEl(n, s, d, i)
              : 'replace' === f
              ? (removeEl(a, i), createEl(n, s, d, i))
              : 'remove' === f && removeEl(a, i)
            var m = i.get(n)
            if (m && u)
              if ('merge' === f) {
                var g = m.getTextContent()
                g ? g.attr(u) : m.setTextContent(new ZRText(u))
              } else 'replace' === f && m.setTextContent(new ZRText(u))
            if (m) {
              var y = inner$7(m)
              ;(y.__ecGraphicWidthOption = t.width),
                (y.__ecGraphicHeightOption = t.height),
                setEventData(m, e, t),
                setTooltipConfig({
                  el: m,
                  componentModel: e,
                  itemName: m.name,
                  itemTooltipOption: t.tooltip
                })
            }
          })
        }
      }),
      (t.prototype._relocate = function (e, t) {
        for (
          var i = e.option.elements,
            r = this.group,
            n = this._elMap,
            a = t.getWidth(),
            o = t.getHeight(),
            s = 0;
          s < i.length;
          s++
        ) {
          if (
            (d = null != (c = convertOptionIdName((p = i[s]).id, null)) ? n.get(c) : null) &&
            d.isGroup
          ) {
            var l = (f = d.parent) === r,
              h = inner$7(d),
              u = inner$7(f)
            ;(h.__ecGraphicWidth =
              parsePercent$1(h.__ecGraphicWidthOption, l ? a : u.__ecGraphicWidth) || 0),
              (h.__ecGraphicHeight =
                parsePercent$1(h.__ecGraphicHeightOption, l ? o : u.__ecGraphicHeight) || 0)
          }
        }
        for (s = i.length - 1; s >= 0; s--) {
          var p, c, d
          if ((d = null != (c = convertOptionIdName((p = i[s]).id, null)) ? n.get(c) : null)) {
            var f = d.parent
            u = inner$7(f)
            positionElement(
              d,
              p,
              f === r
                ? { width: a, height: o }
                : { width: u.__ecGraphicWidth, height: u.__ecGraphicHeight },
              null,
              { hv: p.hv, boundingMode: p.bounding }
            )
          }
        }
      }),
      (t.prototype._clear = function () {
        var e = this._elMap
        e.each(function (t) {
          removeEl(t, e)
        }),
          (this._elMap = createHashMap())
      }),
      (t.prototype.dispose = function () {
        this._clear()
      }),
      (t.type = 'graphic'),
      t
    )
  })(ComponentView)
function createEl(e, t, i, r) {
  var n = i.type,
    a = new (hasOwn(_nonShapeGraphicElements, n) ? _nonShapeGraphicElements[n] : getShapeClass(n))(
      i
    )
  t.add(a), r.set(e, a), (inner$7(a).__ecGraphicId = e)
}
function removeEl(e, t) {
  var i = e && e.parent
  i &&
    ('group' === e.type &&
      e.traverse(function (e) {
        removeEl(e, t)
      }),
    t.removeKey(inner$7(e).__ecGraphicId),
    i.remove(e))
}
function getCleanedElOption(e) {
  return (
    (e = extend$3({}, e)),
    each$i(
      ['id', 'parentId', '$action', 'hv', 'bounding', 'textContent'].concat(LOCATION_PARAMS),
      function (t) {
        delete e[t]
      }
    ),
    e
  )
}
function isSetLoc(e, t) {
  var i
  return (
    each$i(t, function (t) {
      null != e[t] && 'auto' !== e[t] && (i = !0)
    }),
    i
  )
}
function setKeyInfoToNewElOption(e, t) {
  var i = e.existing
  if (((t.id = e.keyInfo.id), !t.type && i && (t.type = i.type), null == t.parentId)) {
    var r = t.parentOption
    r ? (t.parentId = r.id) : i && (t.parentId = i.parentId)
  }
  t.parentOption = null
}
function mergeNewElOptionToExist(e, t, i) {
  var r = extend$3({}, i),
    n = e[t],
    a = i.$action || 'merge'
  'merge' === a
    ? n
      ? (merge(n, r, !0), mergeLayoutParam(n, r, { ignoreSize: !0 }), copyLayoutParams(i, n))
      : (e[t] = r)
    : 'replace' === a
    ? (e[t] = r)
    : 'remove' === a && n && (e[t] = null)
}
function setLayoutInfoToExist(e, t) {
  if (
    e &&
    ((e.hv = t.hv = [isSetLoc(t, ['left', 'right']), isSetLoc(t, ['top', 'bottom'])]),
    'group' === e.type)
  ) {
    var i = e,
      r = t
    null == i.width && (i.width = r.width = 0), null == i.height && (i.height = r.height = 0)
  }
}
function setEventData(e, t, i) {
  var r = getECData(e).eventData
  e.silent ||
    e.ignore ||
    r ||
    (r = getECData(e).eventData =
      { componentType: 'graphic', componentIndex: t.componentIndex, name: e.name }),
    r && (r.info = i.info)
}
function install$l(e) {
  e.registerComponentModel(GraphicComponentModel),
    e.registerComponentView(GraphicComponentView),
    e.registerPreprocessor(preprocessor)
}
var DATA_ZOOM_AXIS_DIMENSIONS = ['x', 'y', 'radius', 'angle', 'single'],
  SERIES_COORDS = ['cartesian2d', 'polar', 'singleAxis']
function isCoordSupported(e) {
  var t = e.get('coordinateSystem')
  return indexOf$1(SERIES_COORDS, t) >= 0
}
function getAxisMainType(e) {
  return e + 'Axis'
}
function findEffectedDataZooms(e, t) {
  var i,
    r = createHashMap(),
    n = [],
    a = createHashMap()
  e.eachComponent({ mainType: 'dataZoom', query: t }, function (e) {
    a.get(e.uid) || s(e)
  })
  do {
    ;(i = !1), e.eachComponent('dataZoom', o)
  } while (i)
  function o(e) {
    !a.get(e.uid) &&
      (function (e) {
        var t = !1
        return (
          e.eachTargetAxis(function (e, i) {
            var n = r.get(e)
            n && n[i] && (t = !0)
          }),
          t
        )
      })(e) &&
      (s(e), (i = !0))
  }
  function s(e) {
    a.set(e.uid, !0),
      n.push(e),
      e.eachTargetAxis(function (e, t) {
        ;(r.get(e) || r.set(e, []))[t] = !0
      })
  }
  return n
}
function collectReferCoordSysModelInfo(e) {
  var t = e.ecModel,
    i = { infoList: [], infoMap: createHashMap() }
  return (
    e.eachTargetAxis(function (e, r) {
      var n = t.getComponent(getAxisMainType(e), r)
      if (n) {
        var a = n.getCoordSysModel()
        if (a) {
          var o = a.uid,
            s = i.infoMap.get(o)
          s || ((s = { model: a, axisModels: [] }), i.infoList.push(s), i.infoMap.set(o, s)),
            s.axisModels.push(n)
        }
      }
    }),
    i
  )
}
var DataZoomAxisInfo = (function () {
    function e() {
      ;(this.indexList = []), (this.indexMap = [])
    }
    return (
      (e.prototype.add = function (e) {
        this.indexMap[e] || (this.indexList.push(e), (this.indexMap[e] = !0))
      }),
      e
    )
  })(),
  DataZoomModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (
        (i.type = t.type),
        (i._autoThrottle = !0),
        (i._noTarget = !0),
        (i._rangePropMode = ['percent', 'percent']),
        i
      )
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (e, t, i) {
        var r = retrieveRawOption(e)
        ;(this.settledOption = r), this.mergeDefaultAndTheme(e, i), this._doInit(r)
      }),
      (t.prototype.mergeOption = function (e) {
        var t = retrieveRawOption(e)
        merge(this.option, e, !0), merge(this.settledOption, t, !0), this._doInit(t)
      }),
      (t.prototype._doInit = function (e) {
        var t = this.option
        this._setDefaultThrottle(e), this._updateRangeUse(e)
        var i = this.settledOption
        each$i(
          [
            ['start', 'startValue'],
            ['end', 'endValue']
          ],
          function (e, r) {
            'value' === this._rangePropMode[r] && (t[e[0]] = i[e[0]] = null)
          },
          this
        ),
          this._resetTarget()
      }),
      (t.prototype._resetTarget = function () {
        var e = this.get('orient', !0),
          t = (this._targetAxisInfoMap = createHashMap())
        this._fillSpecifiedTargetAxis(t)
          ? (this._orient = e || this._makeAutoOrientByTargetAxis())
          : ((this._orient = e || 'horizontal'), this._fillAutoTargetAxisByOrient(t, this._orient)),
          (this._noTarget = !0),
          t.each(function (e) {
            e.indexList.length && (this._noTarget = !1)
          }, this)
      }),
      (t.prototype._fillSpecifiedTargetAxis = function (e) {
        var t = !1
        return (
          each$i(
            DATA_ZOOM_AXIS_DIMENSIONS,
            function (i) {
              var r = this.getReferringComponents(getAxisMainType(i), MULTIPLE_REFERRING)
              if (r.specified) {
                t = !0
                var n = new DataZoomAxisInfo()
                each$i(r.models, function (e) {
                  n.add(e.componentIndex)
                }),
                  e.set(i, n)
              }
            },
            this
          ),
          t
        )
      }),
      (t.prototype._fillAutoTargetAxisByOrient = function (e, t) {
        var i = this.ecModel,
          r = !0
        if (r) {
          var n = 'vertical' === t ? 'y' : 'x'
          a(i.findComponents({ mainType: n + 'Axis' }), n)
        }
        r &&
          a(
            i.findComponents({
              mainType: 'singleAxis',
              filter: function (e) {
                return e.get('orient', !0) === t
              }
            }),
            'single'
          )
        function a(t, i) {
          var n = t[0]
          if (n) {
            var a = new DataZoomAxisInfo()
            if ((a.add(n.componentIndex), e.set(i, a), (r = !1), 'x' === i || 'y' === i)) {
              var o = n.getReferringComponents('grid', SINGLE_REFERRING).models[0]
              o &&
                each$i(t, function (e) {
                  n.componentIndex !== e.componentIndex &&
                    o === e.getReferringComponents('grid', SINGLE_REFERRING).models[0] &&
                    a.add(e.componentIndex)
                })
            }
          }
        }
        r &&
          each$i(
            DATA_ZOOM_AXIS_DIMENSIONS,
            function (t) {
              if (r) {
                var n = i.findComponents({
                  mainType: getAxisMainType(t),
                  filter: function (e) {
                    return 'category' === e.get('type', !0)
                  }
                })
                if (n[0]) {
                  var a = new DataZoomAxisInfo()
                  a.add(n[0].componentIndex), e.set(t, a), (r = !1)
                }
              }
            },
            this
          )
      }),
      (t.prototype._makeAutoOrientByTargetAxis = function () {
        var e
        return (
          this.eachTargetAxis(function (t) {
            !e && (e = t)
          }, this),
          'y' === e ? 'vertical' : 'horizontal'
        )
      }),
      (t.prototype._setDefaultThrottle = function (e) {
        if ((e.hasOwnProperty('throttle') && (this._autoThrottle = !1), this._autoThrottle)) {
          var t = this.ecModel.option
          this.option.throttle = t.animation && t.animationDurationUpdate > 0 ? 100 : 20
        }
      }),
      (t.prototype._updateRangeUse = function (e) {
        var t = this._rangePropMode,
          i = this.get('rangeMode')
        each$i(
          [
            ['start', 'startValue'],
            ['end', 'endValue']
          ],
          function (r, n) {
            var a = null != e[r[0]],
              o = null != e[r[1]]
            a && !o
              ? (t[n] = 'percent')
              : !a && o
              ? (t[n] = 'value')
              : i
              ? (t[n] = i[n])
              : a && (t[n] = 'percent')
          }
        )
      }),
      (t.prototype.noTarget = function () {
        return this._noTarget
      }),
      (t.prototype.getFirstTargetAxisModel = function () {
        var e
        return (
          this.eachTargetAxis(function (t, i) {
            null == e && (e = this.ecModel.getComponent(getAxisMainType(t), i))
          }, this),
          e
        )
      }),
      (t.prototype.eachTargetAxis = function (e, t) {
        this._targetAxisInfoMap.each(function (i, r) {
          each$i(i.indexList, function (i) {
            e.call(t, r, i)
          })
        })
      }),
      (t.prototype.getAxisProxy = function (e, t) {
        var i = this.getAxisModel(e, t)
        if (i) return i.__dzAxisProxy
      }),
      (t.prototype.getAxisModel = function (e, t) {
        var i = this._targetAxisInfoMap.get(e)
        if (i && i.indexMap[t]) return this.ecModel.getComponent(getAxisMainType(e), t)
      }),
      (t.prototype.setRawRange = function (e) {
        var t = this.option,
          i = this.settledOption
        each$i(
          [
            ['start', 'startValue'],
            ['end', 'endValue']
          ],
          function (r) {
            ;(null == e[r[0]] && null == e[r[1]]) ||
              ((t[r[0]] = i[r[0]] = e[r[0]]), (t[r[1]] = i[r[1]] = e[r[1]]))
          },
          this
        ),
          this._updateRangeUse(e)
      }),
      (t.prototype.setCalculatedRange = function (e) {
        var t = this.option
        each$i(['start', 'startValue', 'end', 'endValue'], function (i) {
          t[i] = e[i]
        })
      }),
      (t.prototype.getPercentRange = function () {
        var e = this.findRepresentativeAxisProxy()
        if (e) return e.getDataPercentWindow()
      }),
      (t.prototype.getValueRange = function (e, t) {
        if (null != e || null != t) return this.getAxisProxy(e, t).getDataValueWindow()
        var i = this.findRepresentativeAxisProxy()
        return i ? i.getDataValueWindow() : void 0
      }),
      (t.prototype.findRepresentativeAxisProxy = function (e) {
        if (e) return e.__dzAxisProxy
        for (var t, i = this._targetAxisInfoMap.keys(), r = 0; r < i.length; r++)
          for (
            var n = i[r], a = this._targetAxisInfoMap.get(n), o = 0;
            o < a.indexList.length;
            o++
          ) {
            var s = this.getAxisProxy(n, a.indexList[o])
            if (s.hostedBy(this)) return s
            t || (t = s)
          }
        return t
      }),
      (t.prototype.getRangePropMode = function () {
        return this._rangePropMode.slice()
      }),
      (t.prototype.getOrient = function () {
        return this._orient
      }),
      (t.type = 'dataZoom'),
      (t.dependencies = [
        'xAxis',
        'yAxis',
        'radiusAxis',
        'angleAxis',
        'singleAxis',
        'series',
        'toolbox'
      ]),
      (t.defaultOption = { zlevel: 0, z: 4, filterMode: 'filter', start: 0, end: 100 }),
      t
    )
  })(ComponentModel)
function retrieveRawOption(e) {
  var t = {}
  return (
    each$i(['start', 'end', 'startValue', 'endValue', 'throttle'], function (i) {
      e.hasOwnProperty(i) && (t[i] = e[i])
    }),
    t
  )
}
var SelectDataZoomModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return __extends(t, e), (t.type = 'dataZoom.select'), t
  })(DataZoomModel),
  DataZoomView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i, r) {
        ;(this.dataZoomModel = e), (this.ecModel = t), (this.api = i)
      }),
      (t.type = 'dataZoom'),
      t
    )
  })(ComponentView),
  SelectDataZoomView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return __extends(t, e), (t.type = 'dataZoom.select'), t
  })(DataZoomView),
  each$9 = each$i,
  asc$1 = asc$2,
  AxisProxy = (function () {
    function e(e, t, i, r) {
      ;(this._dimName = e), (this._axisIndex = t), (this.ecModel = r), (this._dataZoomModel = i)
    }
    return (
      (e.prototype.hostedBy = function (e) {
        return this._dataZoomModel === e
      }),
      (e.prototype.getDataValueWindow = function () {
        return this._valueWindow.slice()
      }),
      (e.prototype.getDataPercentWindow = function () {
        return this._percentWindow.slice()
      }),
      (e.prototype.getTargetSeriesModels = function () {
        var e = []
        return (
          this.ecModel.eachSeries(function (t) {
            if (isCoordSupported(t)) {
              var i = getAxisMainType(this._dimName),
                r = t.getReferringComponents(i, SINGLE_REFERRING).models[0]
              r && this._axisIndex === r.componentIndex && e.push(t)
            }
          }, this),
          e
        )
      }),
      (e.prototype.getAxisModel = function () {
        return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex)
      }),
      (e.prototype.getMinMaxSpan = function () {
        return clone$3(this._minMaxSpan)
      }),
      (e.prototype.calculateDataWindow = function (e) {
        var t,
          i = this._dataExtent,
          r = this.getAxisModel().axis.scale,
          n = this._dataZoomModel.getRangePropMode(),
          a = [0, 100],
          o = [],
          s = []
        each$9(['start', 'end'], function (l, h) {
          var u = e[l],
            p = e[l + 'Value']
          'percent' === n[h]
            ? (null == u && (u = a[h]), (p = r.parse(linearMap$2(u, a, i))))
            : ((t = !0), (u = linearMap$2((p = null == p ? i[h] : r.parse(p)), i, a))),
            (s[h] = p),
            (o[h] = u)
        }),
          asc$1(s),
          asc$1(o)
        var l = this._minMaxSpan
        function h(e, t, i, n, a) {
          var o = a ? 'Span' : 'ValueSpan'
          sliderMove(0, e, i, 'all', l['min' + o], l['max' + o])
          for (var s = 0; s < 2; s++)
            (t[s] = linearMap$2(e[s], i, n, !0)), a && (t[s] = r.parse(t[s]))
        }
        return t ? h(s, o, i, a, !1) : h(o, s, a, i, !0), { valueWindow: s, percentWindow: o }
      }),
      (e.prototype.reset = function (e) {
        if (e === this._dataZoomModel) {
          var t = this.getTargetSeriesModels()
          ;(this._dataExtent = calculateDataExtent(this, this._dimName, t)),
            this._updateMinMaxSpan()
          var i = this.calculateDataWindow(e.settledOption)
          ;(this._valueWindow = i.valueWindow),
            (this._percentWindow = i.percentWindow),
            this._setAxisModel()
        }
      }),
      (e.prototype.filterData = function (e, t) {
        if (e === this._dataZoomModel) {
          var i = this._dimName,
            r = this.getTargetSeriesModels(),
            n = e.get('filterMode'),
            a = this._valueWindow
          'none' !== n &&
            each$9(r, function (e) {
              var t = e.getData(),
                r = t.mapDimensionsAll(i)
              r.length &&
                ('weakFilter' === n
                  ? t.filterSelf(function (e) {
                      for (var i, n, o, s = 0; s < r.length; s++) {
                        var l = t.get(r[s], e),
                          h = !isNaN(l),
                          u = l < a[0],
                          p = l > a[1]
                        if (h && !u && !p) return !0
                        h && (o = !0), u && (i = !0), p && (n = !0)
                      }
                      return o && i && n
                    })
                  : each$9(r, function (i) {
                      if ('empty' === n)
                        e.setData(
                          (t = t.map(i, function (e) {
                            return (function (e) {
                              return e >= a[0] && e <= a[1]
                            })(e)
                              ? e
                              : NaN
                          }))
                        )
                      else {
                        var r = {}
                        ;(r[i] = a), t.selectRange(r)
                      }
                    }),
                each$9(r, function (e) {
                  t.setApproximateExtent(a, e)
                }))
            })
        }
      }),
      (e.prototype._updateMinMaxSpan = function () {
        var e = (this._minMaxSpan = {}),
          t = this._dataZoomModel,
          i = this._dataExtent
        each$9(
          ['min', 'max'],
          function (r) {
            var n = t.get(r + 'Span'),
              a = t.get(r + 'ValueSpan')
            null != a && (a = this.getAxisModel().axis.scale.parse(a)),
              null != a
                ? (n = linearMap$2(i[0] + a, i, [0, 100], !0))
                : null != n && (a = linearMap$2(n, [0, 100], i, !0) - i[0]),
              (e[r + 'Span'] = n),
              (e[r + 'ValueSpan'] = a)
          },
          this
        )
      }),
      (e.prototype._setAxisModel = function () {
        var e = this.getAxisModel(),
          t = this._percentWindow,
          i = this._valueWindow
        if (t) {
          var r = getPixelPrecision(i, [0, 500])
          r = Math.min(r, 20)
          var n = e.axis.scale.rawExtentInfo
          0 !== t[0] && n.setDeterminedMinMax('min', +i[0].toFixed(r)),
            100 !== t[1] && n.setDeterminedMinMax('max', +i[1].toFixed(r)),
            n.freeze()
        }
      }),
      e
    )
  })()
function calculateDataExtent(e, t, i) {
  var r = [1 / 0, -1 / 0]
  each$9(i, function (e) {
    unionAxisExtentFromData(r, e.getData(), t)
  })
  var n = e.getAxisModel(),
    a = ensureScaleRawExtentInfo(n.axis.scale, n, r).calculate()
  return [a.min, a.max]
}
var dataZoomProcessor = {
  getTargetSeries: function (e) {
    function t(t) {
      e.eachComponent('dataZoom', function (i) {
        i.eachTargetAxis(function (r, n) {
          var a = e.getComponent(getAxisMainType(r), n)
          t(r, n, a, i)
        })
      })
    }
    t(function (e, t, i, r) {
      i.__dzAxisProxy = null
    })
    var i = []
    t(function (t, r, n, a) {
      n.__dzAxisProxy || ((n.__dzAxisProxy = new AxisProxy(t, r, a, e)), i.push(n.__dzAxisProxy))
    })
    var r = createHashMap()
    return (
      each$i(i, function (e) {
        each$i(e.getTargetSeriesModels(), function (e) {
          r.set(e.uid, e)
        })
      }),
      r
    )
  },
  overallReset: function (e, t) {
    e.eachComponent('dataZoom', function (e) {
      e.eachTargetAxis(function (t, i) {
        e.getAxisProxy(t, i).reset(e)
      }),
        e.eachTargetAxis(function (i, r) {
          e.getAxisProxy(i, r).filterData(e, t)
        })
    }),
      e.eachComponent('dataZoom', function (e) {
        var t = e.findRepresentativeAxisProxy()
        if (t) {
          var i = t.getDataPercentWindow(),
            r = t.getDataValueWindow()
          e.setCalculatedRange({ start: i[0], end: i[1], startValue: r[0], endValue: r[1] })
        }
      })
  }
}
function installDataZoomAction(e) {
  e.registerAction('dataZoom', function (e, t) {
    each$i(findEffectedDataZooms(t, e), function (t) {
      t.setRawRange({ start: e.start, end: e.end, startValue: e.startValue, endValue: e.endValue })
    })
  })
}
var installed$1 = !1
function installCommon$1(e) {
  installed$1 ||
    ((installed$1 = !0),
    e.registerProcessor(e.PRIORITY.PROCESSOR.FILTER, dataZoomProcessor),
    installDataZoomAction(e),
    e.registerSubTypeDefaulter('dataZoom', function () {
      return 'slider'
    }))
}
function install$k(e) {
  e.registerComponentModel(SelectDataZoomModel),
    e.registerComponentView(SelectDataZoomView),
    installCommon$1(e)
}
var ToolboxFeature = function () {},
  features = {}
function registerFeature(e, t) {
  features[e] = t
}
function getFeature(e) {
  return features[e]
}
var ToolboxModel = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), i
  }
  return (
    __extends(t, e),
    (t.prototype.optionUpdated = function () {
      e.prototype.optionUpdated.apply(this, arguments)
      var t = this.ecModel
      each$i(this.option.feature, function (e, i) {
        var r = getFeature(i)
        r &&
          (r.getDefaultOption && (r.defaultOption = r.getDefaultOption(t)),
          merge(e, r.defaultOption))
      })
    }),
    (t.type = 'toolbox'),
    (t.layoutMode = { type: 'box', ignoreSize: !0 }),
    (t.defaultOption = {
      show: !0,
      z: 6,
      zlevel: 0,
      orient: 'horizontal',
      left: 'right',
      top: 'top',
      backgroundColor: 'transparent',
      borderColor: '#ccc',
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: !0,
      iconStyle: { borderColor: '#666', color: 'none' },
      emphasis: { iconStyle: { borderColor: '#3E98C5' } },
      tooltip: { show: !1, position: 'bottom' }
    }),
    t
  )
})(ComponentModel)
function layout(e, t, i) {
  var r = t.getBoxLayoutParams(),
    n = t.get('padding'),
    a = { width: i.getWidth(), height: i.getHeight() },
    o = getLayoutRect(r, a, n)
  box(t.get('orient'), e, t.get('itemGap'), o.width, o.height), positionElement(e, r, a, n)
}
function makeBackground(e, t) {
  var i = normalizeCssArray(t.get('padding')),
    r = t.getItemStyle(['color', 'opacity'])
  return (
    (r.fill = t.get('backgroundColor')),
    (e = new Rect$2({
      shape: {
        x: e.x - i[3],
        y: e.y - i[0],
        width: e.width + i[1] + i[3],
        height: e.height + i[0] + i[2],
        r: t.get('borderRadius')
      },
      style: r,
      silent: !0,
      z2: -1
    }))
  )
}
var ToolboxView = (function (e) {
  function t() {
    return (null !== e && e.apply(this, arguments)) || this
  }
  return (
    __extends(t, e),
    (t.prototype.render = function (e, t, i, r) {
      var n = this.group
      if ((n.removeAll(), e.get('show'))) {
        var a = +e.get('itemSize'),
          o = e.get('feature') || {},
          s = this._features || (this._features = {}),
          l = []
        each$i(o, function (e, t) {
          l.push(t)
        }),
          new DataDiffer(this._featureNames || [], l)
            .add(h)
            .update(h)
            .remove(curry$1(h, null))
            .execute(),
          (this._featureNames = l),
          layout(n, e, i),
          n.add(makeBackground(n.getBoundingRect(), e)),
          n.eachChild(function (e) {
            var t = e.__title,
              r = e.ensureState('emphasis'),
              o = r.textConfig || (r.textConfig = {}),
              s = e.getTextContent(),
              l = s && s.states.emphasis
            if (l && !isFunction$1(l) && t) {
              var h = l.style || (l.style = {}),
                u = getBoundingRect(t, ZRText.makeFont(h)),
                p = e.x + n.x,
                c = !1
              e.y + n.y + a + u.height > i.getHeight() && ((o.position = 'top'), (c = !0))
              var d = c ? -5 - u.height : a + 8
              p + u.width / 2 > i.getWidth()
                ? ((o.position = ['100%', d]), (h.align = 'right'))
                : p - u.width / 2 < 0 && ((o.position = [0, d]), (h.align = 'left'))
            }
          })
      }
      function h(h, u) {
        var p,
          c = l[h],
          d = l[u],
          f = o[c],
          m = new Model(f, e, e.ecModel)
        if ((r && null != r.newTitle && r.featureName === c && (f.title = r.newTitle), c && !d)) {
          if (isUserFeatureName(c)) p = { onclick: m.option.onclick, featureName: c }
          else {
            var g = getFeature(c)
            if (!g) return
            p = new g()
          }
          s[c] = p
        } else if (!(p = s[d])) return
        ;(p.uid = getUID('toolbox-feature')), (p.model = m), (p.ecModel = t), (p.api = i)
        var y = p instanceof ToolboxFeature
        c || !d
          ? !m.get('show') || (y && p.unusable)
            ? y && p.remove && p.remove(t, i)
            : (!(function (r, o, s) {
                var l,
                  h,
                  u = r.getModel('iconStyle'),
                  p = r.getModel(['emphasis', 'iconStyle']),
                  c = o instanceof ToolboxFeature && o.getIcons ? o.getIcons() : r.get('icon'),
                  d = r.get('title') || {}
                'string' == typeof c ? ((l = {})[s] = c) : (l = c)
                'string' == typeof d ? ((h = {})[s] = d) : (h = d)
                var f = (r.iconPaths = {})
                each$i(l, function (s, l) {
                  var c = createIcon(s, {}, { x: -a / 2, y: -a / 2, width: a, height: a })
                  c.setStyle(u.getItemStyle()), (c.ensureState('emphasis').style = p.getItemStyle())
                  var d = new ZRText({
                    style: {
                      text: h[l],
                      align: p.get('textAlign'),
                      borderRadius: p.get('textBorderRadius'),
                      padding: p.get('textPadding'),
                      fill: null
                    },
                    ignore: !0
                  })
                  c.setTextContent(d),
                    setTooltipConfig({
                      el: c,
                      componentModel: e,
                      itemName: l,
                      formatterParamsExtra: { title: h[l] }
                    }),
                    (c.__title = h[l]),
                    c
                      .on('mouseover', function () {
                        var t = p.getItemStyle(),
                          i =
                            'vertical' === e.get('orient')
                              ? null == e.get('right')
                                ? 'right'
                                : 'left'
                              : null == e.get('bottom')
                              ? 'bottom'
                              : 'top'
                        d.setStyle({
                          fill: p.get('textFill') || t.fill || t.stroke || '#000',
                          backgroundColor: p.get('textBackgroundColor')
                        }),
                          c.setTextConfig({ position: p.get('textPosition') || i }),
                          (d.ignore = !e.get('showTitle')),
                          enterEmphasis(this)
                      })
                      .on('mouseout', function () {
                        'emphasis' !== r.get(['iconStatus', l]) && leaveEmphasis(this), d.hide()
                      }),
                    ('emphasis' === r.get(['iconStatus', l]) ? enterEmphasis : leaveEmphasis)(c),
                    n.add(c),
                    c.on('click', bind$2(o.onclick, o, t, i, l)),
                    (f[l] = c)
                })
              })(m, p, c),
              (m.setIconStatus = function (e, t) {
                var i = this.option,
                  r = this.iconPaths
                ;(i.iconStatus = i.iconStatus || {}),
                  (i.iconStatus[e] = t),
                  r[e] && ('emphasis' === t ? enterEmphasis : leaveEmphasis)(r[e])
              }),
              p instanceof ToolboxFeature && p.render && p.render(m, t, i, r))
          : y && p.dispose && p.dispose(t, i)
      }
    }),
    (t.prototype.updateView = function (e, t, i, r) {
      each$i(this._features, function (e) {
        e instanceof ToolboxFeature && e.updateView && e.updateView(e.model, t, i, r)
      })
    }),
    (t.prototype.remove = function (e, t) {
      each$i(this._features, function (i) {
        i instanceof ToolboxFeature && i.remove && i.remove(e, t)
      }),
        this.group.removeAll()
    }),
    (t.prototype.dispose = function (e, t) {
      each$i(this._features, function (i) {
        i instanceof ToolboxFeature && i.dispose && i.dispose(e, t)
      })
    }),
    (t.type = 'toolbox'),
    t
  )
})(ComponentView)
function isUserFeatureName(e) {
  return 0 === e.indexOf('my')
}
var SaveAsImage = (function (e) {
  function t() {
    return (null !== e && e.apply(this, arguments)) || this
  }
  return (
    __extends(t, e),
    (t.prototype.onclick = function (e, t) {
      var i = this.model,
        r = i.get('name') || e.get('title.0.text') || 'echarts',
        n = 'svg' === t.getZr().painter.getType(),
        a = n ? 'svg' : i.get('type', !0) || 'png',
        o = t.getConnectedDataURL({
          type: a,
          backgroundColor: i.get('backgroundColor', !0) || e.get('backgroundColor') || '#fff',
          connectedBackgroundColor: i.get('connectedBackgroundColor'),
          excludeComponents: i.get('excludeComponents'),
          pixelRatio: i.get('pixelRatio')
        })
      if (
        'function' != typeof MouseEvent ||
        (!env.browser.newEdge && (env.browser.ie || env.browser.edge))
      )
        if (window.navigator.msSaveOrOpenBlob || n) {
          var s = o.split(','),
            l = s[0].indexOf('base64') > -1,
            h = n ? decodeURIComponent(s[1]) : s[1]
          l && (h = window.atob(h))
          var u = r + '.' + a
          if (window.navigator.msSaveOrOpenBlob) {
            for (var p = h.length, c = new Uint8Array(p); p--; ) c[p] = h.charCodeAt(p)
            var d = new Blob([c])
            window.navigator.msSaveOrOpenBlob(d, u)
          } else {
            var f = document.createElement('iframe')
            document.body.appendChild(f)
            var m = f.contentWindow,
              g = m.document
            g.open('image/svg+xml', 'replace'),
              g.write(h),
              g.close(),
              m.focus(),
              g.execCommand('SaveAs', !0, u),
              document.body.removeChild(f)
          }
        } else {
          var y = i.get('lang'),
            v =
              '<body style="margin:0;"><img src="' +
              o +
              '" style="max-width:100%;" title="' +
              ((y && y[0]) || '') +
              '" /></body>',
            _ = window.open()
          _.document.write(v), (_.document.title = r)
        }
      else {
        var x = document.createElement('a')
        ;(x.download = r + '.' + a), (x.target = '_blank'), (x.href = o)
        var S = new MouseEvent('click', { view: document.defaultView, bubbles: !0, cancelable: !1 })
        x.dispatchEvent(S)
      }
    }),
    (t.getDefaultOption = function (e) {
      return {
        show: !0,
        icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',
        title: e.getLocale(['toolbox', 'saveAsImage', 'title']),
        type: 'png',
        connectedBackgroundColor: '#fff',
        name: '',
        excludeComponents: ['toolbox'],
        lang: e.getLocale(['toolbox', 'saveAsImage', 'lang'])
      }
    }),
    t
  )
})(ToolboxFeature)
SaveAsImage.prototype.unusable = !env.canvasSupported
var INNER_STACK_KEYWORD = '__ec_magicType_stack__',
  radioTypes = [['line', 'bar'], ['stack']],
  MagicType = (function (e) {
    function t() {
      return (null !== e && e.apply(this, arguments)) || this
    }
    return (
      __extends(t, e),
      (t.prototype.getIcons = function () {
        var e = this.model,
          t = e.get('icon'),
          i = {}
        return (
          each$i(e.get('type'), function (e) {
            t[e] && (i[e] = t[e])
          }),
          i
        )
      }),
      (t.getDefaultOption = function (e) {
        return {
          show: !0,
          type: [],
          icon: {
            line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',
            bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',
            stack:
              'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z'
          },
          title: e.getLocale(['toolbox', 'magicType', 'title']),
          option: {},
          seriesIndex: {}
        }
      }),
      (t.prototype.onclick = function (e, t, i) {
        var r = this.model,
          n = r.get(['seriesIndex', i])
        if (seriesOptGenreator[i]) {
          var a,
            o = { series: [] }
          each$i(radioTypes, function (e) {
            indexOf$1(e, i) >= 0 &&
              each$i(e, function (e) {
                r.setIconStatus(e, 'normal')
              })
          }),
            r.setIconStatus(i, 'emphasis'),
            e.eachComponent(
              { mainType: 'series', query: null == n ? null : { seriesIndex: n } },
              function (e) {
                var t = e.subType,
                  n = e.id,
                  a = seriesOptGenreator[i](t, n, e, r)
                a && (defaults$1(a, e.option), o.series.push(a))
                var s = e.coordinateSystem
                if (s && 'cartesian2d' === s.type && ('line' === i || 'bar' === i)) {
                  var l = s.getAxesByScale('ordinal')[0]
                  if (l) {
                    var h = l.dim + 'Axis',
                      u = e.getReferringComponents(h, SINGLE_REFERRING).models[0].componentIndex
                    o[h] = o[h] || []
                    for (var p = 0; p <= u; p++) o[h][u] = o[h][u] || {}
                    o[h][u].boundaryGap = 'bar' === i
                  }
                }
              }
            )
          var s = i
          'stack' === i &&
            ((a = merge(
              { stack: r.option.title.tiled, tiled: r.option.title.stack },
              r.option.title
            )),
            'emphasis' !== r.get(['iconStatus', i]) && (s = 'tiled')),
            t.dispatchAction({
              type: 'changeMagicType',
              currentType: s,
              newOption: o,
              newTitle: a,
              featureName: 'magicType'
            })
        }
      }),
      t
    )
  })(ToolboxFeature),
  seriesOptGenreator = {
    line: function (e, t, i, r) {
      if ('bar' === e)
        return merge(
          {
            id: t,
            type: 'line',
            data: i.get('data'),
            stack: i.get('stack'),
            markPoint: i.get('markPoint'),
            markLine: i.get('markLine')
          },
          r.get(['option', 'line']) || {},
          !0
        )
    },
    bar: function (e, t, i, r) {
      if ('line' === e)
        return merge(
          {
            id: t,
            type: 'bar',
            data: i.get('data'),
            stack: i.get('stack'),
            markPoint: i.get('markPoint'),
            markLine: i.get('markLine')
          },
          r.get(['option', 'bar']) || {},
          !0
        )
    },
    stack: function (e, t, i, r) {
      var n = i.get('stack') === INNER_STACK_KEYWORD
      if ('line' === e || 'bar' === e)
        return (
          r.setIconStatus('stack', n ? 'normal' : 'emphasis'),
          merge(
            { id: t, stack: n ? '' : INNER_STACK_KEYWORD },
            r.get(['option', 'stack']) || {},
            !0
          )
        )
    }
  }
registerAction(
  { type: 'changeMagicType', event: 'magicTypeChanged', update: 'prepareAndUpdate' },
  function (e, t) {
    t.mergeOption(e.newOption)
  }
)
var BLOCK_SPLITER = new Array(60).join('-'),
  ITEM_SPLITER = '\t'
function groupSeries(e) {
  var t = {},
    i = [],
    r = []
  return (
    e.eachRawSeries(function (e) {
      var n = e.coordinateSystem
      if (!n || ('cartesian2d' !== n.type && 'polar' !== n.type)) i.push(e)
      else {
        var a = n.getBaseAxis()
        if ('category' === a.type) {
          var o = a.dim + '_' + a.index
          t[o] ||
            ((t[o] = { categoryAxis: a, valueAxis: n.getOtherAxis(a), series: [] }),
            r.push({ axisDim: a.dim, axisIndex: a.index })),
            t[o].series.push(e)
        } else i.push(e)
      }
    }),
    { seriesGroupByCategoryAxis: t, other: i, meta: r }
  )
}
function assembleSeriesWithCategoryAxis(e) {
  var t = []
  return (
    each$i(e, function (e, i) {
      var r = e.categoryAxis,
        n = e.valueAxis.dim,
        a = [' '].concat(
          map$1(e.series, function (e) {
            return e.name
          })
        ),
        o = [r.model.getCategories()]
      each$i(e.series, function (e) {
        var t = e.getRawData()
        o.push(
          e.getRawData().mapArray(t.mapDimension(n), function (e) {
            return e
          })
        )
      })
      for (var s = [a.join(ITEM_SPLITER)], l = 0; l < o[0].length; l++) {
        for (var h = [], u = 0; u < o.length; u++) h.push(o[u][l])
        s.push(h.join(ITEM_SPLITER))
      }
      t.push(s.join('\n'))
    }),
    t.join('\n\n' + BLOCK_SPLITER + '\n\n')
  )
}
function assembleOtherSeries(e) {
  return map$1(e, function (e) {
    var t = e.getRawData(),
      i = [e.name],
      r = []
    return (
      t.each(t.dimensions, function () {
        for (
          var e = arguments.length, n = arguments[e - 1], a = t.getName(n), o = 0;
          o < e - 1;
          o++
        )
          r[o] = arguments[o]
        i.push((a ? a + ITEM_SPLITER : '') + r.join(ITEM_SPLITER))
      }),
      i.join('\n')
    )
  }).join('\n\n' + BLOCK_SPLITER + '\n\n')
}
function getContentFromModel(e) {
  var t = groupSeries(e)
  return {
    value: filter$1(
      [assembleSeriesWithCategoryAxis(t.seriesGroupByCategoryAxis), assembleOtherSeries(t.other)],
      function (e) {
        return !!e.replace(/[\n\t\s]/g, '')
      }
    ).join('\n\n' + BLOCK_SPLITER + '\n\n'),
    meta: t.meta
  }
}
function trim(e) {
  return e.replace(/^\s\s*/, '').replace(/\s\s*$/, '')
}
function isTSVFormat(e) {
  if (e.slice(0, e.indexOf('\n')).indexOf(ITEM_SPLITER) >= 0) return !0
}
var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g')
function parseTSVContents(e) {
  for (
    var t = e.split(/\n+/g),
      i = [],
      r = map$1(trim(t.shift()).split(itemSplitRegex), function (e) {
        return { name: e, data: [] }
      }),
      n = 0;
    n < t.length;
    n++
  ) {
    var a = trim(t[n]).split(itemSplitRegex)
    i.push(a.shift())
    for (var o = 0; o < a.length; o++) r[o] && (r[o].data[n] = a[o])
  }
  return { series: r, categories: i }
}
function parseListContents(e) {
  for (var t = e.split(/\n+/g), i = trim(t.shift()), r = [], n = 0; n < t.length; n++) {
    var a = trim(t[n])
    if (a) {
      var o = a.split(itemSplitRegex),
        s = '',
        l = void 0,
        h = !1
      isNaN(o[0])
        ? ((h = !0),
          (s = o[0]),
          (o = o.slice(1)),
          (r[n] = { name: s, value: [] }),
          (l = r[n].value))
        : (l = r[n] = [])
      for (var u = 0; u < o.length; u++) l.push(+o[u])
      1 === l.length && (h ? (r[n].value = l[0]) : (r[n] = l[0]))
    }
  }
  return { name: i, data: r }
}
function parseContents(e, t) {
  var i = e.split(new RegExp('\n*' + BLOCK_SPLITER + '\n*', 'g')),
    r = { series: [] }
  return (
    each$i(i, function (e, i) {
      if (isTSVFormat(e)) {
        var n = parseTSVContents(e),
          a = t[i],
          o = a.axisDim + 'Axis'
        a &&
          ((r[o] = r[o] || []),
          (r[o][a.axisIndex] = { data: n.categories }),
          (r.series = r.series.concat(n.series)))
      } else {
        n = parseListContents(e)
        r.series.push(n)
      }
    }),
    r
  )
}
var DataView = (function (e) {
  function t() {
    return (null !== e && e.apply(this, arguments)) || this
  }
  return (
    __extends(t, e),
    (t.prototype.onclick = function (e, t) {
      var i = t.getDom(),
        r = this.model
      this._dom && i.removeChild(this._dom)
      var n = document.createElement('div')
      ;(n.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;'),
        (n.style.backgroundColor = r.get('backgroundColor') || '#fff')
      var a = document.createElement('h4'),
        o = r.get('lang') || []
      ;(a.innerHTML = o[0] || r.get('title')),
        (a.style.cssText = 'margin: 10px 20px;'),
        (a.style.color = r.get('textColor'))
      var s = document.createElement('div'),
        l = document.createElement('textarea')
      s.style.cssText = 'display:block;width:100%;overflow:auto;'
      var h = r.get('optionToContent'),
        u = r.get('contentToOption'),
        p = getContentFromModel(e)
      if ('function' == typeof h) {
        var c = h(t.getOption())
        'string' == typeof c ? (s.innerHTML = c) : isDom(c) && s.appendChild(c)
      } else
        s.appendChild(l),
          (l.readOnly = r.get('readOnly')),
          (l.style.cssText =
            'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;'),
          (l.style.color = r.get('textColor')),
          (l.style.borderColor = r.get('textareaBorderColor')),
          (l.style.backgroundColor = r.get('textareaColor')),
          (l.value = p.value)
      var d = p.meta,
        f = document.createElement('div')
      f.style.cssText = 'position:absolute;bottom:0;left:0;right:0;'
      var m =
          'float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px',
        g = document.createElement('div'),
        y = document.createElement('div')
      ;(m += ';background-color:' + r.get('buttonColor')),
        (m += ';color:' + r.get('buttonTextColor'))
      var v = this
      function _() {
        i.removeChild(n), (v._dom = null)
      }
      addEventListener(g, 'click', _),
        addEventListener(y, 'click', function () {
          if ((null == u && null != h) || (null != u && null == h)) _()
          else {
            var e
            try {
              e = 'function' == typeof u ? u(s, t.getOption()) : parseContents(l.value, d)
            } catch (i) {
              throw (_(), new Error('Data view format error ' + i))
            }
            e && t.dispatchAction({ type: 'changeDataView', newOption: e }), _()
          }
        }),
        (g.innerHTML = o[1]),
        (y.innerHTML = o[2]),
        (y.style.cssText = m),
        (g.style.cssText = m),
        !r.get('readOnly') && f.appendChild(y),
        f.appendChild(g),
        n.appendChild(a),
        n.appendChild(s),
        n.appendChild(f),
        (s.style.height = i.clientHeight - 80 + 'px'),
        i.appendChild(n),
        (this._dom = n)
    }),
    (t.prototype.remove = function (e, t) {
      this._dom && t.getDom().removeChild(this._dom)
    }),
    (t.prototype.dispose = function (e, t) {
      this.remove(e, t)
    }),
    (t.getDefaultOption = function (e) {
      return {
        show: !0,
        readOnly: !1,
        optionToContent: null,
        contentToOption: null,
        icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',
        title: e.getLocale(['toolbox', 'dataView', 'title']),
        lang: e.getLocale(['toolbox', 'dataView', 'lang']),
        backgroundColor: '#fff',
        textColor: '#000',
        textareaColor: '#fff',
        textareaBorderColor: '#333',
        buttonColor: '#c23531',
        buttonTextColor: '#fff'
      }
    }),
    t
  )
})(ToolboxFeature)
function tryMergeDataOption(e, t) {
  return map$1(e, function (e, i) {
    var r = t && t[i]
    if (isObject$7(r) && !isArray$1(r)) {
      ;(isObject$7(e) && !isArray$1(e)) || (e = { value: e })
      var n = null != r.name && null == e.name
      return (e = defaults$1(e, r)), n && delete e.name, e
    }
    return e
  })
}
registerAction(
  { type: 'changeDataView', event: 'dataViewChanged', update: 'prepareAndUpdate' },
  function (e, t) {
    var i = []
    each$i(e.newOption.series, function (e) {
      var r = t.getSeriesByName(e.name)[0]
      if (r) {
        var n = r.get('data')
        i.push({ name: e.name, data: tryMergeDataOption(e.data, n) })
      } else i.push(extend$3({ type: 'scatter' }, e))
    }),
      t.mergeOption(defaults$1({ series: i }, e.newOption))
  }
)
var each$8 = each$i,
  inner$6 = makeInner()
function push(e, t) {
  var i = getStoreSnapshots(e)
  each$8(t, function (t, r) {
    for (var n = i.length - 1; n >= 0; n--) {
      if (i[n][r]) break
    }
    if (n < 0) {
      var a = e.queryComponents({ mainType: 'dataZoom', subType: 'select', id: r })[0]
      if (a) {
        var o = a.getPercentRange()
        i[0][r] = { dataZoomId: r, start: o[0], end: o[1] }
      }
    }
  }),
    i.push(t)
}
function pop(e) {
  var t = getStoreSnapshots(e),
    i = t[t.length - 1]
  t.length > 1 && t.pop()
  var r = {}
  return (
    each$8(i, function (e, i) {
      for (var n = t.length - 1; n >= 0; n--)
        if ((e = t[n][i])) {
          r[i] = e
          break
        }
    }),
    r
  )
}
function clear(e) {
  inner$6(e).snapshots = null
}
function count(e) {
  return getStoreSnapshots(e).length
}
function getStoreSnapshots(e) {
  var t = inner$6(e)
  return t.snapshots || (t.snapshots = [{}]), t.snapshots
}
var RestoreOption = (function (e) {
  function t() {
    return (null !== e && e.apply(this, arguments)) || this
  }
  return (
    __extends(t, e),
    (t.prototype.onclick = function (e, t) {
      clear(e), t.dispatchAction({ type: 'restore', from: this.uid })
    }),
    (t.getDefaultOption = function (e) {
      return {
        show: !0,
        icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',
        title: e.getLocale(['toolbox', 'restore', 'title'])
      }
    }),
    t
  )
})(ToolboxFeature)
registerAction({ type: 'restore', event: 'restore', update: 'prepareAndUpdate' }, function (e, t) {
  t.resetOption('recreate')
})
var INCLUDE_FINDER_MAIN_TYPES = [
    'grid',
    'xAxis',
    'yAxis',
    'geo',
    'graph',
    'polar',
    'radiusAxis',
    'angleAxis',
    'bmap'
  ],
  BrushTargetManager = (function () {
    function e(e, t, i) {
      var r = this
      this._targetInfoList = []
      var n = parseFinder(t, e)
      each$i(targetInfoBuilders, function (e, t) {
        ;(!i || !i.include || indexOf$1(i.include, t) >= 0) && e(n, r._targetInfoList)
      })
    }
    return (
      (e.prototype.setOutputRanges = function (e, t) {
        return (
          this.matchOutputRanges(e, t, function (e, t, i) {
            if (((e.coordRanges || (e.coordRanges = [])).push(t), !e.coordRange)) {
              e.coordRange = t
              var r = coordConvert[e.brushType](0, i, t)
              e.__rangeOffset = {
                offset: diffProcessor[e.brushType](r.values, e.range, [1, 1]),
                xyMinMax: r.xyMinMax
              }
            }
          }),
          e
        )
      }),
      (e.prototype.matchOutputRanges = function (e, t, i) {
        each$i(
          e,
          function (e) {
            var r = this.findTargetInfo(e, t)
            r &&
              !0 !== r &&
              each$i(r.coordSyses, function (r) {
                var n = coordConvert[e.brushType](1, r, e.range, !0)
                i(e, n.values, r, t)
              })
          },
          this
        )
      }),
      (e.prototype.setInputRanges = function (e, t) {
        each$i(
          e,
          function (e) {
            var i = this.findTargetInfo(e, t)
            if (((e.range = e.range || []), i && !0 !== i)) {
              e.panelId = i.panelId
              var r = coordConvert[e.brushType](0, i.coordSys, e.coordRange),
                n = e.__rangeOffset
              e.range = n
                ? diffProcessor[e.brushType](r.values, n.offset, getScales(r.xyMinMax, n.xyMinMax))
                : r.values
            }
          },
          this
        )
      }),
      (e.prototype.makePanelOpts = function (e, t) {
        return map$1(this._targetInfoList, function (i) {
          var r = i.getPanelRect()
          return {
            panelId: i.panelId,
            defaultBrushType: t ? t(i) : null,
            clipPath: makeRectPanelClipPath(r),
            isTargetByCursor: makeRectIsTargetByCursor(r, e, i.coordSysModel),
            getLinearBrushOtherExtent: makeLinearBrushOtherExtent(r)
          }
        })
      }),
      (e.prototype.controlSeries = function (e, t, i) {
        var r = this.findTargetInfo(e, i)
        return !0 === r || (r && indexOf$1(r.coordSyses, t.coordinateSystem) >= 0)
      }),
      (e.prototype.findTargetInfo = function (e, t) {
        for (var i = this._targetInfoList, r = parseFinder(t, e), n = 0; n < i.length; n++) {
          var a = i[n],
            o = e.panelId
          if (o) {
            if (a.panelId === o) return a
          } else
            for (var s = 0; s < targetInfoMatchers.length; s++)
              if (targetInfoMatchers[s](r, a)) return a
        }
        return !0
      }),
      e
    )
  })()
function formatMinMax(e) {
  return e[0] > e[1] && e.reverse(), e
}
function parseFinder(e, t) {
  return parseFinder$1(e, t, { includeMainTypes: INCLUDE_FINDER_MAIN_TYPES })
}
var targetInfoBuilders = {
    grid: function (e, t) {
      var i = e.xAxisModels,
        r = e.yAxisModels,
        n = e.gridModels,
        a = createHashMap(),
        o = {},
        s = {}
      ;(i || r || n) &&
        (each$i(i, function (e) {
          var t = e.axis.grid.model
          a.set(t.id, t), (o[t.id] = !0)
        }),
        each$i(r, function (e) {
          var t = e.axis.grid.model
          a.set(t.id, t), (s[t.id] = !0)
        }),
        each$i(n, function (e) {
          a.set(e.id, e), (o[e.id] = !0), (s[e.id] = !0)
        }),
        a.each(function (e) {
          var n = e.coordinateSystem,
            a = []
          each$i(n.getCartesians(), function (e, t) {
            ;(indexOf$1(i, e.getAxis('x').model) >= 0 || indexOf$1(r, e.getAxis('y').model) >= 0) &&
              a.push(e)
          }),
            t.push({
              panelId: 'grid--' + e.id,
              gridModel: e,
              coordSysModel: e,
              coordSys: a[0],
              coordSyses: a,
              getPanelRect: panelRectBuilders.grid,
              xAxisDeclared: o[e.id],
              yAxisDeclared: s[e.id]
            })
        }))
    },
    geo: function (e, t) {
      each$i(e.geoModels, function (e) {
        var i = e.coordinateSystem
        t.push({
          panelId: 'geo--' + e.id,
          geoModel: e,
          coordSysModel: e,
          coordSys: i,
          coordSyses: [i],
          getPanelRect: panelRectBuilders.geo
        })
      })
    }
  },
  targetInfoMatchers = [
    function (e, t) {
      var i = e.xAxisModel,
        r = e.yAxisModel,
        n = e.gridModel
      return (
        !n && i && (n = i.axis.grid.model),
        !n && r && (n = r.axis.grid.model),
        n && n === t.gridModel
      )
    },
    function (e, t) {
      var i = e.geoModel
      return i && i === t.geoModel
    }
  ],
  panelRectBuilders = {
    grid: function () {
      return this.coordSys.master.getRect().clone()
    },
    geo: function () {
      var e = this.coordSys,
        t = e.getBoundingRect().clone()
      return t.applyTransform(getTransform$1(e)), t
    }
  },
  coordConvert = {
    lineX: curry$1(axisConvert, 0),
    lineY: curry$1(axisConvert, 1),
    rect: function (e, t, i, r) {
      var n = e ? t.pointToData([i[0][0], i[1][0]], r) : t.dataToPoint([i[0][0], i[1][0]], r),
        a = e ? t.pointToData([i[0][1], i[1][1]], r) : t.dataToPoint([i[0][1], i[1][1]], r),
        o = [formatMinMax([n[0], a[0]]), formatMinMax([n[1], a[1]])]
      return { values: o, xyMinMax: o }
    },
    polygon: function (e, t, i, r) {
      var n = [
        [1 / 0, -1 / 0],
        [1 / 0, -1 / 0]
      ]
      return {
        values: map$1(i, function (i) {
          var a = e ? t.pointToData(i, r) : t.dataToPoint(i, r)
          return (
            (n[0][0] = Math.min(n[0][0], a[0])),
            (n[1][0] = Math.min(n[1][0], a[1])),
            (n[0][1] = Math.max(n[0][1], a[0])),
            (n[1][1] = Math.max(n[1][1], a[1])),
            a
          )
        }),
        xyMinMax: n
      }
    }
  }
function axisConvert(e, t, i, r) {
  var n = i.getAxis(['x', 'y'][e]),
    a = formatMinMax(
      map$1([0, 1], function (e) {
        return t ? n.coordToData(n.toLocalCoord(r[e]), !0) : n.toGlobalCoord(n.dataToCoord(r[e]))
      })
    ),
    o = []
  return (o[e] = a), (o[1 - e] = [NaN, NaN]), { values: a, xyMinMax: o }
}
var diffProcessor = {
  lineX: curry$1(axisDiffProcessor, 0),
  lineY: curry$1(axisDiffProcessor, 1),
  rect: function (e, t, i) {
    return [
      [e[0][0] - i[0] * t[0][0], e[0][1] - i[0] * t[0][1]],
      [e[1][0] - i[1] * t[1][0], e[1][1] - i[1] * t[1][1]]
    ]
  },
  polygon: function (e, t, i) {
    return map$1(e, function (e, r) {
      return [e[0] - i[0] * t[r][0], e[1] - i[1] * t[r][1]]
    })
  }
}
function axisDiffProcessor(e, t, i, r) {
  return [t[0] - r[e] * i[0], t[1] - r[e] * i[1]]
}
function getScales(e, t) {
  var i = getSize(e),
    r = getSize(t),
    n = [i[0] / r[0], i[1] / r[1]]
  return isNaN(n[0]) && (n[0] = 1), isNaN(n[1]) && (n[1] = 1), n
}
function getSize(e) {
  return e ? [e[0][1] - e[0][0], e[1][1] - e[1][0]] : [NaN, NaN]
}
var each$7 = each$i,
  DATA_ZOOM_ID_BASE = makeInternalComponentId('toolbox-dataZoom_'),
  DataZoomFeature = (function (e) {
    function t() {
      return (null !== e && e.apply(this, arguments)) || this
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i, r) {
        this._brushController ||
          ((this._brushController = new BrushController(i.getZr())),
          this._brushController.on('brush', bind$2(this._onBrush, this)).mount()),
          updateZoomBtnStatus(e, t, this, r, i),
          updateBackBtnStatus(e, t)
      }),
      (t.prototype.onclick = function (e, t, i) {
        handlers[i].call(this)
      }),
      (t.prototype.remove = function (e, t) {
        this._brushController && this._brushController.unmount()
      }),
      (t.prototype.dispose = function (e, t) {
        this._brushController && this._brushController.dispose()
      }),
      (t.prototype._onBrush = function (e) {
        var t = e.areas
        if (e.isEnd && t.length) {
          var i = {},
            r = this.ecModel
          this._brushController.updateCovers([]),
            new BrushTargetManager(makeAxisFinder(this.model), r, {
              include: ['grid']
            }).matchOutputRanges(t, r, function (e, t, i) {
              if ('cartesian2d' === i.type) {
                var r = e.brushType
                'rect' === r
                  ? (n('x', i, t[0]), n('y', i, t[1]))
                  : n({ lineX: 'x', lineY: 'y' }[r], i, t)
              }
            }),
            push(r, i),
            this._dispatchZoomAction(i)
        }
        function n(e, t, n) {
          var a = t.getAxis(e),
            o = a.model,
            s = (function (e, t, i) {
              var r
              return (
                i.eachComponent({ mainType: 'dataZoom', subType: 'select' }, function (i) {
                  i.getAxisModel(e, t.componentIndex) && (r = i)
                }),
                r
              )
            })(e, o, r),
            l = s.findRepresentativeAxisProxy(o).getMinMaxSpan()
          ;(null == l.minValueSpan && null == l.maxValueSpan) ||
            (n = sliderMove(0, n.slice(), a.scale.getExtent(), 0, l.minValueSpan, l.maxValueSpan)),
            s && (i[s.id] = { dataZoomId: s.id, startValue: n[0], endValue: n[1] })
        }
      }),
      (t.prototype._dispatchZoomAction = function (e) {
        var t = []
        each$7(e, function (e, i) {
          t.push(clone$3(e))
        }),
          t.length && this.api.dispatchAction({ type: 'dataZoom', from: this.uid, batch: t })
      }),
      (t.getDefaultOption = function (e) {
        return {
          show: !0,
          filterMode: 'filter',
          icon: {
            zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',
            back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'
          },
          title: e.getLocale(['toolbox', 'dataZoom', 'title']),
          brushStyle: { borderWidth: 0, color: 'rgba(210,219,238,0.2)' }
        }
      }),
      t
    )
  })(ToolboxFeature),
  handlers = {
    zoom: function () {
      var e = !this._isZoomActive
      this.api.dispatchAction({
        type: 'takeGlobalCursor',
        key: 'dataZoomSelect',
        dataZoomSelectActive: e
      })
    },
    back: function () {
      this._dispatchZoomAction(pop(this.ecModel))
    }
  }
function makeAxisFinder(e) {
  var t = {
    xAxisIndex: e.get('xAxisIndex', !0),
    yAxisIndex: e.get('yAxisIndex', !0),
    xAxisId: e.get('xAxisId', !0),
    yAxisId: e.get('yAxisId', !0)
  }
  return (
    null == t.xAxisIndex && null == t.xAxisId && (t.xAxisIndex = 'all'),
    null == t.yAxisIndex && null == t.yAxisId && (t.yAxisIndex = 'all'),
    t
  )
}
function updateBackBtnStatus(e, t) {
  e.setIconStatus('back', count(t) > 1 ? 'emphasis' : 'normal')
}
function updateZoomBtnStatus(e, t, i, r, n) {
  var a = i._isZoomActive
  r && 'takeGlobalCursor' === r.type && (a = 'dataZoomSelect' === r.key && r.dataZoomSelectActive),
    (i._isZoomActive = a),
    e.setIconStatus('zoom', a ? 'emphasis' : 'normal')
  var o = new BrushTargetManager(makeAxisFinder(e), t, { include: ['grid'] }).makePanelOpts(
    n,
    function (e) {
      return e.xAxisDeclared && !e.yAxisDeclared
        ? 'lineX'
        : !e.xAxisDeclared && e.yAxisDeclared
        ? 'lineY'
        : 'rect'
    }
  )
  i._brushController.setPanels(o).enableBrush(
    !(!a || !o.length) && {
      brushType: 'auto',
      brushStyle: e.getModel('brushStyle').getItemStyle()
    }
  )
}
function install$j(e) {
  e.registerComponentModel(ToolboxModel),
    e.registerComponentView(ToolboxView),
    registerFeature('saveAsImage', SaveAsImage),
    registerFeature('magicType', MagicType),
    registerFeature('dataView', DataView),
    registerFeature('dataZoom', DataZoomFeature),
    registerFeature('restore', RestoreOption),
    use(install$k)
}
registerInternalOptionCreator('dataZoom', function (e) {
  var t = e.getComponent('toolbox', 0),
    i = ['feature', 'dataZoom']
  if (t && null != t.get(i)) {
    var r = t.getModel(i),
      n = [],
      a = parseFinder$1(e, makeAxisFinder(r))
    return (
      each$7(a.xAxisModels, function (e) {
        return o(e, 'xAxis', 'xAxisIndex')
      }),
      each$7(a.yAxisModels, function (e) {
        return o(e, 'yAxis', 'yAxisIndex')
      }),
      n
    )
  }
  function o(e, t, i) {
    var a = e.componentIndex,
      o = {
        type: 'select',
        $fromToolbox: !0,
        filterMode: r.get('filterMode', !0) || 'filter',
        id: DATA_ZOOM_ID_BASE + t + a
      }
    ;(o[i] = a), n.push(o)
  }
})
var TooltipModel = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), i
  }
  return (
    __extends(t, e),
    (t.type = 'tooltip'),
    (t.dependencies = ['axisPointer']),
    (t.defaultOption = {
      zlevel: 0,
      z: 60,
      show: !0,
      showContent: !0,
      trigger: 'item',
      triggerOn: 'mousemove|click',
      alwaysShowContent: !1,
      displayMode: 'single',
      renderMode: 'auto',
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      transitionDuration: 0.4,
      enterable: !1,
      backgroundColor: '#fff',
      shadowBlur: 10,
      shadowColor: 'rgba(0, 0, 0, .2)',
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      borderRadius: 4,
      borderWidth: 1,
      padding: null,
      extraCssText: '',
      axisPointer: {
        type: 'line',
        axis: 'auto',
        animation: 'auto',
        animationDurationUpdate: 200,
        animationEasingUpdate: 'exponentialOut',
        crossStyle: { color: '#999', width: 1, type: 'dashed', textStyle: {} }
      },
      textStyle: { color: '#666', fontSize: 14 }
    }),
    t
  )
})(ComponentModel)
function shouldTooltipConfine(e) {
  var t = e.get('confine')
  return null != t ? !!t : 'richText' === e.get('renderMode')
}
function testStyle(e) {
  if (env.domSupported)
    for (var t = document.documentElement.style, i = 0, r = e.length; i < r; i++)
      if (e[i] in t) return e[i]
}
var TRANSFORM_VENDOR = testStyle([
    'transform',
    'webkitTransform',
    'OTransform',
    'MozTransform',
    'msTransform'
  ]),
  TRANSITION_VENDOR = testStyle([
    'webkitTransition',
    'transition',
    'OTransition',
    'MozTransition',
    'msTransition'
  ])
function toCSSVendorPrefix(e, t) {
  if (!e) return t
  t = toCamelCase(t, !0)
  var i = e.indexOf(t)
  return (e = -1 === i ? t : '-' + e.slice(0, i) + '-' + t).toLowerCase()
}
function getComputedStyle$2(e, t) {
  var i = e.currentStyle || (document.defaultView && document.defaultView.getComputedStyle(e))
  return i ? (t ? i[t] : i) : null
}
var CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, 'transition'),
  CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, 'transform'),
  gCssText =
    'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;' +
    (env.transform3dSupported ? 'will-change:transform;' : '')
function mirrorPos(e) {
  return (e = 'left' === e ? 'right' : 'right' === e ? 'left' : 'top' === e ? 'bottom' : 'top')
}
function assembleArrow(e, t, i) {
  if (!isString(i) || 'inside' === i) return ''
  t = convertToColorString(t)
  var r = mirrorPos(i),
    n = r + ':-6px;',
    a = CSS_TRANSFORM_VENDOR + ':'
  indexOf$1(['left', 'right'], r) > -1
    ? ((n += 'top:50%'), (a += 'translateY(-50%) rotate(' + ('left' === r ? -225 : -45) + 'deg)'))
    : ((n += 'left:50%'), (a += 'translateX(-50%) rotate(' + ('top' === r ? 225 : 45) + 'deg)'))
  var o = t + ' solid 1px;'
  return (
    '<div style="' +
    [
      'position:absolute;width:10px;height:10px;',
      n + ';' + a + ';',
      'border-bottom:' + o,
      'border-right:' + o,
      'background-color:' + e + ';',
      'box-shadow:8px 8px 16px -3px #000;'
    ].join('') +
    '"></div>'
  )
}
function assembleTransition(e, t) {
  var i = 'cubic-bezier(0.23,1,0.32,1)',
    r = ' ' + e / 2 + 's ' + i,
    n = 'opacity' + r + ',visibility' + r
  return (
    t ||
      ((r = ' ' + e + 's ' + i),
      (n += env.transformSupported ? ',' + CSS_TRANSFORM_VENDOR + r : ',left' + r + ',top' + r)),
    CSS_TRANSITION_VENDOR + ':' + n
  )
}
function assembleTransform(e, t, i) {
  var r = e.toFixed(0) + 'px',
    n = t.toFixed(0) + 'px'
  if (!env.transformSupported)
    return i
      ? 'top:' + n + ';left:' + r + ';'
      : [
          ['top', n],
          ['left', r]
        ]
  var a = env.transform3dSupported,
    o = 'translate' + (a ? '3d' : '') + '(' + r + ',' + n + (a ? ',0' : '') + ')'
  return i
    ? 'top:0;left:0;' + CSS_TRANSFORM_VENDOR + ':' + o + ';'
    : [
        ['top', 0],
        ['left', 0],
        [TRANSFORM_VENDOR, o]
      ]
}
function assembleFont(e) {
  var t = [],
    i = e.get('fontSize'),
    r = e.getTextColor()
  r && t.push('color:' + r),
    t.push('font:' + e.getFont()),
    i && t.push('line-height:' + Math.round((3 * i) / 2) + 'px')
  var n = e.get('textShadowColor'),
    a = e.get('textShadowBlur') || 0,
    o = e.get('textShadowOffsetX') || 0,
    s = e.get('textShadowOffsetY') || 0
  return (
    n && a && t.push('text-shadow:' + o + 'px ' + s + 'px ' + a + 'px ' + n),
    each$i(['decoration', 'align'], function (i) {
      var r = e.get(i)
      r && t.push('text-' + i + ':' + r)
    }),
    t.join(';')
  )
}
function assembleCssText(e, t, i) {
  var r = [],
    n = e.get('transitionDuration'),
    a = e.get('backgroundColor'),
    o = e.get('shadowBlur'),
    s = e.get('shadowColor'),
    l = e.get('shadowOffsetX'),
    h = e.get('shadowOffsetY'),
    u = e.getModel('textStyle'),
    p = getPaddingFromTooltipModel(e, 'html'),
    c = l + 'px ' + h + 'px ' + o + 'px ' + s
  return (
    r.push('box-shadow:' + c),
    t && n && r.push(assembleTransition(n, i)),
    a &&
      (env.canvasSupported
        ? r.push('background-color:' + a)
        : (r.push('background-color:#' + toHex(a)), r.push('filter:alpha(opacity=70)'))),
    each$i(['width', 'color', 'radius'], function (t) {
      var i = 'border-' + t,
        n = toCamelCase(i),
        a = e.get(n)
      null != a && r.push(i + ':' + a + ('color' === t ? '' : 'px'))
    }),
    r.push(assembleFont(u)),
    null != p && r.push('padding:' + normalizeCssArray(p).join('px ') + 'px'),
    r.join(';') + ';'
  )
}
function makeStyleCoord$1(e, t, i, r, n) {
  var a = t && t.painter
  if (i) {
    var o = a && a.getViewportRoot()
    o && transformLocalCoord(e, o, document.body, r, n)
  } else {
    ;(e[0] = r), (e[1] = n)
    var s = a && a.getViewportRootOffset()
    s && ((e[0] += s.offsetLeft), (e[1] += s.offsetTop))
  }
  ;(e[2] = e[0] / t.getWidth()), (e[3] = e[1] / t.getHeight())
}
var TooltipHTMLContent = (function () {
    function e(e, t, i) {
      if (
        ((this._show = !1),
        (this._styleCoord = [0, 0, 0, 0]),
        (this._enterable = !0),
        (this._firstShow = !0),
        (this._longHide = !0),
        env.wxa)
      )
        return null
      var r = document.createElement('div')
      ;(r.domBelongToZr = !0), (this.el = r)
      var n = (this._zr = t.getZr()),
        a = (this._appendToBody = i && i.appendToBody)
      makeStyleCoord$1(this._styleCoord, n, a, t.getWidth() / 2, t.getHeight() / 2),
        a ? document.body.appendChild(r) : e.appendChild(r),
        (this._container = e)
      var o = this
      ;(r.onmouseenter = function () {
        o._enterable && (clearTimeout(o._hideTimeout), (o._show = !0)), (o._inContent = !0)
      }),
        (r.onmousemove = function (e) {
          if (((e = e || window.event), !o._enterable)) {
            var t = n.handler
            normalizeEvent(n.painter.getViewportRoot(), e, !0), t.dispatch('mousemove', e)
          }
        }),
        (r.onmouseleave = function () {
          ;(o._inContent = !1), o._enterable && o._show && o.hideLater(o._hideDelay)
        })
    }
    return (
      (e.prototype.update = function (e) {
        var t = this._container,
          i = getComputedStyle$2(t, 'position'),
          r = t.style
        'absolute' !== r.position && 'absolute' !== i && (r.position = 'relative'),
          e.get('alwaysShowContent') && this._moveIfResized(),
          (this.el.className = e.get('className') || '')
      }),
      (e.prototype.show = function (e, t) {
        clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout)
        var i = this.el,
          r = i.style,
          n = this._styleCoord
        i.innerHTML
          ? (r.cssText =
              gCssText +
              assembleCssText(e, !this._firstShow, this._longHide) +
              assembleTransform(n[0], n[1], !0) +
              'border-color:' +
              convertToColorString(t) +
              ';' +
              (e.get('extraCssText') || '') +
              ';pointer-event:' +
              (this._enterable ? 'auto' : 'none'))
          : (r.display = 'none'),
          (this._show = !0),
          (this._firstShow = !1),
          (this._longHide = !1)
      }),
      (e.prototype.setContent = function (e, t, i, r, n) {
        if (null != e) {
          var a = this.el
          if (
            (isString(n) &&
              'item' === i.get('trigger') &&
              !shouldTooltipConfine(i) &&
              (e += assembleArrow(i.get('backgroundColor'), r, n)),
            isString(e))
          )
            a.innerHTML = e
          else if (e) {
            ;(a.innerHTML = ''), isArray$1(e) || (e = [e])
            for (var o = 0; o < e.length; o++)
              isDom(e[o]) && e[o].parentNode !== a && a.appendChild(e[o])
          }
        }
      }),
      (e.prototype.setEnterable = function (e) {
        this._enterable = e
      }),
      (e.prototype.getSize = function () {
        var e = this.el
        return [e.clientWidth, e.clientHeight]
      }),
      (e.prototype.moveTo = function (e, t) {
        var i = this._styleCoord
        if (
          (makeStyleCoord$1(i, this._zr, this._appendToBody, e, t), null != i[0] && null != i[1])
        ) {
          var r = this.el.style
          each$i(assembleTransform(i[0], i[1]), function (e) {
            r[e[0]] = e[1]
          })
        }
      }),
      (e.prototype._moveIfResized = function () {
        var e = this._styleCoord[2],
          t = this._styleCoord[3]
        this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight())
      }),
      (e.prototype.hide = function () {
        var e = this,
          t = this.el.style
        ;(t.visibility = 'hidden'),
          (t.opacity = '0'),
          env.transform3dSupported && (t.willChange = ''),
          (this._show = !1),
          (this._longHideTimeout = setTimeout(function () {
            return (e._longHide = !0)
          }, 500))
      }),
      (e.prototype.hideLater = function (e) {
        !this._show ||
          (this._inContent && this._enterable) ||
          (e
            ? ((this._hideDelay = e),
              (this._show = !1),
              (this._hideTimeout = setTimeout(bind$2(this.hide, this), e)))
            : this.hide())
      }),
      (e.prototype.isShow = function () {
        return this._show
      }),
      (e.prototype.dispose = function () {
        this.el.parentNode.removeChild(this.el)
      }),
      (e.prototype.getOuterSize = function () {
        var e = this.el.clientWidth,
          t = this.el.clientHeight,
          i = getComputedStyle$2(this.el)
        return (
          i &&
            ((e += parseInt(i.borderLeftWidth, 10) + parseInt(i.borderRightWidth, 10)),
            (t += parseInt(i.borderTopWidth, 10) + parseInt(i.borderBottomWidth, 10))),
          { width: e, height: t }
        )
      }),
      e
    )
  })(),
  TooltipRichContent = (function () {
    function e(e) {
      ;(this._show = !1),
        (this._styleCoord = [0, 0, 0, 0]),
        (this._enterable = !0),
        (this._zr = e.getZr()),
        makeStyleCoord(this._styleCoord, this._zr, e.getWidth() / 2, e.getHeight() / 2)
    }
    return (
      (e.prototype.update = function (e) {
        e.get('alwaysShowContent') && this._moveIfResized()
      }),
      (e.prototype.show = function () {
        this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), (this._show = !0)
      }),
      (e.prototype.setContent = function (e, t, i, r, n) {
        isObject$7(e) && throwError(''), this.el && this._zr.remove(this.el)
        var a = i.getModel('textStyle')
        ;(this.el = new ZRText({
          style: {
            rich: t.richTextStyles,
            text: e,
            lineHeight: 22,
            backgroundColor: i.get('backgroundColor'),
            borderRadius: i.get('borderRadius'),
            borderWidth: 1,
            borderColor: r,
            shadowColor: i.get('shadowColor'),
            shadowBlur: i.get('shadowBlur'),
            shadowOffsetX: i.get('shadowOffsetX'),
            shadowOffsetY: i.get('shadowOffsetY'),
            textShadowColor: a.get('textShadowColor'),
            textShadowBlur: a.get('textShadowBlur') || 0,
            textShadowOffsetX: a.get('textShadowOffsetX') || 0,
            textShadowOffsetY: a.get('textShadowOffsetY') || 0,
            fill: i.get(['textStyle', 'color']),
            padding: getPaddingFromTooltipModel(i, 'richText'),
            verticalAlign: 'top',
            align: 'left'
          },
          z: i.get('z')
        })),
          this._zr.add(this.el)
        var o = this
        this.el.on('mouseover', function () {
          o._enterable && (clearTimeout(o._hideTimeout), (o._show = !0)), (o._inContent = !0)
        }),
          this.el.on('mouseout', function () {
            o._enterable && o._show && o.hideLater(o._hideDelay), (o._inContent = !1)
          })
      }),
      (e.prototype.setEnterable = function (e) {
        this._enterable = e
      }),
      (e.prototype.getSize = function () {
        var e = this.el,
          t = this.el.getBoundingRect(),
          i = calcShadowOuterSize(e.style)
        return [t.width + i.left + i.right, t.height + i.top + i.bottom]
      }),
      (e.prototype.moveTo = function (e, t) {
        var i = this.el
        if (i) {
          var r = this._styleCoord
          makeStyleCoord(r, this._zr, e, t), (e = r[0]), (t = r[1])
          var n = i.style,
            a = mathMaxWith0(n.borderWidth || 0),
            o = calcShadowOuterSize(n)
          ;(i.x = e + a + o.left), (i.y = t + a + o.top), i.markRedraw()
        }
      }),
      (e.prototype._moveIfResized = function () {
        var e = this._styleCoord[2],
          t = this._styleCoord[3]
        this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight())
      }),
      (e.prototype.hide = function () {
        this.el && this.el.hide(), (this._show = !1)
      }),
      (e.prototype.hideLater = function (e) {
        !this._show ||
          (this._inContent && this._enterable) ||
          (e
            ? ((this._hideDelay = e),
              (this._show = !1),
              (this._hideTimeout = setTimeout(bind$2(this.hide, this), e)))
            : this.hide())
      }),
      (e.prototype.isShow = function () {
        return this._show
      }),
      (e.prototype.getOuterSize = function () {
        var e = this.getSize()
        return { width: e[0], height: e[1] }
      }),
      (e.prototype.dispose = function () {
        this._zr.remove(this.el)
      }),
      e
    )
  })()
function mathMaxWith0(e) {
  return Math.max(0, e)
}
function calcShadowOuterSize(e) {
  var t = mathMaxWith0(e.shadowBlur || 0),
    i = mathMaxWith0(e.shadowOffsetX || 0),
    r = mathMaxWith0(e.shadowOffsetY || 0)
  return {
    left: mathMaxWith0(t - i),
    right: mathMaxWith0(t + i),
    top: mathMaxWith0(t - r),
    bottom: mathMaxWith0(t + r)
  }
}
function makeStyleCoord(e, t, i, r) {
  ;(e[0] = i), (e[1] = r), (e[2] = e[0] / t.getWidth()), (e[3] = e[1] / t.getHeight())
}
var bind = bind$2,
  each$6 = each$i,
  parsePercent = parsePercent$1,
  proxyRect = new Rect$2({ shape: { x: -1, y: -1, width: 2, height: 2 } }),
  TooltipView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (e, t) {
        if (!env.node) {
          var i = e.getComponent('tooltip'),
            r = i.get('renderMode')
          ;(this._renderMode = getTooltipRenderMode(r)),
            (this._tooltipContent =
              'richText' === this._renderMode
                ? new TooltipRichContent(t)
                : new TooltipHTMLContent(t.getDom(), t, {
                    appendToBody: i.get('appendToBody', !0)
                  }))
        }
      }),
      (t.prototype.render = function (e, t, i) {
        if (!env.node) {
          this.group.removeAll(),
            (this._tooltipModel = e),
            (this._ecModel = t),
            (this._api = i),
            (this._alwaysShowContent = e.get('alwaysShowContent'))
          var r = this._tooltipContent
          r.update(e),
            r.setEnterable(e.get('enterable')),
            this._initGlobalListener(),
            this._keepShow()
        }
      }),
      (t.prototype._initGlobalListener = function () {
        var e = this._tooltipModel.get('triggerOn')
        register(
          'itemTooltip',
          this._api,
          bind(function (t, i, r) {
            'none' !== e &&
              (e.indexOf(t) >= 0 ? this._tryShow(i, r) : 'leave' === t && this._hide(r))
          }, this)
        )
      }),
      (t.prototype._keepShow = function () {
        var e = this._tooltipModel,
          t = this._ecModel,
          i = this._api
        if (null != this._lastX && null != this._lastY && 'none' !== e.get('triggerOn')) {
          var r = this
          clearTimeout(this._refreshUpdateTimeout),
            (this._refreshUpdateTimeout = setTimeout(function () {
              !i.isDisposed() &&
                r.manuallyShowTip(e, t, i, {
                  x: r._lastX,
                  y: r._lastY,
                  dataByCoordSys: r._lastDataByCoordSys
                })
            }))
        }
      }),
      (t.prototype.manuallyShowTip = function (e, t, i, r) {
        if (r.from !== this.uid && !env.node) {
          var n = makeDispatchAction(r, i)
          this._ticket = ''
          var a = r.dataByCoordSys,
            o = findComponentReference(r, t, i)
          if (o) {
            var s = o.el.getBoundingRect().clone()
            s.applyTransform(o.el.transform),
              this._tryShow(
                {
                  offsetX: s.x + s.width / 2,
                  offsetY: s.y + s.height / 2,
                  target: o.el,
                  position: r.position,
                  positionDefault: 'bottom'
                },
                n
              )
          } else if (r.tooltip && null != r.x && null != r.y) {
            var l = proxyRect
            ;(l.x = r.x),
              (l.y = r.y),
              l.update(),
              (getECData(l).tooltipConfig = { name: null, option: r.tooltip }),
              this._tryShow({ offsetX: r.x, offsetY: r.y, target: l }, n)
          } else if (a)
            this._tryShow(
              {
                offsetX: r.x,
                offsetY: r.y,
                position: r.position,
                dataByCoordSys: a,
                tooltipOption: r.tooltipOption
              },
              n
            )
          else if (null != r.seriesIndex) {
            if (this._manuallyAxisShowTip(e, t, i, r)) return
            var h = findPointFromSeries(r, t),
              u = h.point[0],
              p = h.point[1]
            null != u &&
              null != p &&
              this._tryShow(
                {
                  offsetX: u,
                  offsetY: p,
                  target: h.el,
                  position: r.position,
                  positionDefault: 'bottom'
                },
                n
              )
          } else
            null != r.x &&
              null != r.y &&
              (i.dispatchAction({ type: 'updateAxisPointer', x: r.x, y: r.y }),
              this._tryShow(
                {
                  offsetX: r.x,
                  offsetY: r.y,
                  position: r.position,
                  target: i.getZr().findHover(r.x, r.y).target
                },
                n
              ))
        }
      }),
      (t.prototype.manuallyHideTip = function (e, t, i, r) {
        var n = this._tooltipContent
        !this._alwaysShowContent &&
          this._tooltipModel &&
          n.hideLater(this._tooltipModel.get('hideDelay')),
          (this._lastX = this._lastY = this._lastDataByCoordSys = null),
          r.from !== this.uid && this._hide(makeDispatchAction(r, i))
      }),
      (t.prototype._manuallyAxisShowTip = function (e, t, i, r) {
        var n = r.seriesIndex,
          a = r.dataIndex,
          o = t.getComponent('axisPointer').coordSysAxesInfo
        if (null != n && null != a && null != o) {
          var s = t.getSeriesByIndex(n)
          if (s)
            if (
              'axis' ===
              buildTooltipModel(
                [s.getData().getItemModel(a), s, (s.coordinateSystem || {}).model],
                this._tooltipModel
              ).get('trigger')
            )
              return (
                i.dispatchAction({
                  type: 'updateAxisPointer',
                  seriesIndex: n,
                  dataIndex: a,
                  position: r.position
                }),
                !0
              )
        }
      }),
      (t.prototype._tryShow = function (e, t) {
        var i = e.target
        if (this._tooltipModel) {
          ;(this._lastX = e.offsetX), (this._lastY = e.offsetY)
          var r = e.dataByCoordSys
          if (r && r.length) this._showAxisTooltip(r, e)
          else if (i) {
            var n, a
            ;(this._lastDataByCoordSys = null),
              findEventDispatcher(
                i,
                function (e) {
                  return null != getECData(e).dataIndex
                    ? ((n = e), !0)
                    : null != getECData(e).tooltipConfig
                    ? ((a = e), !0)
                    : void 0
                },
                !0
              ),
              n
                ? this._showSeriesItemTooltip(e, n, t)
                : a
                ? this._showComponentItemTooltip(e, a, t)
                : this._hide(t)
          } else (this._lastDataByCoordSys = null), this._hide(t)
        }
      }),
      (t.prototype._showOrMove = function (e, t) {
        var i = e.get('showDelay')
        ;(t = bind$2(t, this)),
          clearTimeout(this._showTimout),
          i > 0 ? (this._showTimout = setTimeout(t, i)) : t()
      }),
      (t.prototype._showAxisTooltip = function (e, t) {
        var i = this._ecModel,
          r = this._tooltipModel,
          n = [t.offsetX, t.offsetY],
          a = buildTooltipModel([t.tooltipOption], r),
          o = this._renderMode,
          s = [],
          l = createTooltipMarkup('section', { blocks: [], noHeader: !0 }),
          h = [],
          u = new TooltipMarkupStyleCreator()
        each$6(e, function (e) {
          each$6(e.dataByAxis, function (e) {
            var t = i.getComponent(e.axisDim + 'Axis', e.axisIndex),
              r = e.value
            if (t && null != r) {
              var n = getValueLabel(r, t.axis, i, e.seriesDataIndices, e.valueLabelOpt),
                a = createTooltipMarkup('section', {
                  header: n,
                  noHeader: !trim$1(n),
                  sortBlocks: !0,
                  blocks: []
                })
              l.blocks.push(a),
                each$i(e.seriesDataIndices, function (l) {
                  var p = i.getSeriesByIndex(l.seriesIndex),
                    c = l.dataIndexInside,
                    d = p.getDataParams(c)
                  ;(d.axisDim = e.axisDim),
                    (d.axisIndex = e.axisIndex),
                    (d.axisType = e.axisType),
                    (d.axisId = e.axisId),
                    (d.axisValue = getAxisRawValue(t.axis, { value: r })),
                    (d.axisValueLabel = n),
                    (d.marker = u.makeTooltipMarker('item', convertToColorString(d.color), o))
                  var f = normalizeTooltipFormatResult(p.formatTooltip(c, !0, null))
                  f.markupFragment && a.blocks.push(f.markupFragment),
                    f.markupText && h.push(f.markupText),
                    s.push(d)
                })
            }
          })
        }),
          l.blocks.reverse(),
          h.reverse()
        var p = t.position,
          c = a.get('order'),
          d = buildTooltipMarkup(l, u, o, c, i.get('useUTC'), a.get('textStyle'))
        d && h.unshift(d)
        var f = 'richText' === o ? '\n\n' : '<br/>',
          m = h.join(f)
        this._showOrMove(a, function () {
          this._updateContentNotChangedOnAxis(e)
            ? this._updatePosition(a, p, n[0], n[1], this._tooltipContent, s)
            : this._showTooltipContent(a, m, s, Math.random() + '', n[0], n[1], p, null, u)
        })
      }),
      (t.prototype._showSeriesItemTooltip = function (e, t, i) {
        var r = this._ecModel,
          n = getECData(t),
          a = n.seriesIndex,
          o = r.getSeriesByIndex(a),
          s = n.dataModel || o,
          l = n.dataIndex,
          h = n.dataType,
          u = s.getData(h),
          p = this._renderMode,
          c = e.positionDefault,
          d = buildTooltipModel(
            [u.getItemModel(l), s, o && (o.coordinateSystem || {}).model],
            this._tooltipModel,
            c ? { position: c } : null
          ),
          f = d.get('trigger')
        if (null == f || 'item' === f) {
          var m = s.getDataParams(l, h),
            g = new TooltipMarkupStyleCreator()
          m.marker = g.makeTooltipMarker('item', convertToColorString(m.color), p)
          var y = normalizeTooltipFormatResult(s.formatTooltip(l, !1, h)),
            v = d.get('order'),
            _ = y.markupFragment
              ? buildTooltipMarkup(y.markupFragment, g, p, v, r.get('useUTC'), d.get('textStyle'))
              : y.markupText,
            x = 'item_' + s.name + '_' + l
          this._showOrMove(d, function () {
            this._showTooltipContent(d, _, m, x, e.offsetX, e.offsetY, e.position, e.target, g)
          }),
            i({
              type: 'showTip',
              dataIndexInside: l,
              dataIndex: u.getRawIndex(l),
              seriesIndex: a,
              from: this.uid
            })
        }
      }),
      (t.prototype._showComponentItemTooltip = function (e, t, i) {
        var r = getECData(t),
          n = r.tooltipConfig.option || {}
        if (isString(n)) {
          n = { content: n, formatter: n }
        }
        var a = [n],
          o = this._ecModel.getComponent(r.componentMainType, r.componentIndex)
        o && a.push(o), a.push({ formatter: n.content })
        var s = e.positionDefault,
          l = buildTooltipModel(a, this._tooltipModel, s ? { position: s } : null),
          h = l.get('content'),
          u = Math.random() + '',
          p = new TooltipMarkupStyleCreator()
        this._showOrMove(l, function () {
          var i = clone$3(l.get('formatterParams') || {})
          this._showTooltipContent(l, h, i, u, e.offsetX, e.offsetY, e.position, t, p)
        }),
          i({ type: 'showTip', from: this.uid })
      }),
      (t.prototype._showTooltipContent = function (e, t, i, r, n, a, o, s, l) {
        if (((this._ticket = ''), e.get('showContent') && e.get('show'))) {
          var h = this._tooltipContent,
            u = e.get('formatter')
          o = o || e.get('position')
          var p = t,
            c = this._getNearestPoint([n, a], i, e.get('trigger'), e.get('borderColor')).color
          if (u && isString(u)) {
            var d = e.ecModel.get('useUTC'),
              f = isArray$1(i) ? i[0] : i
            ;(p = u),
              f && f.axisType && f.axisType.indexOf('time') >= 0 && (p = format(f.axisValue, p, d)),
              (p = formatTpl(p, i, !0))
          } else if (isFunction$1(u)) {
            var m = bind(function (t, r) {
              t === this._ticket &&
                (h.setContent(r, l, e, c, o), this._updatePosition(e, o, n, a, h, i, s))
            }, this)
            ;(this._ticket = r), (p = u(i, r, m))
          }
          h.setContent(p, l, e, c, o), h.show(e, c), this._updatePosition(e, o, n, a, h, i, s)
        }
      }),
      (t.prototype._getNearestPoint = function (e, t, i, r) {
        return 'axis' === i || isArray$1(t)
          ? { color: r || ('html' === this._renderMode ? '#fff' : 'none') }
          : isArray$1(t)
          ? void 0
          : { color: r || t.color || t.borderColor }
      }),
      (t.prototype._updatePosition = function (e, t, i, r, n, a, o) {
        var s = this._api.getWidth(),
          l = this._api.getHeight()
        t = t || e.get('position')
        var h = n.getSize(),
          u = e.get('align'),
          p = e.get('verticalAlign'),
          c = o && o.getBoundingRect().clone()
        if (
          (o && c.applyTransform(o.transform),
          isFunction$1(t) &&
            (t = t([i, r], a, n.el, c, { viewSize: [s, l], contentSize: h.slice() })),
          isArray$1(t))
        )
          (i = parsePercent(t[0], s)), (r = parsePercent(t[1], l))
        else if (isObject$7(t)) {
          var d = t
          ;(d.width = h[0]), (d.height = h[1])
          var f = getLayoutRect(d, { width: s, height: l })
          ;(i = f.x), (r = f.y), (u = null), (p = null)
        } else if (isString(t) && o) {
          ;(i = (m = calcTooltipPosition(t, c, h))[0]), (r = m[1])
        } else {
          var m
          ;(i = (m = refixTooltipPosition(i, r, n, s, l, u ? null : 20, p ? null : 20))[0]),
            (r = m[1])
        }
        ;(u && (i -= isCenterAlign(u) ? h[0] / 2 : 'right' === u ? h[0] : 0),
        p && (r -= isCenterAlign(p) ? h[1] / 2 : 'bottom' === p ? h[1] : 0),
        shouldTooltipConfine(e)) &&
          ((i = (m = confineTooltipPosition(i, r, n, s, l))[0]), (r = m[1]))
        n.moveTo(i, r)
      }),
      (t.prototype._updateContentNotChangedOnAxis = function (e) {
        var t = this._lastDataByCoordSys,
          i = !!t && t.length === e.length
        return (
          i &&
            each$6(t, function (t, r) {
              var n = t.dataByAxis || [],
                a = (e[r] || {}).dataByAxis || []
              ;(i = i && n.length === a.length) &&
                each$6(n, function (e, t) {
                  var r = a[t] || {},
                    n = e.seriesDataIndices || [],
                    o = r.seriesDataIndices || []
                  ;(i =
                    i &&
                    e.value === r.value &&
                    e.axisType === r.axisType &&
                    e.axisId === r.axisId &&
                    n.length === o.length) &&
                    each$6(n, function (e, t) {
                      var r = o[t]
                      i = i && e.seriesIndex === r.seriesIndex && e.dataIndex === r.dataIndex
                    })
                })
            }),
          (this._lastDataByCoordSys = e),
          !!i
        )
      }),
      (t.prototype._hide = function (e) {
        ;(this._lastDataByCoordSys = null), e({ type: 'hideTip', from: this.uid })
      }),
      (t.prototype.dispose = function (e, t) {
        env.node || (this._tooltipContent.dispose(), unregister('itemTooltip', t))
      }),
      (t.type = 'tooltip'),
      t
    )
  })(ComponentView)
function buildTooltipModel(e, t, i) {
  var r,
    n = t.ecModel
  i ? ((r = new Model(i, n, n)), (r = new Model(t.option, r, n))) : (r = t)
  for (var a = e.length - 1; a >= 0; a--) {
    var o = e[a]
    o &&
      (o instanceof Model && (o = o.get('tooltip', !0)),
      isString(o) && (o = { formatter: o }),
      o && (r = new Model(o, r, n)))
  }
  return r
}
function makeDispatchAction(e, t) {
  return e.dispatchAction || bind$2(t.dispatchAction, t)
}
function refixTooltipPosition(e, t, i, r, n, a, o) {
  var s = i.getOuterSize(),
    l = s.width,
    h = s.height
  return (
    null != a && (e + l + a + 2 > r ? (e -= l + a) : (e += a)),
    null != o && (t + h + o > n ? (t -= h + o) : (t += o)),
    [e, t]
  )
}
function confineTooltipPosition(e, t, i, r, n) {
  var a = i.getOuterSize(),
    o = a.width,
    s = a.height
  return (
    (e = Math.min(e + o, r) - o),
    (t = Math.min(t + s, n) - s),
    [(e = Math.max(e, 0)), (t = Math.max(t, 0))]
  )
}
function calcTooltipPosition(e, t, i) {
  var r = i[0],
    n = i[1],
    a = 0,
    o = 0,
    s = t.width,
    l = t.height
  switch (e) {
    case 'inside':
      ;(a = t.x + s / 2 - r / 2), (o = t.y + l / 2 - n / 2)
      break
    case 'top':
      ;(a = t.x + s / 2 - r / 2), (o = t.y - n - 10)
      break
    case 'bottom':
      ;(a = t.x + s / 2 - r / 2), (o = t.y + l + 10)
      break
    case 'left':
      ;(a = t.x - r - 10 - 5), (o = t.y + l / 2 - n / 2)
      break
    case 'right':
      ;(a = t.x + s + 10 + 5), (o = t.y + l / 2 - n / 2)
  }
  return [a, o]
}
function isCenterAlign(e) {
  return 'center' === e || 'middle' === e
}
function findComponentReference(e, t, i) {
  var r = preParseFinder(e).queryOptionMap,
    n = r.keys()[0]
  if (n && 'series' !== n) {
    var a,
      o = queryReferringComponents(t, n, r.get(n), {
        useDefault: !1,
        enableAll: !1,
        enableNone: !1
      }).models[0]
    if (o)
      return (
        i.getViewOfComponentModel(o).group.traverse(function (t) {
          var i = getECData(t).tooltipConfig
          if (i && i.name === e.name) return (a = t), !0
        }),
        a ? { componentMainType: n, componentIndex: o.componentIndex, el: a } : void 0
      )
  }
}
function install$i(e) {
  use(install$q),
    e.registerComponentModel(TooltipModel),
    e.registerComponentView(TooltipView),
    e.registerAction(
      { type: 'showTip', event: 'showTip', update: 'tooltip:manuallyShowTip' },
      function () {}
    ),
    e.registerAction(
      { type: 'hideTip', event: 'hideTip', update: 'tooltip:manuallyHideTip' },
      function () {}
    )
}
var DEFAULT_TOOLBOX_BTNS = ['rect', 'polygon', 'keep', 'clear']
function brushPreprocessor(e, t) {
  var i = normalizeToArray(e ? e.brush : [])
  if (i.length) {
    var r = []
    each$i(i, function (e) {
      var t = e.hasOwnProperty('toolbox') ? e.toolbox : []
      t instanceof Array && (r = r.concat(t))
    })
    var n = e && e.toolbox
    isArray$1(n) && (n = n[0]), n || ((n = { feature: {} }), (e.toolbox = [n]))
    var a = n.feature || (n.feature = {}),
      o = a.brush || (a.brush = {}),
      s = o.type || (o.type = [])
    s.push.apply(s, r), removeDuplicate(s), t && !s.length && s.push.apply(s, DEFAULT_TOOLBOX_BTNS)
  }
}
function removeDuplicate(e) {
  var t = {}
  each$i(e, function (e) {
    t[e] = 1
  }),
    (e.length = 0),
    each$i(t, function (t, i) {
      e.push(i)
    })
}
var each$5 = each$i
function hasKeys(e) {
  if (e) for (var t in e) if (e.hasOwnProperty(t)) return !0
}
function createVisualMappings(e, t, i) {
  var r = {}
  return (
    each$5(t, function (t) {
      var n,
        a = (r[t] = (((n = function () {}).prototype.__hidden = n.prototype), new n()))
      each$5(e[t], function (e, r) {
        if (VisualMapping.isValidType(r)) {
          var n = { type: r, visual: e }
          i && i(n, t),
            (a[r] = new VisualMapping(n)),
            'opacity' === r &&
              (((n = clone$3(n)).type = 'colorAlpha'),
              (a.__hidden.__alphaForOpacity = new VisualMapping(n)))
        }
      })
    }),
    r
  )
}
function replaceVisualOption(e, t, i) {
  var r
  each$i(i, function (e) {
    t.hasOwnProperty(e) && hasKeys(t[e]) && (r = !0)
  }),
    r &&
      each$i(i, function (i) {
        t.hasOwnProperty(i) && hasKeys(t[i]) ? (e[i] = clone$3(t[i])) : delete e[i]
      })
}
function applyVisual(e, t, i, r, n, a) {
  var o,
    s = {}
  function l(e) {
    return getItemVisualFromData(i, o, e)
  }
  function h(e, t) {
    setItemVisualFromData(i, o, e, t)
  }
  function u(e, u) {
    o = null == a ? e : u
    var p = i.getRawDataItem(o)
    if (!p || !1 !== p.visualMap)
      for (var c = r.call(n, e), d = t[c], f = s[c], m = 0, g = f.length; m < g; m++) {
        var y = f[m]
        d[y] && d[y].applyVisual(e, l, h)
      }
  }
  each$i(e, function (e) {
    var i = VisualMapping.prepareVisualTypes(t[e])
    s[e] = i
  }),
    null == a ? i.each(u) : i.each([a], u)
}
function incrementalApplyVisual(e, t, i, r) {
  var n = {}
  return (
    each$i(e, function (e) {
      var i = VisualMapping.prepareVisualTypes(t[e])
      n[e] = i
    }),
    {
      progress: function (e, a) {
        var o, s
        function l(e) {
          return getItemVisualFromData(a, s, e)
        }
        function h(e, t) {
          setItemVisualFromData(a, s, e, t)
        }
        for (null != r && (o = a.getDimension(r)); null != (s = e.next()); ) {
          var u = a.getRawDataItem(s)
          if (!u || !1 !== u.visualMap)
            for (
              var p = null != r ? a.get(o, s) : s,
                c = i(p),
                d = t[c],
                f = n[c],
                m = 0,
                g = f.length;
              m < g;
              m++
            ) {
              var y = f[m]
              d[y] && d[y].applyVisual(p, l, h)
            }
        }
      }
    }
  )
}
function makeBrushCommonSelectorForSeries(e) {
  var t = e.brushType,
    i = {
      point: function (r) {
        return selector[t].point(r, i, e)
      },
      rect: function (r) {
        return selector[t].rect(r, i, e)
      }
    }
  return i
}
var selector = {
  lineX: getLineSelectors(0),
  lineY: getLineSelectors(1),
  rect: {
    point: function (e, t, i) {
      return e && i.boundingRect.contain(e[0], e[1])
    },
    rect: function (e, t, i) {
      return e && i.boundingRect.intersect(e)
    }
  },
  polygon: {
    point: function (e, t, i) {
      return e && i.boundingRect.contain(e[0], e[1]) && contain$1(i.range, e[0], e[1])
    },
    rect: function (e, t, i) {
      var r = i.range
      if (!e || r.length <= 1) return !1
      var n = e.x,
        a = e.y,
        o = e.width,
        s = e.height,
        l = r[0]
      return (
        !!(
          contain$1(r, n, a) ||
          contain$1(r, n + o, a) ||
          contain$1(r, n, a + s) ||
          contain$1(r, n + o, a + s) ||
          BoundingRect.create(e).contain(l[0], l[1]) ||
          linePolygonIntersect(n, a, n + o, a, r) ||
          linePolygonIntersect(n, a, n, a + s, r) ||
          linePolygonIntersect(n + o, a, n + o, a + s, r) ||
          linePolygonIntersect(n, a + s, n + o, a + s, r)
        ) || void 0
      )
    }
  }
}
function getLineSelectors(e) {
  var t = ['x', 'y'],
    i = ['width', 'height']
  return {
    point: function (t, i, r) {
      if (t) {
        var n = r.range
        return inLineRange(t[e], n)
      }
    },
    rect: function (r, n, a) {
      if (r) {
        var o = a.range,
          s = [r[t[e]], r[t[e]] + r[i[e]]]
        return (
          s[1] < s[0] && s.reverse(),
          inLineRange(s[0], o) ||
            inLineRange(s[1], o) ||
            inLineRange(o[0], s) ||
            inLineRange(o[1], s)
        )
      }
    }
  }
}
function inLineRange(e, t) {
  return t[0] <= e && e <= t[1]
}
var STATE_LIST = ['inBrush', 'outOfBrush'],
  DISPATCH_METHOD = '__ecBrushSelect',
  DISPATCH_FLAG = '__ecInBrushSelectEvent'
function layoutCovers(e) {
  e.eachComponent({ mainType: 'brush' }, function (t) {
    ;(t.brushTargetManager = new BrushTargetManager(t.option, e)).setInputRanges(t.areas, e)
  })
}
function brushVisual(e, t, i) {
  var r,
    n,
    a = []
  e.eachComponent({ mainType: 'brush' }, function (e) {
    i &&
      'takeGlobalCursor' === i.type &&
      e.setBrushOption('brush' === i.key ? i.brushOption : { brushType: !1 })
  }),
    layoutCovers(e),
    e.eachComponent({ mainType: 'brush' }, function (t, i) {
      var o = {
        brushId: t.id,
        brushIndex: i,
        brushName: t.name,
        areas: clone$3(t.areas),
        selected: []
      }
      a.push(o)
      var s = t.option,
        l = s.brushLink,
        h = [],
        u = [],
        p = [],
        c = !1
      i || ((r = s.throttleType), (n = s.throttleDelay))
      var d = map$1(t.areas, function (e) {
          var t = boundingRectBuilders[e.brushType],
            i = defaults$1({ boundingRect: t ? t(e) : void 0 }, e)
          return (i.selectors = makeBrushCommonSelectorForSeries(i)), i
        }),
        f = createVisualMappings(t.option, STATE_LIST, function (e) {
          e.mappingMethod = 'fixed'
        })
      function m(e) {
        return 'all' === l || !!h[e]
      }
      function g(e) {
        return !!e.length
      }
      isArray$1(l) &&
        each$i(l, function (e) {
          h[e] = 1
        }),
        e.eachSeries(function (i, r) {
          var n = (p[r] = [])
          'parallel' === i.subType
            ? (function (e, t) {
                var i = e.coordinateSystem
                ;(c = c || i.hasAxisBrushed()),
                  m(t) &&
                    i.eachActiveState(e.getData(), function (e, t) {
                      'active' === e && (u[t] = 1)
                    })
              })(i, r)
            : (function (i, r, n) {
                if (!i.brushSelector || brushModelNotControll(t, r)) return
                if (
                  (each$i(d, function (r) {
                    t.brushTargetManager.controlSeries(r, i, e) && n.push(r), (c = c || g(n))
                  }),
                  m(r) && g(n))
                ) {
                  var a = i.getData()
                  a.each(function (e) {
                    checkInRange(i, n, a, e) && (u[e] = 1)
                  })
                }
              })(i, r, n)
        }),
        e.eachSeries(function (e, t) {
          var i = { seriesId: e.id, seriesIndex: t, seriesName: e.name, dataIndex: [] }
          o.selected.push(i)
          var r = p[t],
            n = e.getData(),
            a = m(t)
              ? function (e) {
                  return u[e] ? (i.dataIndex.push(n.getRawIndex(e)), 'inBrush') : 'outOfBrush'
                }
              : function (t) {
                  return checkInRange(e, r, n, t)
                    ? (i.dataIndex.push(n.getRawIndex(t)), 'inBrush')
                    : 'outOfBrush'
                }
          ;(m(t) ? c : g(r)) && applyVisual(STATE_LIST, f, n, a)
        })
    }),
    dispatchAction$1(t, r, n, a, i)
}
function dispatchAction$1(e, t, i, r, n) {
  if (n) {
    var a = e.getZr()
    if (!a[DISPATCH_FLAG])
      a[DISPATCH_METHOD] || (a[DISPATCH_METHOD] = doDispatch),
        createOrUpdate(a, DISPATCH_METHOD, i, t)(e, r)
  }
}
function doDispatch(e, t) {
  if (!e.isDisposed()) {
    var i = e.getZr()
    ;(i[DISPATCH_FLAG] = !0),
      e.dispatchAction({ type: 'brushSelect', batch: t }),
      (i[DISPATCH_FLAG] = !1)
  }
}
function checkInRange(e, t, i, r) {
  for (var n = 0, a = t.length; n < a; n++) {
    var o = t[n]
    if (e.brushSelector(r, i, o.selectors, o)) return !0
  }
}
function brushModelNotControll(e, t) {
  var i = e.option.seriesIndex
  return null != i && 'all' !== i && (isArray$1(i) ? indexOf$1(i, t) < 0 : t !== i)
}
var boundingRectBuilders = {
  rect: function (e) {
    return getBoundingRectFromMinMax(e.range)
  },
  polygon: function (e) {
    for (var t, i = e.range, r = 0, n = i.length; r < n; r++) {
      t = t || [
        [1 / 0, -1 / 0],
        [1 / 0, -1 / 0]
      ]
      var a = i[r]
      a[0] < t[0][0] && (t[0][0] = a[0]),
        a[0] > t[0][1] && (t[0][1] = a[0]),
        a[1] < t[1][0] && (t[1][0] = a[1]),
        a[1] > t[1][1] && (t[1][1] = a[1])
    }
    return t && getBoundingRectFromMinMax(t)
  }
}
function getBoundingRectFromMinMax(e) {
  return new BoundingRect(e[0][0], e[1][0], e[0][1] - e[0][0], e[1][1] - e[1][0])
}
var BrushView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (e, t) {
        ;(this.ecModel = e),
          (this.api = t),
          this.model,
          (this._brushController = new BrushController(t.getZr()))
            .on('brush', bind$2(this._onBrush, this))
            .mount()
      }),
      (t.prototype.render = function (e, t, i, r) {
        ;(this.model = e), this._updateController(e, t, i, r)
      }),
      (t.prototype.updateTransform = function (e, t, i, r) {
        layoutCovers(t), this._updateController(e, t, i, r)
      }),
      (t.prototype.updateVisual = function (e, t, i, r) {
        this.updateTransform(e, t, i, r)
      }),
      (t.prototype.updateView = function (e, t, i, r) {
        this._updateController(e, t, i, r)
      }),
      (t.prototype._updateController = function (e, t, i, r) {
        ;(!r || r.$from !== e.id) &&
          this._brushController
            .setPanels(e.brushTargetManager.makePanelOpts(i))
            .enableBrush(e.brushOption)
            .updateCovers(e.areas.slice())
      }),
      (t.prototype.dispose = function () {
        this._brushController.dispose()
      }),
      (t.prototype._onBrush = function (e) {
        var t = this.model.id,
          i = this.model.brushTargetManager.setOutputRanges(e.areas, this.ecModel)
        ;(!e.isEnd || e.removeOnClick) &&
          this.api.dispatchAction({ type: 'brush', brushId: t, areas: clone$3(i), $from: t }),
          e.isEnd &&
            this.api.dispatchAction({ type: 'brushEnd', brushId: t, areas: clone$3(i), $from: t })
      }),
      (t.type = 'brush'),
      t
    )
  })(ComponentView),
  DEFAULT_OUT_OF_BRUSH_COLOR = '#ddd',
  BrushModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.areas = []), (i.brushOption = {}), i
    }
    return (
      __extends(t, e),
      (t.prototype.optionUpdated = function (e, t) {
        var i = this.option
        !t && replaceVisualOption(i, e, ['inBrush', 'outOfBrush'])
        var r = (i.inBrush = i.inBrush || {})
        ;(i.outOfBrush = i.outOfBrush || { color: DEFAULT_OUT_OF_BRUSH_COLOR }),
          r.hasOwnProperty('liftZ') || (r.liftZ = 5)
      }),
      (t.prototype.setAreas = function (e) {
        e &&
          (this.areas = map$1(
            e,
            function (e) {
              return generateBrushOption(this.option, e)
            },
            this
          ))
      }),
      (t.prototype.setBrushOption = function (e) {
        ;(this.brushOption = generateBrushOption(this.option, e)),
          (this.brushType = this.brushOption.brushType)
      }),
      (t.type = 'brush'),
      (t.dependencies = ['geo', 'grid', 'xAxis', 'yAxis', 'parallel', 'series']),
      (t.defaultOption = {
        seriesIndex: 'all',
        brushType: 'rect',
        brushMode: 'single',
        transformable: !0,
        brushStyle: { borderWidth: 1, color: 'rgba(210,219,238,0.3)', borderColor: '#D2DBEE' },
        throttleType: 'fixRate',
        throttleDelay: 0,
        removeOnClick: !0,
        z: 1e4
      }),
      t
    )
  })(ComponentModel)
function generateBrushOption(e, t) {
  return merge(
    {
      brushType: e.brushType,
      brushMode: e.brushMode,
      transformable: e.transformable,
      brushStyle: new Model(e.brushStyle).getItemStyle(),
      removeOnClick: e.removeOnClick,
      z: e.z
    },
    t,
    !0
  )
}
var ICON_TYPES = ['rect', 'polygon', 'lineX', 'lineY', 'keep', 'clear'],
  BrushFeature = (function (e) {
    function t() {
      return (null !== e && e.apply(this, arguments)) || this
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i) {
        var r, n, a
        t.eachComponent({ mainType: 'brush' }, function (e) {
          ;(r = e.brushType), (n = e.brushOption.brushMode || 'single'), (a = a || !!e.areas.length)
        }),
          (this._brushType = r),
          (this._brushMode = n),
          each$i(e.get('type', !0), function (t) {
            e.setIconStatus(
              t,
              ('keep' === t ? 'multiple' === n : 'clear' === t ? a : t === r)
                ? 'emphasis'
                : 'normal'
            )
          })
      }),
      (t.prototype.updateView = function (e, t, i) {
        this.render(e, t, i)
      }),
      (t.prototype.getIcons = function () {
        var e = this.model,
          t = e.get('icon', !0),
          i = {}
        return (
          each$i(e.get('type', !0), function (e) {
            t[e] && (i[e] = t[e])
          }),
          i
        )
      }),
      (t.prototype.onclick = function (e, t, i) {
        var r = this._brushType,
          n = this._brushMode
        'clear' === i
          ? (t.dispatchAction({ type: 'axisAreaSelect', intervals: [] }),
            t.dispatchAction({ type: 'brush', command: 'clear', areas: [] }))
          : t.dispatchAction({
              type: 'takeGlobalCursor',
              key: 'brush',
              brushOption: {
                brushType: 'keep' === i ? r : r !== i && i,
                brushMode: 'keep' === i ? ('multiple' === n ? 'single' : 'multiple') : n
              }
            })
      }),
      (t.getDefaultOption = function (e) {
        return {
          show: !0,
          type: ICON_TYPES.slice(),
          icon: {
            rect: 'M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13',
            polygon:
              'M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2',
            lineX:
              'M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4',
            lineY:
              'M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4',
            keep: 'M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z',
            clear:
              'M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2'
          },
          title: e.getLocale(['toolbox', 'brush', 'title'])
        }
      }),
      t
    )
  })(ToolboxFeature)
function install$h(e) {
  e.registerComponentView(BrushView),
    e.registerComponentModel(BrushModel),
    e.registerPreprocessor(brushPreprocessor),
    e.registerVisual(e.PRIORITY.VISUAL.BRUSH, brushVisual),
    e.registerAction({ type: 'brush', event: 'brush', update: 'updateVisual' }, function (e, t) {
      t.eachComponent({ mainType: 'brush', query: e }, function (t) {
        t.setAreas(e.areas)
      })
    }),
    e.registerAction(
      { type: 'brushSelect', event: 'brushSelected', update: 'none' },
      function () {}
    ),
    e.registerAction({ type: 'brushEnd', event: 'brushEnd', update: 'none' }, function () {}),
    registerFeature('brush', BrushFeature)
}
var TitleModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.layoutMode = { type: 'box', ignoreSize: !0 }), i
    }
    return (
      __extends(t, e),
      (t.type = 'title'),
      (t.defaultOption = {
        zlevel: 0,
        z: 6,
        show: !0,
        text: '',
        target: 'blank',
        subtext: '',
        subtarget: 'blank',
        left: 0,
        top: 0,
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        textStyle: { fontSize: 18, fontWeight: 'bold', color: '#464646' },
        subtextStyle: { fontSize: 12, color: '#6E7079' }
      }),
      t
    )
  })(ComponentModel),
  TitleView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (e, t, i) {
        if ((this.group.removeAll(), e.get('show'))) {
          var r = this.group,
            n = e.getModel('textStyle'),
            a = e.getModel('subtextStyle'),
            o = e.get('textAlign'),
            s = retrieve2(e.get('textBaseline'), e.get('textVerticalAlign')),
            l = new ZRText({
              style: createTextStyle(
                n,
                { text: e.get('text'), fill: n.getTextColor() },
                { disableBox: !0 }
              ),
              z2: 10
            }),
            h = l.getBoundingRect(),
            u = e.get('subtext'),
            p = new ZRText({
              style: createTextStyle(
                a,
                {
                  text: u,
                  fill: a.getTextColor(),
                  y: h.height + e.get('itemGap'),
                  verticalAlign: 'top'
                },
                { disableBox: !0 }
              ),
              z2: 10
            }),
            c = e.get('link'),
            d = e.get('sublink'),
            f = e.get('triggerEvent', !0)
          ;(l.silent = !c && !f),
            (p.silent = !d && !f),
            c &&
              l.on('click', function () {
                windowOpen(c, '_' + e.get('target'))
              }),
            d &&
              p.on('click', function () {
                windowOpen(d, '_' + e.get('subtarget'))
              }),
            (getECData(l).eventData = getECData(p).eventData =
              f ? { componentType: 'title', componentIndex: e.componentIndex } : null),
            r.add(l),
            u && r.add(p)
          var m = r.getBoundingRect(),
            g = e.getBoxLayoutParams()
          ;(g.width = m.width), (g.height = m.height)
          var y = getLayoutRect(g, { width: i.getWidth(), height: i.getHeight() }, e.get('padding'))
          o ||
            ('middle' === (o = e.get('left') || e.get('right')) && (o = 'center'),
            'right' === o ? (y.x += y.width) : 'center' === o && (y.x += y.width / 2)),
            s ||
              ('center' === (s = e.get('top') || e.get('bottom')) && (s = 'middle'),
              'bottom' === s ? (y.y += y.height) : 'middle' === s && (y.y += y.height / 2),
              (s = s || 'top')),
            (r.x = y.x),
            (r.y = y.y),
            r.markRedraw()
          var v = { align: o, verticalAlign: s }
          l.setStyle(v), p.setStyle(v), (m = r.getBoundingRect())
          var _ = y.margin,
            x = e.getItemStyle(['color', 'opacity'])
          x.fill = e.get('backgroundColor')
          var S = new Rect$2({
            shape: {
              x: m.x - _[3],
              y: m.y - _[0],
              width: m.width + _[1] + _[3],
              height: m.height + _[0] + _[2],
              r: e.get('borderRadius')
            },
            style: x,
            subPixelOptimize: !0,
            silent: !0
          })
          r.add(S)
        }
      }),
      (t.type = 'title'),
      t
    )
  })(ComponentView)
function install$g(e) {
  e.registerComponentModel(TitleModel), e.registerComponentView(TitleView)
}
var TimelineModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.layoutMode = 'box'), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (e, t, i) {
        this.mergeDefaultAndTheme(e, i), this._initData()
      }),
      (t.prototype.mergeOption = function (t) {
        e.prototype.mergeOption.apply(this, arguments), this._initData()
      }),
      (t.prototype.setCurrentIndex = function (e) {
        null == e && (e = this.option.currentIndex)
        var t = this._data.count()
        this.option.loop ? (e = ((e % t) + t) % t) : (e >= t && (e = t - 1), e < 0 && (e = 0)),
          (this.option.currentIndex = e)
      }),
      (t.prototype.getCurrentIndex = function () {
        return this.option.currentIndex
      }),
      (t.prototype.isIndexMax = function () {
        return this.getCurrentIndex() >= this._data.count() - 1
      }),
      (t.prototype.setPlayState = function (e) {
        this.option.autoPlay = !!e
      }),
      (t.prototype.getPlayState = function () {
        return !!this.option.autoPlay
      }),
      (t.prototype._initData = function () {
        var e,
          t = this.option,
          i = t.data || [],
          r = t.axisType,
          n = (this._names = [])
        'category' === r
          ? ((e = []),
            each$i(i, function (t, i) {
              var r,
                a = convertOptionIdName(getDataItemValue(t), '')
              isObject$7(t) ? ((r = clone$3(t)).value = i) : (r = i), e.push(r), n.push(a)
            }))
          : (e = i)
        var a = { category: 'ordinal', time: 'time', value: 'number' }[r] || 'number'
        ;(this._data = new List([{ name: 'value', type: a }], this)).initData(e, n)
      }),
      (t.prototype.getData = function () {
        return this._data
      }),
      (t.prototype.getCategories = function () {
        if ('category' === this.get('axisType')) return this._names.slice()
      }),
      (t.type = 'timeline'),
      (t.defaultOption = {
        zlevel: 0,
        z: 4,
        show: !0,
        axisType: 'time',
        realtime: !0,
        left: '20%',
        top: null,
        right: '20%',
        bottom: 0,
        width: null,
        height: 40,
        padding: 5,
        controlPosition: 'left',
        autoPlay: !1,
        rewind: !1,
        loop: !0,
        playInterval: 2e3,
        currentIndex: 0,
        itemStyle: {},
        label: { color: '#000' },
        data: []
      }),
      t
    )
  })(ComponentModel),
  SliderTimelineModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.type = 'timeline.slider'),
      (t.defaultOption = inheritDefaultOption(TimelineModel.defaultOption, {
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        borderWidth: 0,
        orient: 'horizontal',
        inverse: !1,
        tooltip: { trigger: 'item' },
        symbol: 'circle',
        symbolSize: 12,
        lineStyle: { show: !0, width: 2, color: '#DAE1F5' },
        label: { position: 'auto', show: !0, interval: 'auto', rotate: 0, color: '#A4B1D7' },
        itemStyle: { color: '#A4B1D7', borderWidth: 1 },
        checkpointStyle: {
          symbol: 'circle',
          symbolSize: 15,
          color: '#316bf3',
          borderColor: '#fff',
          borderWidth: 2,
          shadowBlur: 2,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: 'rgba(0, 0, 0, 0.3)',
          animation: !0,
          animationDuration: 300,
          animationEasing: 'quinticInOut'
        },
        controlStyle: {
          show: !0,
          showPlayBtn: !0,
          showPrevBtn: !0,
          showNextBtn: !0,
          itemSize: 24,
          itemGap: 12,
          position: 'left',
          playIcon:
            'path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z',
          stopIcon:
            'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z',
          nextIcon:
            'M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z',
          prevIcon:
            'M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z',
          prevBtnSize: 18,
          nextBtnSize: 18,
          color: '#A4B1D7',
          borderColor: '#A4B1D7',
          borderWidth: 1
        },
        emphasis: {
          label: { show: !0, color: '#6f778d' },
          itemStyle: { color: '#316BF3' },
          controlStyle: { color: '#316BF3', borderColor: '#316BF3', borderWidth: 2 }
        },
        progress: {
          lineStyle: { color: '#316BF3' },
          itemStyle: { color: '#316BF3' },
          label: { color: '#6f778d' }
        },
        data: []
      })),
      t
    )
  })(TimelineModel)
mixin(SliderTimelineModel, DataFormatMixin.prototype)
var TimelineView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return __extends(t, e), (t.type = 'timeline'), t
  })(ComponentView),
  TimelineAxis = (function (e) {
    function t(t, i, r, n) {
      var a = e.call(this, t, i, r) || this
      return (a.type = n || 'value'), a
    }
    return (
      __extends(t, e),
      (t.prototype.getLabelModel = function () {
        return this.model.getModel('label')
      }),
      (t.prototype.isHorizontal = function () {
        return 'horizontal' === this.model.get('orient')
      }),
      t
    )
  })(Axis),
  PI = Math.PI,
  labelDataIndexStore = makeInner(),
  SliderTimelineView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (e, t) {
        this.api = t
      }),
      (t.prototype.render = function (e, t, i) {
        if (
          ((this.model = e),
          (this.api = i),
          (this.ecModel = t),
          this.group.removeAll(),
          e.get('show', !0))
        ) {
          var r = this._layout(e, i),
            n = this._createGroup('_mainGroup'),
            a = this._createGroup('_labelGroup'),
            o = (this._axis = this._createAxis(r, e))
          ;(e.formatTooltip = function (e) {
            return createTooltipMarkup('nameValue', {
              noName: !0,
              value: o.scale.getLabel({ value: e })
            })
          }),
            each$i(
              ['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'],
              function (t) {
                this['_render' + t](r, n, o, e)
              },
              this
            ),
            this._renderAxisLabel(r, a, o, e),
            this._position(r, e)
        }
        this._doPlayStop(), this._updateTicksStatus()
      }),
      (t.prototype.remove = function () {
        this._clearTimer(), this.group.removeAll()
      }),
      (t.prototype.dispose = function () {
        this._clearTimer()
      }),
      (t.prototype._layout = function (e, t) {
        var i,
          r,
          n,
          a,
          o = e.get(['label', 'position']),
          s = e.get('orient'),
          l = getViewRect(e, t),
          h = {
            horizontal: 'center',
            vertical:
              (i =
                null == o || 'auto' === o
                  ? 'horizontal' === s
                    ? l.y + l.height / 2 < t.getHeight() / 2
                      ? '-'
                      : '+'
                    : l.x + l.width / 2 < t.getWidth() / 2
                    ? '+'
                    : '-'
                  : isString(o)
                  ? { horizontal: { top: '-', bottom: '+' }, vertical: { left: '-', right: '+' } }[
                      s
                    ][o]
                  : o) >= 0 || '+' === i
                ? 'left'
                : 'right'
          },
          u = { horizontal: i >= 0 || '+' === i ? 'top' : 'bottom', vertical: 'middle' },
          p = { horizontal: 0, vertical: PI / 2 },
          c = 'vertical' === s ? l.height : l.width,
          d = e.getModel('controlStyle'),
          f = d.get('show', !0),
          m = f ? d.get('itemSize') : 0,
          g = f ? d.get('itemGap') : 0,
          y = m + g,
          v = e.get(['label', 'rotate']) || 0
        v = (v * PI) / 180
        var _ = d.get('position', !0),
          x = f && d.get('showPlayBtn', !0),
          S = f && d.get('showPrevBtn', !0),
          b = f && d.get('showNextBtn', !0),
          T = 0,
          A = c
        'left' === _ || 'bottom' === _
          ? (x && ((r = [0, 0]), (T += y)),
            S && ((n = [T, 0]), (T += y)),
            b && ((a = [A - m, 0]), (A -= y)))
          : (x && ((r = [A - m, 0]), (A -= y)),
            S && ((n = [0, 0]), (T += y)),
            b && ((a = [A - m, 0]), (A -= y)))
        var w = [T, A]
        return (
          e.get('inverse') && w.reverse(),
          {
            viewRect: l,
            mainLength: c,
            orient: s,
            rotation: p[s],
            labelRotation: v,
            labelPosOpt: i,
            labelAlign: e.get(['label', 'align']) || h[s],
            labelBaseline:
              e.get(['label', 'verticalAlign']) || e.get(['label', 'baseline']) || u[s],
            playPosition: r,
            prevBtnPosition: n,
            nextBtnPosition: a,
            axisExtent: w,
            controlSize: m,
            controlGap: g
          }
        )
      }),
      (t.prototype._position = function (e, t) {
        var i = this._mainGroup,
          r = this._labelGroup,
          n = e.viewRect
        if ('vertical' === e.orient) {
          var a = create$1(),
            o = n.x,
            s = n.y + n.height
          translate$1(a, a, [-o, -s]),
            rotate(a, a, -PI / 2),
            translate$1(a, a, [o, s]),
            (n = n.clone()).applyTransform(a)
        }
        var l = g(n),
          h = g(i.getBoundingRect()),
          u = g(r.getBoundingRect()),
          p = [i.x, i.y],
          c = [r.x, r.y]
        c[0] = p[0] = l[0][0]
        var d,
          f = e.labelPosOpt
        null == f || isString(f)
          ? (y(p, h, l, 1, (d = '+' === f ? 0 : 1)), y(c, u, l, 1, 1 - d))
          : (y(p, h, l, 1, (d = f >= 0 ? 0 : 1)), (c[1] = p[1] + f))
        function m(e) {
          ;(e.originX = l[0][0] - e.x), (e.originY = l[1][0] - e.y)
        }
        function g(e) {
          return [
            [e.x, e.x + e.width],
            [e.y, e.y + e.height]
          ]
        }
        function y(e, t, i, r, n) {
          e[r] += i[r][n] - t[r][n]
        }
        i.setPosition(p), r.setPosition(c), (i.rotation = r.rotation = e.rotation), m(i), m(r)
      }),
      (t.prototype._createAxis = function (e, t) {
        var i = t.getData(),
          r = t.get('axisType'),
          n = createScaleByModel(t, r)
        n.getTicks = function () {
          return i.mapArray(['value'], function (e) {
            return { value: e }
          })
        }
        var a = i.getDataExtent('value')
        n.setExtent(a[0], a[1]), n.niceTicks()
        var o = new TimelineAxis('value', n, e.axisExtent, r)
        return (o.model = t), o
      }),
      (t.prototype._createGroup = function (e) {
        var t = (this[e] = new Group$3())
        return this.group.add(t), t
      }),
      (t.prototype._renderAxisLine = function (e, t, i, r) {
        var n = i.getExtent()
        if (r.get(['lineStyle', 'show'])) {
          var a = new Line$1({
            shape: { x1: n[0], y1: 0, x2: n[1], y2: 0 },
            style: extend$3({ lineCap: 'round' }, r.getModel('lineStyle').getLineStyle()),
            silent: !0,
            z2: 1
          })
          t.add(a)
          var o = (this._progressLine = new Line$1({
            shape: {
              x1: n[0],
              x2: this._currentPointer ? this._currentPointer.x : n[0],
              y1: 0,
              y2: 0
            },
            style: defaults$1(
              { lineCap: 'round', lineWidth: a.style.lineWidth },
              r.getModel(['progress', 'lineStyle']).getLineStyle()
            ),
            silent: !0,
            z2: 1
          }))
          t.add(o)
        }
      }),
      (t.prototype._renderAxisTick = function (e, t, i, r) {
        var n = this,
          a = r.getData(),
          o = i.scale.getTicks()
        ;(this._tickSymbols = []),
          each$i(o, function (e) {
            var o = i.dataToCoord(e.value),
              s = a.getItemModel(e.value),
              l = s.getModel('itemStyle'),
              h = s.getModel(['emphasis', 'itemStyle']),
              u = s.getModel(['progress', 'itemStyle']),
              p = { x: o, y: 0, onclick: bind$2(n._changeTimeline, n, e.value) },
              c = giveSymbol(s, l, t, p)
            ;(c.ensureState('emphasis').style = h.getItemStyle()),
              (c.ensureState('progress').style = u.getItemStyle()),
              enableHoverEmphasis(c)
            var d = getECData(c)
            s.get('tooltip')
              ? ((d.dataIndex = e.value), (d.dataModel = r))
              : (d.dataIndex = d.dataModel = null),
              n._tickSymbols.push(c)
          })
      }),
      (t.prototype._renderAxisLabel = function (e, t, i, r) {
        var n = this
        if (i.getLabelModel().get('show')) {
          var a = r.getData(),
            o = i.getViewLabels()
          ;(this._tickLabels = []),
            each$i(o, function (r) {
              var o = r.tickValue,
                s = a.getItemModel(o),
                l = s.getModel('label'),
                h = s.getModel(['emphasis', 'label']),
                u = s.getModel(['progress', 'label']),
                p = i.dataToCoord(r.tickValue),
                c = new ZRText({
                  x: p,
                  y: 0,
                  rotation: e.labelRotation - e.rotation,
                  onclick: bind$2(n._changeTimeline, n, o),
                  silent: !1,
                  style: createTextStyle(l, {
                    text: r.formattedLabel,
                    align: e.labelAlign,
                    verticalAlign: e.labelBaseline
                  })
                })
              ;(c.ensureState('emphasis').style = createTextStyle(h)),
                (c.ensureState('progress').style = createTextStyle(u)),
                t.add(c),
                enableHoverEmphasis(c),
                (labelDataIndexStore(c).dataIndex = o),
                n._tickLabels.push(c)
            })
        }
      }),
      (t.prototype._renderControl = function (e, t, i, r) {
        var n = e.controlSize,
          a = e.rotation,
          o = r.getModel('controlStyle').getItemStyle(),
          s = r.getModel(['emphasis', 'controlStyle']).getItemStyle(),
          l = r.getPlayState(),
          h = r.get('inverse', !0)
        function u(e, i, l, h) {
          if (e) {
            var u = parsePercent$2(retrieve2(r.get(['controlStyle', i + 'BtnSize']), n), n),
              p = makeControlIcon(r, i + 'Icon', [0, -u / 2, u, u], {
                x: e[0],
                y: e[1],
                originX: n / 2,
                originY: 0,
                rotation: h ? -a : 0,
                rectHover: !0,
                style: o,
                onclick: l
              })
            ;(p.ensureState('emphasis').style = s), t.add(p), enableHoverEmphasis(p)
          }
        }
        u(e.nextBtnPosition, 'next', bind$2(this._changeTimeline, this, h ? '-' : '+')),
          u(e.prevBtnPosition, 'prev', bind$2(this._changeTimeline, this, h ? '+' : '-')),
          u(e.playPosition, l ? 'stop' : 'play', bind$2(this._handlePlayClick, this, !l), !0)
      }),
      (t.prototype._renderCurrentPointer = function (e, t, i, r) {
        var n = r.getData(),
          a = r.getCurrentIndex(),
          o = n.getItemModel(a).getModel('checkpointStyle'),
          s = this,
          l = {
            onCreate: function (e) {
              ;(e.draggable = !0),
                (e.drift = bind$2(s._handlePointerDrag, s)),
                (e.ondragend = bind$2(s._handlePointerDragend, s)),
                pointerMoveTo(e, s._progressLine, a, i, r, !0)
            },
            onUpdate: function (e) {
              pointerMoveTo(e, s._progressLine, a, i, r)
            }
          }
        this._currentPointer = giveSymbol(o, o, this._mainGroup, {}, this._currentPointer, l)
      }),
      (t.prototype._handlePlayClick = function (e) {
        this._clearTimer(),
          this.api.dispatchAction({ type: 'timelinePlayChange', playState: e, from: this.uid })
      }),
      (t.prototype._handlePointerDrag = function (e, t, i) {
        this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY])
      }),
      (t.prototype._handlePointerDragend = function (e) {
        this._pointerChangeTimeline([e.offsetX, e.offsetY], !0)
      }),
      (t.prototype._pointerChangeTimeline = function (e, t) {
        var i = this._toAxisCoord(e)[0],
          r = asc$2(this._axis.getExtent().slice())
        i > r[1] && (i = r[1]),
          i < r[0] && (i = r[0]),
          (this._currentPointer.x = i),
          this._currentPointer.markRedraw(),
          (this._progressLine.shape.x2 = i),
          this._progressLine.dirty()
        var n = this._findNearestTick(i),
          a = this.model
        ;(t || (n !== a.getCurrentIndex() && a.get('realtime'))) && this._changeTimeline(n)
      }),
      (t.prototype._doPlayStop = function () {
        var e = this
        this._clearTimer(),
          this.model.getPlayState() &&
            (this._timer = setTimeout(function () {
              var t = e.model
              e._changeTimeline(t.getCurrentIndex() + (t.get('rewind', !0) ? -1 : 1))
            }, this.model.get('playInterval')))
      }),
      (t.prototype._toAxisCoord = function (e) {
        return applyTransform(e, this._mainGroup.getLocalTransform(), !0)
      }),
      (t.prototype._findNearestTick = function (e) {
        var t,
          i = this.model.getData(),
          r = 1 / 0,
          n = this._axis
        return (
          i.each(['value'], function (i, a) {
            var o = n.dataToCoord(i),
              s = Math.abs(o - e)
            s < r && ((r = s), (t = a))
          }),
          t
        )
      }),
      (t.prototype._clearTimer = function () {
        this._timer && (clearTimeout(this._timer), (this._timer = null))
      }),
      (t.prototype._changeTimeline = function (e) {
        var t = this.model.getCurrentIndex()
        '+' === e ? (e = t + 1) : '-' === e && (e = t - 1),
          this.api.dispatchAction({ type: 'timelineChange', currentIndex: e, from: this.uid })
      }),
      (t.prototype._updateTicksStatus = function () {
        var e = this.model.getCurrentIndex(),
          t = this._tickSymbols,
          i = this._tickLabels
        if (t) for (var r = 0; r < t.length; r++) t && t[r] && t[r].toggleState('progress', r < e)
        if (i)
          for (r = 0; r < i.length; r++)
            i && i[r] && i[r].toggleState('progress', labelDataIndexStore(i[r]).dataIndex <= e)
      }),
      (t.type = 'timeline.slider'),
      t
    )
  })(TimelineView)
function createScaleByModel(e, t) {
  if ((t = t || e.get('type')))
    switch (t) {
      case 'category':
        return new OrdinalScale({ ordinalMeta: e.getCategories(), extent: [1 / 0, -1 / 0] })
      case 'time':
        return new TimeScale({
          locale: e.ecModel.getLocaleModel(),
          useUTC: e.ecModel.get('useUTC')
        })
      default:
        return new IntervalScale()
    }
}
function getViewRect(e, t) {
  return getLayoutRect(
    e.getBoxLayoutParams(),
    { width: t.getWidth(), height: t.getHeight() },
    e.get('padding')
  )
}
function makeControlIcon(e, t, i, r) {
  var n = r.style,
    a = createIcon(e.get(['controlStyle', t]), r || {}, new BoundingRect(i[0], i[1], i[2], i[3]))
  return n && a.setStyle(n), a
}
function giveSymbol(e, t, i, r, n, a) {
  var o = t.get('color')
  n
    ? (n.setColor(o), i.add(n), a && a.onUpdate(n))
    : ((n = createSymbol$1(e.get('symbol'), -1, -1, 2, 2, o)).setStyle('strokeNoScale', !0),
      i.add(n),
      a && a.onCreate(n))
  var s = t.getItemStyle(['color'])
  n.setStyle(s), (r = merge({ rectHover: !0, z2: 100 }, r, !0))
  var l = e.get('symbolSize')
  ;(l = l instanceof Array ? l.slice() : [+l, +l]), (r.scaleX = l[0] / 2), (r.scaleY = l[1] / 2)
  var h = e.get('symbolOffset')
  h &&
    ((r.x = r.x || 0),
    (r.y = r.y || 0),
    (r.x += parsePercent$1(h[0], l[0])),
    (r.y += parsePercent$1(h[1], l[1])))
  var u = e.get('symbolRotate')
  return (r.rotation = ((u || 0) * Math.PI) / 180 || 0), n.attr(r), n.updateTransform(), n
}
function pointerMoveTo(e, t, i, r, n, a) {
  if (!e.dragging) {
    var o = n.getModel('checkpointStyle'),
      s = r.dataToCoord(n.getData().get('value', i))
    if (a || !o.get('animation', !0)) e.attr({ x: s, y: 0 }), t && t.attr({ shape: { x2: s } })
    else {
      var l = { duration: o.get('animationDuration', !0), easing: o.get('animationEasing', !0) }
      e.stopAnimation(null, !0),
        e.animateTo({ x: s, y: 0 }, l),
        t && t.animateTo({ shape: { x2: s } }, l)
    }
  }
}
function installTimelineAction(e) {
  e.registerAction(
    { type: 'timelineChange', event: 'timelineChanged', update: 'prepareAndUpdate' },
    function (e, t) {
      var i = t.getComponent('timeline')
      return (
        i &&
          null != e.currentIndex &&
          (i.setCurrentIndex(e.currentIndex),
          !i.get('loop', !0) && i.isIndexMax() && i.setPlayState(!1)),
        t.resetOption('timeline', { replaceMerge: i.get('replaceMerge', !0) }),
        defaults$1({ currentIndex: i.option.currentIndex }, e)
      )
    }
  ),
    e.registerAction(
      { type: 'timelinePlayChange', event: 'timelinePlayChanged', update: 'update' },
      function (e, t) {
        var i = t.getComponent('timeline')
        i && null != e.playState && i.setPlayState(e.playState)
      }
    )
}
function timelinePreprocessor(e) {
  var t = e && e.timeline
  isArray$1(t) || (t = t ? [t] : []),
    each$i(t, function (e) {
      e && compatibleEC2(e)
    })
}
function compatibleEC2(e) {
  var t = e.type,
    i = { number: 'value', time: 'time' }
  if (
    (i[t] && ((e.axisType = i[t]), delete e.type), transferItem(e), has$1(e, 'controlPosition'))
  ) {
    var r = e.controlStyle || (e.controlStyle = {})
    has$1(r, 'position') || (r.position = e.controlPosition),
      'none' !== r.position || has$1(r, 'show') || ((r.show = !1), delete r.position),
      delete e.controlPosition
  }
  each$i(e.data || [], function (e) {
    isObject$7(e) &&
      !isArray$1(e) &&
      (!has$1(e, 'value') && has$1(e, 'name') && (e.value = e.name), transferItem(e))
  })
}
function transferItem(e) {
  var t = e.itemStyle || (e.itemStyle = {}),
    i = t.emphasis || (t.emphasis = {}),
    r = e.label || e.label || {},
    n = r.normal || (r.normal = {}),
    a = { normal: 1, emphasis: 1 }
  each$i(r, function (e, t) {
    a[t] || has$1(n, t) || (n[t] = e)
  }),
    i.label && !has$1(r, 'emphasis') && ((r.emphasis = i.label), delete i.label)
}
function has$1(e, t) {
  return e.hasOwnProperty(t)
}
function install$f(e) {
  e.registerComponentModel(SliderTimelineModel),
    e.registerComponentView(SliderTimelineView),
    e.registerSubTypeDefaulter('timeline', function () {
      return 'slider'
    }),
    installTimelineAction(e),
    e.registerPreprocessor(timelinePreprocessor)
}
function checkMarkerInSeries(e, t) {
  if (!e) return !1
  for (var i = isArray$1(e) ? e : [e], r = 0; r < i.length; r++) if (i[r] && i[r][t]) return !0
  return !1
}
function fillLabel(e) {
  defaultEmphasis(e, 'label', ['show'])
}
var inner$5 = makeInner(),
  MarkerModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.createdBySelf = !1), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (e, t, i) {
        this.mergeDefaultAndTheme(e, i), this._mergeOption(e, i, !1, !0)
      }),
      (t.prototype.isAnimationEnabled = function () {
        if (env.node) return !1
        var e = this.__hostSeries
        return this.getShallow('animation') && e && e.isAnimationEnabled()
      }),
      (t.prototype.mergeOption = function (e, t) {
        this._mergeOption(e, t, !1, !1)
      }),
      (t.prototype._mergeOption = function (e, t, i, r) {
        var n = this.mainType
        i ||
          t.eachSeries(function (e) {
            var i = e.get(this.mainType, !0),
              a = inner$5(e)[n]
            i && i.data
              ? (a
                  ? a._mergeOption(i, t, !0)
                  : (r && fillLabel(i),
                    each$i(i.data, function (e) {
                      e instanceof Array ? (fillLabel(e[0]), fillLabel(e[1])) : fillLabel(e)
                    }),
                    extend$3((a = this.createMarkerModelFromSeries(i, this, t)), {
                      mainType: this.mainType,
                      seriesIndex: e.seriesIndex,
                      name: e.name,
                      createdBySelf: !0
                    }),
                    (a.__hostSeries = e)),
                (inner$5(e)[n] = a))
              : (inner$5(e)[n] = null)
          }, this)
      }),
      (t.prototype.formatTooltip = function (e, t, i) {
        var r = this.getData(),
          n = this.getRawValue(e),
          a = r.getName(e)
        return createTooltipMarkup('section', {
          header: this.name,
          blocks: [
            createTooltipMarkup('nameValue', { name: a, value: n, noName: !a, noValue: null == n })
          ]
        })
      }),
      (t.prototype.getData = function () {
        return this._data
      }),
      (t.prototype.setData = function (e) {
        this._data = e
      }),
      (t.getMarkerModelFromSeries = function (e, t) {
        return inner$5(e)[t]
      }),
      (t.type = 'marker'),
      (t.dependencies = ['series', 'grid', 'polar', 'geo']),
      t
    )
  })(ComponentModel)
mixin(MarkerModel, DataFormatMixin.prototype)
var MarkPointModel = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), i
  }
  return (
    __extends(t, e),
    (t.prototype.createMarkerModelFromSeries = function (e, i, r) {
      return new t(e, i, r)
    }),
    (t.type = 'markPoint'),
    (t.defaultOption = {
      zlevel: 0,
      z: 5,
      symbol: 'pin',
      symbolSize: 50,
      tooltip: { trigger: 'item' },
      label: { show: !0, position: 'inside' },
      itemStyle: { borderWidth: 2 },
      emphasis: { label: { show: !0 } }
    }),
    t
  )
})(MarkerModel)
function hasXOrY(e) {
  return !(isNaN(parseFloat(e.x)) && isNaN(parseFloat(e.y)))
}
function hasXAndY(e) {
  return !isNaN(parseFloat(e.x)) && !isNaN(parseFloat(e.y))
}
function markerTypeCalculatorWithExtent(e, t, i, r, n, a) {
  var o = [],
    s = isDimensionStacked(t, r) ? t.getCalculationInfo('stackResultDimension') : r,
    l = numCalculate(t, s, e),
    h = t.indicesOfNearest(s, l)[0]
  ;(o[n] = t.get(i, h)), (o[a] = t.get(s, h))
  var u = t.get(r, h),
    p = getPrecision(t.get(r, h))
  return (p = Math.min(p, 20)) >= 0 && (o[a] = +o[a].toFixed(p)), [o, u]
}
var markerTypeCalculator = {
  min: curry$1(markerTypeCalculatorWithExtent, 'min'),
  max: curry$1(markerTypeCalculatorWithExtent, 'max'),
  average: curry$1(markerTypeCalculatorWithExtent, 'average'),
  median: curry$1(markerTypeCalculatorWithExtent, 'median')
}
function dataTransform(e, t) {
  var i = e.getData(),
    r = e.coordinateSystem
  if (t && !hasXAndY(t) && !isArray$1(t.coord) && r) {
    var n = r.dimensions,
      a = getAxisInfo(t, i, r, e)
    if ((t = clone$3(t)).type && markerTypeCalculator[t.type] && a.baseAxis && a.valueAxis) {
      var o = indexOf$1(n, a.baseAxis.dim),
        s = indexOf$1(n, a.valueAxis.dim),
        l = markerTypeCalculator[t.type](i, a.baseDataDim, a.valueDataDim, o, s)
      ;(t.coord = l[0]), (t.value = l[1])
    } else {
      for (
        var h = [null != t.xAxis ? t.xAxis : t.radiusAxis, null != t.yAxis ? t.yAxis : t.angleAxis],
          u = 0;
        u < 2;
        u++
      )
        markerTypeCalculator[h[u]] && (h[u] = numCalculate(i, i.mapDimension(n[u]), h[u]))
      t.coord = h
    }
  }
  return t
}
function getAxisInfo(e, t, i, r) {
  var n = {}
  return (
    null != e.valueIndex || null != e.valueDim
      ? ((n.valueDataDim = null != e.valueIndex ? t.getDimension(e.valueIndex) : e.valueDim),
        (n.valueAxis = i.getAxis(dataDimToCoordDim(r, n.valueDataDim))),
        (n.baseAxis = i.getOtherAxis(n.valueAxis)),
        (n.baseDataDim = t.mapDimension(n.baseAxis.dim)))
      : ((n.baseAxis = r.getBaseAxis()),
        (n.valueAxis = i.getOtherAxis(n.baseAxis)),
        (n.baseDataDim = t.mapDimension(n.baseAxis.dim)),
        (n.valueDataDim = t.mapDimension(n.valueAxis.dim))),
    n
  )
}
function dataDimToCoordDim(e, t) {
  var i = e.getData(),
    r = i.dimensions
  t = i.getDimension(t)
  for (var n = 0; n < r.length; n++) {
    var a = i.getDimensionInfo(r[n])
    if (a.name === t) return a.coordDim
  }
}
function dataFilter(e, t) {
  return !(e && e.containData && t.coord && !hasXOrY(t)) || e.containData(t.coord)
}
function dimValueGetter(e, t, i, r) {
  return r < 2 ? e.coord && e.coord[r] : e.value
}
function numCalculate(e, t, i) {
  if ('average' === i) {
    var r = 0,
      n = 0
    return (
      e.each(t, function (e, t) {
        isNaN(e) || ((r += e), n++)
      }),
      r / n
    )
  }
  return 'median' === i ? e.getMedian(t) : e.getDataExtent(t)['max' === i ? 1 : 0]
}
var inner$4 = makeInner(),
  MarkerView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function () {
        this.markerGroupMap = createHashMap()
      }),
      (t.prototype.render = function (e, t, i) {
        var r = this,
          n = this.markerGroupMap
        n.each(function (e) {
          inner$4(e).keep = !1
        }),
          t.eachSeries(function (e) {
            var n = MarkerModel.getMarkerModelFromSeries(e, r.type)
            n && r.renderSeries(e, n, t, i)
          }),
          n.each(function (e) {
            !inner$4(e).keep && r.group.remove(e.group)
          })
      }),
      (t.prototype.markKeep = function (e) {
        inner$4(e).keep = !0
      }),
      (t.prototype.blurSeries = function (e) {
        var t = this
        each$i(e, function (e) {
          var i = MarkerModel.getMarkerModelFromSeries(e, t.type)
          i &&
            i.getData().eachItemGraphicEl(function (e) {
              e && enterBlur(e)
            })
        })
      }),
      (t.type = 'marker'),
      t
    )
  })(ComponentView)
function updateMarkerLayout(e, t, i) {
  var r = t.coordinateSystem
  e.each(function (n) {
    var a,
      o = e.getItemModel(n),
      s = parsePercent$1(o.get('x'), i.getWidth()),
      l = parsePercent$1(o.get('y'), i.getHeight())
    if (isNaN(s) || isNaN(l)) {
      if (t.getMarkerPosition) a = t.getMarkerPosition(e.getValues(e.dimensions, n))
      else if (r) {
        var h = e.get(r.dimensions[0], n),
          u = e.get(r.dimensions[1], n)
        a = r.dataToPoint([h, u])
      }
    } else a = [s, l]
    isNaN(s) || (a[0] = s), isNaN(l) || (a[1] = l), e.setItemLayout(n, a)
  })
}
var MarkPointView = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), i
  }
  return (
    __extends(t, e),
    (t.prototype.updateTransform = function (e, t, i) {
      t.eachSeries(function (e) {
        var t = MarkerModel.getMarkerModelFromSeries(e, 'markPoint')
        t && (updateMarkerLayout(t.getData(), e, i), this.markerGroupMap.get(e.id).updateLayout())
      }, this)
    }),
    (t.prototype.renderSeries = function (e, t, i, r) {
      var n = e.coordinateSystem,
        a = e.id,
        o = e.getData(),
        s = this.markerGroupMap,
        l = s.get(a) || s.set(a, new SymbolDraw()),
        h = createList$2(n, e, t)
      t.setData(h),
        updateMarkerLayout(t.getData(), e, r),
        h.each(function (e) {
          var i = h.getItemModel(e),
            r = i.getShallow('symbol'),
            n = i.getShallow('symbolSize'),
            a = i.getShallow('symbolRotate')
          if (isFunction$1(r) || isFunction$1(n) || isFunction$1(a)) {
            var s = t.getRawValue(e),
              l = t.getDataParams(e)
            isFunction$1(r) && (r = r(s, l)),
              isFunction$1(n) && (n = n(s, l)),
              isFunction$1(a) && (a = a(s, l))
          }
          var u = i.getModel('itemStyle').getItemStyle(),
            p = getVisualFromData(o, 'color')
          u.fill || (u.fill = p),
            h.setItemVisual(e, { symbol: r, symbolSize: n, symbolRotate: a, style: u })
        }),
        l.updateData(h),
        this.group.add(l.group),
        h.eachItemGraphicEl(function (e) {
          e.traverse(function (e) {
            getECData(e).dataModel = t
          })
        }),
        this.markKeep(l),
        (l.group.silent = t.get('silent') || e.get('silent'))
    }),
    (t.type = 'markPoint'),
    t
  )
})(MarkerView)
function createList$2(e, t, i) {
  var r
  r = e
    ? map$1(e && e.dimensions, function (e) {
        return defaults$1(
          { name: e },
          t.getData().getDimensionInfo(t.getData().mapDimension(e)) || {}
        )
      })
    : [{ name: 'value', type: 'float' }]
  var n = new List(r, i),
    a = map$1(i.get('data'), curry$1(dataTransform, t))
  return (
    e && (a = filter$1(a, curry$1(dataFilter, e))),
    n.initData(
      a,
      null,
      e
        ? dimValueGetter
        : function (e) {
            return e.value
          }
    ),
    n
  )
}
function install$e(e) {
  e.registerComponentModel(MarkPointModel),
    e.registerComponentView(MarkPointView),
    e.registerPreprocessor(function (e) {
      checkMarkerInSeries(e.series, 'markPoint') && (e.markPoint = e.markPoint || {})
    })
}
var MarkLineModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.createMarkerModelFromSeries = function (e, i, r) {
        return new t(e, i, r)
      }),
      (t.type = 'markLine'),
      (t.defaultOption = {
        zlevel: 0,
        z: 5,
        symbol: ['circle', 'arrow'],
        symbolSize: [8, 16],
        symbolOffset: 0,
        precision: 2,
        tooltip: { trigger: 'item' },
        label: { show: !0, position: 'end', distance: 5 },
        lineStyle: { type: 'dashed' },
        emphasis: { label: { show: !0 }, lineStyle: { width: 3 } },
        animationEasing: 'linear'
      }),
      t
    )
  })(MarkerModel),
  inner$3 = makeInner(),
  markLineTransform = function (e, t, i, r) {
    var n,
      a = e.getData()
    if (isArray$1(r)) n = r
    else {
      var o = r.type
      if (
        'min' === o ||
        'max' === o ||
        'average' === o ||
        'median' === o ||
        null != r.xAxis ||
        null != r.yAxis
      ) {
        var s = void 0,
          l = void 0
        if (null != r.yAxis || null != r.xAxis)
          (s = t.getAxis(null != r.yAxis ? 'y' : 'x')), (l = retrieve(r.yAxis, r.xAxis))
        else {
          var h = getAxisInfo(r, a, t, e)
          ;(s = h.valueAxis), (l = numCalculate(a, getStackedDimension(a, h.valueDataDim), o))
        }
        var u = 'x' === s.dim ? 0 : 1,
          p = 1 - u,
          c = clone$3(r),
          d = { coord: [] }
        ;(c.type = null), (c.coord = []), (c.coord[p] = -1 / 0), (d.coord[p] = 1 / 0)
        var f = i.get('precision')
        f >= 0 && 'number' == typeof l && (l = +l.toFixed(Math.min(f, 20))),
          (c.coord[u] = d.coord[u] = l),
          (n = [c, d, { type: o, valueIndex: r.valueIndex, value: l }])
      } else n = []
    }
    var m = [dataTransform(e, n[0]), dataTransform(e, n[1]), extend$3({}, n[2])]
    return (m[2].type = m[2].type || null), merge(m[2], m[0]), merge(m[2], m[1]), m
  }
function isInifinity$1(e) {
  return !isNaN(e) && !isFinite(e)
}
function ifMarkLineHasOnlyDim(e, t, i, r) {
  var n = 1 - e,
    a = r.dimensions[e]
  return (
    isInifinity$1(t[n]) && isInifinity$1(i[n]) && t[e] === i[e] && r.getAxis(a).containData(t[e])
  )
}
function markLineFilter(e, t) {
  if ('cartesian2d' === e.type) {
    var i = t[0].coord,
      r = t[1].coord
    if (i && r && (ifMarkLineHasOnlyDim(1, i, r, e) || ifMarkLineHasOnlyDim(0, i, r, e))) return !0
  }
  return dataFilter(e, t[0]) && dataFilter(e, t[1])
}
function updateSingleMarkerEndLayout(e, t, i, r, n) {
  var a,
    o = r.coordinateSystem,
    s = e.getItemModel(t),
    l = parsePercent$1(s.get('x'), n.getWidth()),
    h = parsePercent$1(s.get('y'), n.getHeight())
  if (isNaN(l) || isNaN(h)) {
    if (r.getMarkerPosition) a = r.getMarkerPosition(e.getValues(e.dimensions, t))
    else {
      var u = o.dimensions,
        p = e.get(u[0], t),
        c = e.get(u[1], t)
      a = o.dataToPoint([p, c])
    }
    if (isCoordinateSystemType(o, 'cartesian2d')) {
      var d = o.getAxis('x'),
        f = o.getAxis('y')
      u = o.dimensions
      isInifinity$1(e.get(u[0], t))
        ? (a[0] = d.toGlobalCoord(d.getExtent()[i ? 0 : 1]))
        : isInifinity$1(e.get(u[1], t)) && (a[1] = f.toGlobalCoord(f.getExtent()[i ? 0 : 1]))
    }
    isNaN(l) || (a[0] = l), isNaN(h) || (a[1] = h)
  } else a = [l, h]
  e.setItemLayout(t, a)
}
var MarkLineView = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), i
  }
  return (
    __extends(t, e),
    (t.prototype.updateTransform = function (e, t, i) {
      t.eachSeries(function (e) {
        var t = MarkerModel.getMarkerModelFromSeries(e, 'markLine')
        if (t) {
          var r = t.getData(),
            n = inner$3(t).from,
            a = inner$3(t).to
          n.each(function (t) {
            updateSingleMarkerEndLayout(n, t, !0, e, i), updateSingleMarkerEndLayout(a, t, !1, e, i)
          }),
            r.each(function (e) {
              r.setItemLayout(e, [n.getItemLayout(e), a.getItemLayout(e)])
            }),
            this.markerGroupMap.get(e.id).updateLayout()
        }
      }, this)
    }),
    (t.prototype.renderSeries = function (e, t, i, r) {
      var n = e.coordinateSystem,
        a = e.id,
        o = e.getData(),
        s = this.markerGroupMap,
        l = s.get(a) || s.set(a, new LineDraw())
      this.group.add(l.group)
      var h = createList$1(n, e, t),
        u = h.from,
        p = h.to,
        c = h.line
      ;(inner$3(t).from = u), (inner$3(t).to = p), t.setData(c)
      var d = t.get('symbol'),
        f = t.get('symbolSize'),
        m = t.get('symbolRotate'),
        g = t.get('symbolOffset')
      function y(t, i, n) {
        var a = t.getItemModel(i)
        updateSingleMarkerEndLayout(t, i, n, e, r)
        var s = a.getModel('itemStyle').getItemStyle()
        null == s.fill && (s.fill = getVisualFromData(o, 'color')),
          t.setItemVisual(i, {
            symbolKeepAspect: a.get('symbolKeepAspect'),
            symbolOffset: retrieve2(a.get('symbolOffset'), g[n ? 0 : 1]),
            symbolRotate: retrieve2(a.get('symbolRotate', !0), m[n ? 0 : 1]),
            symbolSize: retrieve2(a.get('symbolSize'), f[n ? 0 : 1]),
            symbol: retrieve2(a.get('symbol', !0), d[n ? 0 : 1]),
            style: s
          })
      }
      isArray$1(d) || (d = [d, d]),
        isArray$1(f) || (f = [f, f]),
        isArray$1(m) || (m = [m, m]),
        isArray$1(g) || (g = [g, g]),
        h.from.each(function (e) {
          y(u, e, !0), y(p, e, !1)
        }),
        c.each(function (e) {
          var t = c.getItemModel(e).getModel('lineStyle').getLineStyle()
          c.setItemLayout(e, [u.getItemLayout(e), p.getItemLayout(e)]),
            null == t.stroke && (t.stroke = u.getItemVisual(e, 'style').fill),
            c.setItemVisual(e, {
              fromSymbolKeepAspect: u.getItemVisual(e, 'symbolKeepAspect'),
              fromSymbolOffset: u.getItemVisual(e, 'symbolOffset'),
              fromSymbolRotate: u.getItemVisual(e, 'symbolRotate'),
              fromSymbolSize: u.getItemVisual(e, 'symbolSize'),
              fromSymbol: u.getItemVisual(e, 'symbol'),
              toSymbolKeepAspect: p.getItemVisual(e, 'symbolKeepAspect'),
              toSymbolOffset: p.getItemVisual(e, 'symbolOffset'),
              toSymbolRotate: p.getItemVisual(e, 'symbolRotate'),
              toSymbolSize: p.getItemVisual(e, 'symbolSize'),
              toSymbol: p.getItemVisual(e, 'symbol'),
              style: t
            })
        }),
        l.updateData(c),
        h.line.eachItemGraphicEl(function (e, i) {
          e.traverse(function (e) {
            getECData(e).dataModel = t
          })
        }),
        this.markKeep(l),
        (l.group.silent = t.get('silent') || e.get('silent'))
    }),
    (t.type = 'markLine'),
    t
  )
})(MarkerView)
function createList$1(e, t, i) {
  var r
  r = e
    ? map$1(e && e.dimensions, function (e) {
        return defaults$1(
          { name: e },
          t.getData().getDimensionInfo(t.getData().mapDimension(e)) || {}
        )
      })
    : [{ name: 'value', type: 'float' }]
  var n = new List(r, i),
    a = new List(r, i),
    o = new List([], i),
    s = map$1(i.get('data'), curry$1(markLineTransform, t, e, i))
  e && (s = filter$1(s, curry$1(markLineFilter, e)))
  var l = e
    ? dimValueGetter
    : function (e) {
        return e.value
      }
  return (
    n.initData(
      map$1(s, function (e) {
        return e[0]
      }),
      null,
      l
    ),
    a.initData(
      map$1(s, function (e) {
        return e[1]
      }),
      null,
      l
    ),
    o.initData(
      map$1(s, function (e) {
        return e[2]
      })
    ),
    (o.hasItemOption = !0),
    { from: n, to: a, line: o }
  )
}
function install$d(e) {
  e.registerComponentModel(MarkLineModel),
    e.registerComponentView(MarkLineView),
    e.registerPreprocessor(function (e) {
      checkMarkerInSeries(e.series, 'markLine') && (e.markLine = e.markLine || {})
    })
}
var MarkAreaModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.createMarkerModelFromSeries = function (e, i, r) {
        return new t(e, i, r)
      }),
      (t.type = 'markArea'),
      (t.defaultOption = {
        zlevel: 0,
        z: 1,
        tooltip: { trigger: 'item' },
        animation: !1,
        label: { show: !0, position: 'top' },
        itemStyle: { borderWidth: 0 },
        emphasis: { label: { show: !0, position: 'top' } }
      }),
      t
    )
  })(MarkerModel),
  inner$2 = makeInner(),
  markAreaTransform = function (e, t, i, r) {
    var n = dataTransform(e, r[0]),
      a = dataTransform(e, r[1]),
      o = n.coord,
      s = a.coord
    ;(o[0] = retrieve(o[0], -1 / 0)),
      (o[1] = retrieve(o[1], -1 / 0)),
      (s[0] = retrieve(s[0], 1 / 0)),
      (s[1] = retrieve(s[1], 1 / 0))
    var l = mergeAll([{}, n, a])
    return (l.coord = [n.coord, a.coord]), (l.x0 = n.x), (l.y0 = n.y), (l.x1 = a.x), (l.y1 = a.y), l
  }
function isInifinity(e) {
  return !isNaN(e) && !isFinite(e)
}
function ifMarkAreaHasOnlyDim(e, t, i, r) {
  var n = 1 - e
  return isInifinity(t[n]) && isInifinity(i[n])
}
function markAreaFilter(e, t) {
  var i = t.coord[0],
    r = t.coord[1]
  return (
    !!(
      isCoordinateSystemType(e, 'cartesian2d') &&
      i &&
      r &&
      (ifMarkAreaHasOnlyDim(1, i, r) || ifMarkAreaHasOnlyDim(0, i, r))
    ) ||
    dataFilter(e, { coord: i, x: t.x0, y: t.y0 }) ||
    dataFilter(e, { coord: r, x: t.x1, y: t.y1 })
  )
}
function getSingleMarkerEndPoint(e, t, i, r, n) {
  var a,
    o = r.coordinateSystem,
    s = e.getItemModel(t),
    l = parsePercent$1(s.get(i[0]), n.getWidth()),
    h = parsePercent$1(s.get(i[1]), n.getHeight())
  if (isNaN(l) || isNaN(h)) {
    if (r.getMarkerPosition) a = r.getMarkerPosition(e.getValues(i, t))
    else {
      var u = [(d = e.get(i[0], t)), (f = e.get(i[1], t))]
      o.clampData && o.clampData(u, u), (a = o.dataToPoint(u, !0))
    }
    if (isCoordinateSystemType(o, 'cartesian2d')) {
      var p = o.getAxis('x'),
        c = o.getAxis('y'),
        d = e.get(i[0], t),
        f = e.get(i[1], t)
      isInifinity(d)
        ? (a[0] = p.toGlobalCoord(p.getExtent()['x0' === i[0] ? 0 : 1]))
        : isInifinity(f) && (a[1] = c.toGlobalCoord(c.getExtent()['y0' === i[1] ? 0 : 1]))
    }
    isNaN(l) || (a[0] = l), isNaN(h) || (a[1] = h)
  } else a = [l, h]
  return a
}
var dimPermutations = [
    ['x0', 'y0'],
    ['x1', 'y0'],
    ['x1', 'y1'],
    ['x0', 'y1']
  ],
  MarkAreaView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.updateTransform = function (e, t, i) {
        t.eachSeries(function (e) {
          var t = MarkerModel.getMarkerModelFromSeries(e, 'markArea')
          if (t) {
            var r = t.getData()
            r.each(function (t) {
              var n = map$1(dimPermutations, function (n) {
                return getSingleMarkerEndPoint(r, t, n, e, i)
              })
              r.setItemLayout(t, n), r.getItemGraphicEl(t).setShape('points', n)
            })
          }
        }, this)
      }),
      (t.prototype.renderSeries = function (e, t, i, r) {
        var n = e.coordinateSystem,
          a = e.id,
          o = e.getData(),
          s = this.markerGroupMap,
          l = s.get(a) || s.set(a, { group: new Group$3() })
        this.group.add(l.group), this.markKeep(l)
        var h = createList(n, e, t)
        t.setData(h),
          h.each(function (t) {
            var i = map$1(dimPermutations, function (i) {
                return getSingleMarkerEndPoint(h, t, i, e, r)
              }),
              a = n.getAxis('x').scale,
              s = n.getAxis('y').scale,
              l = a.getExtent(),
              u = s.getExtent(),
              p = [a.parse(h.get('x0', t)), a.parse(h.get('x1', t))],
              c = [s.parse(h.get('y0', t)), s.parse(h.get('y1', t))]
            asc$2(p), asc$2(c)
            var d = !!(l[0] > p[1] || l[1] < p[0] || u[0] > c[1] || u[1] < c[0])
            h.setItemLayout(t, { points: i, allClipped: d })
            var f = h.getItemModel(t).getModel('itemStyle').getItemStyle(),
              m = getVisualFromData(o, 'color')
            f.fill ||
              ((f.fill = m), 'string' == typeof f.fill && (f.fill = modifyAlpha(f.fill, 0.4))),
              f.stroke || (f.stroke = m),
              h.setItemVisual(t, 'style', f)
          }),
          h
            .diff(inner$2(l).data)
            .add(function (e) {
              var t = h.getItemLayout(e)
              if (!t.allClipped) {
                var i = new Polygon({ shape: { points: t.points } })
                h.setItemGraphicEl(e, i), l.group.add(i)
              }
            })
            .update(function (e, i) {
              var r = inner$2(l).data.getItemGraphicEl(i),
                n = h.getItemLayout(e)
              n.allClipped
                ? r && l.group.remove(r)
                : (r
                    ? updateProps$1(r, { shape: { points: n.points } }, t, e)
                    : (r = new Polygon({ shape: { points: n.points } })),
                  h.setItemGraphicEl(e, r),
                  l.group.add(r))
            })
            .remove(function (e) {
              var t = inner$2(l).data.getItemGraphicEl(e)
              l.group.remove(t)
            })
            .execute(),
          h.eachItemGraphicEl(function (e, i) {
            var r = h.getItemModel(i),
              n = h.getItemVisual(i, 'style')
            e.useStyle(h.getItemVisual(i, 'style')),
              setLabelStyle(e, getLabelStatesModels(r), {
                labelFetcher: t,
                labelDataIndex: i,
                defaultText: h.getName(i) || '',
                inheritColor: 'string' == typeof n.fill ? modifyAlpha(n.fill, 1) : '#000'
              }),
              setStatesStylesFromModel(e, r),
              enableHoverEmphasis(e),
              (getECData(e).dataModel = t)
          }),
          (inner$2(l).data = h),
          (l.group.silent = t.get('silent') || e.get('silent'))
      }),
      (t.type = 'markArea'),
      t
    )
  })(MarkerView)
function createList(e, t, i) {
  var r, n
  e
    ? ((r = map$1(e && e.dimensions, function (e) {
        var i = t.getData()
        return defaults$1({ name: e }, i.getDimensionInfo(i.mapDimension(e)) || {})
      })),
      (n = new List(
        map$1(['x0', 'y0', 'x1', 'y1'], function (e, t) {
          return { name: e, type: r[t % 2].type }
        }),
        i
      )))
    : (n = new List((r = [{ name: 'value', type: 'float' }]), i))
  var a = map$1(i.get('data'), curry$1(markAreaTransform, t, e, i))
  e && (a = filter$1(a, curry$1(markAreaFilter, e)))
  var o = e
    ? function (e, t, i, r) {
        return e.coord[Math.floor(r / 2)][r % 2]
      }
    : function (e) {
        return e.value
      }
  return n.initData(a, null, o), (n.hasItemOption = !0), n
}
function install$c(e) {
  e.registerComponentModel(MarkAreaModel),
    e.registerComponentView(MarkAreaView),
    e.registerPreprocessor(function (e) {
      checkMarkerInSeries(e.series, 'markArea') && (e.markArea = e.markArea || {})
    })
}
var getDefaultSelectorOptions = function (e, t) {
    return 'all' === t
      ? { type: 'all', title: e.getLocale(['legend', 'selector', 'all']) }
      : 'inverse' === t
      ? { type: 'inverse', title: e.getLocale(['legend', 'selector', 'inverse']) }
      : void 0
  },
  LegendModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.layoutMode = { type: 'box', ignoreSize: !0 }), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (e, t, i) {
        this.mergeDefaultAndTheme(e, i), (e.selected = e.selected || {}), this._updateSelector(e)
      }),
      (t.prototype.mergeOption = function (t, i) {
        e.prototype.mergeOption.call(this, t, i), this._updateSelector(t)
      }),
      (t.prototype._updateSelector = function (e) {
        var t = e.selector,
          i = this.ecModel
        !0 === t && (t = e.selector = ['all', 'inverse']),
          isArray$1(t) &&
            each$i(t, function (e, r) {
              isString(e) && (e = { type: e }),
                (t[r] = merge(e, getDefaultSelectorOptions(i, e.type)))
            })
      }),
      (t.prototype.optionUpdated = function () {
        this._updateData(this.ecModel)
        var e = this._data
        if (e[0] && 'single' === this.get('selectedMode')) {
          for (var t = !1, i = 0; i < e.length; i++) {
            var r = e[i].get('name')
            if (this.isSelected(r)) {
              this.select(r), (t = !0)
              break
            }
          }
          !t && this.select(e[0].get('name'))
        }
      }),
      (t.prototype._updateData = function (e) {
        var t = [],
          i = []
        e.eachRawSeries(function (r) {
          var n,
            a = r.name
          if ((i.push(a), r.legendVisualProvider)) {
            var o = r.legendVisualProvider.getAllNames()
            e.isSeriesFiltered(r) || (i = i.concat(o)), o.length ? (t = t.concat(o)) : (n = !0)
          } else n = !0
          n && isNameSpecified(r) && t.push(r.name)
        }),
          (this._availableNames = i)
        var r = map$1(
          this.get('data') || t,
          function (e) {
            return (
              ('string' != typeof e && 'number' != typeof e) || (e = { name: e }),
              new Model(e, this, this.ecModel)
            )
          },
          this
        )
        this._data = r
      }),
      (t.prototype.getData = function () {
        return this._data
      }),
      (t.prototype.select = function (e) {
        var t = this.option.selected
        'single' === this.get('selectedMode') &&
          each$i(this._data, function (e) {
            t[e.get('name')] = !1
          })
        t[e] = !0
      }),
      (t.prototype.unSelect = function (e) {
        'single' !== this.get('selectedMode') && (this.option.selected[e] = !1)
      }),
      (t.prototype.toggleSelected = function (e) {
        var t = this.option.selected
        t.hasOwnProperty(e) || (t[e] = !0), this[t[e] ? 'unSelect' : 'select'](e)
      }),
      (t.prototype.allSelect = function () {
        var e = this._data,
          t = this.option.selected
        each$i(e, function (e) {
          t[e.get('name', !0)] = !0
        })
      }),
      (t.prototype.inverseSelect = function () {
        var e = this._data,
          t = this.option.selected
        each$i(e, function (e) {
          var i = e.get('name', !0)
          t.hasOwnProperty(i) || (t[i] = !0), (t[i] = !t[i])
        })
      }),
      (t.prototype.isSelected = function (e) {
        var t = this.option.selected
        return !(t.hasOwnProperty(e) && !t[e]) && indexOf$1(this._availableNames, e) >= 0
      }),
      (t.prototype.getOrient = function () {
        return 'vertical' === this.get('orient')
          ? { index: 1, name: 'vertical' }
          : { index: 0, name: 'horizontal' }
      }),
      (t.type = 'legend.plain'),
      (t.dependencies = ['series']),
      (t.defaultOption = {
        zlevel: 0,
        z: 4,
        show: !0,
        orient: 'horizontal',
        left: 'center',
        top: 0,
        align: 'auto',
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        borderRadius: 0,
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        itemWidth: 25,
        itemHeight: 14,
        symbolRotate: 'inherit',
        inactiveColor: '#ccc',
        inactiveBorderColor: '#ccc',
        inactiveBorderWidth: 'auto',
        itemStyle: {
          color: 'inherit',
          opacity: 'inherit',
          decal: 'inherit',
          shadowBlur: 0,
          shadowColor: null,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          borderColor: 'inherit',
          borderWidth: 'auto',
          borderCap: 'inherit',
          borderJoin: 'inherit',
          borderDashOffset: 'inherit',
          borderMiterLimit: 'inherit'
        },
        lineStyle: {
          width: 'auto',
          color: 'inherit',
          inactiveColor: '#ccc',
          inactiveWidth: 2,
          opacity: 'inherit',
          type: 'inherit',
          cap: 'inherit',
          join: 'inherit',
          dashOffset: 'inherit',
          miterLimit: 'inherit',
          shadowBlur: 0,
          shadowColor: null,
          shadowOffsetX: 0,
          shadowOffsetY: 0
        },
        textStyle: { color: '#333' },
        selectedMode: !0,
        selector: !1,
        selectorLabel: {
          show: !0,
          borderRadius: 10,
          padding: [3, 5, 3, 5],
          fontSize: 12,
          fontFamily: ' sans-serif',
          color: '#666',
          borderWidth: 1,
          borderColor: '#666'
        },
        emphasis: { selectorLabel: { show: !0, color: '#eee', backgroundColor: '#666' } },
        selectorPosition: 'auto',
        selectorItemGap: 7,
        selectorButtonGap: 10,
        tooltip: { show: !1 }
      }),
      t
    )
  })(ComponentModel),
  curry = curry$1,
  each$4 = each$i,
  Group$1 = Group$3,
  LegendView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.newlineDisabled = !1), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function () {
        this.group.add((this._contentGroup = new Group$1())),
          this.group.add((this._selectorGroup = new Group$1())),
          (this._isFirstRender = !0)
      }),
      (t.prototype.getContentGroup = function () {
        return this._contentGroup
      }),
      (t.prototype.getSelectorGroup = function () {
        return this._selectorGroup
      }),
      (t.prototype.render = function (e, t, i) {
        var r = this._isFirstRender
        if (((this._isFirstRender = !1), this.resetInner(), e.get('show', !0))) {
          var n = e.get('align'),
            a = e.get('orient')
          ;(n && 'auto' !== n) ||
            (n = 'right' === e.get('left') && 'vertical' === a ? 'right' : 'left')
          var o = e.get('selector', !0),
            s = e.get('selectorPosition', !0)
          !o || (s && 'auto' !== s) || (s = 'horizontal' === a ? 'end' : 'start'),
            this.renderInner(n, e, t, i, o, a, s)
          var l = e.getBoxLayoutParams(),
            h = { width: i.getWidth(), height: i.getHeight() },
            u = e.get('padding'),
            p = getLayoutRect(l, h, u),
            c = this.layoutInner(e, n, p, r, o, s),
            d = getLayoutRect(defaults$1({ width: c.width, height: c.height }, l), h, u)
          ;(this.group.x = d.x - c.x),
            (this.group.y = d.y - c.y),
            this.group.markRedraw(),
            this.group.add((this._backgroundEl = makeBackground(c, e)))
        }
      }),
      (t.prototype.resetInner = function () {
        this.getContentGroup().removeAll(),
          this._backgroundEl && this.group.remove(this._backgroundEl),
          this.getSelectorGroup().removeAll()
      }),
      (t.prototype.renderInner = function (e, t, i, r, n, a, o) {
        var s = this.getContentGroup(),
          l = createHashMap(),
          h = t.get('selectedMode'),
          u = []
        i.eachRawSeries(function (e) {
          !e.get('legendHoverLink') && u.push(e.id)
        }),
          each$4(
            t.getData(),
            function (n, a) {
              var o = n.get('name')
              if (!this.newlineDisabled && ('' === o || '\n' === o)) {
                var p = new Group$1()
                return (p.newline = !0), void s.add(p)
              }
              var c = i.getSeriesByName(o)[0]
              if (!l.get(o))
                if (c) {
                  var d = c.getData(),
                    f = d.getVisual('legendLineStyle') || {},
                    m = d.getVisual('legendIcon'),
                    g = d.getVisual('style')
                  this._createItem(c, o, a, n, t, e, f, g, m, h)
                    .on('click', curry(dispatchSelectAction, o, null, r, u))
                    .on('mouseover', curry(dispatchHighlightAction, c.name, null, r, u))
                    .on('mouseout', curry(dispatchDownplayAction, c.name, null, r, u)),
                    l.set(o, !0)
                } else
                  i.eachRawSeries(function (i) {
                    if (!l.get(o) && i.legendVisualProvider) {
                      var s = i.legendVisualProvider
                      if (!s.containName(o)) return
                      var p = s.indexOfName(o),
                        c = s.getItemVisual(p, 'style'),
                        d = s.getItemVisual(p, 'legendIcon'),
                        f = parse(c.fill)
                      f && 0 === f[3] && ((f[3] = 0.2), (c.fill = stringify(f, 'rgba'))),
                        this._createItem(i, o, a, n, t, e, {}, c, d, h)
                          .on('click', curry(dispatchSelectAction, null, o, r, u))
                          .on('mouseover', curry(dispatchHighlightAction, null, o, r, u))
                          .on('mouseout', curry(dispatchDownplayAction, null, o, r, u)),
                        l.set(o, !0)
                    }
                  }, this)
            },
            this
          ),
          n && this._createSelector(n, t, r, a, o)
      }),
      (t.prototype._createSelector = function (e, t, i, r, n) {
        var a = this.getSelectorGroup()
        each$4(e, function (e) {
          var r = e.type,
            n = new ZRText({
              style: { x: 0, y: 0, align: 'center', verticalAlign: 'middle' },
              onclick: function () {
                i.dispatchAction({ type: 'all' === r ? 'legendAllSelect' : 'legendInverseSelect' })
              }
            })
          a.add(n),
            setLabelStyle(
              n,
              {
                normal: t.getModel('selectorLabel'),
                emphasis: t.getModel(['emphasis', 'selectorLabel'])
              },
              { defaultText: e.title }
            ),
            enableHoverEmphasis(n)
        })
      }),
      (t.prototype._createItem = function (e, t, i, r, n, a, o, s, l, h) {
        var u = e.visualDrawType,
          p = n.get('itemWidth'),
          c = n.get('itemHeight'),
          d = n.isSelected(t),
          f = r.get('symbolRotate'),
          m = r.get('icon'),
          g = getLegendStyle((l = m || l || 'roundRect'), r, n.getModel('lineStyle'), o, s, u, d),
          y = new Group$1(),
          v = r.getModel('textStyle')
        if ('function' != typeof e.getLegendIcon || (m && 'inherit' !== m)) {
          var _ =
            'inherit' === m && e.getData().getVisual('symbol')
              ? 'inherit' === f
                ? e.getData().getVisual('symbolRotate')
                : f
              : 0
          y.add(
            getDefaultLegendIcon({
              itemWidth: p,
              itemHeight: c,
              icon: l,
              iconRotate: _,
              itemStyle: g.itemStyle,
              lineStyle: g.lineStyle
            })
          )
        } else
          y.add(
            e.getLegendIcon({
              itemWidth: p,
              itemHeight: c,
              icon: l,
              iconRotate: f,
              itemStyle: g.itemStyle,
              lineStyle: g.lineStyle
            })
          )
        var x = 'left' === a ? p + 5 : -5,
          S = a,
          b = n.get('formatter'),
          T = t
        'string' == typeof b && b
          ? (T = b.replace('{name}', null != t ? t : ''))
          : 'function' == typeof b && (T = b(t))
        var A = r.get('inactiveColor')
        y.add(
          new ZRText({
            style: createTextStyle(v, {
              text: T,
              x: x,
              y: c / 2,
              fill: d ? v.getTextColor() : A,
              align: S,
              verticalAlign: 'middle'
            })
          })
        )
        var w = new Rect$2({ shape: y.getBoundingRect(), invisible: !0 }),
          M = r.getModel('tooltip')
        return (
          M.get('show') &&
            setTooltipConfig({
              el: w,
              componentModel: n,
              itemName: t,
              itemTooltipOption: M.option
            }),
          y.add(w),
          y.eachChild(function (e) {
            e.silent = !0
          }),
          (w.silent = !h),
          this.getContentGroup().add(y),
          enableHoverEmphasis(y),
          (y.__legendDataIndex = i),
          y
        )
      }),
      (t.prototype.layoutInner = function (e, t, i, r, n, a) {
        var o = this.getContentGroup(),
          s = this.getSelectorGroup()
        box(e.get('orient'), o, e.get('itemGap'), i.width, i.height)
        var l = o.getBoundingRect(),
          h = [-l.x, -l.y]
        if ((s.markRedraw(), o.markRedraw(), n)) {
          box('horizontal', s, e.get('selectorItemGap', !0))
          var u = s.getBoundingRect(),
            p = [-u.x, -u.y],
            c = e.get('selectorButtonGap', !0),
            d = e.getOrient().index,
            f = 0 === d ? 'width' : 'height',
            m = 0 === d ? 'height' : 'width',
            g = 0 === d ? 'y' : 'x'
          'end' === a ? (p[d] += l[f] + c) : (h[d] += u[f] + c),
            (p[1 - d] += l[m] / 2 - u[m] / 2),
            (s.x = p[0]),
            (s.y = p[1]),
            (o.x = h[0]),
            (o.y = h[1])
          var y = { x: 0, y: 0 }
          return (
            (y[f] = l[f] + c + u[f]),
            (y[m] = Math.max(l[m], u[m])),
            (y[g] = Math.min(0, u[g] + p[1 - d])),
            y
          )
        }
        return (o.x = h[0]), (o.y = h[1]), this.group.getBoundingRect()
      }),
      (t.prototype.remove = function () {
        this.getContentGroup().removeAll(), (this._isFirstRender = !0)
      }),
      (t.type = 'legend.plain'),
      t
    )
  })(ComponentView)
function getLegendStyle(e, t, i, r, n, a, o) {
  for (
    var s = t.getModel('itemStyle'), l = ITEM_STYLE_KEY_MAP.concat([['decal']]), h = {}, u = 0;
    u < l.length;
    ++u
  ) {
    var p = l[u][l[u].length - 1],
      c = l[u][0]
    if ('inherit' === (g = s.getShallow(p)))
      switch (c) {
        case 'fill':
          h.fill = n[a]
          break
        case 'stroke':
          h.stroke = n[0 === e.lastIndexOf('empty', 0) ? 'fill' : 'stroke']
          break
        case 'opacity':
          h.opacity = ('fill' === a ? n : r).opacity
          break
        default:
          h[c] = n[c]
      }
    else 'auto' === g && 'lineWidth' === c ? (h.lineWidth = n.lineWidth > 0 ? 2 : 0) : (h[c] = g)
  }
  var d = t.getModel('lineStyle'),
    f = LINE_STYLE_KEY_MAP.concat([['inactiveColor'], ['inactiveWidth']]),
    m = {}
  for (u = 0; u < f.length; ++u) {
    var g
    ;(p = f[u][1]), (c = f[u][0])
    'inherit' === (g = d.getShallow(p))
      ? (m[c] = r[c])
      : 'auto' === g && 'lineWidth' === c
      ? (m.lineWidth = r.lineWidth > 0 ? 2 : 0)
      : (m[c] = g)
  }
  if (
    ('auto' === h.fill && (h.fill = n.fill),
    'auto' === h.stroke && (h.stroke = n.fill),
    'auto' === m.stroke && (m.stroke = n.fill),
    !o)
  ) {
    var y = t.get('inactiveBorderWidth'),
      v = h[e.indexOf('empty') > -1 ? 'fill' : 'stroke']
    ;(h.lineWidth = 'auto' === y ? (n.lineWidth > 0 && v ? 2 : 0) : h.lineWidth),
      (h.fill = t.get('inactiveColor')),
      (h.stroke = t.get('inactiveBorderColor')),
      (m.stroke = i.get('inactiveColor')),
      (m.lineWidth = i.get('inactiveWidth'))
  }
  return { itemStyle: h, lineStyle: m }
}
function getDefaultLegendIcon(e) {
  var t = e.icon || 'roundRect',
    i = createSymbol$1(t, 0, 0, e.itemWidth, e.itemHeight, e.itemStyle.fill)
  return (
    i.setStyle(e.itemStyle),
    (i.rotation = ((e.iconRotate || 0) * Math.PI) / 180),
    i.setOrigin([e.itemWidth / 2, e.itemHeight / 2]),
    t.indexOf('empty') > -1 &&
      ((i.style.stroke = i.style.fill), (i.style.fill = '#fff'), (i.style.lineWidth = 2)),
    i
  )
}
function dispatchSelectAction(e, t, i, r) {
  dispatchDownplayAction(e, t, i, r),
    i.dispatchAction({ type: 'legendToggleSelect', name: null != e ? e : t }),
    dispatchHighlightAction(e, t, i, r)
}
function isUseHoverLayer(e) {
  for (
    var t, i = e.getZr().storage.getDisplayList(), r = 0, n = i.length;
    r < n && !(t = i[r].states.emphasis);

  )
    r++
  return t && t.hoverLayer
}
function dispatchHighlightAction(e, t, i, r) {
  isUseHoverLayer(i) ||
    i.dispatchAction({ type: 'highlight', seriesName: e, name: t, excludeSeriesId: r })
}
function dispatchDownplayAction(e, t, i, r) {
  isUseHoverLayer(i) ||
    i.dispatchAction({ type: 'downplay', seriesName: e, name: t, excludeSeriesId: r })
}
function legendFilter(e) {
  var t = e.findComponents({ mainType: 'legend' })
  t &&
    t.length &&
    e.filterSeries(function (e) {
      for (var i = 0; i < t.length; i++) if (!t[i].isSelected(e.name)) return !1
      return !0
    })
}
function legendSelectActionHandler(e, t, i) {
  var r,
    n = {},
    a = 'toggleSelected' === e
  return (
    i.eachComponent('legend', function (i) {
      a && null != r
        ? i[r ? 'select' : 'unSelect'](t.name)
        : 'allSelect' === e || 'inverseSelect' === e
        ? i[e]()
        : (i[e](t.name), (r = i.isSelected(t.name))),
        each$i(i.getData(), function (e) {
          var t = e.get('name')
          if ('\n' !== t && '' !== t) {
            var r = i.isSelected(t)
            n.hasOwnProperty(t) ? (n[t] = n[t] && r) : (n[t] = r)
          }
        })
    }),
    'allSelect' === e || 'inverseSelect' === e ? { selected: n } : { name: t.name, selected: n }
  )
}
function installLegendAction(e) {
  e.registerAction(
    'legendToggleSelect',
    'legendselectchanged',
    curry$1(legendSelectActionHandler, 'toggleSelected')
  ),
    e.registerAction(
      'legendAllSelect',
      'legendselectall',
      curry$1(legendSelectActionHandler, 'allSelect')
    ),
    e.registerAction(
      'legendInverseSelect',
      'legendinverseselect',
      curry$1(legendSelectActionHandler, 'inverseSelect')
    ),
    e.registerAction(
      'legendSelect',
      'legendselected',
      curry$1(legendSelectActionHandler, 'select')
    ),
    e.registerAction(
      'legendUnSelect',
      'legendunselected',
      curry$1(legendSelectActionHandler, 'unSelect')
    )
}
function install$b(e) {
  e.registerComponentModel(LegendModel),
    e.registerComponentView(LegendView),
    e.registerProcessor(e.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter),
    e.registerSubTypeDefaulter('legend', function () {
      return 'plain'
    }),
    installLegendAction(e)
}
var ScrollableLegendModel = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), i
  }
  return (
    __extends(t, e),
    (t.prototype.setScrollDataIndex = function (e) {
      this.option.scrollDataIndex = e
    }),
    (t.prototype.init = function (t, i, r) {
      var n = getLayoutParams(t)
      e.prototype.init.call(this, t, i, r), mergeAndNormalizeLayoutParams(this, t, n)
    }),
    (t.prototype.mergeOption = function (t, i) {
      e.prototype.mergeOption.call(this, t, i), mergeAndNormalizeLayoutParams(this, this.option, t)
    }),
    (t.type = 'legend.scroll'),
    (t.defaultOption = inheritDefaultOption(LegendModel.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: 'end',
      pageFormatter: '{current}/{total}',
      pageIcons: {
        horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],
        vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']
      },
      pageIconColor: '#2f4554',
      pageIconInactiveColor: '#aaa',
      pageIconSize: 15,
      pageTextStyle: { color: '#333' },
      animationDurationUpdate: 800
    })),
    t
  )
})(LegendModel)
function mergeAndNormalizeLayoutParams(e, t, i) {
  var r = [1, 1]
  ;(r[e.getOrient().index] = 0), mergeLayoutParam(t, i, { type: 'box', ignoreSize: !!r })
}
var Group = Group$3,
  WH = ['width', 'height'],
  XY = ['x', 'y'],
  ScrollableLegendView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.newlineDisabled = !0), (i._currentIndex = 0), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function () {
        e.prototype.init.call(this),
          this.group.add((this._containerGroup = new Group())),
          this._containerGroup.add(this.getContentGroup()),
          this.group.add((this._controllerGroup = new Group()))
      }),
      (t.prototype.resetInner = function () {
        e.prototype.resetInner.call(this),
          this._controllerGroup.removeAll(),
          this._containerGroup.removeClipPath(),
          (this._containerGroup.__rectSize = null)
      }),
      (t.prototype.renderInner = function (t, i, r, n, a, o, s) {
        var l = this
        e.prototype.renderInner.call(this, t, i, r, n, a, o, s)
        var h = this._controllerGroup,
          u = i.get('pageIconSize', !0),
          p = isArray$1(u) ? u : [u, u]
        d('pagePrev', 0)
        var c = i.getModel('pageTextStyle')
        function d(e, t) {
          var r = e + 'DataIndex',
            a = createIcon(
              i.get('pageIcons', !0)[i.getOrient().name][t],
              { onclick: bind$2(l._pageGo, l, r, i, n) },
              { x: -p[0] / 2, y: -p[1] / 2, width: p[0], height: p[1] }
            )
          ;(a.name = e), h.add(a)
        }
        h.add(
          new ZRText({
            name: 'pageText',
            style: {
              text: 'xx/xx',
              fill: c.getTextColor(),
              font: c.getFont(),
              verticalAlign: 'middle',
              align: 'center'
            },
            silent: !0
          })
        ),
          d('pageNext', 1)
      }),
      (t.prototype.layoutInner = function (e, t, i, r, n, a) {
        var o = this.getSelectorGroup(),
          s = e.getOrient().index,
          l = WH[s],
          h = XY[s],
          u = WH[1 - s],
          p = XY[1 - s]
        n && box('horizontal', o, e.get('selectorItemGap', !0))
        var c = e.get('selectorButtonGap', !0),
          d = o.getBoundingRect(),
          f = [-d.x, -d.y],
          m = clone$3(i)
        n && (m[l] = i[l] - d[l] - c)
        var g = this._layoutContentAndController(e, r, m, s, l, u, p, h)
        if (n) {
          if ('end' === a) f[s] += g[l] + c
          else {
            var y = d[l] + c
            ;(f[s] -= y), (g[h] -= y)
          }
          ;(g[l] += d[l] + c),
            (f[1 - s] += g[p] + g[u] / 2 - d[u] / 2),
            (g[u] = Math.max(g[u], d[u])),
            (g[p] = Math.min(g[p], d[p] + f[1 - s])),
            (o.x = f[0]),
            (o.y = f[1]),
            o.markRedraw()
        }
        return g
      }),
      (t.prototype._layoutContentAndController = function (e, t, i, r, n, a, o, s) {
        var l = this.getContentGroup(),
          h = this._containerGroup,
          u = this._controllerGroup
        box(e.get('orient'), l, e.get('itemGap'), r ? i.width : null, r ? null : i.height),
          box('horizontal', u, e.get('pageButtonItemGap', !0))
        var p = l.getBoundingRect(),
          c = u.getBoundingRect(),
          d = (this._showController = p[n] > i[n]),
          f = [-p.x, -p.y]
        t || (f[r] = l[s])
        var m = [0, 0],
          g = [-c.x, -c.y],
          y = retrieve2(e.get('pageButtonGap', !0), e.get('itemGap', !0))
        d &&
          ('end' === e.get('pageButtonPosition', !0) ? (g[r] += i[n] - c[n]) : (m[r] += c[n] + y))
        ;(g[1 - r] += p[a] / 2 - c[a] / 2), l.setPosition(f), h.setPosition(m), u.setPosition(g)
        var v = { x: 0, y: 0 }
        if (
          ((v[n] = d ? i[n] : p[n]),
          (v[a] = Math.max(p[a], c[a])),
          (v[o] = Math.min(0, c[o] + g[1 - r])),
          (h.__rectSize = i[n]),
          d)
        ) {
          var _ = { x: 0, y: 0 }
          ;(_[n] = Math.max(i[n] - c[n] - y, 0)),
            (_[a] = v[a]),
            h.setClipPath(new Rect$2({ shape: _ })),
            (h.__rectSize = _[n])
        } else
          u.eachChild(function (e) {
            e.attr({ invisible: !0, silent: !0 })
          })
        var x = this._getPageInfo(e)
        return (
          null != x.pageIndex &&
            updateProps$1(l, { x: x.contentPosition[0], y: x.contentPosition[1] }, d ? e : null),
          this._updatePageInfoView(e, x),
          v
        )
      }),
      (t.prototype._pageGo = function (e, t, i) {
        var r = this._getPageInfo(t)[e]
        null != r && i.dispatchAction({ type: 'legendScroll', scrollDataIndex: r, legendId: t.id })
      }),
      (t.prototype._updatePageInfoView = function (e, t) {
        var i = this._controllerGroup
        each$i(['pagePrev', 'pageNext'], function (r) {
          var n = null != t[r + 'DataIndex'],
            a = i.childOfName(r)
          a &&
            (a.setStyle(
              'fill',
              n ? e.get('pageIconColor', !0) : e.get('pageIconInactiveColor', !0)
            ),
            (a.cursor = n ? 'pointer' : 'default'))
        })
        var r = i.childOfName('pageText'),
          n = e.get('pageFormatter'),
          a = t.pageIndex,
          o = null != a ? a + 1 : 0,
          s = t.pageCount
        r &&
          n &&
          r.setStyle(
            'text',
            isString(n)
              ? n
                  .replace('{current}', null == o ? '' : o + '')
                  .replace('{total}', null == s ? '' : s + '')
              : n({ current: o, total: s })
          )
      }),
      (t.prototype._getPageInfo = function (e) {
        var t = e.get('scrollDataIndex', !0),
          i = this.getContentGroup(),
          r = this._containerGroup.__rectSize,
          n = e.getOrient().index,
          a = WH[n],
          o = XY[n],
          s = this._findTargetItemIndex(t),
          l = i.children(),
          h = l[s],
          u = l.length,
          p = u ? 1 : 0,
          c = {
            contentPosition: [i.x, i.y],
            pageCount: p,
            pageIndex: p - 1,
            pagePrevDataIndex: null,
            pageNextDataIndex: null
          }
        if (!h) return c
        var d = v(h)
        c.contentPosition[n] = -d.s
        for (var f = s + 1, m = d, g = d, y = null; f <= u; ++f)
          ((!(y = v(l[f])) && g.e > m.s + r) || (y && !_(y, m.s))) &&
            (m = g.i > m.i ? g : y) &&
            (null == c.pageNextDataIndex && (c.pageNextDataIndex = m.i), ++c.pageCount),
            (g = y)
        for (f = s - 1, m = d, g = d, y = null; f >= -1; --f)
          ((y = v(l[f])) && _(g, y.s)) ||
            !(m.i < g.i) ||
            ((g = m),
            null == c.pagePrevDataIndex && (c.pagePrevDataIndex = m.i),
            ++c.pageCount,
            ++c.pageIndex),
            (m = y)
        return c
        function v(e) {
          if (e) {
            var t = e.getBoundingRect(),
              i = t[o] + e[o]
            return { s: i, e: i + t[a], i: e.__legendDataIndex }
          }
        }
        function _(e, t) {
          return e.e >= t && e.s <= t + r
        }
      }),
      (t.prototype._findTargetItemIndex = function (e) {
        return this._showController
          ? (this.getContentGroup().eachChild(function (r, n) {
              var a = r.__legendDataIndex
              null == i && null != a && (i = n), a === e && (t = n)
            }),
            null != t ? t : i)
          : 0
        var t, i
      }),
      (t.type = 'legend.scroll'),
      t
    )
  })(LegendView)
function installScrollableLegendAction(e) {
  e.registerAction('legendScroll', 'legendscroll', function (e, t) {
    var i = e.scrollDataIndex
    null != i &&
      t.eachComponent({ mainType: 'legend', subType: 'scroll', query: e }, function (e) {
        e.setScrollDataIndex(i)
      })
  })
}
function install$a(e) {
  use(install$b),
    e.registerComponentModel(ScrollableLegendModel),
    e.registerComponentView(ScrollableLegendView),
    installScrollableLegendAction(e)
}
function install$9(e) {
  use(install$b), use(install$a)
}
var InsideZoomModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.type = 'dataZoom.inside'),
      (t.defaultOption = inheritDefaultOption(DataZoomModel.defaultOption, {
        disabled: !1,
        zoomLock: !1,
        zoomOnMouseWheel: !0,
        moveOnMouseMove: !0,
        moveOnMouseWheel: !1,
        preventDefaultMouseMove: !0
      })),
      t
    )
  })(DataZoomModel),
  inner$1 = makeInner()
function setViewInfoToCoordSysRecord(e, t, i) {
  inner$1(e).coordSysRecordMap.each(function (e) {
    var r = e.dataZoomInfoMap.get(t.uid)
    r && (r.getRange = i)
  })
}
function disposeCoordSysRecordIfNeeded(e, t) {
  for (var i = inner$1(e).coordSysRecordMap, r = i.keys(), n = 0; n < r.length; n++) {
    var a = r[n],
      o = i.get(a),
      s = o.dataZoomInfoMap
    if (s) {
      var l = t.uid
      s.get(l) && (s.removeKey(l), s.keys().length || disposeCoordSysRecord(i, o))
    }
  }
}
function disposeCoordSysRecord(e, t) {
  if (t) {
    e.removeKey(t.model.uid)
    var i = t.controller
    i && i.dispose()
  }
}
function createCoordSysRecord(e, t) {
  var i = {
      model: t,
      containsPoint: curry$1(containsPoint, t),
      dispatchAction: curry$1(dispatchAction, e),
      dataZoomInfoMap: null,
      controller: null
    },
    r = (i.controller = new RoamController(e.getZr()))
  return (
    each$i(['pan', 'zoom', 'scrollMove'], function (e) {
      r.on(e, function (t) {
        var r = []
        i.dataZoomInfoMap.each(function (n) {
          if (t.isAvailableBehavior(n.model.option)) {
            var a = (n.getRange || {})[e],
              o = a && a(n.dzReferCoordSysInfo, i.model.mainType, i.controller, t)
            !n.model.get('disabled', !0) &&
              o &&
              r.push({ dataZoomId: n.model.id, start: o[0], end: o[1] })
          }
        }),
          r.length && i.dispatchAction(r)
      })
    }),
    i
  )
}
function dispatchAction(e, t) {
  e.dispatchAction({ type: 'dataZoom', animation: { easing: 'cubicOut', duration: 100 }, batch: t })
}
function containsPoint(e, t, i, r) {
  return e.coordinateSystem.containPoint([i, r])
}
function mergeControllerParams(e) {
  var t,
    i = 'type_',
    r = { type_true: 2, type_move: 1, type_false: 0, type_undefined: -1 },
    n = !0
  return (
    e.each(function (e) {
      var a = e.model,
        o = !a.get('disabled', !0) && (!a.get('zoomLock', !0) || 'move')
      r[i + o] > r[i + t] && (t = o), (n = n && a.get('preventDefaultMouseMove', !0))
    }),
    {
      controlType: t,
      opt: {
        zoomOnMouseWheel: !0,
        moveOnMouseMove: !0,
        moveOnMouseWheel: !0,
        preventDefaultMouseMove: !!n
      }
    }
  )
}
function installDataZoomRoamProcessor(e) {
  e.registerProcessor(e.PRIORITY.PROCESSOR.FILTER, function (e, t) {
    var i = inner$1(t),
      r = i.coordSysRecordMap || (i.coordSysRecordMap = createHashMap())
    r.each(function (e) {
      e.dataZoomInfoMap = null
    }),
      e.eachComponent({ mainType: 'dataZoom', subType: 'inside' }, function (e) {
        each$i(collectReferCoordSysModelInfo(e).infoList, function (i) {
          var n = i.model.uid,
            a = r.get(n) || r.set(n, createCoordSysRecord(t, i.model))
          ;(a.dataZoomInfoMap || (a.dataZoomInfoMap = createHashMap())).set(e.uid, {
            dzReferCoordSysInfo: i,
            model: e,
            getRange: null
          })
        })
      }),
      r.each(function (e) {
        var t,
          i = e.controller,
          n = e.dataZoomInfoMap
        if (n) {
          var a = n.keys()[0]
          null != a && (t = n.get(a))
        }
        if (t) {
          var o = mergeControllerParams(n)
          i.enable(o.controlType, o.opt),
            i.setPointerChecker(e.containsPoint),
            createOrUpdate(e, 'dispatchAction', t.model.get('throttle', !0), 'fixRate')
        } else disposeCoordSysRecord(r, e)
      })
  })
}
var InsideZoomView = (function (e) {
    function t() {
      var t = (null !== e && e.apply(this, arguments)) || this
      return (t.type = 'dataZoom.inside'), t
    }
    return (
      __extends(t, e),
      (t.prototype.render = function (t, i, r) {
        e.prototype.render.apply(this, arguments),
          t.noTarget()
            ? this._clear()
            : ((this.range = t.getPercentRange()),
              setViewInfoToCoordSysRecord(r, t, {
                pan: bind$2(getRangeHandlers.pan, this),
                zoom: bind$2(getRangeHandlers.zoom, this),
                scrollMove: bind$2(getRangeHandlers.scrollMove, this)
              }))
      }),
      (t.prototype.dispose = function () {
        this._clear(), e.prototype.dispose.apply(this, arguments)
      }),
      (t.prototype._clear = function () {
        disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel), (this.range = null)
      }),
      (t.type = 'dataZoom.inside'),
      t
    )
  })(DataZoomView),
  getRangeHandlers = {
    zoom: function (e, t, i, r) {
      var n = this.range,
        a = n.slice(),
        o = e.axisModels[0]
      if (o) {
        var s = getDirectionInfo[t](null, [r.originX, r.originY], o, i, e),
          l =
            ((s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) /
              s.pixelLength) *
              (a[1] - a[0]) +
            a[0],
          h = Math.max(1 / r.scale, 0)
        ;(a[0] = (a[0] - l) * h + l), (a[1] = (a[1] - l) * h + l)
        var u = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan()
        return (
          sliderMove(0, a, [0, 100], 0, u.minSpan, u.maxSpan),
          (this.range = a),
          n[0] !== a[0] || n[1] !== a[1] ? a : void 0
        )
      }
    },
    pan: makeMover(function (e, t, i, r, n, a) {
      var o = getDirectionInfo[r]([a.oldX, a.oldY], [a.newX, a.newY], t, n, i)
      return (o.signal * (e[1] - e[0]) * o.pixel) / o.pixelLength
    }),
    scrollMove: makeMover(function (e, t, i, r, n, a) {
      return (
        getDirectionInfo[r]([0, 0], [a.scrollDelta, a.scrollDelta], t, n, i).signal *
        (e[1] - e[0]) *
        a.scrollDelta
      )
    })
  }
function makeMover(e) {
  return function (t, i, r, n) {
    var a = this.range,
      o = a.slice(),
      s = t.axisModels[0]
    if (s)
      return (
        sliderMove(e(o, s, t, i, r, n), o, [0, 100], 'all'),
        (this.range = o),
        a[0] !== o[0] || a[1] !== o[1] ? o : void 0
      )
  }
}
var getDirectionInfo = {
  grid: function (e, t, i, r, n) {
    var a = i.axis,
      o = {},
      s = n.model.coordinateSystem.getRect()
    return (
      (e = e || [0, 0]),
      'x' === a.dim
        ? ((o.pixel = t[0] - e[0]),
          (o.pixelLength = s.width),
          (o.pixelStart = s.x),
          (o.signal = a.inverse ? 1 : -1))
        : ((o.pixel = t[1] - e[1]),
          (o.pixelLength = s.height),
          (o.pixelStart = s.y),
          (o.signal = a.inverse ? -1 : 1)),
      o
    )
  },
  polar: function (e, t, i, r, n) {
    var a = i.axis,
      o = {},
      s = n.model.coordinateSystem,
      l = s.getRadiusAxis().getExtent(),
      h = s.getAngleAxis().getExtent()
    return (
      (e = e ? s.pointToCoord(e) : [0, 0]),
      (t = s.pointToCoord(t)),
      'radiusAxis' === i.mainType
        ? ((o.pixel = t[0] - e[0]),
          (o.pixelLength = l[1] - l[0]),
          (o.pixelStart = l[0]),
          (o.signal = a.inverse ? 1 : -1))
        : ((o.pixel = t[1] - e[1]),
          (o.pixelLength = h[1] - h[0]),
          (o.pixelStart = h[0]),
          (o.signal = a.inverse ? -1 : 1)),
      o
    )
  },
  singleAxis: function (e, t, i, r, n) {
    var a = i.axis,
      o = n.model.coordinateSystem.getRect(),
      s = {}
    return (
      (e = e || [0, 0]),
      'horizontal' === a.orient
        ? ((s.pixel = t[0] - e[0]),
          (s.pixelLength = o.width),
          (s.pixelStart = o.x),
          (s.signal = a.inverse ? 1 : -1))
        : ((s.pixel = t[1] - e[1]),
          (s.pixelLength = o.height),
          (s.pixelStart = o.y),
          (s.signal = a.inverse ? -1 : 1)),
      s
    )
  }
}
function install$8(e) {
  installCommon$1(e),
    e.registerComponentModel(InsideZoomModel),
    e.registerComponentView(InsideZoomView),
    installDataZoomRoamProcessor(e)
}
var SliderZoomModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.type = 'dataZoom.slider'),
      (t.layoutMode = 'box'),
      (t.defaultOption = inheritDefaultOption(DataZoomModel.defaultOption, {
        show: !0,
        right: 'ph',
        top: 'ph',
        width: 'ph',
        height: 'ph',
        left: null,
        bottom: null,
        borderColor: '#d2dbee',
        borderRadius: 3,
        backgroundColor: 'rgba(47,69,84,0)',
        dataBackground: {
          lineStyle: { color: '#d2dbee', width: 0.5 },
          areaStyle: { color: '#d2dbee', opacity: 0.2 }
        },
        selectedDataBackground: {
          lineStyle: { color: '#8fb0f7', width: 0.5 },
          areaStyle: { color: '#8fb0f7', opacity: 0.2 }
        },
        fillerColor: 'rgba(135,175,274,0.2)',
        handleIcon:
          'path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z',
        handleSize: '100%',
        handleStyle: { color: '#fff', borderColor: '#ACB8D1' },
        moveHandleSize: 7,
        moveHandleIcon:
          'path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z',
        moveHandleStyle: { color: '#D2DBEE', opacity: 0.7 },
        showDetail: !0,
        showDataShadow: 'auto',
        realtime: !0,
        zoomLock: !1,
        textStyle: { color: '#6E7079' },
        brushSelect: !0,
        brushStyle: { color: 'rgba(135,175,274,0.15)' },
        emphasis: { handleStyle: { borderColor: '#8FB0F7' }, moveHandleStyle: { color: '#8FB0F7' } }
      })),
      t
    )
  })(DataZoomModel),
  Rect = Rect$2,
  DEFAULT_LOCATION_EDGE_GAP = 7,
  DEFAULT_FRAME_BORDER_WIDTH = 1,
  DEFAULT_FILLER_SIZE = 30,
  DEFAULT_MOVE_HANDLE_SIZE = 7,
  HORIZONTAL = 'horizontal',
  VERTICAL = 'vertical',
  LABEL_GAP = 5,
  SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'],
  REALTIME_ANIMATION_CONFIG = { easing: 'cubicOut', duration: 100 },
  SliderZoomView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i._displayables = {}), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (e, t) {
        ;(this.api = t),
          (this._onBrush = bind$2(this._onBrush, this)),
          (this._onBrushEnd = bind$2(this._onBrushEnd, this))
      }),
      (t.prototype.render = function (t, i, r, n) {
        if (
          (e.prototype.render.apply(this, arguments),
          createOrUpdate(this, '_dispatchZoomAction', t.get('throttle'), 'fixRate'),
          (this._orient = t.getOrient()),
          !1 !== t.get('show'))
        ) {
          if (t.noTarget()) return this._clear(), void this.group.removeAll()
          ;(n && 'dataZoom' === n.type && n.from === this.uid) || this._buildView(),
            this._updateView()
        } else this.group.removeAll()
      }),
      (t.prototype.dispose = function () {
        this._clear(), e.prototype.dispose.apply(this, arguments)
      }),
      (t.prototype._clear = function () {
        clear$1(this, '_dispatchZoomAction')
        var e = this.api.getZr()
        e.off('mousemove', this._onBrush), e.off('mouseup', this._onBrushEnd)
      }),
      (t.prototype._buildView = function () {
        var e = this.group
        e.removeAll(),
          (this._brushing = !1),
          (this._displayables.brushRect = null),
          this._resetLocation(),
          this._resetInterval()
        var t = (this._displayables.sliderGroup = new Group$3())
        this._renderBackground(),
          this._renderHandle(),
          this._renderDataShadow(),
          e.add(t),
          this._positionGroup()
      }),
      (t.prototype._resetLocation = function () {
        var e = this.dataZoomModel,
          t = this.api,
          i = e.get('brushSelect') ? DEFAULT_MOVE_HANDLE_SIZE : 0,
          r = this._findCoordRect(),
          n = { width: t.getWidth(), height: t.getHeight() },
          a =
            this._orient === HORIZONTAL
              ? {
                  right: n.width - r.x - r.width,
                  top: n.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP - i,
                  width: r.width,
                  height: DEFAULT_FILLER_SIZE
                }
              : {
                  right: DEFAULT_LOCATION_EDGE_GAP,
                  top: r.y,
                  width: DEFAULT_FILLER_SIZE,
                  height: r.height
                },
          o = getLayoutParams(e.option)
        each$i(['right', 'top', 'width', 'height'], function (e) {
          'ph' === o[e] && (o[e] = a[e])
        })
        var s = getLayoutRect(o, n)
        ;(this._location = { x: s.x, y: s.y }),
          (this._size = [s.width, s.height]),
          this._orient === VERTICAL && this._size.reverse()
      }),
      (t.prototype._positionGroup = function () {
        var e = this.group,
          t = this._location,
          i = this._orient,
          r = this.dataZoomModel.getFirstTargetAxisModel(),
          n = r && r.get('inverse'),
          a = this._displayables.sliderGroup,
          o = (this._dataShadowInfo || {}).otherAxisInverse
        a.attr(
          i !== HORIZONTAL || n
            ? i === HORIZONTAL && n
              ? { scaleY: o ? 1 : -1, scaleX: -1 }
              : i !== VERTICAL || n
              ? { scaleY: o ? -1 : 1, scaleX: -1, rotation: Math.PI / 2 }
              : { scaleY: o ? -1 : 1, scaleX: 1, rotation: Math.PI / 2 }
            : { scaleY: o ? 1 : -1, scaleX: 1 }
        )
        var s = e.getBoundingRect([a])
        ;(e.x = t.x - s.x), (e.y = t.y - s.y), e.markRedraw()
      }),
      (t.prototype._getViewExtent = function () {
        return [0, this._size[0]]
      }),
      (t.prototype._renderBackground = function () {
        var e = this.dataZoomModel,
          t = this._size,
          i = this._displayables.sliderGroup,
          r = e.get('brushSelect')
        i.add(
          new Rect({
            silent: !0,
            shape: { x: 0, y: 0, width: t[0], height: t[1] },
            style: { fill: e.get('backgroundColor') },
            z2: -40
          })
        )
        var n = new Rect({
            shape: { x: 0, y: 0, width: t[0], height: t[1] },
            style: { fill: 'transparent' },
            z2: 0,
            onclick: bind$2(this._onClickPanel, this)
          }),
          a = this.api.getZr()
        r
          ? (n.on('mousedown', this._onBrushStart, this),
            (n.cursor = 'crosshair'),
            a.on('mousemove', this._onBrush),
            a.on('mouseup', this._onBrushEnd))
          : (a.off('mousemove', this._onBrush), a.off('mouseup', this._onBrushEnd)),
          i.add(n)
      }),
      (t.prototype._renderDataShadow = function () {
        var e = (this._dataShadowInfo = this._prepareDataShadowInfo())
        if (((this._displayables.dataShadowSegs = []), e)) {
          var t = this._size,
            i = e.series,
            r = i.getRawData(),
            n = i.getShadowDim ? i.getShadowDim() : e.otherDim
          if (null != n) {
            var a = r.getDataExtent(n),
              o = 0.3 * (a[1] - a[0])
            a = [a[0] - o, a[1] + o]
            var s,
              l = [0, t[1]],
              h = [0, t[0]],
              u = [
                [t[0], 0],
                [0, 0]
              ],
              p = [],
              c = h[1] / (r.count() - 1),
              d = 0,
              f = Math.round(r.count() / t[0])
            r.each([n], function (e, t) {
              if (f > 0 && t % f) d += c
              else {
                var i = null == e || isNaN(e) || '' === e,
                  r = i ? 0 : linearMap$2(e, a, l, !0)
                i && !s && t
                  ? (u.push([u[u.length - 1][0], 0]), p.push([p[p.length - 1][0], 0]))
                  : !i && s && (u.push([d, 0]), p.push([d, 0])),
                  u.push([d, r]),
                  p.push([d, r]),
                  (d += c),
                  (s = i)
              }
            })
            for (var m, g, y, v, _, x = this.dataZoomModel, S = 0; S < 3; S++) {
              var b =
                ((m = 1 === S),
                (g = void 0),
                (y = void 0),
                (v = void 0),
                (_ = void 0),
                (g = x.getModel(m ? 'selectedDataBackground' : 'dataBackground')),
                (y = new Group$3()),
                (v = new Polygon({
                  shape: { points: u },
                  segmentIgnoreThreshold: 1,
                  style: g.getModel('areaStyle').getAreaStyle(),
                  silent: !0,
                  z2: -20
                })),
                (_ = new Polyline$1({
                  shape: { points: p },
                  segmentIgnoreThreshold: 1,
                  style: g.getModel('lineStyle').getLineStyle(),
                  silent: !0,
                  z2: -19
                })),
                y.add(v),
                y.add(_),
                y)
              this._displayables.sliderGroup.add(b), this._displayables.dataShadowSegs.push(b)
            }
          }
        }
      }),
      (t.prototype._prepareDataShadowInfo = function () {
        var e = this.dataZoomModel,
          t = e.get('showDataShadow')
        if (!1 !== t) {
          var i,
            r = this.ecModel
          return (
            e.eachTargetAxis(function (n, a) {
              each$i(
                e.getAxisProxy(n, a).getTargetSeriesModels(),
                function (e) {
                  if (
                    !(i || (!0 !== t && indexOf$1(SHOW_DATA_SHADOW_SERIES_TYPE, e.get('type')) < 0))
                  ) {
                    var o,
                      s = r.getComponent(getAxisMainType(n), a).axis,
                      l = getOtherDim(n),
                      h = e.coordinateSystem
                    null != l && h.getOtherAxis && (o = h.getOtherAxis(s).inverse),
                      (l = e.getData().mapDimension(l)),
                      (i = { thisAxis: s, series: e, thisDim: n, otherDim: l, otherAxisInverse: o })
                  }
                },
                this
              )
            }, this),
            i
          )
        }
      }),
      (t.prototype._renderHandle = function () {
        var e = this.group,
          t = this._displayables,
          i = (t.handles = [null, null]),
          r = (t.handleLabels = [null, null]),
          n = this._displayables.sliderGroup,
          a = this._size,
          o = this.dataZoomModel,
          s = this.api,
          l = o.get('borderRadius') || 0,
          h = o.get('brushSelect'),
          u = (t.filler = new Rect({
            silent: h,
            style: { fill: o.get('fillerColor') },
            textConfig: { position: 'inside' }
          }))
        n.add(u),
          n.add(
            new Rect({
              silent: !0,
              subPixelOptimize: !0,
              shape: { x: 0, y: 0, width: a[0], height: a[1], r: l },
              style: {
                stroke: o.get('dataBackgroundColor') || o.get('borderColor'),
                lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
                fill: 'rgba(0,0,0,0)'
              }
            })
          ),
          each$i(
            [0, 1],
            function (t) {
              var a = o.get('handleIcon')
              !symbolBuildProxies[a] &&
                a.indexOf('path://') < 0 &&
                a.indexOf('image://') < 0 &&
                (a = 'path://' + a)
              var s = createSymbol$1(a, -1, 0, 2, 2, null, !0)
              s.attr({
                cursor: getCursor$1(this._orient),
                draggable: !0,
                drift: bind$2(this._onDragMove, this, t),
                ondragend: bind$2(this._onDragEnd, this),
                onmouseover: bind$2(this._showDataInfo, this, !0),
                onmouseout: bind$2(this._showDataInfo, this, !1),
                z2: 5
              })
              var l = s.getBoundingRect(),
                h = o.get('handleSize')
              ;(this._handleHeight = parsePercent$1(h, this._size[1])),
                (this._handleWidth = (l.width / l.height) * this._handleHeight),
                s.setStyle(o.getModel('handleStyle').getItemStyle()),
                (s.style.strokeNoScale = !0),
                (s.rectHover = !0),
                (s.ensureState('emphasis').style = o
                  .getModel(['emphasis', 'handleStyle'])
                  .getItemStyle()),
                enableHoverEmphasis(s)
              var u = o.get('handleColor')
              null != u && (s.style.fill = u), n.add((i[t] = s))
              var p = o.getModel('textStyle')
              e.add(
                (r[t] = new ZRText({
                  silent: !0,
                  invisible: !0,
                  style: createTextStyle(p, {
                    x: 0,
                    y: 0,
                    text: '',
                    verticalAlign: 'middle',
                    align: 'center',
                    fill: p.getTextColor(),
                    font: p.getFont()
                  }),
                  z2: 10
                }))
              )
            },
            this
          )
        var p = u
        if (h) {
          var c = parsePercent$1(o.get('moveHandleSize'), a[1]),
            d = (t.moveHandle = new Rect$2({
              style: o.getModel('moveHandleStyle').getItemStyle(),
              silent: !0,
              shape: { r: [0, 0, 2, 2], y: a[1] - 0.5, height: c }
            })),
            f = 0.8 * c,
            m = (t.moveHandleIcon = createSymbol$1(
              o.get('moveHandleIcon'),
              -f / 2,
              -f / 2,
              f,
              f,
              '#fff',
              !0
            ))
          ;(m.silent = !0),
            (m.y = a[1] + c / 2 - 0.5),
            (d.ensureState('emphasis').style = o
              .getModel(['emphasis', 'moveHandleStyle'])
              .getItemStyle())
          var g = Math.min(a[1] / 2, Math.max(c, 10))
          ;(p = t.moveZone = new Rect$2({ invisible: !0, shape: { y: a[1] - g, height: c + g } }))
            .on('mouseover', function () {
              s.enterEmphasis(d)
            })
            .on('mouseout', function () {
              s.leaveEmphasis(d)
            }),
            n.add(d),
            n.add(m),
            n.add(p)
        }
        p.attr({
          draggable: !0,
          cursor: getCursor$1(this._orient),
          drift: bind$2(this._onDragMove, this, 'all'),
          ondragstart: bind$2(this._showDataInfo, this, !0),
          ondragend: bind$2(this._onDragEnd, this),
          onmouseover: bind$2(this._showDataInfo, this, !0),
          onmouseout: bind$2(this._showDataInfo, this, !1)
        })
      }),
      (t.prototype._resetInterval = function () {
        var e = (this._range = this.dataZoomModel.getPercentRange()),
          t = this._getViewExtent()
        this._handleEnds = [linearMap$2(e[0], [0, 100], t, !0), linearMap$2(e[1], [0, 100], t, !0)]
      }),
      (t.prototype._updateInterval = function (e, t) {
        var i = this.dataZoomModel,
          r = this._handleEnds,
          n = this._getViewExtent(),
          a = i.findRepresentativeAxisProxy().getMinMaxSpan(),
          o = [0, 100]
        sliderMove(
          t,
          r,
          n,
          i.get('zoomLock') ? 'all' : e,
          null != a.minSpan ? linearMap$2(a.minSpan, o, n, !0) : null,
          null != a.maxSpan ? linearMap$2(a.maxSpan, o, n, !0) : null
        )
        var s = this._range,
          l = (this._range = asc$2([linearMap$2(r[0], n, o, !0), linearMap$2(r[1], n, o, !0)]))
        return !s || s[0] !== l[0] || s[1] !== l[1]
      }),
      (t.prototype._updateView = function (e) {
        var t = this._displayables,
          i = this._handleEnds,
          r = asc$2(i.slice()),
          n = this._size
        each$i(
          [0, 1],
          function (e) {
            var r = t.handles[e],
              a = this._handleHeight
            r.attr({ scaleX: a / 2, scaleY: a / 2, x: i[e] + (e ? -1 : 1), y: n[1] / 2 - a / 2 })
          },
          this
        ),
          t.filler.setShape({ x: r[0], y: 0, width: r[1] - r[0], height: n[1] })
        var a = { x: r[0], width: r[1] - r[0] }
        t.moveHandle &&
          (t.moveHandle.setShape(a),
          t.moveZone.setShape(a),
          t.moveZone.getBoundingRect(),
          t.moveHandleIcon && t.moveHandleIcon.attr('x', a.x + a.width / 2))
        for (var o = t.dataShadowSegs, s = [0, r[0], r[1], n[0]], l = 0; l < o.length; l++) {
          var h = o[l],
            u = h.getClipPath()
          u || ((u = new Rect$2()), h.setClipPath(u)),
            u.setShape({ x: s[l], y: 0, width: s[l + 1] - s[l], height: n[1] })
        }
        this._updateDataInfo(e)
      }),
      (t.prototype._updateDataInfo = function (e) {
        var t = this.dataZoomModel,
          i = this._displayables,
          r = i.handleLabels,
          n = this._orient,
          a = ['', '']
        if (t.get('showDetail')) {
          var o = t.findRepresentativeAxisProxy()
          if (o) {
            var s = o.getAxisModel().axis,
              l = this._range,
              h = e
                ? o.calculateDataWindow({ start: l[0], end: l[1] }).valueWindow
                : o.getDataValueWindow()
            a = [this._formatLabel(h[0], s), this._formatLabel(h[1], s)]
          }
        }
        var u = asc$2(this._handleEnds.slice())
        function p(e) {
          var t = getTransform$1(i.handles[e].parent, this.group),
            o = transformDirection(0 === e ? 'right' : 'left', t),
            s = this._handleWidth / 2 + LABEL_GAP,
            l = applyTransform([u[e] + (0 === e ? -s : s), this._size[1] / 2], t)
          r[e].setStyle({
            x: l[0],
            y: l[1],
            verticalAlign: n === HORIZONTAL ? 'middle' : o,
            align: n === HORIZONTAL ? o : 'center',
            text: a[e]
          })
        }
        p.call(this, 0), p.call(this, 1)
      }),
      (t.prototype._formatLabel = function (e, t) {
        var i = this.dataZoomModel,
          r = i.get('labelFormatter'),
          n = i.get('labelPrecision')
        ;(null != n && 'auto' !== n) || (n = t.getPixelPrecision())
        var a =
          null == e || isNaN(e)
            ? ''
            : 'category' === t.type || 'time' === t.type
            ? t.scale.getLabel({ value: Math.round(e) })
            : e.toFixed(Math.min(n, 20))
        return isFunction$1(r) ? r(e, a) : isString(r) ? r.replace('{value}', a) : a
      }),
      (t.prototype._showDataInfo = function (e) {
        e = this._dragging || e
        var t = this._displayables,
          i = t.handleLabels
        i[0].attr('invisible', !e),
          i[1].attr('invisible', !e),
          t.moveHandle && this.api[e ? 'enterEmphasis' : 'leaveEmphasis'](t.moveHandle, 1)
      }),
      (t.prototype._onDragMove = function (e, t, i, r) {
        ;(this._dragging = !0), stop(r.event)
        var n = applyTransform([t, i], this._displayables.sliderGroup.getLocalTransform(), !0),
          a = this._updateInterval(e, n[0]),
          o = this.dataZoomModel.get('realtime')
        this._updateView(!o), a && o && this._dispatchZoomAction(!0)
      }),
      (t.prototype._onDragEnd = function () {
        ;(this._dragging = !1),
          this._showDataInfo(!1),
          !this.dataZoomModel.get('realtime') && this._dispatchZoomAction(!1)
      }),
      (t.prototype._onClickPanel = function (e) {
        var t = this._size,
          i = this._displayables.sliderGroup.transformCoordToLocal(e.offsetX, e.offsetY)
        if (!(i[0] < 0 || i[0] > t[0] || i[1] < 0 || i[1] > t[1])) {
          var r = this._handleEnds,
            n = (r[0] + r[1]) / 2,
            a = this._updateInterval('all', i[0] - n)
          this._updateView(), a && this._dispatchZoomAction(!1)
        }
      }),
      (t.prototype._onBrushStart = function (e) {
        var t = e.offsetX,
          i = e.offsetY
        ;(this._brushStart = new Point(t, i)),
          (this._brushing = !0),
          (this._brushStartTime = +new Date())
      }),
      (t.prototype._onBrushEnd = function (e) {
        if (this._brushing) {
          var t = this._displayables.brushRect
          if (((this._brushing = !1), t)) {
            t.attr('ignore', !0)
            var i = t.shape
            if (!(+new Date() - this._brushStartTime < 200 && Math.abs(i.width) < 5)) {
              var r = this._getViewExtent(),
                n = [0, 100]
              ;(this._range = asc$2([
                linearMap$2(i.x, r, n, !0),
                linearMap$2(i.x + i.width, r, n, !0)
              ])),
                (this._handleEnds = [i.x, i.x + i.width]),
                this._updateView(),
                this._dispatchZoomAction(!1)
            }
          }
        }
      }),
      (t.prototype._onBrush = function (e) {
        this._brushing && (stop(e.event), this._updateBrushRect(e.offsetX, e.offsetY))
      }),
      (t.prototype._updateBrushRect = function (e, t) {
        var i = this._displayables,
          r = this.dataZoomModel,
          n = i.brushRect
        n ||
          ((n = i.brushRect =
            new Rect({ silent: !0, style: r.getModel('brushStyle').getItemStyle() })),
          i.sliderGroup.add(n)),
          n.attr('ignore', !1)
        var a = this._brushStart,
          o = this._displayables.sliderGroup,
          s = o.transformCoordToLocal(e, t),
          l = o.transformCoordToLocal(a.x, a.y),
          h = this._size
        ;(s[0] = Math.max(Math.min(h[0], s[0]), 0)),
          n.setShape({ x: l[0], y: 0, width: s[0] - l[0], height: h[1] })
      }),
      (t.prototype._dispatchZoomAction = function (e) {
        var t = this._range
        this.api.dispatchAction({
          type: 'dataZoom',
          from: this.uid,
          dataZoomId: this.dataZoomModel.id,
          animation: e ? REALTIME_ANIMATION_CONFIG : null,
          start: t[0],
          end: t[1]
        })
      }),
      (t.prototype._findCoordRect = function () {
        var e,
          t = collectReferCoordSysModelInfo(this.dataZoomModel).infoList
        if (!e && t.length) {
          var i = t[0].model.coordinateSystem
          e = i.getRect && i.getRect()
        }
        if (!e) {
          var r = this.api.getWidth(),
            n = this.api.getHeight()
          e = { x: 0.2 * r, y: 0.2 * n, width: 0.6 * r, height: 0.6 * n }
        }
        return e
      }),
      (t.type = 'dataZoom.slider'),
      t
    )
  })(DataZoomView)
function getOtherDim(e) {
  return { x: 'y', y: 'x', radius: 'angle', angle: 'radius' }[e]
}
function getCursor$1(e) {
  return 'vertical' === e ? 'ns-resize' : 'ew-resize'
}
function install$7(e) {
  e.registerComponentModel(SliderZoomModel),
    e.registerComponentView(SliderZoomView),
    installCommon$1(e)
}
function install$6(e) {
  use(install$8), use(install$7)
}
var visualDefault = {
    get: function (e, t, i) {
      var r = clone$3((defaultOption[e] || {})[t])
      return i && isArray$1(r) ? r[r.length - 1] : r
    }
  },
  defaultOption = {
    color: { active: ['#006edd', '#e0ffff'], inactive: ['rgba(0,0,0,0)'] },
    colorHue: { active: [0, 360], inactive: [0, 0] },
    colorSaturation: { active: [0.3, 1], inactive: [0, 0] },
    colorLightness: { active: [0.9, 0.5], inactive: [0, 0] },
    colorAlpha: { active: [0.3, 1], inactive: [0, 0] },
    opacity: { active: [0.3, 1], inactive: [0, 0] },
    symbol: { active: ['circle', 'roundRect', 'diamond'], inactive: ['none'] },
    symbolSize: { active: [10, 50], inactive: [0, 0] }
  },
  mapVisual = VisualMapping.mapVisual,
  eachVisual = VisualMapping.eachVisual,
  isArray = isArray$1,
  each$3 = each$i,
  asc = asc$2,
  linearMap$1 = linearMap$2,
  VisualMapModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (
        (i.type = t.type),
        (i.stateList = ['inRange', 'outOfRange']),
        (i.replacableOptionKeys = ['inRange', 'outOfRange', 'target', 'controller', 'color']),
        (i.layoutMode = { type: 'box', ignoreSize: !0 }),
        (i.dataBound = [-1 / 0, 1 / 0]),
        (i.targetVisuals = {}),
        (i.controllerVisuals = {}),
        i
      )
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (e, t, i) {
        this.mergeDefaultAndTheme(e, i)
      }),
      (t.prototype.optionUpdated = function (e, t) {
        var i = this.option
        env.canvasSupported || (i.realtime = !1),
          !t && replaceVisualOption(i, e, this.replacableOptionKeys),
          (this.textStyleModel = this.getModel('textStyle')),
          this.resetItemSize(),
          this.completeVisualOption()
      }),
      (t.prototype.resetVisual = function (e) {
        var t = this.stateList
        ;(e = bind$2(e, this)),
          (this.controllerVisuals = createVisualMappings(this.option.controller, t, e)),
          (this.targetVisuals = createVisualMappings(this.option.target, t, e))
      }),
      (t.prototype.getItemSymbol = function () {
        return null
      }),
      (t.prototype.getTargetSeriesIndices = function () {
        var e = this.option.seriesIndex,
          t = []
        return (
          null == e || 'all' === e
            ? this.ecModel.eachSeries(function (e, i) {
                t.push(i)
              })
            : (t = normalizeToArray(e)),
          t
        )
      }),
      (t.prototype.eachTargetSeries = function (e, t) {
        each$i(
          this.getTargetSeriesIndices(),
          function (i) {
            var r = this.ecModel.getSeriesByIndex(i)
            r && e.call(t, r)
          },
          this
        )
      }),
      (t.prototype.isTargetSeries = function (e) {
        var t = !1
        return (
          this.eachTargetSeries(function (i) {
            i === e && (t = !0)
          }),
          t
        )
      }),
      (t.prototype.formatValueText = function (e, t, i) {
        var r,
          n = this.option,
          a = n.precision,
          o = this.dataBound,
          s = n.formatter
        ;(i = i || ['<', '>']), isArray$1(e) && ((e = e.slice()), (r = !0))
        var l = t ? e : r ? [h(e[0]), h(e[1])] : h(e)
        return isString(s)
          ? s.replace('{value}', r ? l[0] : l).replace('{value2}', r ? l[1] : l)
          : isFunction$1(s)
          ? r
            ? s(e[0], e[1])
            : s(e)
          : r
          ? e[0] === o[0]
            ? i[0] + ' ' + l[1]
            : e[1] === o[1]
            ? i[1] + ' ' + l[0]
            : l[0] + ' - ' + l[1]
          : l
        function h(e) {
          return e === o[0] ? 'min' : e === o[1] ? 'max' : (+e).toFixed(Math.min(a, 20))
        }
      }),
      (t.prototype.resetExtent = function () {
        var e = this.option,
          t = asc([e.min, e.max])
        this._dataExtent = t
      }),
      (t.prototype.getDataDimension = function (e) {
        var t = this.option.dimension,
          i = e.dimensions
        if (null != t || i.length) {
          if (null != t) return e.getDimension(t)
          for (var r = e.dimensions, n = r.length - 1; n >= 0; n--) {
            var a = r[n]
            if (!e.getDimensionInfo(a).isCalculationCoord) return a
          }
        }
      }),
      (t.prototype.getExtent = function () {
        return this._dataExtent.slice()
      }),
      (t.prototype.completeVisualOption = function () {
        var e = this.ecModel,
          t = this.option,
          i = { inRange: t.inRange, outOfRange: t.outOfRange },
          r = t.target || (t.target = {}),
          n = t.controller || (t.controller = {})
        merge(r, i), merge(n, i)
        var a = this.isCategory()
        function o(i) {
          isArray(t.color) && !i.inRange && (i.inRange = { color: t.color.slice().reverse() }),
            (i.inRange = i.inRange || { color: e.get('gradientColor') })
        }
        o.call(this, r),
          o.call(this, n),
          function (e, t, i) {
            var r = e[t],
              n = e[i]
            r &&
              !n &&
              ((n = e[i] = {}),
              each$3(r, function (e, t) {
                if (VisualMapping.isValidType(t)) {
                  var i = visualDefault.get(t, 'inactive', a)
                  null != i &&
                    ((n[t] = i),
                    'color' !== t ||
                      n.hasOwnProperty('opacity') ||
                      n.hasOwnProperty('colorAlpha') ||
                      (n.opacity = [0, 0]))
                }
              }))
          }.call(this, r, 'inRange', 'outOfRange'),
          function (e) {
            var t = (e.inRange || {}).symbol || (e.outOfRange || {}).symbol,
              i = (e.inRange || {}).symbolSize || (e.outOfRange || {}).symbolSize,
              r = this.get('inactiveColor'),
              n = this.getItemSymbol() || 'roundRect'
            each$3(
              this.stateList,
              function (o) {
                var s = this.itemSize,
                  l = e[o]
                l || (l = e[o] = { color: a ? r : [r] }),
                  null == l.symbol && (l.symbol = (t && clone$3(t)) || (a ? n : [n])),
                  null == l.symbolSize &&
                    (l.symbolSize = (i && clone$3(i)) || (a ? s[0] : [s[0], s[0]])),
                  (l.symbol = mapVisual(l.symbol, function (e) {
                    return 'none' === e ? n : e
                  }))
                var h = l.symbolSize
                if (null != h) {
                  var u = -1 / 0
                  eachVisual(h, function (e) {
                    e > u && (u = e)
                  }),
                    (l.symbolSize = mapVisual(h, function (e) {
                      return linearMap$1(e, [0, u], [0, s[0]], !0)
                    }))
                }
              },
              this
            )
          }.call(this, n)
      }),
      (t.prototype.resetItemSize = function () {
        this.itemSize = [parseFloat(this.get('itemWidth')), parseFloat(this.get('itemHeight'))]
      }),
      (t.prototype.isCategory = function () {
        return !!this.option.categories
      }),
      (t.prototype.setSelected = function (e) {}),
      (t.prototype.getSelected = function () {
        return null
      }),
      (t.prototype.getValueState = function (e) {
        return null
      }),
      (t.prototype.getVisualMeta = function (e) {
        return null
      }),
      (t.type = 'visualMap'),
      (t.dependencies = ['series']),
      (t.defaultOption = {
        show: !0,
        zlevel: 0,
        z: 4,
        seriesIndex: 'all',
        min: 0,
        max: 200,
        left: 0,
        right: null,
        top: null,
        bottom: 0,
        itemWidth: null,
        itemHeight: null,
        inverse: !1,
        orient: 'vertical',
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        contentColor: '#5793f3',
        inactiveColor: '#aaa',
        borderWidth: 0,
        padding: 5,
        textGap: 10,
        precision: 0,
        textStyle: { color: '#333' }
      }),
      t
    )
  })(ComponentModel),
  DEFAULT_BAR_BOUND = [20, 140],
  ContinuousModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), i
    }
    return (
      __extends(t, e),
      (t.prototype.optionUpdated = function (t, i) {
        e.prototype.optionUpdated.apply(this, arguments),
          this.resetExtent(),
          this.resetVisual(function (e) {
            ;(e.mappingMethod = 'linear'), (e.dataExtent = this.getExtent())
          }),
          this._resetRange()
      }),
      (t.prototype.resetItemSize = function () {
        e.prototype.resetItemSize.apply(this, arguments)
        var t = this.itemSize
        ;(null == t[0] || isNaN(t[0])) && (t[0] = DEFAULT_BAR_BOUND[0]),
          (null == t[1] || isNaN(t[1])) && (t[1] = DEFAULT_BAR_BOUND[1])
      }),
      (t.prototype._resetRange = function () {
        var e = this.getExtent(),
          t = this.option.range
        !t || t.auto
          ? ((e.auto = 1), (this.option.range = e))
          : isArray$1(t) &&
            (t[0] > t[1] && t.reverse(),
            (t[0] = Math.max(t[0], e[0])),
            (t[1] = Math.min(t[1], e[1])))
      }),
      (t.prototype.completeVisualOption = function () {
        e.prototype.completeVisualOption.apply(this, arguments),
          each$i(
            this.stateList,
            function (e) {
              var t = this.option.controller[e].symbolSize
              t && t[0] !== t[1] && (t[0] = t[1] / 3)
            },
            this
          )
      }),
      (t.prototype.setSelected = function (e) {
        ;(this.option.range = e.slice()), this._resetRange()
      }),
      (t.prototype.getSelected = function () {
        var e = this.getExtent(),
          t = asc$2((this.get('range') || []).slice())
        return (
          t[0] > e[1] && (t[0] = e[1]),
          t[1] > e[1] && (t[1] = e[1]),
          t[0] < e[0] && (t[0] = e[0]),
          t[1] < e[0] && (t[1] = e[0]),
          t
        )
      }),
      (t.prototype.getValueState = function (e) {
        var t = this.option.range,
          i = this.getExtent()
        return (t[0] <= i[0] || t[0] <= e) && (t[1] >= i[1] || e <= t[1]) ? 'inRange' : 'outOfRange'
      }),
      (t.prototype.findTargetDataIndices = function (e) {
        var t = []
        return (
          this.eachTargetSeries(function (i) {
            var r = [],
              n = i.getData()
            n.each(
              this.getDataDimension(n),
              function (t, i) {
                e[0] <= t && t <= e[1] && r.push(i)
              },
              this
            ),
              t.push({ seriesId: i.id, dataIndex: r })
          }, this),
          t
        )
      }),
      (t.prototype.getVisualMeta = function (e) {
        var t = getColorStopValues(this, 'outOfRange', this.getExtent()),
          i = getColorStopValues(this, 'inRange', this.option.range.slice()),
          r = []
        function n(t, i) {
          r.push({ value: t, color: e(t, i) })
        }
        for (
          var a = 0, o = 0, s = i.length, l = t.length;
          o < l && (!i.length || t[o] <= i[0]);
          o++
        )
          t[o] < i[a] && n(t[o], 'outOfRange')
        for (var h = 1; a < s; a++, h = 0)
          h && r.length && n(i[a], 'outOfRange'), n(i[a], 'inRange')
        for (h = 1; o < l; o++)
          (!i.length || i[i.length - 1] < t[o]) &&
            (h && (r.length && n(r[r.length - 1].value, 'outOfRange'), (h = 0)),
            n(t[o], 'outOfRange'))
        var u = r.length
        return {
          stops: r,
          outerColors: [u ? r[0].color : 'transparent', u ? r[u - 1].color : 'transparent']
        }
      }),
      (t.type = 'visualMap.continuous'),
      (t.defaultOption = inheritDefaultOption(VisualMapModel.defaultOption, {
        align: 'auto',
        calculable: !1,
        hoverLink: !0,
        realtime: !0,
        handleIcon:
          'path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z',
        handleSize: '120%',
        handleStyle: { borderColor: '#fff', borderWidth: 1 },
        indicatorIcon: 'circle',
        indicatorSize: '50%',
        indicatorStyle: {
          borderColor: '#fff',
          borderWidth: 2,
          shadowBlur: 2,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: 'rgba(0,0,0,0.2)'
        }
      })),
      t
    )
  })(VisualMapModel)
function getColorStopValues(e, t, i) {
  if (i[0] === i[1]) return i.slice()
  for (var r = (i[1] - i[0]) / 200, n = i[0], a = [], o = 0; o <= 200 && n < i[1]; o++)
    a.push(n), (n += r)
  return a.push(i[1]), a
}
var VisualMapView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i.autoPositionValues = { left: 1, right: 1, top: 1, bottom: 1 }), i
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (e, t) {
        ;(this.ecModel = e), (this.api = t)
      }),
      (t.prototype.render = function (e, t, i, r) {
        ;(this.visualMapModel = e),
          !1 !== e.get('show') ? this.doRender(e, t, i, r) : this.group.removeAll()
      }),
      (t.prototype.renderBackground = function (e) {
        var t = this.visualMapModel,
          i = normalizeCssArray(t.get('padding') || 0),
          r = e.getBoundingRect()
        e.add(
          new Rect$2({
            z2: -1,
            silent: !0,
            shape: {
              x: r.x - i[3],
              y: r.y - i[0],
              width: r.width + i[3] + i[1],
              height: r.height + i[0] + i[2]
            },
            style: {
              fill: t.get('backgroundColor'),
              stroke: t.get('borderColor'),
              lineWidth: t.get('borderWidth')
            }
          })
        )
      }),
      (t.prototype.getControllerVisual = function (e, t, i) {
        var r = (i = i || {}).forceState,
          n = this.visualMapModel,
          a = {}
        if ('color' === t) {
          var o = n.get('contentColor')
          a.color = o
        }
        function s(e) {
          return a[e]
        }
        function l(e, t) {
          a[e] = t
        }
        var h = n.controllerVisuals[r || n.getValueState(e)]
        return (
          each$i(VisualMapping.prepareVisualTypes(h), function (r) {
            var n = h[r]
            i.convertOpacityToAlpha &&
              'opacity' === r &&
              ((r = 'colorAlpha'), (n = h.__alphaForOpacity)),
              VisualMapping.dependsOn(r, t) && n && n.applyVisual(e, s, l)
          }),
          a[t]
        )
      }),
      (t.prototype.positionGroup = function (e) {
        var t = this.visualMapModel,
          i = this.api
        positionElement(e, t.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() })
      }),
      (t.prototype.doRender = function (e, t, i, r) {}),
      (t.type = 'visualMap'),
      t
    )
  })(ComponentView),
  paramsSet = [
    ['left', 'right', 'width'],
    ['top', 'bottom', 'height']
  ]
function getItemAlign(e, t, i) {
  var r = e.option,
    n = r.align
  if (null != n && 'auto' !== n) return n
  for (
    var a = { width: t.getWidth(), height: t.getHeight() },
      o = 'horizontal' === r.orient ? 1 : 0,
      s = paramsSet[o],
      l = [0, null, 10],
      h = {},
      u = 0;
    u < 3;
    u++
  )
    (h[paramsSet[1 - o][u]] = l[u]), (h[s[u]] = 2 === u ? i[0] : r[s[u]])
  var p = [
      ['x', 'width', 3],
      ['y', 'height', 0]
    ][o],
    c = getLayoutRect(h, a, r.padding)
  return s[(c.margin[p[2]] || 0) + c[p[0]] + 0.5 * c[p[1]] < 0.5 * a[p[1]] ? 0 : 1]
}
function makeHighDownBatch(e, t) {
  return (
    each$i(e || [], function (e) {
      null != e.dataIndex && ((e.dataIndexInside = e.dataIndex), (e.dataIndex = null)),
        (e.highlightKey = 'visualMap' + (t ? t.componentIndex : ''))
    }),
    e
  )
}
var linearMap = linearMap$2,
  each$2 = each$i,
  mathMin = Math.min,
  mathMax = Math.max,
  HOVER_LINK_SIZE = 12,
  HOVER_LINK_OUT = 6,
  ContinuousView = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (
        (i.type = t.type),
        (i._shapes = {}),
        (i._dataInterval = []),
        (i._handleEnds = []),
        (i._hoverLinkDataIndices = []),
        i
      )
    }
    return (
      __extends(t, e),
      (t.prototype.doRender = function (e, t, i, r) {
        ;(this._api = i),
          (r && 'selectDataRange' === r.type && r.from === this.uid) || this._buildView()
      }),
      (t.prototype._buildView = function () {
        this.group.removeAll()
        var e = this.visualMapModel,
          t = this.group
        ;(this._orient = e.get('orient')),
          (this._useHandle = e.get('calculable')),
          this._resetInterval(),
          this._renderBar(t)
        var i = e.get('text')
        this._renderEndsText(t, i, 0),
          this._renderEndsText(t, i, 1),
          this._updateView(!0),
          this.renderBackground(t),
          this._updateView(),
          this._enableHoverLinkToSeries(),
          this._enableHoverLinkFromSeries(),
          this.positionGroup(t)
      }),
      (t.prototype._renderEndsText = function (e, t, i) {
        if (t) {
          var r = t[1 - i]
          r = null != r ? r + '' : ''
          var n = this.visualMapModel,
            a = n.get('textGap'),
            o = n.itemSize,
            s = this._shapes.mainGroup,
            l = this._applyTransform([o[0] / 2, 0 === i ? -a : o[1] + a], s),
            h = this._applyTransform(0 === i ? 'bottom' : 'top', s),
            u = this._orient,
            p = this.visualMapModel.textStyleModel
          this.group.add(
            new ZRText({
              style: {
                x: l[0],
                y: l[1],
                verticalAlign: 'horizontal' === u ? 'middle' : h,
                align: 'horizontal' === u ? h : 'center',
                text: r,
                font: p.getFont(),
                fill: p.getTextColor()
              }
            })
          )
        }
      }),
      (t.prototype._renderBar = function (e) {
        var t = this.visualMapModel,
          i = this._shapes,
          r = t.itemSize,
          n = this._orient,
          a = this._useHandle,
          o = getItemAlign(t, this.api, r),
          s = (i.mainGroup = this._createBarGroup(o)),
          l = new Group$3()
        s.add(l),
          l.add((i.outOfRange = createPolygon())),
          l.add(
            (i.inRange = createPolygon(
              null,
              a ? getCursor(this._orient) : null,
              bind$2(this._dragHandle, this, 'all', !1),
              bind$2(this._dragHandle, this, 'all', !0)
            ))
          ),
          l.setClipPath(new Rect$2({ shape: { x: 0, y: 0, width: r[0], height: r[1], r: 3 } }))
        var h = t.textStyleModel.getTextRect(''),
          u = mathMax(h.width, h.height)
        a &&
          ((i.handleThumbs = []),
          (i.handleLabels = []),
          (i.handleLabelPoints = []),
          this._createHandle(t, s, 0, r, u, n),
          this._createHandle(t, s, 1, r, u, n)),
          this._createIndicator(t, s, r, u, n),
          e.add(s)
      }),
      (t.prototype._createHandle = function (e, t, i, r, n, a) {
        var o = bind$2(this._dragHandle, this, i, !1),
          s = bind$2(this._dragHandle, this, i, !0),
          l = parsePercent$2(e.get('handleSize'), r[0]),
          h = createSymbol$1(e.get('handleIcon'), -l / 2, -l / 2, l, l, null, !0),
          u = getCursor(this._orient)
        h.attr({
          cursor: u,
          draggable: !0,
          drift: o,
          ondragend: s,
          onmousemove: function (e) {
            stop(e.event)
          }
        }),
          (h.x = r[0] / 2),
          h.useStyle(e.getModel('handleStyle').getItemStyle()),
          h.setStyle({ strokeNoScale: !0, strokeFirst: !0 }),
          (h.style.lineWidth *= 2),
          (h.ensureState('emphasis').style = e
            .getModel(['emphasis', 'handleStyle'])
            .getItemStyle()),
          setAsHighDownDispatcher(h, !0),
          t.add(h)
        var p = this.visualMapModel.textStyleModel,
          c = new ZRText({
            cursor: u,
            draggable: !0,
            drift: o,
            onmousemove: function (e) {
              stop(e.event)
            },
            ondragend: s,
            style: { x: 0, y: 0, text: '', font: p.getFont(), fill: p.getTextColor() }
          })
        ;(c.ensureState('blur').style = { opacity: 0.1 }),
          (c.stateTransition = { duration: 200 }),
          this.group.add(c)
        var d = [l, 0],
          f = this._shapes
        ;(f.handleThumbs[i] = h), (f.handleLabelPoints[i] = d), (f.handleLabels[i] = c)
      }),
      (t.prototype._createIndicator = function (e, t, i, r, n) {
        var a = parsePercent$2(e.get('indicatorSize'), i[0]),
          o = createSymbol$1(e.get('indicatorIcon'), -a / 2, -a / 2, a, a, null, !0)
        o.attr({ cursor: 'move', invisible: !0, silent: !0, x: i[0] / 2 })
        var s = e.getModel('indicatorStyle').getItemStyle()
        if (o instanceof ZRImage) {
          var l = o.style
          o.useStyle(
            extend$3({ image: l.image, x: l.x, y: l.y, width: l.width, height: l.height }, s)
          )
        } else o.useStyle(s)
        t.add(o)
        var h = this.visualMapModel.textStyleModel,
          u = new ZRText({
            silent: !0,
            invisible: !0,
            style: { x: 0, y: 0, text: '', font: h.getFont(), fill: h.getTextColor() }
          })
        this.group.add(u)
        var p = [('horizontal' === n ? r / 2 : HOVER_LINK_OUT) + i[0] / 2, 0],
          c = this._shapes
        ;(c.indicator = o),
          (c.indicatorLabel = u),
          (c.indicatorLabelPoint = p),
          (this._firstShowIndicator = !0)
      }),
      (t.prototype._dragHandle = function (e, t, i, r) {
        if (this._useHandle) {
          if (((this._dragging = !t), !t)) {
            var n = this._applyTransform([i, r], this._shapes.mainGroup, !0)
            this._updateInterval(e, n[1]), this._hideIndicator(), this._updateView()
          }
          t === !this.visualMapModel.get('realtime') &&
            this.api.dispatchAction({
              type: 'selectDataRange',
              from: this.uid,
              visualMapId: this.visualMapModel.id,
              selected: this._dataInterval.slice()
            }),
            t
              ? !this._hovering && this._clearHoverLinkToSeries()
              : useHoverLinkOnHandle(this.visualMapModel) &&
                this._doHoverLinkToSeries(this._handleEnds[e], !1)
        }
      }),
      (t.prototype._resetInterval = function () {
        var e = this.visualMapModel,
          t = (this._dataInterval = e.getSelected()),
          i = e.getExtent(),
          r = [0, e.itemSize[1]]
        this._handleEnds = [linearMap(t[0], i, r, !0), linearMap(t[1], i, r, !0)]
      }),
      (t.prototype._updateInterval = function (e, t) {
        t = t || 0
        var i = this.visualMapModel,
          r = this._handleEnds,
          n = [0, i.itemSize[1]]
        sliderMove(t, r, n, e, 0)
        var a = i.getExtent()
        this._dataInterval = [linearMap(r[0], n, a, !0), linearMap(r[1], n, a, !0)]
      }),
      (t.prototype._updateView = function (e) {
        var t = this.visualMapModel,
          i = t.getExtent(),
          r = this._shapes,
          n = [0, t.itemSize[1]],
          a = e ? n : this._handleEnds,
          o = this._createBarVisual(this._dataInterval, i, a, 'inRange'),
          s = this._createBarVisual(i, i, n, 'outOfRange')
        r.inRange.setStyle({ fill: o.barColor }).setShape('points', o.barPoints),
          r.outOfRange.setStyle({ fill: s.barColor }).setShape('points', s.barPoints),
          this._updateHandle(a, o)
      }),
      (t.prototype._createBarVisual = function (e, t, i, r) {
        var n = { forceState: r, convertOpacityToAlpha: !0 },
          a = this._makeColorGradient(e, n),
          o = [
            this.getControllerVisual(e[0], 'symbolSize', n),
            this.getControllerVisual(e[1], 'symbolSize', n)
          ],
          s = this._createBarPoints(i, o)
        return {
          barColor: new LinearGradient(0, 0, 0, 1, a),
          barPoints: s,
          handlesColor: [a[0].color, a[a.length - 1].color]
        }
      }),
      (t.prototype._makeColorGradient = function (e, t) {
        var i = [],
          r = (e[1] - e[0]) / 100
        i.push({ color: this.getControllerVisual(e[0], 'color', t), offset: 0 })
        for (var n = 1; n < 100; n++) {
          var a = e[0] + r * n
          if (a > e[1]) break
          i.push({ color: this.getControllerVisual(a, 'color', t), offset: n / 100 })
        }
        return i.push({ color: this.getControllerVisual(e[1], 'color', t), offset: 1 }), i
      }),
      (t.prototype._createBarPoints = function (e, t) {
        var i = this.visualMapModel.itemSize
        return [
          [i[0] - t[0], e[0]],
          [i[0], e[0]],
          [i[0], e[1]],
          [i[0] - t[1], e[1]]
        ]
      }),
      (t.prototype._createBarGroup = function (e) {
        var t = this._orient,
          i = this.visualMapModel.get('inverse')
        return new Group$3(
          'horizontal' !== t || i
            ? 'horizontal' === t && i
              ? { scaleX: 'bottom' === e ? -1 : 1, rotation: -Math.PI / 2 }
              : 'vertical' !== t || i
              ? { scaleX: 'left' === e ? 1 : -1 }
              : { scaleX: 'left' === e ? 1 : -1, scaleY: -1 }
            : { scaleX: 'bottom' === e ? 1 : -1, rotation: Math.PI / 2 }
        )
      }),
      (t.prototype._updateHandle = function (e, t) {
        if (this._useHandle) {
          var i = this._shapes,
            r = this.visualMapModel,
            n = i.handleThumbs,
            a = i.handleLabels,
            o = r.itemSize,
            s = r.getExtent()
          each$2(
            [0, 1],
            function (l) {
              var h = n[l]
              h.setStyle('fill', t.handlesColor[l]), (h.y = e[l])
              var u = linearMap(e[l], [0, o[1]], s, !0),
                p = this.getControllerVisual(u, 'symbolSize')
              ;(h.scaleX = h.scaleY = p / o[0]), (h.x = o[0] - p / 2)
              var c = applyTransform(i.handleLabelPoints[l], getTransform$1(h, this.group))
              a[l].setStyle({
                x: c[0],
                y: c[1],
                text: r.formatValueText(this._dataInterval[l]),
                verticalAlign: 'middle',
                align:
                  'vertical' === this._orient ? this._applyTransform('left', i.mainGroup) : 'center'
              })
            },
            this
          )
        }
      }),
      (t.prototype._showIndicator = function (e, t, i, r) {
        var n = this.visualMapModel,
          a = n.getExtent(),
          o = n.itemSize,
          s = [0, o[1]],
          l = this._shapes,
          h = l.indicator
        if (h) {
          h.attr('invisible', !1)
          var u = this.getControllerVisual(e, 'color', { convertOpacityToAlpha: !0 }),
            p = this.getControllerVisual(e, 'symbolSize'),
            c = linearMap(e, a, s, !0),
            d = o[0] - p / 2,
            f = { x: h.x, y: h.y }
          ;(h.y = c), (h.x = d)
          var m = applyTransform(l.indicatorLabelPoint, getTransform$1(h, this.group)),
            g = l.indicatorLabel
          g.attr('invisible', !1)
          var y = this._applyTransform('left', l.mainGroup),
            v = 'horizontal' === this._orient
          g.setStyle({
            text: (i || '') + n.formatValueText(t),
            verticalAlign: v ? y : 'middle',
            align: v ? 'center' : y
          })
          var _ = { x: d, y: c, style: { fill: u } },
            x = { style: { x: m[0], y: m[1] } }
          if (n.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
            var S = { duration: 100, easing: 'cubicInOut', additive: !0 }
            ;(h.x = f.x), (h.y = f.y), h.animateTo(_, S), g.animateTo(x, S)
          } else h.attr(_), g.attr(x)
          this._firstShowIndicator = !1
          var b = this._shapes.handleLabels
          if (b) for (var T = 0; T < b.length; T++) this._api.enterBlur(b[T])
        }
      }),
      (t.prototype._enableHoverLinkToSeries = function () {
        var e = this
        this._shapes.mainGroup
          .on('mousemove', function (t) {
            if (((e._hovering = !0), !e._dragging)) {
              var i = e.visualMapModel.itemSize,
                r = e._applyTransform([t.offsetX, t.offsetY], e._shapes.mainGroup, !0, !0)
              ;(r[1] = mathMin(mathMax(0, r[1]), i[1])),
                e._doHoverLinkToSeries(r[1], 0 <= r[0] && r[0] <= i[0])
            }
          })
          .on('mouseout', function () {
            ;(e._hovering = !1), !e._dragging && e._clearHoverLinkToSeries()
          })
      }),
      (t.prototype._enableHoverLinkFromSeries = function () {
        var e = this.api.getZr()
        this.visualMapModel.option.hoverLink
          ? (e.on('mouseover', this._hoverLinkFromSeriesMouseOver, this),
            e.on('mouseout', this._hideIndicator, this))
          : this._clearHoverLinkFromSeries()
      }),
      (t.prototype._doHoverLinkToSeries = function (e, t) {
        var i = this.visualMapModel,
          r = i.itemSize
        if (i.option.hoverLink) {
          var n = [0, r[1]],
            a = i.getExtent()
          e = mathMin(mathMax(n[0], e), n[1])
          var o = getHalfHoverLinkSize(i, a, n),
            s = [e - o, e + o],
            l = linearMap(e, n, a, !0),
            h = [linearMap(s[0], n, a, !0), linearMap(s[1], n, a, !0)]
          s[0] < n[0] && (h[0] = -1 / 0),
            s[1] > n[1] && (h[1] = 1 / 0),
            t &&
              (h[0] === -1 / 0
                ? this._showIndicator(l, h[1], '< ', o)
                : h[1] === 1 / 0
                ? this._showIndicator(l, h[0], '> ', o)
                : this._showIndicator(l, l, ' ', o))
          var u = this._hoverLinkDataIndices,
            p = []
          ;(t || useHoverLinkOnHandle(i)) &&
            (p = this._hoverLinkDataIndices = i.findTargetDataIndices(h))
          var c = compressBatches(u, p)
          this._dispatchHighDown('downplay', makeHighDownBatch(c[0], i)),
            this._dispatchHighDown('highlight', makeHighDownBatch(c[1], i))
        }
      }),
      (t.prototype._hoverLinkFromSeriesMouseOver = function (e) {
        var t = e.target,
          i = this.visualMapModel
        if (t && null != getECData(t).dataIndex) {
          var r = getECData(t),
            n = this.ecModel.getSeriesByIndex(r.seriesIndex)
          if (i.isTargetSeries(n)) {
            var a = n.getData(r.dataType),
              o = a.get(i.getDataDimension(a), r.dataIndex)
            isNaN(o) || this._showIndicator(o, o)
          }
        }
      }),
      (t.prototype._hideIndicator = function () {
        var e = this._shapes
        e.indicator && e.indicator.attr('invisible', !0),
          e.indicatorLabel && e.indicatorLabel.attr('invisible', !0)
        var t = this._shapes.handleLabels
        if (t) for (var i = 0; i < t.length; i++) this._api.leaveBlur(t[i])
      }),
      (t.prototype._clearHoverLinkToSeries = function () {
        this._hideIndicator()
        var e = this._hoverLinkDataIndices
        this._dispatchHighDown('downplay', makeHighDownBatch(e, this.visualMapModel)),
          (e.length = 0)
      }),
      (t.prototype._clearHoverLinkFromSeries = function () {
        this._hideIndicator()
        var e = this.api.getZr()
        e.off('mouseover', this._hoverLinkFromSeriesMouseOver),
          e.off('mouseout', this._hideIndicator)
      }),
      (t.prototype._applyTransform = function (e, t, i, r) {
        var n = getTransform$1(t, r ? null : this.group)
        return isArray$1(e) ? applyTransform(e, n, i) : transformDirection(e, n, i)
      }),
      (t.prototype._dispatchHighDown = function (e, t) {
        t && t.length && this.api.dispatchAction({ type: e, batch: t })
      }),
      (t.prototype.dispose = function () {
        this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries()
      }),
      (t.prototype.remove = function () {
        this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries()
      }),
      (t.type = 'visualMap.continuous'),
      t
    )
  })(VisualMapView)
function createPolygon(e, t, i, r) {
  return new Polygon({
    shape: { points: e },
    draggable: !!i,
    cursor: t,
    drift: i,
    onmousemove: function (e) {
      stop(e.event)
    },
    ondragend: r
  })
}
function getHalfHoverLinkSize(e, t, i) {
  var r = HOVER_LINK_SIZE / 2,
    n = e.get('hoverLinkDataSize')
  return n && (r = linearMap(n, t, i, !0) / 2), r
}
function useHoverLinkOnHandle(e) {
  var t = e.get('hoverLinkOnHandle')
  return !!(null == t ? e.get('realtime') : t)
}
function getCursor(e) {
  return 'vertical' === e ? 'ns-resize' : 'ew-resize'
}
var visualMapActionInfo = { type: 'selectDataRange', event: 'dataRangeSelected', update: 'update' },
  visualMapActionHander = function (e, t) {
    t.eachComponent({ mainType: 'visualMap', query: e }, function (t) {
      t.setSelected(e.selected)
    })
  },
  visualMapEncodingHandlers = [
    {
      createOnAllSeries: !0,
      reset: function (e, t) {
        var i = []
        return (
          t.eachComponent('visualMap', function (t) {
            var r = e.pipelineContext
            !t.isTargetSeries(e) ||
              (r && r.large) ||
              i.push(
                incrementalApplyVisual(
                  t.stateList,
                  t.targetVisuals,
                  bind$2(t.getValueState, t),
                  t.getDataDimension(e.getData())
                )
              )
          }),
          i
        )
      }
    },
    {
      createOnAllSeries: !0,
      reset: function (e, t) {
        var i = e.getData(),
          r = []
        t.eachComponent('visualMap', function (t) {
          if (t.isTargetSeries(e)) {
            var n = t.getVisualMeta(bind$2(getColorVisual, null, e, t)) || {
                stops: [],
                outerColors: []
              },
              a = t.getDataDimension(i),
              o = i.getDimensionInfo(a)
            null != o && ((n.dimension = o.index), r.push(n))
          }
        }),
          e.getData().setVisual('visualMeta', r)
      }
    }
  ]
function getColorVisual(e, t, i, r) {
  for (
    var n = t.targetVisuals[r],
      a = VisualMapping.prepareVisualTypes(n),
      o = { color: getVisualFromData(e.getData(), 'color') },
      s = 0,
      l = a.length;
    s < l;
    s++
  ) {
    var h = a[s],
      u = n['opacity' === h ? '__alphaForOpacity' : h]
    u && u.applyVisual(i, p, c)
  }
  return o.color
  function p(e) {
    return o[e]
  }
  function c(e, t) {
    o[e] = t
  }
}
var each$1 = each$i
function visualMapPreprocessor(e) {
  var t = e && e.visualMap
  isArray$1(t) || (t = t ? [t] : []),
    each$1(t, function (e) {
      if (e) {
        has(e, 'splitList') && !has(e, 'pieces') && ((e.pieces = e.splitList), delete e.splitList)
        var t = e.pieces
        t &&
          isArray$1(t) &&
          each$1(t, function (e) {
            isObject$7(e) &&
              (has(e, 'start') && !has(e, 'min') && (e.min = e.start),
              has(e, 'end') && !has(e, 'max') && (e.max = e.end))
          })
      }
    })
}
function has(e, t) {
  return e && e.hasOwnProperty && e.hasOwnProperty(t)
}
var installed = !1
function installCommon(e) {
  installed ||
    ((installed = !0),
    e.registerSubTypeDefaulter('visualMap', function (e) {
      return e.categories || ((e.pieces ? e.pieces.length > 0 : e.splitNumber > 0) && !e.calculable)
        ? 'piecewise'
        : 'continuous'
    }),
    e.registerAction(visualMapActionInfo, visualMapActionHander),
    each$i(visualMapEncodingHandlers, function (t) {
      e.registerVisual(e.PRIORITY.VISUAL.COMPONENT, t)
    }),
    e.registerPreprocessor(visualMapPreprocessor))
}
function install$5(e) {
  e.registerComponentModel(ContinuousModel),
    e.registerComponentView(ContinuousView),
    installCommon(e)
}
var PiecewiseModel = (function (e) {
    function t() {
      var i = (null !== e && e.apply(this, arguments)) || this
      return (i.type = t.type), (i._pieceList = []), i
    }
    return (
      __extends(t, e),
      (t.prototype.optionUpdated = function (t, i) {
        e.prototype.optionUpdated.apply(this, arguments), this.resetExtent()
        var r = (this._mode = this._determineMode())
        ;(this._pieceList = []),
          resetMethods[this._mode].call(this, this._pieceList),
          this._resetSelected(t, i)
        var n = this.option.categories
        this.resetVisual(function (e, t) {
          'categories' === r
            ? ((e.mappingMethod = 'category'), (e.categories = clone$3(n)))
            : ((e.dataExtent = this.getExtent()),
              (e.mappingMethod = 'piecewise'),
              (e.pieceList = map$1(this._pieceList, function (e) {
                return (e = clone$3(e)), 'inRange' !== t && (e.visual = null), e
              })))
        })
      }),
      (t.prototype.completeVisualOption = function () {
        var t = this.option,
          i = {},
          r = VisualMapping.listVisualTypes(),
          n = this.isCategory()
        function a(e, t, i) {
          return e && e[t] && e[t].hasOwnProperty(i)
        }
        each$i(t.pieces, function (e) {
          each$i(r, function (t) {
            e.hasOwnProperty(t) && (i[t] = 1)
          })
        }),
          each$i(
            i,
            function (e, i) {
              var r = !1
              each$i(
                this.stateList,
                function (e) {
                  r = r || a(t, e, i) || a(t.target, e, i)
                },
                this
              ),
                !r &&
                  each$i(this.stateList, function (e) {
                    ;(t[e] || (t[e] = {}))[i] = visualDefault.get(
                      i,
                      'inRange' === e ? 'active' : 'inactive',
                      n
                    )
                  })
            },
            this
          ),
          e.prototype.completeVisualOption.apply(this, arguments)
      }),
      (t.prototype._resetSelected = function (e, t) {
        var i = this.option,
          r = this._pieceList,
          n = (t ? i : e).selected || {}
        if (
          ((i.selected = n),
          each$i(
            r,
            function (e, t) {
              var i = this.getSelectedMapKey(e)
              n.hasOwnProperty(i) || (n[i] = !0)
            },
            this
          ),
          'single' === i.selectedMode)
        ) {
          var a = !1
          each$i(
            r,
            function (e, t) {
              var i = this.getSelectedMapKey(e)
              n[i] && (a ? (n[i] = !1) : (a = !0))
            },
            this
          )
        }
      }),
      (t.prototype.getItemSymbol = function () {
        return this.get('itemSymbol')
      }),
      (t.prototype.getSelectedMapKey = function (e) {
        return 'categories' === this._mode ? e.value + '' : e.index + ''
      }),
      (t.prototype.getPieceList = function () {
        return this._pieceList
      }),
      (t.prototype._determineMode = function () {
        var e = this.option
        return e.pieces && e.pieces.length > 0
          ? 'pieces'
          : this.option.categories
          ? 'categories'
          : 'splitNumber'
      }),
      (t.prototype.setSelected = function (e) {
        this.option.selected = clone$3(e)
      }),
      (t.prototype.getValueState = function (e) {
        var t = VisualMapping.findPieceIndex(e, this._pieceList)
        return null != t && this.option.selected[this.getSelectedMapKey(this._pieceList[t])]
          ? 'inRange'
          : 'outOfRange'
      }),
      (t.prototype.findTargetDataIndices = function (e) {
        var t = [],
          i = this._pieceList
        return (
          this.eachTargetSeries(function (r) {
            var n = [],
              a = r.getData()
            a.each(
              this.getDataDimension(a),
              function (t, r) {
                VisualMapping.findPieceIndex(t, i) === e && n.push(r)
              },
              this
            ),
              t.push({ seriesId: r.id, dataIndex: n })
          }, this),
          t
        )
      }),
      (t.prototype.getRepresentValue = function (e) {
        var t
        if (this.isCategory()) t = e.value
        else if (null != e.value) t = e.value
        else {
          var i = e.interval || []
          t = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2
        }
        return t
      }),
      (t.prototype.getVisualMeta = function (e) {
        if (!this.isCategory()) {
          var t = [],
            i = ['', ''],
            r = this,
            n = this._pieceList.slice()
          if (n.length) {
            var a = n[0].interval[0]
            a !== -1 / 0 && n.unshift({ interval: [-1 / 0, a] }),
              (a = n[n.length - 1].interval[1]) !== 1 / 0 && n.push({ interval: [a, 1 / 0] })
          } else n.push({ interval: [-1 / 0, 1 / 0] })
          var o = -1 / 0
          return (
            each$i(
              n,
              function (e) {
                var t = e.interval
                t && (t[0] > o && s([o, t[0]], 'outOfRange'), s(t.slice()), (o = t[1]))
              },
              this
            ),
            { stops: t, outerColors: i }
          )
        }
        function s(n, a) {
          var o = r.getRepresentValue({ interval: n })
          a || (a = r.getValueState(o))
          var s = e(o, a)
          n[0] === -1 / 0
            ? (i[0] = s)
            : n[1] === 1 / 0
            ? (i[1] = s)
            : t.push({ value: n[0], color: s }, { value: n[1], color: s })
        }
      }),
      (t.type = 'visualMap.piecewise'),
      (t.defaultOption = inheritDefaultOption(VisualMapModel.defaultOption, {
        selected: null,
        minOpen: !1,
        maxOpen: !1,
        align: 'auto',
        itemWidth: 20,
        itemHeight: 14,
        itemSymbol: 'roundRect',
        pieces: null,
        categories: null,
        splitNumber: 5,
        selectedMode: 'multiple',
        itemGap: 10,
        hoverLink: !0
      })),
      t
    )
  })(VisualMapModel),
  resetMethods = {
    splitNumber: function (e) {
      var t = this.option,
        i = Math.min(t.precision, 20),
        r = this.getExtent(),
        n = t.splitNumber
      ;(n = Math.max(parseInt(n, 10), 1)), (t.splitNumber = n)
      for (var a = (r[1] - r[0]) / n; +a.toFixed(i) !== a && i < 5; ) i++
      ;(t.precision = i),
        (a = +a.toFixed(i)),
        t.minOpen && e.push({ interval: [-1 / 0, r[0]], close: [0, 0] })
      for (var o = 0, s = r[0]; o < n; s += a, o++) {
        var l = o === n - 1 ? r[1] : s + a
        e.push({ interval: [s, l], close: [1, 1] })
      }
      t.maxOpen && e.push({ interval: [r[1], 1 / 0], close: [0, 0] }),
        reformIntervals(e),
        each$i(
          e,
          function (e, t) {
            ;(e.index = t), (e.text = this.formatValueText(e.interval))
          },
          this
        )
    },
    categories: function (e) {
      var t = this.option
      each$i(
        t.categories,
        function (t) {
          e.push({ text: this.formatValueText(t, !0), value: t })
        },
        this
      ),
        normalizeReverse(t, e)
    },
    pieces: function (e) {
      var t = this.option
      each$i(
        t.pieces,
        function (t, i) {
          isObject$7(t) || (t = { value: t })
          var r = { text: '', index: i }
          if ((null != t.label && (r.text = t.label), t.hasOwnProperty('value'))) {
            var n = (r.value = t.value)
            ;(r.interval = [n, n]), (r.close = [1, 1])
          } else {
            for (
              var a = (r.interval = []),
                o = (r.close = [0, 0]),
                s = [1, 0, 1],
                l = [-1 / 0, 1 / 0],
                h = [],
                u = 0;
              u < 2;
              u++
            ) {
              for (
                var p = [
                    ['gte', 'gt', 'min'],
                    ['lte', 'lt', 'max']
                  ][u],
                  c = 0;
                c < 3 && null == a[u];
                c++
              )
                (a[u] = t[p[c]]), (o[u] = s[c]), (h[u] = 2 === c)
              null == a[u] && (a[u] = l[u])
            }
            h[0] && a[1] === 1 / 0 && (o[0] = 0),
              h[1] && a[0] === -1 / 0 && (o[1] = 0),
              a[0] === a[1] && o[0] && o[1] && (r.value = a[0])
          }
          ;(r.visual = VisualMapping.retrieveVisuals(t)), e.push(r)
        },
        this
      ),
        normalizeReverse(t, e),
        reformIntervals(e),
        each$i(
          e,
          function (e) {
            var t = e.close,
              i = [['<', ''][t[1]], ['>', ''][t[0]]]
            e.text = e.text || this.formatValueText(null != e.value ? e.value : e.interval, !1, i)
          },
          this
        )
    }
  }
function normalizeReverse(e, t) {
  var i = e.inverse
  ;('vertical' === e.orient ? !i : i) && t.reverse()
}
var PiecewiseVisualMapView = (function (e) {
  function t() {
    var i = (null !== e && e.apply(this, arguments)) || this
    return (i.type = t.type), i
  }
  return (
    __extends(t, e),
    (t.prototype.doRender = function () {
      var e = this.group
      e.removeAll()
      var t = this.visualMapModel,
        i = t.get('textGap'),
        r = t.textStyleModel,
        n = r.getFont(),
        a = r.getTextColor(),
        o = this._getItemAlign(),
        s = t.itemSize,
        l = this._getViewData(),
        h = l.endsText,
        u = retrieve(t.get('showLabel', !0), !h)
      h && this._renderEndsText(e, h[0], s, u, o),
        each$i(
          l.viewPieceList,
          function (r) {
            var l = r.piece,
              h = new Group$3()
            ;(h.onclick = bind$2(this._onItemClick, this, l)),
              this._enableHoverLink(h, r.indexInModelPieceList)
            var p = t.getRepresentValue(l)
            if ((this._createItemSymbol(h, p, [0, 0, s[0], s[1]]), u)) {
              var c = this.visualMapModel.getValueState(p)
              h.add(
                new ZRText({
                  style: {
                    x: 'right' === o ? -i : s[0] + i,
                    y: s[1] / 2,
                    text: l.text,
                    verticalAlign: 'middle',
                    align: o,
                    font: n,
                    fill: a,
                    opacity: 'outOfRange' === c ? 0.5 : 1
                  }
                })
              )
            }
            e.add(h)
          },
          this
        ),
        h && this._renderEndsText(e, h[1], s, u, o),
        box(t.get('orient'), e, t.get('itemGap')),
        this.renderBackground(e),
        this.positionGroup(e)
    }),
    (t.prototype._enableHoverLink = function (e, t) {
      var i = this
      e.on('mouseover', function () {
        return r('highlight')
      }).on('mouseout', function () {
        return r('downplay')
      })
      var r = function (e) {
        var r = i.visualMapModel
        r.option.hoverLink &&
          i.api.dispatchAction({ type: e, batch: makeHighDownBatch(r.findTargetDataIndices(t), r) })
      }
    }),
    (t.prototype._getItemAlign = function () {
      var e = this.visualMapModel,
        t = e.option
      if ('vertical' === t.orient) return getItemAlign(e, this.api, e.itemSize)
      var i = t.align
      return (i && 'auto' !== i) || (i = 'left'), i
    }),
    (t.prototype._renderEndsText = function (e, t, i, r, n) {
      if (t) {
        var a = new Group$3(),
          o = this.visualMapModel.textStyleModel
        a.add(
          new ZRText({
            style: {
              x: r ? ('right' === n ? i[0] : 0) : i[0] / 2,
              y: i[1] / 2,
              verticalAlign: 'middle',
              align: r ? n : 'center',
              text: t,
              font: o.getFont(),
              fill: o.getTextColor()
            }
          })
        ),
          e.add(a)
      }
    }),
    (t.prototype._getViewData = function () {
      var e = this.visualMapModel,
        t = map$1(e.getPieceList(), function (e, t) {
          return { piece: e, indexInModelPieceList: t }
        }),
        i = e.get('text'),
        r = e.get('orient'),
        n = e.get('inverse')
      return (
        ('horizontal' === r ? n : !n) ? t.reverse() : i && (i = i.slice().reverse()),
        { viewPieceList: t, endsText: i }
      )
    }),
    (t.prototype._createItemSymbol = function (e, t, i) {
      e.add(
        createSymbol$1(
          this.getControllerVisual(t, 'symbol'),
          i[0],
          i[1],
          i[2],
          i[3],
          this.getControllerVisual(t, 'color')
        )
      )
    }),
    (t.prototype._onItemClick = function (e) {
      var t = this.visualMapModel,
        i = t.option,
        r = clone$3(i.selected),
        n = t.getSelectedMapKey(e)
      'single' === i.selectedMode
        ? ((r[n] = !0),
          each$i(r, function (e, t) {
            r[t] = t === n
          }))
        : (r[n] = !r[n]),
        this.api.dispatchAction({
          type: 'selectDataRange',
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: r
        })
    }),
    (t.type = 'visualMap.piecewise'),
    t
  )
})(VisualMapView)
function install$4(e) {
  e.registerComponentModel(PiecewiseModel),
    e.registerComponentView(PiecewiseVisualMapView),
    installCommon(e)
}
function install$3(e) {
  use(install$5), use(install$4)
}
var DEFAULT_OPTION = { label: { enabled: !0 }, decal: { show: !1 } },
  inner = makeInner(),
  decalPaletteScope = {}
function ariaVisual(e, t) {
  var i = e.getModel('aria')
  if (i.get('enabled')) {
    var r = clone$3(DEFAULT_OPTION)
    merge(r.label, e.getLocaleModel().get('aria'), !1),
      merge(i.option, r, !1),
      (function () {
        if (i.getModel('decal').get('show')) {
          var t = createHashMap()
          e.eachSeries(function (e) {
            if (e.useColorPaletteOnData) {
              var i = t.get(e.type)
              i || ((i = {}), t.set(e.type, i)), (inner(e).scope = i)
            }
          }),
            e.eachRawSeries(function (t) {
              if (!e.isSeriesFiltered(t))
                if ('function' != typeof t.enableAriaDecal) {
                  var i = t.getData()
                  if (t.useColorPaletteOnData) {
                    var r = t.getRawData(),
                      n = {},
                      a = inner(t).scope
                    i.each(function (e) {
                      var t = i.getRawIndex(e)
                      n[t] = e
                    })
                    var o = r.count()
                    r.each(function (e) {
                      var s = n[e],
                        l = r.getName(e) || e + '',
                        u = getDecalFromPalette(t.ecModel, l, a, o),
                        p = i.getItemVisual(s, 'decal')
                      i.setItemVisual(s, 'decal', h(p, u))
                    })
                  } else {
                    var s = getDecalFromPalette(
                        t.ecModel,
                        t.name,
                        decalPaletteScope,
                        e.getSeriesCount()
                      ),
                      l = i.getVisual('decal')
                    i.setVisual('decal', h(l, s))
                  }
                } else t.enableAriaDecal()
              function h(e, t) {
                var i = e ? extend$3(extend$3({}, t), e) : t
                return (i.dirty = !0), i
              }
            })
        }
      })(),
      (function () {
        var r = e.getLocaleModel().get('aria'),
          a = i.getModel('label')
        if (((a.option = defaults$1(a.option, r)), !a.get('enabled'))) return
        var o = t.getZr().dom
        if (a.get('description')) return void o.setAttribute('aria-label', a.get('description'))
        var s,
          l = e.getSeriesCount(),
          h = a.get(['data', 'maxCount']) || 10,
          u = a.get(['series', 'maxCount']) || 10,
          p = Math.min(l, u)
        if (l < 1) return
        var c = (function () {
          var t = e.get('title')
          t && t.length && (t = t[0])
          return t && t.text
        })()
        if (c) {
          var d = a.get(['general', 'withTitle'])
          s = n(d, { title: c })
        } else s = a.get(['general', 'withoutTitle'])
        var f = [],
          m =
            l > 1 ? a.get(['series', 'multiple', 'prefix']) : a.get(['series', 'single', 'prefix'])
        ;(s += n(m, { seriesCount: l })),
          e.eachSeries(function (t, i) {
            if (i < p) {
              var r = void 0,
                o = t.get('name') ? 'withName' : 'withoutName'
              r = n(
                (r = l > 1 ? a.get(['series', 'multiple', o]) : a.get(['series', 'single', o])),
                {
                  seriesId: t.seriesIndex,
                  seriesName: t.get('name'),
                  seriesType:
                    ((_ = t.subType),
                    e.getLocaleModel().get(['series', 'typeNames'])[_] || '')
                }
              )
              var s = t.getData()
              if (s.count() > h) r += n(a.get(['data', 'partialData']), { displayCnt: h })
              else r += a.get(['data', 'allData'])
              for (var u = [], c = 0; c < s.count(); c++)
                if (c < h) {
                  var d = s.getName(c),
                    m = retrieveRawValue(s, c),
                    g = a.get(['data', d ? 'withName' : 'withoutName'])
                  u.push(n(g, { name: d, value: m }))
                }
              var y = a.get(['data', 'separator', 'middle']),
                v = a.get(['data', 'separator', 'end'])
              ;(r += u.join(y) + v), f.push(r)
            }
            var _
          })
        var g = a.getModel(['series', 'multiple', 'separator']),
          y = g.get('middle'),
          v = g.get('end')
        ;(s += f.join(y) + v), o.setAttribute('aria-label', s)
      })()
  }
  function n(e, t) {
    if ('string' != typeof e) return e
    var i = e
    return (
      each$i(t, function (e, t) {
        i = i.replace(new RegExp('\\{\\s*' + t + '\\s*\\}', 'g'), e)
      }),
      i
    )
  }
}
function ariaPreprocessor(e) {
  if (e && e.aria) {
    var t = e.aria
    null != t.show && (t.enabled = t.show),
      (t.label = t.label || {}),
      each$i(['description', 'general', 'series', 'data'], function (e) {
        null != t[e] && (t.label[e] = t[e])
      })
  }
}
function install$2(e) {
  e.registerPreprocessor(ariaPreprocessor), e.registerVisual(e.PRIORITY.VISUAL.ARIA, ariaVisual)
}
var RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {
    value: 'eq',
    '<': 'lt',
    '<=': 'lte',
    '>': 'gt',
    '>=': 'gte',
    '=': 'eq',
    '!=': 'ne',
    '<>': 'ne'
  },
  RegExpEvaluator = (function () {
    function e(e) {
      if (null == (this._condVal = isString(e) ? new RegExp(e) : isRegExp(e) ? e : null)) {
        throwError('')
      }
    }
    return (
      (e.prototype.evaluate = function (e) {
        var t = typeof e
        return 'string' === t ? this._condVal.test(e) : 'number' === t && this._condVal.test(e + '')
      }),
      e
    )
  })(),
  ConstConditionInternal = (function () {
    function e() {}
    return (
      (e.prototype.evaluate = function () {
        return this.value
      }),
      e
    )
  })(),
  AndConditionInternal = (function () {
    function e() {}
    return (
      (e.prototype.evaluate = function () {
        for (var e = this.children, t = 0; t < e.length; t++) if (!e[t].evaluate()) return !1
        return !0
      }),
      e
    )
  })(),
  OrConditionInternal = (function () {
    function e() {}
    return (
      (e.prototype.evaluate = function () {
        for (var e = this.children, t = 0; t < e.length; t++) if (e[t].evaluate()) return !0
        return !1
      }),
      e
    )
  })(),
  NotConditionInternal = (function () {
    function e() {}
    return (
      (e.prototype.evaluate = function () {
        return !this.child.evaluate()
      }),
      e
    )
  })(),
  RelationalConditionInternal = (function () {
    function e() {}
    return (
      (e.prototype.evaluate = function () {
        for (
          var e = !!this.valueParser,
            t = (0, this.getValue)(this.valueGetterParam),
            i = e ? this.valueParser(t) : null,
            r = 0;
          r < this.subCondList.length;
          r++
        )
          if (!this.subCondList[r].evaluate(e ? i : t)) return !1
        return !0
      }),
      e
    )
  })()
function parseOption(e, t) {
  if (!0 === e || !1 === e) {
    var i = new ConstConditionInternal()
    return (i.value = e), i
  }
  return (
    isObjectNotArray(e) || throwError(''),
    e.and
      ? parseAndOrOption('and', e, t)
      : e.or
      ? parseAndOrOption('or', e, t)
      : e.not
      ? parseNotOption(e, t)
      : parseRelationalOption(e, t)
  )
}
function parseAndOrOption(e, t, i) {
  var r = t[e]
  isArray$1(r) || throwError(''), r.length || throwError('')
  var n = 'and' === e ? new AndConditionInternal() : new OrConditionInternal()
  return (
    (n.children = map$1(r, function (e) {
      return parseOption(e, i)
    })),
    n.children.length || throwError(''),
    n
  )
}
function parseNotOption(e, t) {
  var i = e.not
  isObjectNotArray(i) || throwError('')
  var r = new NotConditionInternal()
  return (r.child = parseOption(i, t)), r.child || throwError(''), r
}
function parseRelationalOption(e, t) {
  for (
    var i = t.prepareGetValue(e),
      r = [],
      n = keys(e),
      a = e.parser,
      o = a ? getRawValueParser(a) : null,
      s = 0;
    s < n.length;
    s++
  ) {
    var l = n[s]
    if ('parser' !== l && !t.valueGetterAttrMap.get(l)) {
      var h = hasOwn(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, l)
          ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[l]
          : l,
        u = e[l],
        p = o ? o(u) : u,
        c = createFilterComparator(h, p) || ('reg' === h && new RegExpEvaluator(p))
      c || throwError(''), r.push(c)
    }
  }
  r.length || throwError('')
  var d = new RelationalConditionInternal()
  return (
    (d.valueGetterParam = i), (d.valueParser = o), (d.getValue = t.getValue), (d.subCondList = r), d
  )
}
function isObjectNotArray(e) {
  return isObject$7(e) && !isArrayLike(e)
}
var ConditionalExpressionParsed = (function () {
  function e(e, t) {
    this._cond = parseOption(e, t)
  }
  return (
    (e.prototype.evaluate = function () {
      return this._cond.evaluate()
    }),
    e
  )
})()
function parseConditionalExpression(e, t) {
  return new ConditionalExpressionParsed(e, t)
}
var filterTransform = {
    type: 'echarts:filter',
    transform: function (e) {
      for (
        var t,
          i = e.upstream,
          r = parseConditionalExpression(e.config, {
            valueGetterAttrMap: createHashMap({ dimension: !0 }),
            prepareGetValue: function (e) {
              var t = e.dimension
              hasOwn(e, 'dimension') || throwError('')
              var r = i.getDimensionInfo(t)
              return r || throwError(''), { dimIdx: r.index }
            },
            getValue: function (e) {
              return i.retrieveValueFromItem(t, e.dimIdx)
            }
          }),
          n = [],
          a = 0,
          o = i.count();
        a < o;
        a++
      )
        (t = i.getRawDataItem(a)), r.evaluate() && n.push(t)
      return { data: n }
    }
  },
  sortTransform = {
    type: 'echarts:sort',
    transform: function (e) {
      var t = e.upstream,
        i = e.config,
        r = '',
        n = normalizeToArray(i)
      n.length || throwError(r)
      var a = []
      each$i(n, function (e) {
        var i = e.dimension,
          n = e.order,
          o = e.parser,
          s = e.incomparable
        if (
          (null == i && throwError(r),
          'asc' !== n && 'desc' !== n && throwError(r),
          s && 'min' !== s && 'max' !== s)
        ) {
          throwError('')
        }
        if ('asc' !== n && 'desc' !== n) {
          throwError('')
        }
        var l = t.getDimensionInfo(i)
        l || throwError(r)
        var h = o ? getRawValueParser(o) : null
        o && !h && throwError(r),
          a.push({ dimIdx: l.index, parser: h, comparator: new SortOrderComparator(n, s) })
      })
      var o = t.sourceFormat
      o !== SOURCE_FORMAT_ARRAY_ROWS && o !== SOURCE_FORMAT_OBJECT_ROWS && throwError(r)
      for (var s = [], l = 0, h = t.count(); l < h; l++) s.push(t.getRawDataItem(l))
      return (
        s.sort(function (e, i) {
          for (var r = 0; r < a.length; r++) {
            var n = a[r],
              o = t.retrieveValueFromItem(e, n.dimIdx),
              s = t.retrieveValueFromItem(i, n.dimIdx)
            n.parser && ((o = n.parser(o)), (s = n.parser(s)))
            var l = n.comparator.evaluate(o, s)
            if (0 !== l) return l
          }
          return 0
        }),
        { data: s }
      )
    }
  }
function install$1(e) {
  e.registerTransform(filterTransform), e.registerTransform(sortTransform)
}
var DatasetModel = (function (e) {
    function t() {
      var t = (null !== e && e.apply(this, arguments)) || this
      return (t.type = 'dataset'), t
    }
    return (
      __extends(t, e),
      (t.prototype.init = function (t, i, r) {
        e.prototype.init.call(this, t, i, r),
          (this._sourceManager = new SourceManager(this)),
          disableTransformOptionMerge(this)
      }),
      (t.prototype.mergeOption = function (t, i) {
        e.prototype.mergeOption.call(this, t, i), disableTransformOptionMerge(this)
      }),
      (t.prototype.optionUpdated = function () {
        this._sourceManager.dirty()
      }),
      (t.prototype.getSourceManager = function () {
        return this._sourceManager
      }),
      (t.type = 'dataset'),
      (t.defaultOption = { seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN }),
      t
    )
  })(ComponentModel),
  DatasetView = (function (e) {
    function t() {
      var t = (null !== e && e.apply(this, arguments)) || this
      return (t.type = 'dataset'), t
    }
    return __extends(t, e), (t.type = 'dataset'), t
  })(ComponentView)
function install(e) {
  e.registerComponentModel(DatasetModel), e.registerComponentView(DatasetView)
}
function isObject$2(e) {
  return null !== e && 'object' == typeof e && 'constructor' in e && e.constructor === Object
}
function extend$2(e, t) {
  void 0 === e && (e = {}),
    void 0 === t && (t = {}),
    Object.keys(t).forEach(function (i) {
      void 0 === e[i]
        ? (e[i] = t[i])
        : isObject$2(t[i]) &&
          isObject$2(e[i]) &&
          Object.keys(t[i]).length > 0 &&
          extend$2(e[i], t[i])
    })
}
use([install$R]),
  use([install$S]),
  use([
    install$Q,
    install$P,
    install$O,
    install$M,
    install$K,
    install$I,
    install$H,
    install$G,
    install$F,
    install$E,
    install$D,
    install$B,
    install$A,
    install$z,
    install$y,
    install$x,
    install$w,
    install$v,
    install$u,
    install$t,
    install$s,
    install$r
  ]),
  use(install$p),
  use(install$o),
  use(install$J),
  use(install$n),
  use(install$C),
  use(install$m),
  use(install$l),
  use(install$j),
  use(install$i),
  use(install$q),
  use(install$h),
  use(install$g),
  use(install$f),
  use(install$e),
  use(install$d),
  use(install$c),
  use(install$9),
  use(install$6),
  use(install$8),
  use(install$7),
  use(install$3),
  use(install$5),
  use(install$4),
  use(install$2),
  use(install$1),
  use(install)
var ssrDocument = {
  body: {},
  addEventListener: function () {},
  removeEventListener: function () {},
  activeElement: { blur: function () {}, nodeName: '' },
  querySelector: function () {
    return null
  },
  querySelectorAll: function () {
    return []
  },
  getElementById: function () {
    return null
  },
  createEvent: function () {
    return { initEvent: function () {} }
  },
  createElement: function () {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute: function () {},
      getElementsByTagName: function () {
        return []
      }
    }
  },
  createElementNS: function () {
    return {}
  },
  importNode: function () {
    return null
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: ''
  }
}
function getDocument() {
  var e = 'undefined' != typeof document ? document : {}
  return extend$2(e, ssrDocument), e
}
var ssrWindow = {
  document: ssrDocument,
  navigator: { userAgent: '' },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: ''
  },
  history: {
    replaceState: function () {},
    pushState: function () {},
    go: function () {},
    back: function () {}
  },
  CustomEvent: function () {
    return this
  },
  addEventListener: function () {},
  removeEventListener: function () {},
  getComputedStyle: function () {
    return {
      getPropertyValue: function () {
        return ''
      }
    }
  },
  Image: function () {},
  Date: function () {},
  screen: {},
  setTimeout: function () {},
  clearTimeout: function () {},
  matchMedia: function () {
    return {}
  },
  requestAnimationFrame: function (e) {
    return 'undefined' == typeof setTimeout ? (e(), null) : setTimeout(e, 0)
  },
  cancelAnimationFrame: function (e) {
    'undefined' != typeof setTimeout && clearTimeout(e)
  }
}
function getWindow() {
  var e = 'undefined' != typeof window ? window : {}
  return extend$2(e, ssrWindow), e
}
function _inheritsLoose(e, t) {
  ;(e.prototype = Object.create(t.prototype)), (e.prototype.constructor = e), (e.__proto__ = t)
}
function _getPrototypeOf(e) {
  return (_getPrototypeOf = Object.setPrototypeOf
    ? Object.getPrototypeOf
    : function (e) {
        return e.__proto__ || Object.getPrototypeOf(e)
      })(e)
}
function _setPrototypeOf(e, t) {
  return (_setPrototypeOf =
    Object.setPrototypeOf ||
    function (e, t) {
      return (e.__proto__ = t), e
    })(e, t)
}
function _isNativeReflectConstruct() {
  if ('undefined' == typeof Reflect || !Reflect.construct) return !1
  if (Reflect.construct.sham) return !1
  if ('function' == typeof Proxy) return !0
  try {
    return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
  } catch (e) {
    return !1
  }
}
function _construct(e, t, i) {
  return (_construct = _isNativeReflectConstruct()
    ? Reflect.construct
    : function (e, t, i) {
        var r = [null]
        r.push.apply(r, t)
        var n = new (Function.bind.apply(e, r))()
        return i && _setPrototypeOf(n, i.prototype), n
      }).apply(null, arguments)
}
function _isNativeFunction(e) {
  return -1 !== Function.toString.call(e).indexOf('[native code]')
}
function _wrapNativeSuper(e) {
  var t = 'function' == typeof Map ? new Map() : void 0
  return (_wrapNativeSuper = function (e) {
    if (null === e || !_isNativeFunction(e)) return e
    if ('function' != typeof e)
      throw new TypeError('Super expression must either be null or a function')
    if (void 0 !== t) {
      if (t.has(e)) return t.get(e)
      t.set(e, i)
    }
    function i() {
      return _construct(e, arguments, _getPrototypeOf(this).constructor)
    }
    return (
      (i.prototype = Object.create(e.prototype, {
        constructor: { value: i, enumerable: !1, writable: !0, configurable: !0 }
      })),
      _setPrototypeOf(i, e)
    )
  })(e)
}
function _assertThisInitialized(e) {
  if (void 0 === e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
  return e
}
function makeReactive(e) {
  var t = e.__proto__
  Object.defineProperty(e, '__proto__', {
    get: function () {
      return t
    },
    set: function (e) {
      t.__proto__ = e
    }
  })
}
var Dom7 = (function (e) {
  function t(t) {
    var i
    return makeReactive(_assertThisInitialized((i = e.call.apply(e, [this].concat(t)) || this))), i
  }
  return _inheritsLoose(t, e), t
})(_wrapNativeSuper(Array))
function arrayFlat(e) {
  void 0 === e && (e = [])
  var t = []
  return (
    e.forEach(function (e) {
      Array.isArray(e) ? t.push.apply(t, arrayFlat(e)) : t.push(e)
    }),
    t
  )
}
function arrayFilter(e, t) {
  return Array.prototype.filter.call(e, t)
}
function arrayUnique(e) {
  for (var t = [], i = 0; i < e.length; i += 1) -1 === t.indexOf(e[i]) && t.push(e[i])
  return t
}
function qsa(e, t) {
  if ('string' != typeof e) return [e]
  for (var i = [], r = t.querySelectorAll(e), n = 0; n < r.length; n += 1) i.push(r[n])
  return i
}
function $(e, t) {
  var i = getWindow(),
    r = getDocument(),
    n = []
  if (!t && e instanceof Dom7) return e
  if (!e) return new Dom7(n)
  if ('string' == typeof e) {
    var a = e.trim()
    if (a.indexOf('<') >= 0 && a.indexOf('>') >= 0) {
      var o = 'div'
      0 === a.indexOf('<li') && (o = 'ul'),
        0 === a.indexOf('<tr') && (o = 'tbody'),
        (0 !== a.indexOf('<td') && 0 !== a.indexOf('<th')) || (o = 'tr'),
        0 === a.indexOf('<tbody') && (o = 'table'),
        0 === a.indexOf('<option') && (o = 'select')
      var s = r.createElement(o)
      s.innerHTML = a
      for (var l = 0; l < s.childNodes.length; l += 1) n.push(s.childNodes[l])
    } else n = qsa(e.trim(), t || r)
  } else if (e.nodeType || e === i || e === r) n.push(e)
  else if (Array.isArray(e)) {
    if (e instanceof Dom7) return e
    n = e
  }
  return new Dom7(arrayUnique(n))
}
function addClass() {
  for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i]
  var r = arrayFlat(
    t.map(function (e) {
      return e.split(' ')
    })
  )
  return (
    this.forEach(function (e) {
      var t
      ;(t = e.classList).add.apply(t, r)
    }),
    this
  )
}
function removeClass() {
  for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i]
  var r = arrayFlat(
    t.map(function (e) {
      return e.split(' ')
    })
  )
  return (
    this.forEach(function (e) {
      var t
      ;(t = e.classList).remove.apply(t, r)
    }),
    this
  )
}
function toggleClass() {
  for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i]
  var r = arrayFlat(
    t.map(function (e) {
      return e.split(' ')
    })
  )
  this.forEach(function (e) {
    r.forEach(function (t) {
      e.classList.toggle(t)
    })
  })
}
function hasClass() {
  for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i]
  var r = arrayFlat(
    t.map(function (e) {
      return e.split(' ')
    })
  )
  return (
    arrayFilter(this, function (e) {
      return (
        r.filter(function (t) {
          return e.classList.contains(t)
        }).length > 0
      )
    }).length > 0
  )
}
function attr(e, t) {
  if (1 === arguments.length && 'string' == typeof e)
    return this[0] ? this[0].getAttribute(e) : void 0
  for (var i = 0; i < this.length; i += 1)
    if (2 === arguments.length) this[i].setAttribute(e, t)
    else for (var r in e) (this[i][r] = e[r]), this[i].setAttribute(r, e[r])
  return this
}
function removeAttr(e) {
  for (var t = 0; t < this.length; t += 1) this[t].removeAttribute(e)
  return this
}
function transform(e) {
  for (var t = 0; t < this.length; t += 1) this[t].style.transform = e
  return this
}
function transition$1(e) {
  for (var t = 0; t < this.length; t += 1)
    this[t].style.transitionDuration = 'string' != typeof e ? e + 'ms' : e
  return this
}
function on() {
  for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i]
  var r = t[0],
    n = t[1],
    a = t[2],
    o = t[3]
  function s(e) {
    var t = e.target
    if (t) {
      var i = e.target.dom7EventData || []
      if ((i.indexOf(e) < 0 && i.unshift(e), $(t).is(n))) a.apply(t, i)
      else
        for (var r = $(t).parents(), o = 0; o < r.length; o += 1) $(r[o]).is(n) && a.apply(r[o], i)
    }
  }
  function l(e) {
    var t = (e && e.target && e.target.dom7EventData) || []
    t.indexOf(e) < 0 && t.unshift(e), a.apply(this, t)
  }
  'function' == typeof t[1] && ((r = t[0]), (a = t[1]), (o = t[2]), (n = void 0)), o || (o = !1)
  for (var h, u = r.split(' '), p = 0; p < this.length; p += 1) {
    var c = this[p]
    if (n)
      for (h = 0; h < u.length; h += 1) {
        var d = u[h]
        c.dom7LiveListeners || (c.dom7LiveListeners = {}),
          c.dom7LiveListeners[d] || (c.dom7LiveListeners[d] = []),
          c.dom7LiveListeners[d].push({ listener: a, proxyListener: s }),
          c.addEventListener(d, s, o)
      }
    else
      for (h = 0; h < u.length; h += 1) {
        var f = u[h]
        c.dom7Listeners || (c.dom7Listeners = {}),
          c.dom7Listeners[f] || (c.dom7Listeners[f] = []),
          c.dom7Listeners[f].push({ listener: a, proxyListener: l }),
          c.addEventListener(f, l, o)
      }
  }
  return this
}
function off() {
  for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i]
  var r = t[0],
    n = t[1],
    a = t[2],
    o = t[3]
  'function' == typeof t[1] && ((r = t[0]), (a = t[1]), (o = t[2]), (n = void 0)), o || (o = !1)
  for (var s = r.split(' '), l = 0; l < s.length; l += 1)
    for (var h = s[l], u = 0; u < this.length; u += 1) {
      var p = this[u],
        c = void 0
      if (
        (!n && p.dom7Listeners
          ? (c = p.dom7Listeners[h])
          : n && p.dom7LiveListeners && (c = p.dom7LiveListeners[h]),
        c && c.length)
      )
        for (var d = c.length - 1; d >= 0; d -= 1) {
          var f = c[d]
          ;(a && f.listener === a) ||
          (a && f.listener && f.listener.dom7proxy && f.listener.dom7proxy === a)
            ? (p.removeEventListener(h, f.proxyListener, o), c.splice(d, 1))
            : a || (p.removeEventListener(h, f.proxyListener, o), c.splice(d, 1))
        }
    }
  return this
}
function trigger() {
  for (var e = getWindow(), t = arguments.length, i = new Array(t), r = 0; r < t; r++)
    i[r] = arguments[r]
  for (var n = i[0].split(' '), a = i[1], o = 0; o < n.length; o += 1)
    for (var s = n[o], l = 0; l < this.length; l += 1) {
      var h = this[l]
      if (e.CustomEvent) {
        var u = new e.CustomEvent(s, { detail: a, bubbles: !0, cancelable: !0 })
        ;(h.dom7EventData = i.filter(function (e, t) {
          return t > 0
        })),
          h.dispatchEvent(u),
          (h.dom7EventData = []),
          delete h.dom7EventData
      }
    }
  return this
}
function transitionEnd$1(e) {
  var t = this
  return (
    e &&
      t.on('transitionend', function i(r) {
        r.target === this && (e.call(this, r), t.off('transitionend', i))
      }),
    this
  )
}
function outerWidth(e) {
  if (this.length > 0) {
    if (e) {
      var t = this.styles()
      return (
        this[0].offsetWidth +
        parseFloat(t.getPropertyValue('margin-right')) +
        parseFloat(t.getPropertyValue('margin-left'))
      )
    }
    return this[0].offsetWidth
  }
  return null
}
function outerHeight(e) {
  if (this.length > 0) {
    if (e) {
      var t = this.styles()
      return (
        this[0].offsetHeight +
        parseFloat(t.getPropertyValue('margin-top')) +
        parseFloat(t.getPropertyValue('margin-bottom'))
      )
    }
    return this[0].offsetHeight
  }
  return null
}
function offset() {
  if (this.length > 0) {
    var e = getWindow(),
      t = getDocument(),
      i = this[0],
      r = i.getBoundingClientRect(),
      n = t.body,
      a = i.clientTop || n.clientTop || 0,
      o = i.clientLeft || n.clientLeft || 0,
      s = i === e ? e.scrollY : i.scrollTop,
      l = i === e ? e.scrollX : i.scrollLeft
    return { top: r.top + s - a, left: r.left + l - o }
  }
  return null
}
function styles() {
  var e = getWindow()
  return this[0] ? e.getComputedStyle(this[0], null) : {}
}
function css(e, t) {
  var i,
    r = getWindow()
  if (1 === arguments.length) {
    if ('string' != typeof e) {
      for (i = 0; i < this.length; i += 1) for (var n in e) this[i].style[n] = e[n]
      return this
    }
    if (this[0]) return r.getComputedStyle(this[0], null).getPropertyValue(e)
  }
  if (2 === arguments.length && 'string' == typeof e) {
    for (i = 0; i < this.length; i += 1) this[i].style[e] = t
    return this
  }
  return this
}
function each(e) {
  return e
    ? (this.forEach(function (t, i) {
        e.apply(t, [t, i])
      }),
      this)
    : this
}
function filter(e) {
  return $(arrayFilter(this, e))
}
function html(e) {
  if (void 0 === e) return this[0] ? this[0].innerHTML : null
  for (var t = 0; t < this.length; t += 1) this[t].innerHTML = e
  return this
}
function text(e) {
  if (void 0 === e) return this[0] ? this[0].textContent.trim() : null
  for (var t = 0; t < this.length; t += 1) this[t].textContent = e
  return this
}
function is(e) {
  var t,
    i,
    r = getWindow(),
    n = getDocument(),
    a = this[0]
  if (!a || void 0 === e) return !1
  if ('string' == typeof e) {
    if (a.matches) return a.matches(e)
    if (a.webkitMatchesSelector) return a.webkitMatchesSelector(e)
    if (a.msMatchesSelector) return a.msMatchesSelector(e)
    for (t = $(e), i = 0; i < t.length; i += 1) if (t[i] === a) return !0
    return !1
  }
  if (e === n) return a === n
  if (e === r) return a === r
  if (e.nodeType || e instanceof Dom7) {
    for (t = e.nodeType ? [e] : e, i = 0; i < t.length; i += 1) if (t[i] === a) return !0
    return !1
  }
  return !1
}
function index() {
  var e,
    t = this[0]
  if (t) {
    for (e = 0; null !== (t = t.previousSibling); ) 1 === t.nodeType && (e += 1)
    return e
  }
}
function eq(e) {
  if (void 0 === e) return this
  var t = this.length
  if (e > t - 1) return $([])
  if (e < 0) {
    var i = t + e
    return $(i < 0 ? [] : [this[i]])
  }
  return $([this[e]])
}
function append() {
  for (var e, t = getDocument(), i = 0; i < arguments.length; i += 1) {
    e = i < 0 || arguments.length <= i ? void 0 : arguments[i]
    for (var r = 0; r < this.length; r += 1)
      if ('string' == typeof e) {
        var n = t.createElement('div')
        for (n.innerHTML = e; n.firstChild; ) this[r].appendChild(n.firstChild)
      } else if (e instanceof Dom7) for (var a = 0; a < e.length; a += 1) this[r].appendChild(e[a])
      else this[r].appendChild(e)
  }
  return this
}
function prepend(e) {
  var t,
    i,
    r = getDocument()
  for (t = 0; t < this.length; t += 1)
    if ('string' == typeof e) {
      var n = r.createElement('div')
      for (n.innerHTML = e, i = n.childNodes.length - 1; i >= 0; i -= 1)
        this[t].insertBefore(n.childNodes[i], this[t].childNodes[0])
    } else if (e instanceof Dom7)
      for (i = 0; i < e.length; i += 1) this[t].insertBefore(e[i], this[t].childNodes[0])
    else this[t].insertBefore(e, this[t].childNodes[0])
  return this
}
function next(e) {
  return this.length > 0
    ? e
      ? this[0].nextElementSibling && $(this[0].nextElementSibling).is(e)
        ? $([this[0].nextElementSibling])
        : $([])
      : this[0].nextElementSibling
      ? $([this[0].nextElementSibling])
      : $([])
    : $([])
}
function nextAll(e) {
  var t = [],
    i = this[0]
  if (!i) return $([])
  for (; i.nextElementSibling; ) {
    var r = i.nextElementSibling
    e ? $(r).is(e) && t.push(r) : t.push(r), (i = r)
  }
  return $(t)
}
function prev(e) {
  if (this.length > 0) {
    var t = this[0]
    return e
      ? t.previousElementSibling && $(t.previousElementSibling).is(e)
        ? $([t.previousElementSibling])
        : $([])
      : t.previousElementSibling
      ? $([t.previousElementSibling])
      : $([])
  }
  return $([])
}
function prevAll(e) {
  var t = [],
    i = this[0]
  if (!i) return $([])
  for (; i.previousElementSibling; ) {
    var r = i.previousElementSibling
    e ? $(r).is(e) && t.push(r) : t.push(r), (i = r)
  }
  return $(t)
}
function parent(e) {
  for (var t = [], i = 0; i < this.length; i += 1)
    null !== this[i].parentNode &&
      (e ? $(this[i].parentNode).is(e) && t.push(this[i].parentNode) : t.push(this[i].parentNode))
  return $(t)
}
function parents(e) {
  for (var t = [], i = 0; i < this.length; i += 1)
    for (var r = this[i].parentNode; r; )
      e ? $(r).is(e) && t.push(r) : t.push(r), (r = r.parentNode)
  return $(t)
}
function closest(e) {
  var t = this
  return void 0 === e ? $([]) : (t.is(e) || (t = t.parents(e).eq(0)), t)
}
function find(e) {
  for (var t = [], i = 0; i < this.length; i += 1)
    for (var r = this[i].querySelectorAll(e), n = 0; n < r.length; n += 1) t.push(r[n])
  return $(t)
}
function children(e) {
  for (var t = [], i = 0; i < this.length; i += 1)
    for (var r = this[i].children, n = 0; n < r.length; n += 1)
      (e && !$(r[n]).is(e)) || t.push(r[n])
  return $(t)
}
function remove() {
  for (var e = 0; e < this.length; e += 1)
    this[e].parentNode && this[e].parentNode.removeChild(this[e])
  return this
}
$.fn = Dom7.prototype
var Methods = {
    addClass: addClass,
    removeClass: removeClass,
    hasClass: hasClass,
    toggleClass: toggleClass,
    attr: attr,
    removeAttr: removeAttr,
    transform: transform,
    transition: transition$1,
    on: on,
    off: off,
    trigger: trigger,
    transitionEnd: transitionEnd$1,
    outerWidth: outerWidth,
    outerHeight: outerHeight,
    styles: styles,
    offset: offset,
    css: css,
    each: each,
    html: html,
    text: text,
    is: is,
    index: index,
    eq: eq,
    append: append,
    prepend: prepend,
    next: next,
    nextAll: nextAll,
    prev: prev,
    prevAll: prevAll,
    parent: parent,
    parents: parents,
    closest: closest,
    find: find,
    children: children,
    filter: filter,
    remove: remove
  },
  support,
  device,
  browser
function deleteProps(e) {
  var t = e
  Object.keys(t).forEach(function (e) {
    try {
      t[e] = null
    } catch (i) {}
    try {
      delete t[e]
    } catch (i) {}
  })
}
function nextTick(e, t) {
  return void 0 === t && (t = 0), setTimeout(e, t)
}
function now() {
  return Date.now()
}
function getComputedStyle$1(e) {
  var t,
    i = getWindow()
  return (
    i.getComputedStyle && (t = i.getComputedStyle(e, null)),
    !t && e.currentStyle && (t = e.currentStyle),
    t || (t = e.style),
    t
  )
}
function getTranslate(e, t) {
  void 0 === t && (t = 'x')
  var i,
    r,
    n,
    a = getWindow(),
    o = getComputedStyle$1(e)
  return (
    a.WebKitCSSMatrix
      ? ((r = o.transform || o.webkitTransform).split(',').length > 6 &&
          (r = r
            .split(', ')
            .map(function (e) {
              return e.replace(',', '.')
            })
            .join(', ')),
        (n = new a.WebKitCSSMatrix('none' === r ? '' : r)))
      : (i = (n =
          o.MozTransform ||
          o.OTransform ||
          o.MsTransform ||
          o.msTransform ||
          o.transform ||
          o.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,'))
          .toString()
          .split(',')),
    'x' === t &&
      (r = a.WebKitCSSMatrix ? n.m41 : 16 === i.length ? parseFloat(i[12]) : parseFloat(i[4])),
    'y' === t &&
      (r = a.WebKitCSSMatrix ? n.m42 : 16 === i.length ? parseFloat(i[13]) : parseFloat(i[5])),
    r || 0
  )
}
function isObject$1(e) {
  return (
    'object' == typeof e &&
    null !== e &&
    e.constructor &&
    'Object' === Object.prototype.toString.call(e).slice(8, -1)
  )
}
function extend$1() {
  for (
    var e = Object(arguments.length <= 0 ? void 0 : arguments[0]),
      t = ['__proto__', 'constructor', 'prototype'],
      i = 1;
    i < arguments.length;
    i += 1
  ) {
    var r = i < 0 || arguments.length <= i ? void 0 : arguments[i]
    if (null != r)
      for (
        var n = Object.keys(Object(r)).filter(function (e) {
            return t.indexOf(e) < 0
          }),
          a = 0,
          o = n.length;
        a < o;
        a += 1
      ) {
        var s = n[a],
          l = Object.getOwnPropertyDescriptor(r, s)
        void 0 !== l &&
          l.enumerable &&
          (isObject$1(e[s]) && isObject$1(r[s])
            ? r[s].__swiper__
              ? (e[s] = r[s])
              : extend$1(e[s], r[s])
            : !isObject$1(e[s]) && isObject$1(r[s])
            ? ((e[s] = {}), r[s].__swiper__ ? (e[s] = r[s]) : extend$1(e[s], r[s]))
            : (e[s] = r[s]))
      }
  }
  return e
}
function bindModuleMethods(e, t) {
  Object.keys(t).forEach(function (i) {
    isObject$1(t[i]) &&
      Object.keys(t[i]).forEach(function (r) {
        'function' == typeof t[i][r] && (t[i][r] = t[i][r].bind(e))
      }),
      (e[i] = t[i])
  })
}
function calcSupport() {
  var e = getWindow(),
    t = getDocument()
  return {
    touch: !!('ontouchstart' in e || (e.DocumentTouch && t instanceof e.DocumentTouch)),
    pointerEvents:
      !!e.PointerEvent && 'maxTouchPoints' in e.navigator && e.navigator.maxTouchPoints >= 0,
    observer: 'MutationObserver' in e || 'WebkitMutationObserver' in e,
    passiveListener: (function () {
      var t = !1
      try {
        var i = Object.defineProperty({}, 'passive', {
          get: function () {
            t = !0
          }
        })
        e.addEventListener('testPassiveListener', null, i)
      } catch (r) {}
      return t
    })(),
    gestures: 'ongesturestart' in e
  }
}
function getSupport() {
  return support || (support = calcSupport()), support
}
function calcDevice(e) {
  var t = (void 0 === e ? {} : e).userAgent,
    i = getSupport(),
    r = getWindow(),
    n = r.navigator.platform,
    a = t || r.navigator.userAgent,
    o = { ios: !1, android: !1 },
    s = r.screen.width,
    l = r.screen.height,
    h = a.match(/(Android);?[\s\/]+([\d.]+)?/),
    u = a.match(/(iPad).*OS\s([\d_]+)/),
    p = a.match(/(iPod)(.*OS\s([\d_]+))?/),
    c = !u && a.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
    d = 'Win32' === n,
    f = 'MacIntel' === n
  return (
    !u &&
      f &&
      i.touch &&
      [
        '1024x1366',
        '1366x1024',
        '834x1194',
        '1194x834',
        '834x1112',
        '1112x834',
        '768x1024',
        '1024x768',
        '820x1180',
        '1180x820',
        '810x1080',
        '1080x810'
      ].indexOf(s + 'x' + l) >= 0 &&
      ((u = a.match(/(Version)\/([\d.]+)/)) || (u = [0, 1, '13_0_0']), (f = !1)),
    h && !d && ((o.os = 'android'), (o.android = !0)),
    (u || c || p) && ((o.os = 'ios'), (o.ios = !0)),
    o
  )
}
function getDevice(e) {
  return void 0 === e && (e = {}), device || (device = calcDevice(e)), device
}
function calcBrowser() {
  var e,
    t = getWindow()
  return {
    isEdge: !!t.navigator.userAgent.match(/Edge/g),
    isSafari:
      ((e = t.navigator.userAgent.toLowerCase()),
      e.indexOf('safari') >= 0 && e.indexOf('chrome') < 0 && e.indexOf('android') < 0),
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(t.navigator.userAgent)
  }
}
function getBrowser() {
  return browser || (browser = calcBrowser()), browser
}
Object.keys(Methods).forEach(function (e) {
  Object.defineProperty($.fn, e, { value: Methods[e], writable: !0 })
})
var supportsResizeObserver = function () {
    return void 0 !== getWindow().ResizeObserver
  },
  Resize = {
    name: 'resize',
    create: function () {
      var e = this
      extend$1(e, {
        resize: {
          observer: null,
          createObserver: function () {
            e &&
              !e.destroyed &&
              e.initialized &&
              ((e.resize.observer = new ResizeObserver(function (t) {
                var i = e.width,
                  r = e.height,
                  n = i,
                  a = r
                t.forEach(function (t) {
                  var i = t.contentBoxSize,
                    r = t.contentRect,
                    o = t.target
                  ;(o && o !== e.el) ||
                    ((n = r ? r.width : (i[0] || i).inlineSize),
                    (a = r ? r.height : (i[0] || i).blockSize))
                }),
                  (n === i && a === r) || e.resize.resizeHandler()
              })),
              e.resize.observer.observe(e.el))
          },
          removeObserver: function () {
            e.resize.observer &&
              e.resize.observer.unobserve &&
              e.el &&
              (e.resize.observer.unobserve(e.el), (e.resize.observer = null))
          },
          resizeHandler: function () {
            e && !e.destroyed && e.initialized && (e.emit('beforeResize'), e.emit('resize'))
          },
          orientationChangeHandler: function () {
            e && !e.destroyed && e.initialized && e.emit('orientationchange')
          }
        }
      })
    },
    on: {
      init: function (e) {
        var t = getWindow()
        e.params.resizeObserver && supportsResizeObserver()
          ? e.resize.createObserver()
          : (t.addEventListener('resize', e.resize.resizeHandler),
            t.addEventListener('orientationchange', e.resize.orientationChangeHandler))
      },
      destroy: function (e) {
        var t = getWindow()
        e.resize.removeObserver(),
          t.removeEventListener('resize', e.resize.resizeHandler),
          t.removeEventListener('orientationchange', e.resize.orientationChangeHandler)
      }
    }
  }
function _extends$2() {
  return (_extends$2 =
    Object.assign ||
    function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var i = arguments[t]
        for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r])
      }
      return e
    }).apply(this, arguments)
}
var Observer = {
    attach: function (e, t) {
      void 0 === t && (t = {})
      var i = getWindow(),
        r = this,
        n = new (i.MutationObserver || i.WebkitMutationObserver)(function (e) {
          if (1 !== e.length) {
            var t = function () {
              r.emit('observerUpdate', e[0])
            }
            i.requestAnimationFrame ? i.requestAnimationFrame(t) : i.setTimeout(t, 0)
          } else r.emit('observerUpdate', e[0])
        })
      n.observe(e, {
        attributes: void 0 === t.attributes || t.attributes,
        childList: void 0 === t.childList || t.childList,
        characterData: void 0 === t.characterData || t.characterData
      }),
        r.observer.observers.push(n)
    },
    init: function () {
      var e = this
      if (e.support.observer && e.params.observer) {
        if (e.params.observeParents)
          for (var t = e.$el.parents(), i = 0; i < t.length; i += 1) e.observer.attach(t[i])
        e.observer.attach(e.$el[0], { childList: e.params.observeSlideChildren }),
          e.observer.attach(e.$wrapperEl[0], { attributes: !1 })
      }
    },
    destroy: function () {
      this.observer.observers.forEach(function (e) {
        e.disconnect()
      }),
        (this.observer.observers = [])
    }
  },
  Observer$1 = {
    name: 'observer',
    params: { observer: !1, observeParents: !1, observeSlideChildren: !1 },
    create: function () {
      bindModuleMethods(this, { observer: _extends$2({}, Observer, { observers: [] }) })
    },
    on: {
      init: function (e) {
        e.observer.init()
      },
      destroy: function (e) {
        e.observer.destroy()
      }
    }
  },
  modular = {
    useParams: function (e) {
      var t = this
      t.modules &&
        Object.keys(t.modules).forEach(function (i) {
          var r = t.modules[i]
          r.params && extend$1(e, r.params)
        })
    },
    useModules: function (e) {
      void 0 === e && (e = {})
      var t = this
      t.modules &&
        Object.keys(t.modules).forEach(function (i) {
          var r = t.modules[i],
            n = e[i] || {}
          r.on &&
            t.on &&
            Object.keys(r.on).forEach(function (e) {
              t.on(e, r.on[e])
            }),
            r.create && r.create.bind(t)(n)
        })
    }
  },
  eventsEmitter = {
    on: function (e, t, i) {
      var r = this
      if ('function' != typeof t) return r
      var n = i ? 'unshift' : 'push'
      return (
        e.split(' ').forEach(function (e) {
          r.eventsListeners[e] || (r.eventsListeners[e] = []), r.eventsListeners[e][n](t)
        }),
        r
      )
    },
    once: function (e, t, i) {
      var r = this
      if ('function' != typeof t) return r
      function n() {
        r.off(e, n), n.__emitterProxy && delete n.__emitterProxy
        for (var i = arguments.length, a = new Array(i), o = 0; o < i; o++) a[o] = arguments[o]
        t.apply(r, a)
      }
      return (n.__emitterProxy = t), r.on(e, n, i)
    },
    onAny: function (e, t) {
      var i = this
      if ('function' != typeof e) return i
      var r = t ? 'unshift' : 'push'
      return i.eventsAnyListeners.indexOf(e) < 0 && i.eventsAnyListeners[r](e), i
    },
    offAny: function (e) {
      var t = this
      if (!t.eventsAnyListeners) return t
      var i = t.eventsAnyListeners.indexOf(e)
      return i >= 0 && t.eventsAnyListeners.splice(i, 1), t
    },
    off: function (e, t) {
      var i = this
      return i.eventsListeners
        ? (e.split(' ').forEach(function (e) {
            void 0 === t
              ? (i.eventsListeners[e] = [])
              : i.eventsListeners[e] &&
                i.eventsListeners[e].forEach(function (r, n) {
                  ;(r === t || (r.__emitterProxy && r.__emitterProxy === t)) &&
                    i.eventsListeners[e].splice(n, 1)
                })
          }),
          i)
        : i
    },
    emit: function () {
      var e,
        t,
        i,
        r = this
      if (!r.eventsListeners) return r
      for (var n = arguments.length, a = new Array(n), o = 0; o < n; o++) a[o] = arguments[o]
      'string' == typeof a[0] || Array.isArray(a[0])
        ? ((e = a[0]), (t = a.slice(1, a.length)), (i = r))
        : ((e = a[0].events), (t = a[0].data), (i = a[0].context || r)),
        t.unshift(i)
      var s = Array.isArray(e) ? e : e.split(' ')
      return (
        s.forEach(function (e) {
          r.eventsAnyListeners &&
            r.eventsAnyListeners.length &&
            r.eventsAnyListeners.forEach(function (r) {
              r.apply(i, [e].concat(t))
            }),
            r.eventsListeners &&
              r.eventsListeners[e] &&
              r.eventsListeners[e].forEach(function (e) {
                e.apply(i, t)
              })
        }),
        r
      )
    }
  }
function updateSize() {
  var e,
    t,
    i = this,
    r = i.$el
  ;(e = void 0 !== i.params.width && null !== i.params.width ? i.params.width : r[0].clientWidth),
    (t =
      void 0 !== i.params.height && null !== i.params.height ? i.params.height : r[0].clientHeight),
    (0 === e && i.isHorizontal()) ||
      (0 === t && i.isVertical()) ||
      ((e =
        e - parseInt(r.css('padding-left') || 0, 10) - parseInt(r.css('padding-right') || 0, 10)),
      (t =
        t - parseInt(r.css('padding-top') || 0, 10) - parseInt(r.css('padding-bottom') || 0, 10)),
      Number.isNaN(e) && (e = 0),
      Number.isNaN(t) && (t = 0),
      extend$1(i, { width: e, height: t, size: i.isHorizontal() ? e : t }))
}
function updateSlides() {
  var e = this
  function t(t) {
    return e.isHorizontal()
      ? t
      : {
          width: 'height',
          'margin-top': 'margin-left',
          'margin-bottom ': 'margin-right',
          'margin-left': 'margin-top',
          'margin-right': 'margin-bottom',
          'padding-left': 'padding-top',
          'padding-right': 'padding-bottom',
          marginRight: 'marginBottom'
        }[t]
  }
  function i(e, i) {
    return parseFloat(e.getPropertyValue(t(i)) || 0)
  }
  var r = e.params,
    n = e.$wrapperEl,
    a = e.size,
    o = e.rtlTranslate,
    s = e.wrongRTL,
    l = e.virtual && r.virtual.enabled,
    h = l ? e.virtual.slides.length : e.slides.length,
    u = n.children('.' + e.params.slideClass),
    p = l ? e.virtual.slides.length : u.length,
    c = [],
    d = [],
    f = [],
    m = r.slidesOffsetBefore
  'function' == typeof m && (m = r.slidesOffsetBefore.call(e))
  var g = r.slidesOffsetAfter
  'function' == typeof g && (g = r.slidesOffsetAfter.call(e))
  var y = e.snapGrid.length,
    v = e.slidesGrid.length,
    _ = r.spaceBetween,
    x = -m,
    S = 0,
    b = 0
  if (void 0 !== a) {
    var T, A
    'string' == typeof _ && _.indexOf('%') >= 0 && (_ = (parseFloat(_.replace('%', '')) / 100) * a),
      (e.virtualSize = -_),
      o ? u.css({ marginLeft: '', marginTop: '' }) : u.css({ marginRight: '', marginBottom: '' }),
      r.slidesPerColumn > 1 &&
        ((T =
          Math.floor(p / r.slidesPerColumn) === p / e.params.slidesPerColumn
            ? p
            : Math.ceil(p / r.slidesPerColumn) * r.slidesPerColumn),
        'auto' !== r.slidesPerView &&
          'row' === r.slidesPerColumnFill &&
          (T = Math.max(T, r.slidesPerView * r.slidesPerColumn)))
    for (
      var w, M, C, P = r.slidesPerColumn, E = T / P, I = Math.floor(p / r.slidesPerColumn), D = 0;
      D < p;
      D += 1
    ) {
      A = 0
      var L = u.eq(D)
      if (r.slidesPerColumn > 1) {
        var R = void 0,
          O = void 0,
          k = void 0
        if ('row' === r.slidesPerColumnFill && r.slidesPerGroup > 1) {
          var $ = Math.floor(D / (r.slidesPerGroup * r.slidesPerColumn)),
            N = D - r.slidesPerColumn * r.slidesPerGroup * $,
            F =
              0 === $
                ? r.slidesPerGroup
                : Math.min(Math.ceil((p - $ * P * r.slidesPerGroup) / P), r.slidesPerGroup)
          ;(R = (O = N - (k = Math.floor(N / F)) * F + $ * r.slidesPerGroup) + (k * T) / P),
            L.css({
              '-webkit-box-ordinal-group': R,
              '-moz-box-ordinal-group': R,
              '-ms-flex-order': R,
              '-webkit-order': R,
              order: R
            })
        } else
          'column' === r.slidesPerColumnFill
            ? ((k = D - (O = Math.floor(D / P)) * P),
              (O > I || (O === I && k === P - 1)) && (k += 1) >= P && ((k = 0), (O += 1)))
            : (O = D - (k = Math.floor(D / E)) * E)
        L.css(t('margin-top'), 0 !== k && r.spaceBetween && r.spaceBetween + 'px')
      }
      if ('none' !== L.css('display')) {
        if ('auto' === r.slidesPerView) {
          var B = getComputedStyle(L[0]),
            V = L[0].style.transform,
            z = L[0].style.webkitTransform
          if (
            (V && (L[0].style.transform = 'none'),
            z && (L[0].style.webkitTransform = 'none'),
            r.roundLengths)
          )
            A = e.isHorizontal() ? L.outerWidth(!0) : L.outerHeight(!0)
          else {
            var G = i(B, 'width'),
              H = i(B, 'padding-left'),
              U = i(B, 'padding-right'),
              Y = i(B, 'margin-left'),
              W = i(B, 'margin-right'),
              j = B.getPropertyValue('box-sizing')
            if (j && 'border-box' === j) A = G + Y + W
            else {
              var Z = L[0],
                X = Z.clientWidth
              A = G + H + U + Y + W + (Z.offsetWidth - X)
            }
          }
          V && (L[0].style.transform = V),
            z && (L[0].style.webkitTransform = z),
            r.roundLengths && (A = Math.floor(A))
        } else
          (A = (a - (r.slidesPerView - 1) * _) / r.slidesPerView),
            r.roundLengths && (A = Math.floor(A)),
            u[D] && (u[D].style[t('width')] = A + 'px')
        u[D] && (u[D].swiperSlideSize = A),
          f.push(A),
          r.centeredSlides
            ? ((x = x + A / 2 + S / 2 + _),
              0 === S && 0 !== D && (x = x - a / 2 - _),
              0 === D && (x = x - a / 2 - _),
              Math.abs(x) < 0.001 && (x = 0),
              r.roundLengths && (x = Math.floor(x)),
              b % r.slidesPerGroup == 0 && c.push(x),
              d.push(x))
            : (r.roundLengths && (x = Math.floor(x)),
              (b - Math.min(e.params.slidesPerGroupSkip, b)) % e.params.slidesPerGroup == 0 &&
                c.push(x),
              d.push(x),
              (x = x + A + _)),
          (e.virtualSize += A + _),
          (S = A),
          (b += 1)
      }
    }
    if (
      ((e.virtualSize = Math.max(e.virtualSize, a) + g),
      o &&
        s &&
        ('slide' === r.effect || 'coverflow' === r.effect) &&
        n.css({ width: e.virtualSize + r.spaceBetween + 'px' }),
      r.setWrapperSize)
    )
      n.css((((M = {})[t('width')] = e.virtualSize + r.spaceBetween + 'px'), M))
    if (r.slidesPerColumn > 1)
      if (
        ((e.virtualSize = (A + r.spaceBetween) * T),
        (e.virtualSize = Math.ceil(e.virtualSize / r.slidesPerColumn) - r.spaceBetween),
        n.css((((C = {})[t('width')] = e.virtualSize + r.spaceBetween + 'px'), C)),
        r.centeredSlides)
      ) {
        w = []
        for (var q = 0; q < c.length; q += 1) {
          var K = c[q]
          r.roundLengths && (K = Math.floor(K)), c[q] < e.virtualSize + c[0] && w.push(K)
        }
        c = w
      }
    if (!r.centeredSlides) {
      w = []
      for (var J = 0; J < c.length; J += 1) {
        var Q = c[J]
        r.roundLengths && (Q = Math.floor(Q)), c[J] <= e.virtualSize - a && w.push(Q)
      }
      ;(c = w),
        Math.floor(e.virtualSize - a) - Math.floor(c[c.length - 1]) > 1 && c.push(e.virtualSize - a)
    }
    if ((0 === c.length && (c = [0]), 0 !== r.spaceBetween)) {
      var ee,
        te = e.isHorizontal() && o ? 'marginLeft' : t('marginRight')
      u.filter(function (e, t) {
        return !r.cssMode || t !== u.length - 1
      }).css((((ee = {})[te] = _ + 'px'), ee))
    }
    if (r.centeredSlides && r.centeredSlidesBounds) {
      var ie = 0
      f.forEach(function (e) {
        ie += e + (r.spaceBetween ? r.spaceBetween : 0)
      })
      var re = (ie -= r.spaceBetween) - a
      c = c.map(function (e) {
        return e < 0 ? -m : e > re ? re + g : e
      })
    }
    if (r.centerInsufficientSlides) {
      var ne = 0
      if (
        (f.forEach(function (e) {
          ne += e + (r.spaceBetween ? r.spaceBetween : 0)
        }),
        (ne -= r.spaceBetween) < a)
      ) {
        var ae = (a - ne) / 2
        c.forEach(function (e, t) {
          c[t] = e - ae
        }),
          d.forEach(function (e, t) {
            d[t] = e + ae
          })
      }
    }
    extend$1(e, { slides: u, snapGrid: c, slidesGrid: d, slidesSizesGrid: f }),
      p !== h && e.emit('slidesLengthChange'),
      c.length !== y &&
        (e.params.watchOverflow && e.checkOverflow(), e.emit('snapGridLengthChange')),
      d.length !== v && e.emit('slidesGridLengthChange'),
      (r.watchSlidesProgress || r.watchSlidesVisibility) && e.updateSlidesOffset()
  }
}
function updateAutoHeight(e) {
  var t,
    i = this,
    r = [],
    n = i.virtual && i.params.virtual.enabled,
    a = 0
  'number' == typeof e ? i.setTransition(e) : !0 === e && i.setTransition(i.params.speed)
  var o = function (e) {
    return n
      ? i.slides.filter(function (t) {
          return parseInt(t.getAttribute('data-swiper-slide-index'), 10) === e
        })[0]
      : i.slides.eq(e)[0]
  }
  if ('auto' !== i.params.slidesPerView && i.params.slidesPerView > 1)
    if (i.params.centeredSlides)
      i.visibleSlides.each(function (e) {
        r.push(e)
      })
    else
      for (t = 0; t < Math.ceil(i.params.slidesPerView); t += 1) {
        var s = i.activeIndex + t
        if (s > i.slides.length && !n) break
        r.push(o(s))
      }
  else r.push(o(i.activeIndex))
  for (t = 0; t < r.length; t += 1)
    if (void 0 !== r[t]) {
      var l = r[t].offsetHeight
      a = l > a ? l : a
    }
  a && i.$wrapperEl.css('height', a + 'px')
}
function updateSlidesOffset() {
  for (var e = this.slides, t = 0; t < e.length; t += 1)
    e[t].swiperSlideOffset = this.isHorizontal() ? e[t].offsetLeft : e[t].offsetTop
}
function updateSlidesProgress(e) {
  void 0 === e && (e = (this && this.translate) || 0)
  var t = this,
    i = t.params,
    r = t.slides,
    n = t.rtlTranslate
  if (0 !== r.length) {
    void 0 === r[0].swiperSlideOffset && t.updateSlidesOffset()
    var a = -e
    n && (a = e),
      r.removeClass(i.slideVisibleClass),
      (t.visibleSlidesIndexes = []),
      (t.visibleSlides = [])
    for (var o = 0; o < r.length; o += 1) {
      var s = r[o],
        l =
          (a + (i.centeredSlides ? t.minTranslate() : 0) - s.swiperSlideOffset) /
          (s.swiperSlideSize + i.spaceBetween)
      if (i.watchSlidesVisibility || (i.centeredSlides && i.autoHeight)) {
        var h = -(a - s.swiperSlideOffset),
          u = h + t.slidesSizesGrid[o]
        ;((h >= 0 && h < t.size - 1) || (u > 1 && u <= t.size) || (h <= 0 && u >= t.size)) &&
          (t.visibleSlides.push(s),
          t.visibleSlidesIndexes.push(o),
          r.eq(o).addClass(i.slideVisibleClass))
      }
      s.progress = n ? -l : l
    }
    t.visibleSlides = $(t.visibleSlides)
  }
}
function updateProgress(e) {
  var t = this
  if (void 0 === e) {
    var i = t.rtlTranslate ? -1 : 1
    e = (t && t.translate && t.translate * i) || 0
  }
  var r = t.params,
    n = t.maxTranslate() - t.minTranslate(),
    a = t.progress,
    o = t.isBeginning,
    s = t.isEnd,
    l = o,
    h = s
  0 === n
    ? ((a = 0), (o = !0), (s = !0))
    : ((o = (a = (e - t.minTranslate()) / n) <= 0), (s = a >= 1)),
    extend$1(t, { progress: a, isBeginning: o, isEnd: s }),
    (r.watchSlidesProgress || r.watchSlidesVisibility || (r.centeredSlides && r.autoHeight)) &&
      t.updateSlidesProgress(e),
    o && !l && t.emit('reachBeginning toEdge'),
    s && !h && t.emit('reachEnd toEdge'),
    ((l && !o) || (h && !s)) && t.emit('fromEdge'),
    t.emit('progress', a)
}
function updateSlidesClasses() {
  var e,
    t = this,
    i = t.slides,
    r = t.params,
    n = t.$wrapperEl,
    a = t.activeIndex,
    o = t.realIndex,
    s = t.virtual && r.virtual.enabled
  i.removeClass(
    r.slideActiveClass +
      ' ' +
      r.slideNextClass +
      ' ' +
      r.slidePrevClass +
      ' ' +
      r.slideDuplicateActiveClass +
      ' ' +
      r.slideDuplicateNextClass +
      ' ' +
      r.slideDuplicatePrevClass
  ),
    (e = s
      ? t.$wrapperEl.find('.' + r.slideClass + '[data-swiper-slide-index="' + a + '"]')
      : i.eq(a)).addClass(r.slideActiveClass),
    r.loop &&
      (e.hasClass(r.slideDuplicateClass)
        ? n
            .children(
              '.' +
                r.slideClass +
                ':not(.' +
                r.slideDuplicateClass +
                ')[data-swiper-slide-index="' +
                o +
                '"]'
            )
            .addClass(r.slideDuplicateActiveClass)
        : n
            .children(
              '.' +
                r.slideClass +
                '.' +
                r.slideDuplicateClass +
                '[data-swiper-slide-index="' +
                o +
                '"]'
            )
            .addClass(r.slideDuplicateActiveClass))
  var l = e
    .nextAll('.' + r.slideClass)
    .eq(0)
    .addClass(r.slideNextClass)
  r.loop && 0 === l.length && (l = i.eq(0)).addClass(r.slideNextClass)
  var h = e
    .prevAll('.' + r.slideClass)
    .eq(0)
    .addClass(r.slidePrevClass)
  r.loop && 0 === h.length && (h = i.eq(-1)).addClass(r.slidePrevClass),
    r.loop &&
      (l.hasClass(r.slideDuplicateClass)
        ? n
            .children(
              '.' +
                r.slideClass +
                ':not(.' +
                r.slideDuplicateClass +
                ')[data-swiper-slide-index="' +
                l.attr('data-swiper-slide-index') +
                '"]'
            )
            .addClass(r.slideDuplicateNextClass)
        : n
            .children(
              '.' +
                r.slideClass +
                '.' +
                r.slideDuplicateClass +
                '[data-swiper-slide-index="' +
                l.attr('data-swiper-slide-index') +
                '"]'
            )
            .addClass(r.slideDuplicateNextClass),
      h.hasClass(r.slideDuplicateClass)
        ? n
            .children(
              '.' +
                r.slideClass +
                ':not(.' +
                r.slideDuplicateClass +
                ')[data-swiper-slide-index="' +
                h.attr('data-swiper-slide-index') +
                '"]'
            )
            .addClass(r.slideDuplicatePrevClass)
        : n
            .children(
              '.' +
                r.slideClass +
                '.' +
                r.slideDuplicateClass +
                '[data-swiper-slide-index="' +
                h.attr('data-swiper-slide-index') +
                '"]'
            )
            .addClass(r.slideDuplicatePrevClass)),
    t.emitSlidesClasses()
}
function updateActiveIndex(e) {
  var t,
    i = this,
    r = i.rtlTranslate ? i.translate : -i.translate,
    n = i.slidesGrid,
    a = i.snapGrid,
    o = i.params,
    s = i.activeIndex,
    l = i.realIndex,
    h = i.snapIndex,
    u = e
  if (void 0 === u) {
    for (var p = 0; p < n.length; p += 1)
      void 0 !== n[p + 1]
        ? r >= n[p] && r < n[p + 1] - (n[p + 1] - n[p]) / 2
          ? (u = p)
          : r >= n[p] && r < n[p + 1] && (u = p + 1)
        : r >= n[p] && (u = p)
    o.normalizeSlideIndex && (u < 0 || void 0 === u) && (u = 0)
  }
  if (a.indexOf(r) >= 0) t = a.indexOf(r)
  else {
    var c = Math.min(o.slidesPerGroupSkip, u)
    t = c + Math.floor((u - c) / o.slidesPerGroup)
  }
  if ((t >= a.length && (t = a.length - 1), u !== s)) {
    var d = parseInt(i.slides.eq(u).attr('data-swiper-slide-index') || u, 10)
    extend$1(i, { snapIndex: t, realIndex: d, previousIndex: s, activeIndex: u }),
      i.emit('activeIndexChange'),
      i.emit('snapIndexChange'),
      l !== d && i.emit('realIndexChange'),
      (i.initialized || i.params.runCallbacksOnInit) && i.emit('slideChange')
  } else t !== h && ((i.snapIndex = t), i.emit('snapIndexChange'))
}
function updateClickedSlide(e) {
  var t,
    i = this,
    r = i.params,
    n = $(e.target).closest('.' + r.slideClass)[0],
    a = !1
  if (n)
    for (var o = 0; o < i.slides.length; o += 1)
      if (i.slides[o] === n) {
        ;(a = !0), (t = o)
        break
      }
  if (!n || !a) return (i.clickedSlide = void 0), void (i.clickedIndex = void 0)
  ;(i.clickedSlide = n),
    i.virtual && i.params.virtual.enabled
      ? (i.clickedIndex = parseInt($(n).attr('data-swiper-slide-index'), 10))
      : (i.clickedIndex = t),
    r.slideToClickedSlide &&
      void 0 !== i.clickedIndex &&
      i.clickedIndex !== i.activeIndex &&
      i.slideToClickedSlide()
}
var update = {
  updateSize: updateSize,
  updateSlides: updateSlides,
  updateAutoHeight: updateAutoHeight,
  updateSlidesOffset: updateSlidesOffset,
  updateSlidesProgress: updateSlidesProgress,
  updateProgress: updateProgress,
  updateSlidesClasses: updateSlidesClasses,
  updateActiveIndex: updateActiveIndex,
  updateClickedSlide: updateClickedSlide
}
function getSwiperTranslate(e) {
  void 0 === e && (e = this.isHorizontal() ? 'x' : 'y')
  var t = this,
    i = t.params,
    r = t.rtlTranslate,
    n = t.translate,
    a = t.$wrapperEl
  if (i.virtualTranslate) return r ? -n : n
  if (i.cssMode) return n
  var o = getTranslate(a[0], e)
  return r && (o = -o), o || 0
}
function setTranslate(e, t) {
  var i = this,
    r = i.rtlTranslate,
    n = i.params,
    a = i.$wrapperEl,
    o = i.wrapperEl,
    s = i.progress,
    l = 0,
    h = 0
  i.isHorizontal() ? (l = r ? -e : e) : (h = e),
    n.roundLengths && ((l = Math.floor(l)), (h = Math.floor(h))),
    n.cssMode
      ? (o[i.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = i.isHorizontal() ? -l : -h)
      : n.virtualTranslate || a.transform('translate3d(' + l + 'px, ' + h + 'px, 0px)'),
    (i.previousTranslate = i.translate),
    (i.translate = i.isHorizontal() ? l : h)
  var u = i.maxTranslate() - i.minTranslate()
  ;(0 === u ? 0 : (e - i.minTranslate()) / u) !== s && i.updateProgress(e),
    i.emit('setTranslate', i.translate, t)
}
function minTranslate() {
  return -this.snapGrid[0]
}
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1]
}
function translateTo(e, t, i, r, n) {
  void 0 === e && (e = 0),
    void 0 === t && (t = this.params.speed),
    void 0 === i && (i = !0),
    void 0 === r && (r = !0)
  var a = this,
    o = a.params,
    s = a.wrapperEl
  if (a.animating && o.preventInteractionOnTransition) return !1
  var l,
    h = a.minTranslate(),
    u = a.maxTranslate()
  if (((l = r && e > h ? h : r && e < u ? u : e), a.updateProgress(l), o.cssMode)) {
    var p,
      c = a.isHorizontal()
    if (0 === t) s[c ? 'scrollLeft' : 'scrollTop'] = -l
    else if (s.scrollTo)
      s.scrollTo((((p = {})[c ? 'left' : 'top'] = -l), (p.behavior = 'smooth'), p))
    else s[c ? 'scrollLeft' : 'scrollTop'] = -l
    return !0
  }
  return (
    0 === t
      ? (a.setTransition(0),
        a.setTranslate(l),
        i && (a.emit('beforeTransitionStart', t, n), a.emit('transitionEnd')))
      : (a.setTransition(t),
        a.setTranslate(l),
        i && (a.emit('beforeTransitionStart', t, n), a.emit('transitionStart')),
        a.animating ||
          ((a.animating = !0),
          a.onTranslateToWrapperTransitionEnd ||
            (a.onTranslateToWrapperTransitionEnd = function (e) {
              a &&
                !a.destroyed &&
                e.target === this &&
                (a.$wrapperEl[0].removeEventListener(
                  'transitionend',
                  a.onTranslateToWrapperTransitionEnd
                ),
                a.$wrapperEl[0].removeEventListener(
                  'webkitTransitionEnd',
                  a.onTranslateToWrapperTransitionEnd
                ),
                (a.onTranslateToWrapperTransitionEnd = null),
                delete a.onTranslateToWrapperTransitionEnd,
                i && a.emit('transitionEnd'))
            }),
          a.$wrapperEl[0].addEventListener('transitionend', a.onTranslateToWrapperTransitionEnd),
          a.$wrapperEl[0].addEventListener(
            'webkitTransitionEnd',
            a.onTranslateToWrapperTransitionEnd
          ))),
    !0
  )
}
var translate = {
  getTranslate: getSwiperTranslate,
  setTranslate: setTranslate,
  minTranslate: minTranslate,
  maxTranslate: maxTranslate,
  translateTo: translateTo
}
function setTransition(e, t) {
  var i = this
  i.params.cssMode || i.$wrapperEl.transition(e), i.emit('setTransition', e, t)
}
function transitionStart(e, t) {
  void 0 === e && (e = !0)
  var i = this,
    r = i.activeIndex,
    n = i.params,
    a = i.previousIndex
  if (!n.cssMode) {
    n.autoHeight && i.updateAutoHeight()
    var o = t
    if (
      (o || (o = r > a ? 'next' : r < a ? 'prev' : 'reset'),
      i.emit('transitionStart'),
      e && r !== a)
    ) {
      if ('reset' === o) return void i.emit('slideResetTransitionStart')
      i.emit('slideChangeTransitionStart'),
        'next' === o ? i.emit('slideNextTransitionStart') : i.emit('slidePrevTransitionStart')
    }
  }
}
function transitionEnd(e, t) {
  void 0 === e && (e = !0)
  var i = this,
    r = i.activeIndex,
    n = i.previousIndex,
    a = i.params
  if (((i.animating = !1), !a.cssMode)) {
    i.setTransition(0)
    var o = t
    if (
      (o || (o = r > n ? 'next' : r < n ? 'prev' : 'reset'), i.emit('transitionEnd'), e && r !== n)
    ) {
      if ('reset' === o) return void i.emit('slideResetTransitionEnd')
      i.emit('slideChangeTransitionEnd'),
        'next' === o ? i.emit('slideNextTransitionEnd') : i.emit('slidePrevTransitionEnd')
    }
  }
}
var transition = {
  setTransition: setTransition,
  transitionStart: transitionStart,
  transitionEnd: transitionEnd
}
function slideTo(e, t, i, r, n) {
  if (
    (void 0 === e && (e = 0),
    void 0 === t && (t = this.params.speed),
    void 0 === i && (i = !0),
    'number' != typeof e && 'string' != typeof e)
  )
    throw new Error(
      "The 'index' argument cannot have type other than 'number' or 'string'. [" +
        typeof e +
        '] given.'
    )
  if ('string' == typeof e) {
    var a = parseInt(e, 10)
    if (!isFinite(a))
      throw new Error(
        "The passed-in 'index' (string) couldn't be converted to 'number'. [" + e + '] given.'
      )
    e = a
  }
  var o = this,
    s = e
  s < 0 && (s = 0)
  var l = o.params,
    h = o.snapGrid,
    u = o.slidesGrid,
    p = o.previousIndex,
    c = o.activeIndex,
    d = o.rtlTranslate,
    f = o.wrapperEl,
    m = o.enabled
  if ((o.animating && l.preventInteractionOnTransition) || (!m && !r && !n)) return !1
  var g = Math.min(o.params.slidesPerGroupSkip, s),
    y = g + Math.floor((s - g) / o.params.slidesPerGroup)
  y >= h.length && (y = h.length - 1),
    (c || l.initialSlide || 0) === (p || 0) && i && o.emit('beforeSlideChangeStart')
  var v,
    _ = -h[y]
  if ((o.updateProgress(_), l.normalizeSlideIndex))
    for (var x = 0; x < u.length; x += 1) {
      var S = -Math.floor(100 * _),
        b = Math.floor(100 * u[x]),
        T = Math.floor(100 * u[x + 1])
      void 0 !== u[x + 1]
        ? S >= b && S < T - (T - b) / 2
          ? (s = x)
          : S >= b && S < T && (s = x + 1)
        : S >= b && (s = x)
    }
  if (o.initialized && s !== c) {
    if (!o.allowSlideNext && _ < o.translate && _ < o.minTranslate()) return !1
    if (!o.allowSlidePrev && _ > o.translate && _ > o.maxTranslate() && (c || 0) !== s) return !1
  }
  if (
    ((v = s > c ? 'next' : s < c ? 'prev' : 'reset'),
    (d && -_ === o.translate) || (!d && _ === o.translate))
  )
    return (
      o.updateActiveIndex(s),
      l.autoHeight && o.updateAutoHeight(),
      o.updateSlidesClasses(),
      'slide' !== l.effect && o.setTranslate(_),
      'reset' !== v && (o.transitionStart(i, v), o.transitionEnd(i, v)),
      !1
    )
  if (l.cssMode) {
    var A,
      w = o.isHorizontal(),
      M = -_
    if ((d && (M = f.scrollWidth - f.offsetWidth - M), 0 === t))
      f[w ? 'scrollLeft' : 'scrollTop'] = M
    else if (f.scrollTo)
      f.scrollTo((((A = {})[w ? 'left' : 'top'] = M), (A.behavior = 'smooth'), A))
    else f[w ? 'scrollLeft' : 'scrollTop'] = M
    return !0
  }
  return (
    0 === t
      ? (o.setTransition(0),
        o.setTranslate(_),
        o.updateActiveIndex(s),
        o.updateSlidesClasses(),
        o.emit('beforeTransitionStart', t, r),
        o.transitionStart(i, v),
        o.transitionEnd(i, v))
      : (o.setTransition(t),
        o.setTranslate(_),
        o.updateActiveIndex(s),
        o.updateSlidesClasses(),
        o.emit('beforeTransitionStart', t, r),
        o.transitionStart(i, v),
        o.animating ||
          ((o.animating = !0),
          o.onSlideToWrapperTransitionEnd ||
            (o.onSlideToWrapperTransitionEnd = function (e) {
              o &&
                !o.destroyed &&
                e.target === this &&
                (o.$wrapperEl[0].removeEventListener(
                  'transitionend',
                  o.onSlideToWrapperTransitionEnd
                ),
                o.$wrapperEl[0].removeEventListener(
                  'webkitTransitionEnd',
                  o.onSlideToWrapperTransitionEnd
                ),
                (o.onSlideToWrapperTransitionEnd = null),
                delete o.onSlideToWrapperTransitionEnd,
                o.transitionEnd(i, v))
            }),
          o.$wrapperEl[0].addEventListener('transitionend', o.onSlideToWrapperTransitionEnd),
          o.$wrapperEl[0].addEventListener(
            'webkitTransitionEnd',
            o.onSlideToWrapperTransitionEnd
          ))),
    !0
  )
}
function slideToLoop(e, t, i, r) {
  void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === i && (i = !0)
  var n = this,
    a = e
  return n.params.loop && (a += n.loopedSlides), n.slideTo(a, t, i, r)
}
function slideNext(e, t, i) {
  void 0 === e && (e = this.params.speed), void 0 === t && (t = !0)
  var r = this,
    n = r.params,
    a = r.animating
  if (!r.enabled) return r
  var o = r.activeIndex < n.slidesPerGroupSkip ? 1 : n.slidesPerGroup
  if (n.loop) {
    if (a && n.loopPreventsSlide) return !1
    r.loopFix(), (r._clientLeft = r.$wrapperEl[0].clientLeft)
  }
  return r.slideTo(r.activeIndex + o, e, t, i)
}
function slidePrev(e, t, i) {
  void 0 === e && (e = this.params.speed), void 0 === t && (t = !0)
  var r = this,
    n = r.params,
    a = r.animating,
    o = r.snapGrid,
    s = r.slidesGrid,
    l = r.rtlTranslate
  if (!r.enabled) return r
  if (n.loop) {
    if (a && n.loopPreventsSlide) return !1
    r.loopFix(), (r._clientLeft = r.$wrapperEl[0].clientLeft)
  }
  function h(e) {
    return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
  }
  var u = h(l ? r.translate : -r.translate),
    p = o.map(function (e) {
      return h(e)
    })
  o[p.indexOf(u)]
  var c,
    d = o[p.indexOf(u) - 1]
  return (
    void 0 === d &&
      n.cssMode &&
      o.forEach(function (e) {
        !d && u >= e && (d = e)
      }),
    void 0 !== d && (c = s.indexOf(d)) < 0 && (c = r.activeIndex - 1),
    r.slideTo(c, e, t, i)
  )
}
function slideReset(e, t, i) {
  void 0 === e && (e = this.params.speed), void 0 === t && (t = !0)
  return this.slideTo(this.activeIndex, e, t, i)
}
function slideToClosest(e, t, i, r) {
  void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), void 0 === r && (r = 0.5)
  var n = this,
    a = n.activeIndex,
    o = Math.min(n.params.slidesPerGroupSkip, a),
    s = o + Math.floor((a - o) / n.params.slidesPerGroup),
    l = n.rtlTranslate ? n.translate : -n.translate
  if (l >= n.snapGrid[s]) {
    var h = n.snapGrid[s]
    l - h > (n.snapGrid[s + 1] - h) * r && (a += n.params.slidesPerGroup)
  } else {
    var u = n.snapGrid[s - 1]
    l - u <= (n.snapGrid[s] - u) * r && (a -= n.params.slidesPerGroup)
  }
  return (a = Math.max(a, 0)), (a = Math.min(a, n.slidesGrid.length - 1)), n.slideTo(a, e, t, i)
}
function slideToClickedSlide() {
  var e,
    t = this,
    i = t.params,
    r = t.$wrapperEl,
    n = 'auto' === i.slidesPerView ? t.slidesPerViewDynamic() : i.slidesPerView,
    a = t.clickedIndex
  if (i.loop) {
    if (t.animating) return
    ;(e = parseInt($(t.clickedSlide).attr('data-swiper-slide-index'), 10)),
      i.centeredSlides
        ? a < t.loopedSlides - n / 2 || a > t.slides.length - t.loopedSlides + n / 2
          ? (t.loopFix(),
            (a = r
              .children(
                '.' +
                  i.slideClass +
                  '[data-swiper-slide-index="' +
                  e +
                  '"]:not(.' +
                  i.slideDuplicateClass +
                  ')'
              )
              .eq(0)
              .index()),
            nextTick(function () {
              t.slideTo(a)
            }))
          : t.slideTo(a)
        : a > t.slides.length - n
        ? (t.loopFix(),
          (a = r
            .children(
              '.' +
                i.slideClass +
                '[data-swiper-slide-index="' +
                e +
                '"]:not(.' +
                i.slideDuplicateClass +
                ')'
            )
            .eq(0)
            .index()),
          nextTick(function () {
            t.slideTo(a)
          }))
        : t.slideTo(a)
  } else t.slideTo(a)
}
var slide = {
  slideTo: slideTo,
  slideToLoop: slideToLoop,
  slideNext: slideNext,
  slidePrev: slidePrev,
  slideReset: slideReset,
  slideToClosest: slideToClosest,
  slideToClickedSlide: slideToClickedSlide
}
function loopCreate() {
  var e = this,
    t = getDocument(),
    i = e.params,
    r = e.$wrapperEl
  r.children('.' + i.slideClass + '.' + i.slideDuplicateClass).remove()
  var n = r.children('.' + i.slideClass)
  if (i.loopFillGroupWithBlank) {
    var a = i.slidesPerGroup - (n.length % i.slidesPerGroup)
    if (a !== i.slidesPerGroup) {
      for (var o = 0; o < a; o += 1) {
        var s = $(t.createElement('div')).addClass(i.slideClass + ' ' + i.slideBlankClass)
        r.append(s)
      }
      n = r.children('.' + i.slideClass)
    }
  }
  'auto' !== i.slidesPerView || i.loopedSlides || (i.loopedSlides = n.length),
    (e.loopedSlides = Math.ceil(parseFloat(i.loopedSlides || i.slidesPerView, 10))),
    (e.loopedSlides += i.loopAdditionalSlides),
    e.loopedSlides > n.length && (e.loopedSlides = n.length)
  var l = [],
    h = []
  n.each(function (t, i) {
    var r = $(t)
    i < e.loopedSlides && h.push(t),
      i < n.length && i >= n.length - e.loopedSlides && l.push(t),
      r.attr('data-swiper-slide-index', i)
  })
  for (var u = 0; u < h.length; u += 1)
    r.append($(h[u].cloneNode(!0)).addClass(i.slideDuplicateClass))
  for (var p = l.length - 1; p >= 0; p -= 1)
    r.prepend($(l[p].cloneNode(!0)).addClass(i.slideDuplicateClass))
}
function loopFix() {
  var e = this
  e.emit('beforeLoopFix')
  var t,
    i = e.activeIndex,
    r = e.slides,
    n = e.loopedSlides,
    a = e.allowSlidePrev,
    o = e.allowSlideNext,
    s = e.snapGrid,
    l = e.rtlTranslate
  ;(e.allowSlidePrev = !0), (e.allowSlideNext = !0)
  var h = -s[i] - e.getTranslate()
  if (i < n)
    (t = r.length - 3 * n + i),
      (t += n),
      e.slideTo(t, 0, !1, !0) && 0 !== h && e.setTranslate((l ? -e.translate : e.translate) - h)
  else if (i >= r.length - n) {
    ;(t = -r.length + i + n),
      (t += n),
      e.slideTo(t, 0, !1, !0) && 0 !== h && e.setTranslate((l ? -e.translate : e.translate) - h)
  }
  ;(e.allowSlidePrev = a), (e.allowSlideNext = o), e.emit('loopFix')
}
function loopDestroy() {
  var e = this,
    t = e.$wrapperEl,
    i = e.params,
    r = e.slides
  t
    .children(
      '.' +
        i.slideClass +
        '.' +
        i.slideDuplicateClass +
        ',.' +
        i.slideClass +
        '.' +
        i.slideBlankClass
    )
    .remove(),
    r.removeAttr('data-swiper-slide-index')
}
var loop = { loopCreate: loopCreate, loopFix: loopFix, loopDestroy: loopDestroy }
function setGrabCursor(e) {
  var t = this
  if (
    !(
      t.support.touch ||
      !t.params.simulateTouch ||
      (t.params.watchOverflow && t.isLocked) ||
      t.params.cssMode
    )
  ) {
    var i = t.el
    ;(i.style.cursor = 'move'),
      (i.style.cursor = e ? '-webkit-grabbing' : '-webkit-grab'),
      (i.style.cursor = e ? '-moz-grabbin' : '-moz-grab'),
      (i.style.cursor = e ? 'grabbing' : 'grab')
  }
}
function unsetGrabCursor() {
  var e = this
  e.support.touch ||
    (e.params.watchOverflow && e.isLocked) ||
    e.params.cssMode ||
    (e.el.style.cursor = '')
}
var grabCursor = { setGrabCursor: setGrabCursor, unsetGrabCursor: unsetGrabCursor }
function appendSlide(e) {
  var t = this,
    i = t.$wrapperEl,
    r = t.params
  if ((r.loop && t.loopDestroy(), 'object' == typeof e && 'length' in e))
    for (var n = 0; n < e.length; n += 1) e[n] && i.append(e[n])
  else i.append(e)
  r.loop && t.loopCreate(), (r.observer && t.support.observer) || t.update()
}
function prependSlide(e) {
  var t = this,
    i = t.params,
    r = t.$wrapperEl,
    n = t.activeIndex
  i.loop && t.loopDestroy()
  var a = n + 1
  if ('object' == typeof e && 'length' in e) {
    for (var o = 0; o < e.length; o += 1) e[o] && r.prepend(e[o])
    a = n + e.length
  } else r.prepend(e)
  i.loop && t.loopCreate(), (i.observer && t.support.observer) || t.update(), t.slideTo(a, 0, !1)
}
function addSlide(e, t) {
  var i = this,
    r = i.$wrapperEl,
    n = i.params,
    a = i.activeIndex
  n.loop && ((a -= i.loopedSlides), i.loopDestroy(), (i.slides = r.children('.' + n.slideClass)))
  var o = i.slides.length
  if (e <= 0) i.prependSlide(t)
  else if (e >= o) i.appendSlide(t)
  else {
    for (var s = a > e ? a + 1 : a, l = [], h = o - 1; h >= e; h -= 1) {
      var u = i.slides.eq(h)
      u.remove(), l.unshift(u)
    }
    if ('object' == typeof t && 'length' in t) {
      for (var p = 0; p < t.length; p += 1) t[p] && r.append(t[p])
      s = a > e ? a + t.length : a
    } else r.append(t)
    for (var c = 0; c < l.length; c += 1) r.append(l[c])
    n.loop && i.loopCreate(),
      (n.observer && i.support.observer) || i.update(),
      n.loop ? i.slideTo(s + i.loopedSlides, 0, !1) : i.slideTo(s, 0, !1)
  }
}
function removeSlide(e) {
  var t = this,
    i = t.params,
    r = t.$wrapperEl,
    n = t.activeIndex
  i.loop && ((n -= t.loopedSlides), t.loopDestroy(), (t.slides = r.children('.' + i.slideClass)))
  var a,
    o = n
  if ('object' == typeof e && 'length' in e) {
    for (var s = 0; s < e.length; s += 1)
      (a = e[s]), t.slides[a] && t.slides.eq(a).remove(), a < o && (o -= 1)
    o = Math.max(o, 0)
  } else (a = e), t.slides[a] && t.slides.eq(a).remove(), a < o && (o -= 1), (o = Math.max(o, 0))
  i.loop && t.loopCreate(),
    (i.observer && t.support.observer) || t.update(),
    i.loop ? t.slideTo(o + t.loopedSlides, 0, !1) : t.slideTo(o, 0, !1)
}
function removeAllSlides() {
  for (var e = [], t = 0; t < this.slides.length; t += 1) e.push(t)
  this.removeSlide(e)
}
var manipulation = {
  appendSlide: appendSlide,
  prependSlide: prependSlide,
  addSlide: addSlide,
  removeSlide: removeSlide,
  removeAllSlides: removeAllSlides
}
function onTouchStart(e) {
  var t = this,
    i = getDocument(),
    r = getWindow(),
    n = t.touchEventsData,
    a = t.params,
    o = t.touches
  if (t.enabled && (!t.animating || !a.preventInteractionOnTransition)) {
    var s = e
    s.originalEvent && (s = s.originalEvent)
    var l = $(s.target)
    if ('wrapper' !== a.touchEventsTarget || l.closest(t.wrapperEl).length)
      if (
        ((n.isTouchEvent = 'touchstart' === s.type),
        n.isTouchEvent || !('which' in s) || 3 !== s.which)
      )
        if (!(!n.isTouchEvent && 'button' in s && s.button > 0))
          if (!n.isTouched || !n.isMoved)
            if (
              (!!a.noSwipingClass &&
                '' !== a.noSwipingClass &&
                s.target &&
                s.target.shadowRoot &&
                e.path &&
                e.path[0] &&
                (l = $(e.path[0])),
              a.noSwiping &&
                l.closest(a.noSwipingSelector ? a.noSwipingSelector : '.' + a.noSwipingClass)[0])
            )
              t.allowClick = !0
            else if (!a.swipeHandler || l.closest(a.swipeHandler)[0]) {
              ;(o.currentX = 'touchstart' === s.type ? s.targetTouches[0].pageX : s.pageX),
                (o.currentY = 'touchstart' === s.type ? s.targetTouches[0].pageY : s.pageY)
              var h = o.currentX,
                u = o.currentY,
                p = a.edgeSwipeDetection || a.iOSEdgeSwipeDetection,
                c = a.edgeSwipeThreshold || a.iOSEdgeSwipeThreshold
              if (p && (h <= c || h >= r.innerWidth - c)) {
                if ('prevent' !== p) return
                e.preventDefault()
              }
              if (
                (extend$1(n, {
                  isTouched: !0,
                  isMoved: !1,
                  allowTouchCallbacks: !0,
                  isScrolling: void 0,
                  startMoving: void 0
                }),
                (o.startX = h),
                (o.startY = u),
                (n.touchStartTime = now()),
                (t.allowClick = !0),
                t.updateSize(),
                (t.swipeDirection = void 0),
                a.threshold > 0 && (n.allowThresholdMove = !1),
                'touchstart' !== s.type)
              ) {
                var d = !0
                l.is(n.formElements) && (d = !1),
                  i.activeElement &&
                    $(i.activeElement).is(n.formElements) &&
                    i.activeElement !== l[0] &&
                    i.activeElement.blur()
                var f = d && t.allowTouchMove && a.touchStartPreventDefault
                ;(!a.touchStartForcePreventDefault && !f) ||
                  l[0].isContentEditable ||
                  s.preventDefault()
              }
              t.emit('touchStart', s)
            }
  }
}
function onTouchMove(e) {
  var t = getDocument(),
    i = this,
    r = i.touchEventsData,
    n = i.params,
    a = i.touches,
    o = i.rtlTranslate
  if (i.enabled) {
    var s = e
    if ((s.originalEvent && (s = s.originalEvent), r.isTouched)) {
      if (!r.isTouchEvent || 'touchmove' === s.type) {
        var l =
            'touchmove' === s.type &&
            s.targetTouches &&
            (s.targetTouches[0] || s.changedTouches[0]),
          h = 'touchmove' === s.type ? l.pageX : s.pageX,
          u = 'touchmove' === s.type ? l.pageY : s.pageY
        if (s.preventedByNestedSwiper) return (a.startX = h), void (a.startY = u)
        if (!i.allowTouchMove)
          return (
            (i.allowClick = !1),
            void (
              r.isTouched &&
              (extend$1(a, { startX: h, startY: u, currentX: h, currentY: u }),
              (r.touchStartTime = now()))
            )
          )
        if (r.isTouchEvent && n.touchReleaseOnEdges && !n.loop)
          if (i.isVertical()) {
            if (
              (u < a.startY && i.translate <= i.maxTranslate()) ||
              (u > a.startY && i.translate >= i.minTranslate())
            )
              return (r.isTouched = !1), void (r.isMoved = !1)
          } else if (
            (h < a.startX && i.translate <= i.maxTranslate()) ||
            (h > a.startX && i.translate >= i.minTranslate())
          )
            return
        if (
          r.isTouchEvent &&
          t.activeElement &&
          s.target === t.activeElement &&
          $(s.target).is(r.formElements)
        )
          return (r.isMoved = !0), void (i.allowClick = !1)
        if (
          (r.allowTouchCallbacks && i.emit('touchMove', s),
          !(s.targetTouches && s.targetTouches.length > 1))
        ) {
          ;(a.currentX = h), (a.currentY = u)
          var p = a.currentX - a.startX,
            c = a.currentY - a.startY
          if (
            !(i.params.threshold && Math.sqrt(Math.pow(p, 2) + Math.pow(c, 2)) < i.params.threshold)
          ) {
            var d
            if (void 0 === r.isScrolling)
              (i.isHorizontal() && a.currentY === a.startY) ||
              (i.isVertical() && a.currentX === a.startX)
                ? (r.isScrolling = !1)
                : p * p + c * c >= 25 &&
                  ((d = (180 * Math.atan2(Math.abs(c), Math.abs(p))) / Math.PI),
                  (r.isScrolling = i.isHorizontal() ? d > n.touchAngle : 90 - d > n.touchAngle))
            if (
              (r.isScrolling && i.emit('touchMoveOpposite', s),
              void 0 === r.startMoving &&
                ((a.currentX === a.startX && a.currentY === a.startY) || (r.startMoving = !0)),
              r.isScrolling)
            )
              r.isTouched = !1
            else if (r.startMoving) {
              ;(i.allowClick = !1),
                !n.cssMode && s.cancelable && s.preventDefault(),
                n.touchMoveStopPropagation && !n.nested && s.stopPropagation(),
                r.isMoved ||
                  (n.loop && i.loopFix(),
                  (r.startTranslate = i.getTranslate()),
                  i.setTransition(0),
                  i.animating && i.$wrapperEl.trigger('webkitTransitionEnd transitionend'),
                  (r.allowMomentumBounce = !1),
                  !n.grabCursor ||
                    (!0 !== i.allowSlideNext && !0 !== i.allowSlidePrev) ||
                    i.setGrabCursor(!0),
                  i.emit('sliderFirstMove', s)),
                i.emit('sliderMove', s),
                (r.isMoved = !0)
              var f = i.isHorizontal() ? p : c
              ;(a.diff = f),
                (f *= n.touchRatio),
                o && (f = -f),
                (i.swipeDirection = f > 0 ? 'prev' : 'next'),
                (r.currentTranslate = f + r.startTranslate)
              var m = !0,
                g = n.resistanceRatio
              if (
                (n.touchReleaseOnEdges && (g = 0),
                f > 0 && r.currentTranslate > i.minTranslate()
                  ? ((m = !1),
                    n.resistance &&
                      (r.currentTranslate =
                        i.minTranslate() -
                        1 +
                        Math.pow(-i.minTranslate() + r.startTranslate + f, g)))
                  : f < 0 &&
                    r.currentTranslate < i.maxTranslate() &&
                    ((m = !1),
                    n.resistance &&
                      (r.currentTranslate =
                        i.maxTranslate() +
                        1 -
                        Math.pow(i.maxTranslate() - r.startTranslate - f, g))),
                m && (s.preventedByNestedSwiper = !0),
                !i.allowSlideNext &&
                  'next' === i.swipeDirection &&
                  r.currentTranslate < r.startTranslate &&
                  (r.currentTranslate = r.startTranslate),
                !i.allowSlidePrev &&
                  'prev' === i.swipeDirection &&
                  r.currentTranslate > r.startTranslate &&
                  (r.currentTranslate = r.startTranslate),
                i.allowSlidePrev || i.allowSlideNext || (r.currentTranslate = r.startTranslate),
                n.threshold > 0)
              ) {
                if (!(Math.abs(f) > n.threshold || r.allowThresholdMove))
                  return void (r.currentTranslate = r.startTranslate)
                if (!r.allowThresholdMove)
                  return (
                    (r.allowThresholdMove = !0),
                    (a.startX = a.currentX),
                    (a.startY = a.currentY),
                    (r.currentTranslate = r.startTranslate),
                    void (a.diff = i.isHorizontal() ? a.currentX - a.startX : a.currentY - a.startY)
                  )
              }
              n.followFinger &&
                !n.cssMode &&
                ((n.freeMode || n.watchSlidesProgress || n.watchSlidesVisibility) &&
                  (i.updateActiveIndex(), i.updateSlidesClasses()),
                n.freeMode &&
                  (0 === r.velocities.length &&
                    r.velocities.push({
                      position: a[i.isHorizontal() ? 'startX' : 'startY'],
                      time: r.touchStartTime
                    }),
                  r.velocities.push({
                    position: a[i.isHorizontal() ? 'currentX' : 'currentY'],
                    time: now()
                  })),
                i.updateProgress(r.currentTranslate),
                i.setTranslate(r.currentTranslate))
            }
          }
        }
      }
    } else r.startMoving && r.isScrolling && i.emit('touchMoveOpposite', s)
  }
}
function onTouchEnd(e) {
  var t = this,
    i = t.touchEventsData,
    r = t.params,
    n = t.touches,
    a = t.rtlTranslate,
    o = t.$wrapperEl,
    s = t.slidesGrid,
    l = t.snapGrid
  if (t.enabled) {
    var h = e
    if (
      (h.originalEvent && (h = h.originalEvent),
      i.allowTouchCallbacks && t.emit('touchEnd', h),
      (i.allowTouchCallbacks = !1),
      !i.isTouched)
    )
      return (
        i.isMoved && r.grabCursor && t.setGrabCursor(!1),
        (i.isMoved = !1),
        void (i.startMoving = !1)
      )
    r.grabCursor &&
      i.isMoved &&
      i.isTouched &&
      (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) &&
      t.setGrabCursor(!1)
    var u,
      p = now(),
      c = p - i.touchStartTime
    if (
      (t.allowClick &&
        (t.updateClickedSlide(h),
        t.emit('tap click', h),
        c < 300 && p - i.lastClickTime < 300 && t.emit('doubleTap doubleClick', h)),
      (i.lastClickTime = now()),
      nextTick(function () {
        t.destroyed || (t.allowClick = !0)
      }),
      !i.isTouched ||
        !i.isMoved ||
        !t.swipeDirection ||
        0 === n.diff ||
        i.currentTranslate === i.startTranslate)
    )
      return (i.isTouched = !1), (i.isMoved = !1), void (i.startMoving = !1)
    if (
      ((i.isTouched = !1),
      (i.isMoved = !1),
      (i.startMoving = !1),
      (u = r.followFinger ? (a ? t.translate : -t.translate) : -i.currentTranslate),
      !r.cssMode)
    )
      if (r.freeMode) {
        if (u < -t.minTranslate()) return void t.slideTo(t.activeIndex)
        if (u > -t.maxTranslate())
          return void (t.slides.length < l.length
            ? t.slideTo(l.length - 1)
            : t.slideTo(t.slides.length - 1))
        if (r.freeModeMomentum) {
          if (i.velocities.length > 1) {
            var d = i.velocities.pop(),
              f = i.velocities.pop(),
              m = d.position - f.position,
              g = d.time - f.time
            ;(t.velocity = m / g),
              (t.velocity /= 2),
              Math.abs(t.velocity) < r.freeModeMinimumVelocity && (t.velocity = 0),
              (g > 150 || now() - d.time > 300) && (t.velocity = 0)
          } else t.velocity = 0
          ;(t.velocity *= r.freeModeMomentumVelocityRatio), (i.velocities.length = 0)
          var y = 1e3 * r.freeModeMomentumRatio,
            v = t.velocity * y,
            _ = t.translate + v
          a && (_ = -_)
          var x,
            S,
            b = !1,
            T = 20 * Math.abs(t.velocity) * r.freeModeMomentumBounceRatio
          if (_ < t.maxTranslate())
            r.freeModeMomentumBounce
              ? (_ + t.maxTranslate() < -T && (_ = t.maxTranslate() - T),
                (x = t.maxTranslate()),
                (b = !0),
                (i.allowMomentumBounce = !0))
              : (_ = t.maxTranslate()),
              r.loop && r.centeredSlides && (S = !0)
          else if (_ > t.minTranslate())
            r.freeModeMomentumBounce
              ? (_ - t.minTranslate() > T && (_ = t.minTranslate() + T),
                (x = t.minTranslate()),
                (b = !0),
                (i.allowMomentumBounce = !0))
              : (_ = t.minTranslate()),
              r.loop && r.centeredSlides && (S = !0)
          else if (r.freeModeSticky) {
            for (var A, w = 0; w < l.length; w += 1)
              if (l[w] > -_) {
                A = w
                break
              }
            _ = -(_ =
              Math.abs(l[A] - _) < Math.abs(l[A - 1] - _) || 'next' === t.swipeDirection
                ? l[A]
                : l[A - 1])
          }
          if (
            (S &&
              t.once('transitionEnd', function () {
                t.loopFix()
              }),
            0 !== t.velocity)
          ) {
            if (
              ((y = a
                ? Math.abs((-_ - t.translate) / t.velocity)
                : Math.abs((_ - t.translate) / t.velocity)),
              r.freeModeSticky)
            ) {
              var M = Math.abs((a ? -_ : _) - t.translate),
                C = t.slidesSizesGrid[t.activeIndex]
              y = M < C ? r.speed : M < 2 * C ? 1.5 * r.speed : 2.5 * r.speed
            }
          } else if (r.freeModeSticky) return void t.slideToClosest()
          r.freeModeMomentumBounce && b
            ? (t.updateProgress(x),
              t.setTransition(y),
              t.setTranslate(_),
              t.transitionStart(!0, t.swipeDirection),
              (t.animating = !0),
              o.transitionEnd(function () {
                t &&
                  !t.destroyed &&
                  i.allowMomentumBounce &&
                  (t.emit('momentumBounce'),
                  t.setTransition(r.speed),
                  setTimeout(function () {
                    t.setTranslate(x),
                      o.transitionEnd(function () {
                        t && !t.destroyed && t.transitionEnd()
                      })
                  }, 0))
              }))
            : t.velocity
            ? (t.updateProgress(_),
              t.setTransition(y),
              t.setTranslate(_),
              t.transitionStart(!0, t.swipeDirection),
              t.animating ||
                ((t.animating = !0),
                o.transitionEnd(function () {
                  t && !t.destroyed && t.transitionEnd()
                })))
            : (t.emit('_freeModeNoMomentumRelease'), t.updateProgress(_)),
            t.updateActiveIndex(),
            t.updateSlidesClasses()
        } else {
          if (r.freeModeSticky) return void t.slideToClosest()
          r.freeMode && t.emit('_freeModeNoMomentumRelease')
        }
        ;(!r.freeModeMomentum || c >= r.longSwipesMs) &&
          (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses())
      } else {
        for (
          var P = 0, E = t.slidesSizesGrid[0], I = 0;
          I < s.length;
          I += I < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup
        ) {
          var D = I < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup
          void 0 !== s[I + D]
            ? u >= s[I] && u < s[I + D] && ((P = I), (E = s[I + D] - s[I]))
            : u >= s[I] && ((P = I), (E = s[s.length - 1] - s[s.length - 2]))
        }
        var L = (u - s[P]) / E,
          R = P < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup
        if (c > r.longSwipesMs) {
          if (!r.longSwipes) return void t.slideTo(t.activeIndex)
          'next' === t.swipeDirection && (L >= r.longSwipesRatio ? t.slideTo(P + R) : t.slideTo(P)),
            'prev' === t.swipeDirection &&
              (L > 1 - r.longSwipesRatio ? t.slideTo(P + R) : t.slideTo(P))
        } else {
          if (!r.shortSwipes) return void t.slideTo(t.activeIndex)
          t.navigation && (h.target === t.navigation.nextEl || h.target === t.navigation.prevEl)
            ? h.target === t.navigation.nextEl
              ? t.slideTo(P + R)
              : t.slideTo(P)
            : ('next' === t.swipeDirection && t.slideTo(P + R),
              'prev' === t.swipeDirection && t.slideTo(P))
        }
      }
  }
}
function onResize() {
  var e = this,
    t = e.params,
    i = e.el
  if (!i || 0 !== i.offsetWidth) {
    t.breakpoints && e.setBreakpoint()
    var r = e.allowSlideNext,
      n = e.allowSlidePrev,
      a = e.snapGrid
    ;(e.allowSlideNext = !0),
      (e.allowSlidePrev = !0),
      e.updateSize(),
      e.updateSlides(),
      e.updateSlidesClasses(),
      ('auto' === t.slidesPerView || t.slidesPerView > 1) &&
      e.isEnd &&
      !e.isBeginning &&
      !e.params.centeredSlides
        ? e.slideTo(e.slides.length - 1, 0, !1, !0)
        : e.slideTo(e.activeIndex, 0, !1, !0),
      e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(),
      (e.allowSlidePrev = n),
      (e.allowSlideNext = r),
      e.params.watchOverflow && a !== e.snapGrid && e.checkOverflow()
  }
}
function onClick(e) {
  var t = this
  t.enabled &&
    (t.allowClick ||
      (t.params.preventClicks && e.preventDefault(),
      t.params.preventClicksPropagation &&
        t.animating &&
        (e.stopPropagation(), e.stopImmediatePropagation())))
}
function onScroll() {
  var e = this,
    t = e.wrapperEl,
    i = e.rtlTranslate
  if (e.enabled) {
    ;(e.previousTranslate = e.translate),
      e.isHorizontal()
        ? (e.translate = i ? t.scrollWidth - t.offsetWidth - t.scrollLeft : -t.scrollLeft)
        : (e.translate = -t.scrollTop),
      -0 === e.translate && (e.translate = 0),
      e.updateActiveIndex(),
      e.updateSlidesClasses()
    var r = e.maxTranslate() - e.minTranslate()
    ;(0 === r ? 0 : (e.translate - e.minTranslate()) / r) !== e.progress &&
      e.updateProgress(i ? -e.translate : e.translate),
      e.emit('setTranslate', e.translate, !1)
  }
}
var dummyEventAttached = !1
function dummyEventListener() {}
function attachEvents() {
  var e = this,
    t = getDocument(),
    i = e.params,
    r = e.touchEvents,
    n = e.el,
    a = e.wrapperEl,
    o = e.device,
    s = e.support
  ;(e.onTouchStart = onTouchStart.bind(e)),
    (e.onTouchMove = onTouchMove.bind(e)),
    (e.onTouchEnd = onTouchEnd.bind(e)),
    i.cssMode && (e.onScroll = onScroll.bind(e)),
    (e.onClick = onClick.bind(e))
  var l = !!i.nested
  if (!s.touch && s.pointerEvents)
    n.addEventListener(r.start, e.onTouchStart, !1),
      t.addEventListener(r.move, e.onTouchMove, l),
      t.addEventListener(r.end, e.onTouchEnd, !1)
  else {
    if (s.touch) {
      var h = !('touchstart' !== r.start || !s.passiveListener || !i.passiveListeners) && {
        passive: !0,
        capture: !1
      }
      n.addEventListener(r.start, e.onTouchStart, h),
        n.addEventListener(
          r.move,
          e.onTouchMove,
          s.passiveListener ? { passive: !1, capture: l } : l
        ),
        n.addEventListener(r.end, e.onTouchEnd, h),
        r.cancel && n.addEventListener(r.cancel, e.onTouchEnd, h),
        dummyEventAttached ||
          (t.addEventListener('touchstart', dummyEventListener), (dummyEventAttached = !0))
    }
    ;((i.simulateTouch && !o.ios && !o.android) || (i.simulateTouch && !s.touch && o.ios)) &&
      (n.addEventListener('mousedown', e.onTouchStart, !1),
      t.addEventListener('mousemove', e.onTouchMove, l),
      t.addEventListener('mouseup', e.onTouchEnd, !1))
  }
  ;(i.preventClicks || i.preventClicksPropagation) && n.addEventListener('click', e.onClick, !0),
    i.cssMode && a.addEventListener('scroll', e.onScroll),
    i.updateOnWindowResize
      ? e.on(
          o.ios || o.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate',
          onResize,
          !0
        )
      : e.on('observerUpdate', onResize, !0)
}
function detachEvents() {
  var e = this,
    t = getDocument(),
    i = e.params,
    r = e.touchEvents,
    n = e.el,
    a = e.wrapperEl,
    o = e.device,
    s = e.support,
    l = !!i.nested
  if (!s.touch && s.pointerEvents)
    n.removeEventListener(r.start, e.onTouchStart, !1),
      t.removeEventListener(r.move, e.onTouchMove, l),
      t.removeEventListener(r.end, e.onTouchEnd, !1)
  else {
    if (s.touch) {
      var h = !('onTouchStart' !== r.start || !s.passiveListener || !i.passiveListeners) && {
        passive: !0,
        capture: !1
      }
      n.removeEventListener(r.start, e.onTouchStart, h),
        n.removeEventListener(r.move, e.onTouchMove, l),
        n.removeEventListener(r.end, e.onTouchEnd, h),
        r.cancel && n.removeEventListener(r.cancel, e.onTouchEnd, h)
    }
    ;((i.simulateTouch && !o.ios && !o.android) || (i.simulateTouch && !s.touch && o.ios)) &&
      (n.removeEventListener('mousedown', e.onTouchStart, !1),
      t.removeEventListener('mousemove', e.onTouchMove, l),
      t.removeEventListener('mouseup', e.onTouchEnd, !1))
  }
  ;(i.preventClicks || i.preventClicksPropagation) && n.removeEventListener('click', e.onClick, !0),
    i.cssMode && a.removeEventListener('scroll', e.onScroll),
    e.off(
      o.ios || o.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate',
      onResize
    )
}
var events = { attachEvents: attachEvents, detachEvents: detachEvents }
function setBreakpoint() {
  var e = this,
    t = e.activeIndex,
    i = e.initialized,
    r = e.loopedSlides,
    n = void 0 === r ? 0 : r,
    a = e.params,
    o = e.$el,
    s = a.breakpoints
  if (s && (!s || 0 !== Object.keys(s).length)) {
    var l = e.getBreakpoint(s, e.params.breakpointsBase, e.el)
    if (l && e.currentBreakpoint !== l) {
      var h = l in s ? s[l] : void 0
      h &&
        [
          'slidesPerView',
          'spaceBetween',
          'slidesPerGroup',
          'slidesPerGroupSkip',
          'slidesPerColumn'
        ].forEach(function (e) {
          var t = h[e]
          void 0 !== t &&
            (h[e] =
              'slidesPerView' !== e || ('AUTO' !== t && 'auto' !== t)
                ? 'slidesPerView' === e
                  ? parseFloat(t)
                  : parseInt(t, 10)
                : 'auto')
        })
      var u = h || e.originalParams,
        p = a.slidesPerColumn > 1,
        c = u.slidesPerColumn > 1,
        d = a.enabled
      p && !c
        ? (o.removeClass(
            a.containerModifierClass + 'multirow ' + a.containerModifierClass + 'multirow-column'
          ),
          e.emitContainerClasses())
        : !p &&
          c &&
          (o.addClass(a.containerModifierClass + 'multirow'),
          'column' === u.slidesPerColumnFill &&
            o.addClass(a.containerModifierClass + 'multirow-column'),
          e.emitContainerClasses())
      var f = u.direction && u.direction !== a.direction,
        m = a.loop && (u.slidesPerView !== a.slidesPerView || f)
      f && i && e.changeDirection(), extend$1(e.params, u)
      var g = e.params.enabled
      extend$1(e, {
        allowTouchMove: e.params.allowTouchMove,
        allowSlideNext: e.params.allowSlideNext,
        allowSlidePrev: e.params.allowSlidePrev
      }),
        d && !g ? e.disable() : !d && g && e.enable(),
        (e.currentBreakpoint = l),
        e.emit('_beforeBreakpoint', u),
        m &&
          i &&
          (e.loopDestroy(),
          e.loopCreate(),
          e.updateSlides(),
          e.slideTo(t - n + e.loopedSlides, 0, !1)),
        e.emit('breakpoint', u)
    }
  }
}
function getBreakpoint(e, t, i) {
  if ((void 0 === t && (t = 'window'), e && ('container' !== t || i))) {
    var r = !1,
      n = getWindow(),
      a = 'window' === t ? n.innerWidth : i.clientWidth,
      o = 'window' === t ? n.innerHeight : i.clientHeight,
      s = Object.keys(e).map(function (e) {
        if ('string' == typeof e && 0 === e.indexOf('@')) {
          var t = parseFloat(e.substr(1))
          return { value: o * t, point: e }
        }
        return { value: e, point: e }
      })
    s.sort(function (e, t) {
      return parseInt(e.value, 10) - parseInt(t.value, 10)
    })
    for (var l = 0; l < s.length; l += 1) {
      var h = s[l],
        u = h.point
      h.value <= a && (r = u)
    }
    return r || 'max'
  }
}
var breakpoints = { setBreakpoint: setBreakpoint, getBreakpoint: getBreakpoint }
function prepareClasses(e, t) {
  var i = []
  return (
    e.forEach(function (e) {
      'object' == typeof e
        ? Object.keys(e).forEach(function (r) {
            e[r] && i.push(t + r)
          })
        : 'string' == typeof e && i.push(t + e)
    }),
    i
  )
}
function addClasses() {
  var e = this,
    t = e.classNames,
    i = e.params,
    r = e.rtl,
    n = e.$el,
    a = e.device,
    o = e.support,
    s = prepareClasses(
      [
        'initialized',
        i.direction,
        { 'pointer-events': o.pointerEvents && !o.touch },
        { 'free-mode': i.freeMode },
        { autoheight: i.autoHeight },
        { rtl: r },
        { multirow: i.slidesPerColumn > 1 },
        { 'multirow-column': i.slidesPerColumn > 1 && 'column' === i.slidesPerColumnFill },
        { android: a.android },
        { ios: a.ios },
        { 'css-mode': i.cssMode }
      ],
      i.containerModifierClass
    )
  t.push.apply(t, s), n.addClass([].concat(t).join(' ')), e.emitContainerClasses()
}
function removeClasses() {
  var e = this,
    t = e.$el,
    i = e.classNames
  t.removeClass(i.join(' ')), e.emitContainerClasses()
}
var classes = { addClasses: addClasses, removeClasses: removeClasses }
function loadImage(e, t, i, r, n, a) {
  var o,
    s = getWindow()
  function l() {
    a && a()
  }
  $(e).parent('picture')[0] || (e.complete && n)
    ? l()
    : t
    ? (((o = new s.Image()).onload = l),
      (o.onerror = l),
      r && (o.sizes = r),
      i && (o.srcset = i),
      t && (o.src = t))
    : l()
}
function preloadImages() {
  var e = this
  function t() {
    null != e &&
      e &&
      !e.destroyed &&
      (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1),
      e.imagesLoaded === e.imagesToLoad.length &&
        (e.params.updateOnImagesReady && e.update(), e.emit('imagesReady')))
  }
  e.imagesToLoad = e.$el.find('img')
  for (var i = 0; i < e.imagesToLoad.length; i += 1) {
    var r = e.imagesToLoad[i]
    e.loadImage(
      r,
      r.currentSrc || r.getAttribute('src'),
      r.srcset || r.getAttribute('srcset'),
      r.sizes || r.getAttribute('sizes'),
      !0,
      t
    )
  }
}
var images = { loadImage: loadImage, preloadImages: preloadImages }
function checkOverflow() {
  var e = this,
    t = e.params,
    i = e.isLocked,
    r =
      e.slides.length > 0 &&
      t.slidesOffsetBefore +
        t.spaceBetween * (e.slides.length - 1) +
        e.slides[0].offsetWidth * e.slides.length
  t.slidesOffsetBefore && t.slidesOffsetAfter && r
    ? (e.isLocked = r <= e.size)
    : (e.isLocked = 1 === e.snapGrid.length),
    (e.allowSlideNext = !e.isLocked),
    (e.allowSlidePrev = !e.isLocked),
    i !== e.isLocked && e.emit(e.isLocked ? 'lock' : 'unlock'),
    i && i !== e.isLocked && ((e.isEnd = !1), e.navigation && e.navigation.update())
}
var checkOverflow$1 = { checkOverflow: checkOverflow },
  defaults = {
    init: !0,
    direction: 'horizontal',
    touchEventsTarget: 'container',
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !1,
    nested: !1,
    enabled: !0,
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    freeMode: !1,
    freeModeMomentum: !0,
    freeModeMomentumRatio: 1,
    freeModeMomentumBounce: !0,
    freeModeMomentumBounceRatio: 1,
    freeModeMomentumVelocityRatio: 1,
    freeModeSticky: !1,
    freeModeMinimumVelocity: 0.02,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: 'slide',
    breakpoints: void 0,
    breakpointsBase: 'window',
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerColumn: 1,
    slidesPerColumnFill: 'column',
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !1,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 0,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: 0.85,
    watchSlidesProgress: !1,
    watchSlidesVisibility: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    preloadImages: !0,
    updateOnImagesReady: !0,
    loop: !1,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopFillGroupWithBlank: !1,
    loopPreventsSlide: !0,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: 'swiper-no-swiping',
    noSwipingSelector: null,
    passiveListeners: !0,
    containerModifierClass: 'swiper-container-',
    slideClass: 'swiper-slide',
    slideBlankClass: 'swiper-slide-invisible-blank',
    slideActiveClass: 'swiper-slide-active',
    slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
    slideVisibleClass: 'swiper-slide-visible',
    slideDuplicateClass: 'swiper-slide-duplicate',
    slideNextClass: 'swiper-slide-next',
    slideDuplicateNextClass: 'swiper-slide-duplicate-next',
    slidePrevClass: 'swiper-slide-prev',
    slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
    wrapperClass: 'swiper-wrapper',
    runCallbacksOnInit: !0,
    _emitClasses: !1
  }
function _defineProperties(e, t) {
  for (var i = 0; i < t.length; i++) {
    var r = t[i]
    ;(r.enumerable = r.enumerable || !1),
      (r.configurable = !0),
      'value' in r && (r.writable = !0),
      Object.defineProperty(e, r.key, r)
  }
}
function _createClass(e, t, i) {
  return t && _defineProperties(e.prototype, t), i && _defineProperties(e, i), e
}
var prototypes = {
    modular: modular,
    eventsEmitter: eventsEmitter,
    update: update,
    translate: translate,
    transition: transition,
    slide: slide,
    loop: loop,
    grabCursor: grabCursor,
    manipulation: manipulation,
    events: events,
    breakpoints: breakpoints,
    checkOverflow: checkOverflow$1,
    classes: classes,
    images: images
  },
  extendedDefaults = {},
  Swiper$1 = (function () {
    function e() {
      for (var t, i, r = arguments.length, n = new Array(r), a = 0; a < r; a++) n[a] = arguments[a]
      if (
        (1 === n.length &&
        n[0].constructor &&
        'Object' === Object.prototype.toString.call(n[0]).slice(8, -1)
          ? (i = n[0])
          : ((t = n[0]), (i = n[1])),
        i || (i = {}),
        (i = extend$1({}, i)),
        t && !i.el && (i.el = t),
        i.el && $(i.el).length > 1)
      ) {
        var o = []
        return (
          $(i.el).each(function (t) {
            var r = extend$1({}, i, { el: t })
            o.push(new e(r))
          }),
          o
        )
      }
      var s = this
      ;(s.__swiper__ = !0),
        (s.support = getSupport()),
        (s.device = getDevice({ userAgent: i.userAgent })),
        (s.browser = getBrowser()),
        (s.eventsListeners = {}),
        (s.eventsAnyListeners = []),
        void 0 === s.modules && (s.modules = {}),
        Object.keys(s.modules).forEach(function (e) {
          var t = s.modules[e]
          if (t.params) {
            var r = Object.keys(t.params)[0],
              n = t.params[r]
            if ('object' != typeof n || null === n) return
            if (!(r in i) || !('enabled' in n)) return
            !0 === i[r] && (i[r] = { enabled: !0 }),
              'object' != typeof i[r] || 'enabled' in i[r] || (i[r].enabled = !0),
              i[r] || (i[r] = { enabled: !1 })
          }
        })
      var l,
        h,
        u = extend$1({}, defaults)
      return (
        s.useParams(u),
        (s.params = extend$1({}, u, extendedDefaults, i)),
        (s.originalParams = extend$1({}, s.params)),
        (s.passedParams = extend$1({}, i)),
        s.params &&
          s.params.on &&
          Object.keys(s.params.on).forEach(function (e) {
            s.on(e, s.params.on[e])
          }),
        s.params && s.params.onAny && s.onAny(s.params.onAny),
        (s.$ = $),
        extend$1(s, {
          enabled: s.params.enabled,
          el: t,
          classNames: [],
          slides: $(),
          slidesGrid: [],
          snapGrid: [],
          slidesSizesGrid: [],
          isHorizontal: function () {
            return 'horizontal' === s.params.direction
          },
          isVertical: function () {
            return 'vertical' === s.params.direction
          },
          activeIndex: 0,
          realIndex: 0,
          isBeginning: !0,
          isEnd: !1,
          translate: 0,
          previousTranslate: 0,
          progress: 0,
          velocity: 0,
          animating: !1,
          allowSlideNext: s.params.allowSlideNext,
          allowSlidePrev: s.params.allowSlidePrev,
          touchEvents:
            ((l = ['touchstart', 'touchmove', 'touchend', 'touchcancel']),
            (h = ['mousedown', 'mousemove', 'mouseup']),
            s.support.pointerEvents && (h = ['pointerdown', 'pointermove', 'pointerup']),
            (s.touchEventsTouch = { start: l[0], move: l[1], end: l[2], cancel: l[3] }),
            (s.touchEventsDesktop = { start: h[0], move: h[1], end: h[2] }),
            s.support.touch || !s.params.simulateTouch ? s.touchEventsTouch : s.touchEventsDesktop),
          touchEventsData: {
            isTouched: void 0,
            isMoved: void 0,
            allowTouchCallbacks: void 0,
            touchStartTime: void 0,
            isScrolling: void 0,
            currentTranslate: void 0,
            startTranslate: void 0,
            allowThresholdMove: void 0,
            formElements: 'input, select, option, textarea, button, video, label',
            lastClickTime: now(),
            clickTimeout: void 0,
            velocities: [],
            allowMomentumBounce: void 0,
            isTouchEvent: void 0,
            startMoving: void 0
          },
          allowClick: !0,
          allowTouchMove: s.params.allowTouchMove,
          touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 },
          imagesToLoad: [],
          imagesLoaded: 0
        }),
        s.useModules(),
        s.emit('_swiper'),
        s.params.init && s.init(),
        s
      )
    }
    var t = e.prototype
    return (
      (t.enable = function () {
        var e = this
        e.enabled || ((e.enabled = !0), e.params.grabCursor && e.setGrabCursor(), e.emit('enable'))
      }),
      (t.disable = function () {
        var e = this
        e.enabled &&
          ((e.enabled = !1), e.params.grabCursor && e.unsetGrabCursor(), e.emit('disable'))
      }),
      (t.setProgress = function (e, t) {
        var i = this
        e = Math.min(Math.max(e, 0), 1)
        var r = i.minTranslate(),
          n = (i.maxTranslate() - r) * e + r
        i.translateTo(n, void 0 === t ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses()
      }),
      (t.emitContainerClasses = function () {
        var e = this
        if (e.params._emitClasses && e.el) {
          var t = e.el.className.split(' ').filter(function (t) {
            return (
              0 === t.indexOf('swiper-container') ||
              0 === t.indexOf(e.params.containerModifierClass)
            )
          })
          e.emit('_containerClasses', t.join(' '))
        }
      }),
      (t.getSlideClasses = function (e) {
        var t = this
        return e.className
          .split(' ')
          .filter(function (e) {
            return 0 === e.indexOf('swiper-slide') || 0 === e.indexOf(t.params.slideClass)
          })
          .join(' ')
      }),
      (t.emitSlidesClasses = function () {
        var e = this
        if (e.params._emitClasses && e.el) {
          var t = []
          e.slides.each(function (i) {
            var r = e.getSlideClasses(i)
            t.push({ slideEl: i, classNames: r }), e.emit('_slideClass', i, r)
          }),
            e.emit('_slideClasses', t)
        }
      }),
      (t.slidesPerViewDynamic = function () {
        var e = this,
          t = e.params,
          i = e.slides,
          r = e.slidesGrid,
          n = e.size,
          a = e.activeIndex,
          o = 1
        if (t.centeredSlides) {
          for (var s, l = i[a].swiperSlideSize, h = a + 1; h < i.length; h += 1)
            i[h] && !s && ((o += 1), (l += i[h].swiperSlideSize) > n && (s = !0))
          for (var u = a - 1; u >= 0; u -= 1)
            i[u] && !s && ((o += 1), (l += i[u].swiperSlideSize) > n && (s = !0))
        } else for (var p = a + 1; p < i.length; p += 1) r[p] - r[a] < n && (o += 1)
        return o
      }),
      (t.update = function () {
        var e = this
        if (e && !e.destroyed) {
          var t = e.snapGrid,
            i = e.params
          i.breakpoints && e.setBreakpoint(),
            e.updateSize(),
            e.updateSlides(),
            e.updateProgress(),
            e.updateSlidesClasses(),
            e.params.freeMode
              ? (r(), e.params.autoHeight && e.updateAutoHeight())
              : (('auto' === e.params.slidesPerView || e.params.slidesPerView > 1) &&
                e.isEnd &&
                !e.params.centeredSlides
                  ? e.slideTo(e.slides.length - 1, 0, !1, !0)
                  : e.slideTo(e.activeIndex, 0, !1, !0)) || r(),
            i.watchOverflow && t !== e.snapGrid && e.checkOverflow(),
            e.emit('update')
        }
        function r() {
          var t = e.rtlTranslate ? -1 * e.translate : e.translate,
            i = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate())
          e.setTranslate(i), e.updateActiveIndex(), e.updateSlidesClasses()
        }
      }),
      (t.changeDirection = function (e, t) {
        void 0 === t && (t = !0)
        var i = this,
          r = i.params.direction
        return (
          e || (e = 'horizontal' === r ? 'vertical' : 'horizontal'),
          e === r ||
            ('horizontal' !== e && 'vertical' !== e) ||
            (i.$el
              .removeClass('' + i.params.containerModifierClass + r)
              .addClass('' + i.params.containerModifierClass + e),
            i.emitContainerClasses(),
            (i.params.direction = e),
            i.slides.each(function (t) {
              'vertical' === e ? (t.style.width = '') : (t.style.height = '')
            }),
            i.emit('changeDirection'),
            t && i.update()),
          i
        )
      }),
      (t.mount = function (e) {
        var t = this
        if (t.mounted) return !0
        var i,
          r = $(e || t.params.el)
        return (
          !!(e = r[0]) &&
          ((e.swiper = t),
          e && e.shadowRoot && e.shadowRoot.querySelector
            ? ((i = $(e.shadowRoot.querySelector('.' + t.params.wrapperClass))).children =
                function (e) {
                  return r.children(e)
                })
            : (i = r.children('.' + t.params.wrapperClass)),
          extend$1(t, {
            $el: r,
            el: e,
            $wrapperEl: i,
            wrapperEl: i[0],
            mounted: !0,
            rtl: 'rtl' === e.dir.toLowerCase() || 'rtl' === r.css('direction'),
            rtlTranslate:
              'horizontal' === t.params.direction &&
              ('rtl' === e.dir.toLowerCase() || 'rtl' === r.css('direction')),
            wrongRTL: '-webkit-box' === i.css('display')
          }),
          !0)
        )
      }),
      (t.init = function (e) {
        var t = this
        return (
          t.initialized ||
            !1 === t.mount(e) ||
            (t.emit('beforeInit'),
            t.params.breakpoints && t.setBreakpoint(),
            t.addClasses(),
            t.params.loop && t.loopCreate(),
            t.updateSize(),
            t.updateSlides(),
            t.params.watchOverflow && t.checkOverflow(),
            t.params.grabCursor && t.enabled && t.setGrabCursor(),
            t.params.preloadImages && t.preloadImages(),
            t.params.loop
              ? t.slideTo(
                  t.params.initialSlide + t.loopedSlides,
                  0,
                  t.params.runCallbacksOnInit,
                  !1,
                  !0
                )
              : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0),
            t.attachEvents(),
            (t.initialized = !0),
            t.emit('init'),
            t.emit('afterInit')),
          t
        )
      }),
      (t.destroy = function (e, t) {
        void 0 === e && (e = !0), void 0 === t && (t = !0)
        var i = this,
          r = i.params,
          n = i.$el,
          a = i.$wrapperEl,
          o = i.slides
        return (
          void 0 === i.params ||
            i.destroyed ||
            (i.emit('beforeDestroy'),
            (i.initialized = !1),
            i.detachEvents(),
            r.loop && i.loopDestroy(),
            t &&
              (i.removeClasses(),
              n.removeAttr('style'),
              a.removeAttr('style'),
              o &&
                o.length &&
                o
                  .removeClass(
                    [
                      r.slideVisibleClass,
                      r.slideActiveClass,
                      r.slideNextClass,
                      r.slidePrevClass
                    ].join(' ')
                  )
                  .removeAttr('style')
                  .removeAttr('data-swiper-slide-index')),
            i.emit('destroy'),
            Object.keys(i.eventsListeners).forEach(function (e) {
              i.off(e)
            }),
            !1 !== e && ((i.$el[0].swiper = null), deleteProps(i)),
            (i.destroyed = !0)),
          null
        )
      }),
      (e.extendDefaults = function (e) {
        extend$1(extendedDefaults, e)
      }),
      (e.installModule = function (t) {
        e.prototype.modules || (e.prototype.modules = {})
        var i = t.name || Object.keys(e.prototype.modules).length + '_' + now()
        e.prototype.modules[i] = t
      }),
      (e.use = function (t) {
        return Array.isArray(t)
          ? (t.forEach(function (t) {
              return e.installModule(t)
            }),
            e)
          : (e.installModule(t), e)
      }),
      _createClass(e, null, [
        {
          key: 'extendedDefaults',
          get: function () {
            return extendedDefaults
          }
        },
        {
          key: 'defaults',
          get: function () {
            return defaults
          }
        }
      ]),
      e
    )
  })()
function isObject(e) {
  return (
    'object' == typeof e &&
    null !== e &&
    e.constructor &&
    'Object' === Object.prototype.toString.call(e).slice(8, -1)
  )
}
function extend(e, t) {
  var i = ['__proto__', 'constructor', 'prototype']
  Object.keys(t)
    .filter(function (e) {
      return i.indexOf(e) < 0
    })
    .forEach(function (i) {
      void 0 === e[i]
        ? (e[i] = t[i])
        : isObject(t[i]) && isObject(e[i]) && Object.keys(t[i]).length > 0
        ? t[i].__swiper__
          ? (e[i] = t[i])
          : extend(e[i], t[i])
        : (e[i] = t[i])
    })
}
function needsNavigation(e) {
  return (
    void 0 === e && (e = {}),
    e.navigation && void 0 === e.navigation.nextEl && void 0 === e.navigation.prevEl
  )
}
function needsPagination(e) {
  return void 0 === e && (e = {}), e.pagination && void 0 === e.pagination.el
}
function needsScrollbar(e) {
  return void 0 === e && (e = {}), e.scrollbar && void 0 === e.scrollbar.el
}
function uniqueClasses(e) {
  void 0 === e && (e = '')
  var t = e
      .split(' ')
      .map(function (e) {
        return e.trim()
      })
      .filter(function (e) {
        return !!e
      }),
    i = []
  return (
    t.forEach(function (e) {
      i.indexOf(e) < 0 && i.push(e)
    }),
    i.join(' ')
  )
}
Object.keys(prototypes).forEach(function (e) {
  Object.keys(prototypes[e]).forEach(function (t) {
    Swiper$1.prototype[t] = prototypes[e][t]
  })
}),
  Swiper$1.use([Resize, Observer$1])
var paramsList = [
  'init',
  '_direction',
  'touchEventsTarget',
  'initialSlide',
  '_speed',
  'cssMode',
  'updateOnWindowResize',
  'resizeObserver',
  'nested',
  '_width',
  '_height',
  'preventInteractionOnTransition',
  'userAgent',
  'url',
  '_edgeSwipeDetection',
  '_edgeSwipeThreshold',
  '_freeMode',
  '_freeModeMomentum',
  '_freeModeMomentumRatio',
  '_freeModeMomentumBounce',
  '_freeModeMomentumBounceRatio',
  '_freeModeMomentumVelocityRatio',
  '_freeModeSticky',
  '_freeModeMinimumVelocity',
  '_autoHeight',
  'setWrapperSize',
  'virtualTranslate',
  '_effect',
  'breakpoints',
  '_spaceBetween',
  '_slidesPerView',
  '_slidesPerColumn',
  '_slidesPerColumnFill',
  '_slidesPerGroup',
  '_slidesPerGroupSkip',
  '_centeredSlides',
  '_centeredSlidesBounds',
  '_slidesOffsetBefore',
  '_slidesOffsetAfter',
  'normalizeSlideIndex',
  '_centerInsufficientSlides',
  '_watchOverflow',
  'roundLengths',
  'touchRatio',
  'touchAngle',
  'simulateTouch',
  '_shortSwipes',
  '_longSwipes',
  'longSwipesRatio',
  'longSwipesMs',
  '_followFinger',
  'allowTouchMove',
  '_threshold',
  'touchMoveStopPropagation',
  'touchStartPreventDefault',
  'touchStartForcePreventDefault',
  'touchReleaseOnEdges',
  'uniqueNavElements',
  '_resistance',
  '_resistanceRatio',
  '_watchSlidesProgress',
  '_watchSlidesVisibility',
  '_grabCursor',
  'preventClicks',
  'preventClicksPropagation',
  '_slideToClickedSlide',
  '_preloadImages',
  'updateOnImagesReady',
  '_loop',
  '_loopAdditionalSlides',
  '_loopedSlides',
  '_loopFillGroupWithBlank',
  'loopPreventsSlide',
  '_allowSlidePrev',
  '_allowSlideNext',
  '_swipeHandler',
  '_noSwiping',
  'noSwipingClass',
  'noSwipingSelector',
  'passiveListeners',
  'containerModifierClass',
  'slideClass',
  'slideBlankClass',
  'slideActiveClass',
  'slideDuplicateActiveClass',
  'slideVisibleClass',
  'slideDuplicateClass',
  'slideNextClass',
  'slideDuplicateNextClass',
  'slidePrevClass',
  'slideDuplicatePrevClass',
  'wrapperClass',
  'runCallbacksOnInit',
  'observer',
  'observeParents',
  'observeSlideChildren',
  'a11y',
  'autoplay',
  '_controller',
  'coverflowEffect',
  'cubeEffect',
  'fadeEffect',
  'flipEffect',
  'hashNavigation',
  'history',
  'keyboard',
  'lazy',
  'mousewheel',
  '_navigation',
  '_pagination',
  'parallax',
  '_scrollbar',
  '_thumbs',
  'virtual',
  'zoom'
]
function getParams(e) {
  void 0 === e && (e = {})
  var t = { on: {} },
    i = {}
  extend(t, Swiper$1.defaults),
    extend(t, Swiper$1.extendedDefaults),
    (t._emitClasses = !0),
    (t.init = !1)
  var r = {},
    n = paramsList.map(function (e) {
      return e.replace(/_/, '')
    }),
    a = Object.assign({}, e)
  return (
    Object.keys(a).forEach(function (a) {
      void 0 !== e[a] &&
        (n.indexOf(a) >= 0
          ? isObject(e[a])
            ? ((t[a] = {}), (i[a] = {}), extend(t[a], e[a]), extend(i[a], e[a]))
            : ((t[a] = e[a]), (i[a] = e[a]))
          : 0 === a.search(/on[A-Z]/) && 'function' == typeof e[a]
          ? (t.on['' + a[2].toLowerCase() + a.substr(3)] = e[a])
          : (r[a] = e[a]))
    }),
    ['navigation', 'pagination', 'scrollbar'].forEach(function (e) {
      !0 === t[e] && (t[e] = {})
    }),
    { params: t, passedParams: i, rest: r }
  )
}
function initSwiper(e) {
  return new Swiper$1(e)
}
function mountSwiper(e, t) {
  var i = e.el,
    r = e.nextEl,
    n = e.prevEl,
    a = e.paginationEl,
    o = e.scrollbarEl,
    s = e.swiper
  needsNavigation(t) &&
    r &&
    n &&
    ((s.params.navigation.nextEl = r),
    (s.originalParams.navigation.nextEl = r),
    (s.params.navigation.prevEl = n),
    (s.originalParams.navigation.prevEl = n)),
    needsPagination(t) && a && ((s.params.pagination.el = a), (s.originalParams.pagination.el = a)),
    needsScrollbar(t) && o && ((s.params.scrollbar.el = o), (s.originalParams.scrollbar.el = o)),
    s.init(i)
}
function _extends$1() {
  return (_extends$1 =
    Object.assign ||
    function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var i = arguments[t]
        for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r])
      }
      return e
    }).apply(this, arguments)
}
function calcLoopedSlides(e, t) {
  var i = t.slidesPerView
  if (t.breakpoints) {
    var r = Swiper$1.prototype.getBreakpoint(t.breakpoints),
      n = r in t.breakpoints ? t.breakpoints[r] : void 0
    n && n.slidesPerView && (i = n.slidesPerView)
  }
  var a = Math.ceil(parseFloat(t.loopedSlides || i, 10))
  return (a += t.loopAdditionalSlides) > e.length && (a = e.length), a
}
function renderLoop(e, t, i) {
  var r = t.map(function (t, i) {
    return (
      t.props || (t.props = {}),
      (t.props.swiperRef = e),
      (t.props['data-swiper-slide-index'] = i),
      t
    )
  })
  function n(e, t, r) {
    return (
      e.props || (e.props = {}),
      h(
        e.type,
        _extends$1({}, e.props, {
          key: e.key + '-duplicate-' + t + '-' + r,
          class:
            (e.props.className || '') + ' ' + i.slideDuplicateClass + ' ' + (e.props.class || '')
        }),
        e.children
      )
    )
  }
  if (i.loopFillGroupWithBlank) {
    var a = i.slidesPerGroup - (r.length % i.slidesPerGroup)
    if (a !== i.slidesPerGroup)
      for (var o = 0; o < a; o += 1) {
        var s = h('div', { class: i.slideClass + ' ' + i.slideBlankClass })
        r.push(s)
      }
  }
  'auto' !== i.slidesPerView || i.loopedSlides || (i.loopedSlides = r.length)
  var l = calcLoopedSlides(r, i),
    u = [],
    p = []
  return (
    r.forEach(function (e, t) {
      t < l && p.push(n(e, t, 'prepend')),
        t < r.length && t >= r.length - l && u.push(n(e, t, 'append'))
    }),
    e.value && (e.value.loopedSlides = l),
    [].concat(u, r, p)
  )
}
function getChangedParams(e, t, i, r) {
  var n = []
  if (!t) return n
  var a = function (e) {
      n.indexOf(e) < 0 && n.push(e)
    },
    o = r.map(function (e) {
      return e.props && e.props.key
    }),
    s = i.map(function (e) {
      return e.props && e.props.key
    })
  return (
    o.join('') !== s.join('') && n.push('children'),
    r.length !== i.length && n.push('children'),
    paramsList
      .filter(function (e) {
        return '_' === e[0]
      })
      .map(function (e) {
        return e.replace(/_/, '')
      })
      .forEach(function (i) {
        if (i in e && i in t)
          if (isObject(e[i]) && isObject(t[i])) {
            var r = Object.keys(e[i]),
              n = Object.keys(t[i])
            r.length !== n.length
              ? a(i)
              : (r.forEach(function (r) {
                  e[i][r] !== t[i][r] && a(i)
                }),
                n.forEach(function (r) {
                  e[i][r] !== t[i][r] && a(i)
                }))
          } else e[i] !== t[i] && a(i)
      }),
    n
  )
}
function getChildren(e, t, i) {
  void 0 === e && (e = {})
  var r = [],
    n = { 'container-start': [], 'container-end': [], 'wrapper-start': [], 'wrapper-end': [] },
    a = function e(t, i) {
      Array.isArray(t) &&
        t.forEach(function (t) {
          var a = 'symbol' == typeof t.type
          'default' === i && (i = 'container-end'),
            a && t.children
              ? e(t.children, 'default')
              : t.type && 'SwiperSlide' === t.type.name
              ? r.push(t)
              : n[i] && n[i].push(t)
        })
    }
  return (
    Object.keys(e).forEach(function (t) {
      var i = e[t]()
      a(i, t)
    }),
    (i.value = t.value),
    (t.value = r),
    { slides: r, slots: n }
  )
}
function updateSwiper(e, t, i, r) {
  var n,
    a,
    o,
    s,
    l,
    h = r.filter(function (e) {
      return 'children' !== e && 'direction' !== e
    }),
    u = e.params,
    p = e.pagination,
    c = e.navigation,
    d = e.scrollbar,
    f = e.virtual,
    m = e.thumbs
  ;(r.includes('thumbs') && i.thumbs && i.thumbs.swiper && u.thumbs && !u.thumbs.swiper && (n = !0),
  r.includes('controller') &&
    i.controller &&
    i.controller.control &&
    u.controller &&
    !u.controller.control &&
    (a = !0),
  r.includes('pagination') &&
    i.pagination &&
    i.pagination.el &&
    (u.pagination || !1 === u.pagination) &&
    p &&
    !p.el &&
    (o = !0),
  r.includes('scrollbar') &&
    i.scrollbar &&
    i.scrollbar.el &&
    (u.scrollbar || !1 === u.scrollbar) &&
    d &&
    !d.el &&
    (s = !0),
  r.includes('navigation') &&
    i.navigation &&
    i.navigation.prevEl &&
    i.navigation.nextEl &&
    (u.navigation || !1 === u.navigation) &&
    c &&
    !c.prevEl &&
    !c.nextEl &&
    (l = !0),
  h.forEach(function (e) {
    isObject(u[e]) && isObject(i[e]) ? extend(u[e], i[e]) : (u[e] = i[e])
  }),
  r.includes('children') && f && u.virtual.enabled
    ? ((f.slides = t), f.update(!0))
    : r.includes('children') && e.lazy && e.params.lazy.enabled && e.lazy.load(),
  n) &&
    m.init() &&
    m.update(!0)
  a && (e.controller.control = u.controller.control),
    o && (p.init(), p.render(), p.update()),
    s && (d.init(), d.updateSize(), d.setTranslate()),
    l && (c.init(), c.update()),
    r.includes('allowSlideNext') && (e.allowSlideNext = i.allowSlideNext),
    r.includes('allowSlidePrev') && (e.allowSlidePrev = i.allowSlidePrev),
    r.includes('direction') && e.changeDirection(i.direction, !1),
    e.update()
}
function _extends() {
  return (_extends =
    Object.assign ||
    function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var i = arguments[t]
        for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r])
      }
      return e
    }).apply(this, arguments)
}
function updateOnVirtualData(e) {
  !e ||
    e.destroyed ||
    !e.params.virtual ||
    (e.params.virtual && !e.params.virtual.enabled) ||
    (e.updateSlides(),
    e.updateProgress(),
    e.updateSlidesClasses(),
    e.lazy && e.params.lazy.enabled && e.lazy.load())
}
function renderVirtual(e, t, i) {
  var r
  if (!i) return null
  var n = e.value.isHorizontal()
    ? (((r = {})[e.value.rtlTranslate ? 'right' : 'left'] = i.offset + 'px'), r)
    : { top: i.offset + 'px' }
  return t
    .filter(function (e, t) {
      return t >= i.from && t <= i.to
    })
    .map(function (t) {
      return (
        t.props || (t.props = {}),
        t.props.style || (t.props.style = {}),
        (t.props.swiperRef = e),
        (t.props.style = n),
        h(t.type, _extends({}, t.props), t.children)
      )
    })
}
var Swiper = {
    name: 'Swiper',
    props: {
      tag: { type: String, default: 'div' },
      wrapperTag: { type: String, default: 'div' },
      init: { type: Boolean, default: void 0 },
      direction: { type: String, default: void 0 },
      touchEventsTarget: { type: String, default: void 0 },
      initialSlide: { type: Number, default: void 0 },
      speed: { type: Number, default: void 0 },
      cssMode: { type: Boolean, default: void 0 },
      updateOnWindowResize: { type: Boolean, default: void 0 },
      resizeObserver: { type: Boolean, default: void 0 },
      nested: { type: Boolean, default: void 0 },
      width: { type: Number, default: void 0 },
      height: { type: Number, default: void 0 },
      preventInteractionOnTransition: { type: Boolean, default: void 0 },
      userAgent: { type: String, default: void 0 },
      url: { type: String, default: void 0 },
      edgeSwipeDetection: { type: [Boolean, String], default: void 0 },
      edgeSwipeThreshold: { type: Number, default: void 0 },
      freeMode: { type: Boolean, default: void 0 },
      freeModeMomentum: { type: Boolean, default: void 0 },
      freeModeMomentumRatio: { type: Number, default: void 0 },
      freeModeMomentumBounce: { type: Boolean, default: void 0 },
      freeModeMomentumBounceRatio: { type: Number, default: void 0 },
      freeModeMomentumVelocityRatio: { type: Number, default: void 0 },
      freeModeSticky: { type: Boolean, default: void 0 },
      freeModeMinimumVelocity: { type: Number, default: void 0 },
      autoHeight: { type: Boolean, default: void 0 },
      setWrapperSize: { type: Boolean, default: void 0 },
      virtualTranslate: { type: Boolean, default: void 0 },
      effect: { type: String, default: void 0 },
      breakpoints: { type: Object, default: void 0 },
      spaceBetween: { type: Number, default: void 0 },
      slidesPerView: { type: [Number, String], default: void 0 },
      slidesPerColumn: { type: Number, default: void 0 },
      slidesPerColumnFill: { type: String, default: void 0 },
      slidesPerGroup: { type: Number, default: void 0 },
      slidesPerGroupSkip: { type: Number, default: void 0 },
      centeredSlides: { type: Boolean, default: void 0 },
      centeredSlidesBounds: { type: Boolean, default: void 0 },
      slidesOffsetBefore: { type: Number, default: void 0 },
      slidesOffsetAfter: { type: Number, default: void 0 },
      normalizeSlideIndex: { type: Boolean, default: void 0 },
      centerInsufficientSlides: { type: Boolean, default: void 0 },
      watchOverflow: { type: Boolean, default: void 0 },
      roundLengths: { type: Boolean, default: void 0 },
      touchRatio: { type: Number, default: void 0 },
      touchAngle: { type: Number, default: void 0 },
      simulateTouch: { type: Boolean, default: void 0 },
      shortSwipes: { type: Boolean, default: void 0 },
      longSwipes: { type: Boolean, default: void 0 },
      longSwipesRatio: { type: Number, default: void 0 },
      longSwipesMs: { type: Number, default: void 0 },
      followFinger: { type: Boolean, default: void 0 },
      allowTouchMove: { type: Boolean, default: void 0 },
      threshold: { type: Number, default: void 0 },
      touchMoveStopPropagation: { type: Boolean, default: void 0 },
      touchStartPreventDefault: { type: Boolean, default: void 0 },
      touchStartForcePreventDefault: { type: Boolean, default: void 0 },
      touchReleaseOnEdges: { type: Boolean, default: void 0 },
      uniqueNavElements: { type: Boolean, default: void 0 },
      resistance: { type: Boolean, default: void 0 },
      resistanceRatio: { type: Number, default: void 0 },
      watchSlidesProgress: { type: Boolean, default: void 0 },
      watchSlidesVisibility: { type: Boolean, default: void 0 },
      grabCursor: { type: Boolean, default: void 0 },
      preventClicks: { type: Boolean, default: void 0 },
      preventClicksPropagation: { type: Boolean, default: void 0 },
      slideToClickedSlide: { type: Boolean, default: void 0 },
      preloadImages: { type: Boolean, default: void 0 },
      updateOnImagesReady: { type: Boolean, default: void 0 },
      loop: { type: Boolean, default: void 0 },
      loopAdditionalSlides: { type: Number, default: void 0 },
      loopedSlides: { type: Number, default: void 0 },
      loopFillGroupWithBlank: { type: Boolean, default: void 0 },
      loopPreventsSlide: { type: Boolean, default: void 0 },
      allowSlidePrev: { type: Boolean, default: void 0 },
      allowSlideNext: { type: Boolean, default: void 0 },
      swipeHandler: { type: Boolean, default: void 0 },
      noSwiping: { type: Boolean, default: void 0 },
      noSwipingClass: { type: String, default: void 0 },
      noSwipingSelector: { type: String, default: void 0 },
      passiveListeners: { type: Boolean, default: void 0 },
      containerModifierClass: { type: String, default: void 0 },
      slideClass: { type: String, default: void 0 },
      slideBlankClass: { type: String, default: void 0 },
      slideActiveClass: { type: String, default: void 0 },
      slideDuplicateActiveClass: { type: String, default: void 0 },
      slideVisibleClass: { type: String, default: void 0 },
      slideDuplicateClass: { type: String, default: void 0 },
      slideNextClass: { type: String, default: void 0 },
      slideDuplicateNextClass: { type: String, default: void 0 },
      slidePrevClass: { type: String, default: void 0 },
      slideDuplicatePrevClass: { type: String, default: void 0 },
      wrapperClass: { type: String, default: void 0 },
      runCallbacksOnInit: { type: Boolean, default: void 0 },
      observer: { type: Boolean, default: void 0 },
      observeParents: { type: Boolean, default: void 0 },
      observeSlideChildren: { type: Boolean, default: void 0 },
      a11y: { type: [Boolean, Object], default: void 0 },
      autoplay: { type: [Boolean, Object], default: void 0 },
      controller: { type: Object, default: void 0 },
      coverflowEffect: { type: Object, default: void 0 },
      cubeEffect: { type: Object, default: void 0 },
      fadeEffect: { type: Object, default: void 0 },
      flipEffect: { type: Object, default: void 0 },
      hashNavigation: { type: [Boolean, Object], default: void 0 },
      history: { type: [Boolean, Object], default: void 0 },
      keyboard: { type: [Boolean, Object], default: void 0 },
      lazy: { type: [Boolean, Object], default: void 0 },
      mousewheel: { type: [Boolean, Object], default: void 0 },
      navigation: { type: [Boolean, Object], default: void 0 },
      pagination: { type: [Boolean, Object], default: void 0 },
      parallax: { type: [Boolean, Object], default: void 0 },
      scrollbar: { type: [Boolean, Object], default: void 0 },
      thumbs: { type: Object, default: void 0 },
      virtual: { type: [Boolean, Object], default: void 0 },
      zoom: { type: [Boolean, Object], default: void 0 }
    },
    emits: [
      '_beforeBreakpoint',
      '_containerClasses',
      '_slideClass',
      '_slideClasses',
      '_swiper',
      'activeIndexChange',
      'afterInit',
      'autoplay',
      'autoplayStart',
      'autoplayStop',
      'beforeDestroy',
      'beforeInit',
      'beforeLoopFix',
      'beforeResize',
      'beforeSlideChangeStart',
      'beforeTransitionStart',
      'breakpoint',
      'changeDirection',
      'click',
      'doubleTap',
      'doubleClick',
      'destroy',
      'fromEdge',
      'hashChange',
      'hashSet',
      'imagesReady',
      'init',
      'keyPress',
      'lazyImageLoad',
      'lazyImageReady',
      'loopFix',
      'momentumBounce',
      'navigationHide',
      'navigationShow',
      'observerUpdate',
      'orientationchange',
      'paginationHide',
      'paginationRender',
      'paginationShow',
      'paginationUpdate',
      'progress',
      'reachBeginning',
      'reachEnd',
      'realIndexChange',
      'resize',
      'scroll',
      'scrollbarDragEnd',
      'scrollbarDragMove',
      'scrollbarDragStart',
      'setTransition',
      'setTranslate',
      'slideChange',
      'slideChangeTransitionEnd',
      'slideChangeTransitionStart',
      'slideNextTransitionEnd',
      'slideNextTransitionStart',
      'slidePrevTransitionEnd',
      'slidePrevTransitionStart',
      'slideResetTransitionStart',
      'slideResetTransitionEnd',
      'sliderMove',
      'sliderFirstMove',
      'slidesLengthChange',
      'slidesGridLengthChange',
      'snapGridLengthChange',
      'snapIndexChange',
      'swiper',
      'tap',
      'toEdge',
      'touchEnd',
      'touchMove',
      'touchMoveOpposite',
      'touchStart',
      'transitionEnd',
      'transitionStart',
      'update',
      'zoomChange'
    ],
    setup: function (e, t) {
      var i = t.slots,
        r = t.emit,
        n = e.tag,
        a = e.wrapperTag,
        o = ref('swiper-container'),
        s = ref(null),
        l = ref(!1),
        u = ref(!1),
        p = ref(null),
        c = ref(null),
        d = ref(null),
        f = { value: [] },
        m = { value: [] },
        g = ref(null),
        y = ref(null),
        v = ref(null),
        _ = ref(null),
        x = getParams(e),
        S = x.params,
        b = x.passedParams
      getChildren(i, f, m), (d.value = b), (m.value = f.value)
      if (
        ((S.onAny = function (e) {
          for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
            i[n - 1] = arguments[n]
          r.apply(void 0, [e].concat(i))
        }),
        Object.assign(S.on, {
          _beforeBreakpoint: function () {
            getChildren(i, f, m), (l.value = !0)
          },
          _containerClasses: function (e, t) {
            o.value = t
          }
        }),
        (c.value = initSwiper(S)),
        (c.value.loopCreate = function () {}),
        (c.value.loopDestroy = function () {}),
        S.loop && (c.value.loopedSlides = calcLoopedSlides(f.value, S)),
        c.value.virtual && c.value.params.virtual.enabled)
      ) {
        c.value.virtual.slides = f.value
        var T = {
          cache: !1,
          renderExternal: function (e) {
            s.value = e
          },
          renderExternalUpdate: !1
        }
        extend(c.value.params.virtual, T), extend(c.value.originalParams.virtual, T)
      }
      function A(e) {
        return S.virtual
          ? renderVirtual(c, e, s.value)
          : !S.loop || (c.value && c.value.destroyed)
          ? (e.forEach(function (e) {
              e.props || (e.props = {}), (e.props.swiperRef = c)
            }),
            e)
          : renderLoop(c, e, S)
      }
      return (
        onUpdated(function () {
          !u.value && c.value && (c.value.emitSlidesClasses(), (u.value = !0))
          var t = getParams(e).passedParams,
            i = getChangedParams(t, d.value, f.value, m.value)
          ;(d.value = t),
            (i.length || l.value) &&
              c.value &&
              !c.value.destroyed &&
              updateSwiper(c.value, f.value, t, i),
            (l.value = !1)
        }),
        watch(s, function () {
          nextTick$1(function () {
            updateOnVirtualData(c.value)
          })
        }),
        onMounted(function () {
          p.value &&
            (mountSwiper(
              {
                el: p.value,
                nextEl: g.value,
                prevEl: y.value,
                paginationEl: v.value,
                scrollbarEl: _.value,
                swiper: c.value
              },
              S
            ),
            r('swiper', c.value))
        }),
        onBeforeUnmount(function () {
          c.value && !c.value.destroyed && c.value.destroy(!0, !1)
        }),
        function () {
          var t = getChildren(i, f, m),
            r = t.slides,
            s = t.slots
          return h(n, { ref: p, class: uniqueClasses(o.value) }, [
            s['container-start'],
            needsNavigation(e) && [
              h('div', { ref: y, class: 'swiper-button-prev' }),
              h('div', { ref: g, class: 'swiper-button-next' })
            ],
            needsScrollbar(e) && h('div', { ref: _, class: 'swiper-scrollbar' }),
            needsPagination(e) && h('div', { ref: v, class: 'swiper-pagination' }),
            h(a, { class: 'swiper-wrapper' }, [s['wrapper-start'], A(r), s['wrapper-end']]),
            s['container-end']
          ])
        }
      )
    }
  },
  SwiperSlide = {
    name: 'SwiperSlide',
    props: {
      tag: { type: String, default: 'div' },
      swiperRef: Object,
      zoom: { type: Boolean, default: void 0 },
      virtualIndex: { type: [String, Number], default: void 0 }
    },
    setup: function (e, t) {
      var i = t.slots,
        r = !1,
        n = e.swiperRef,
        a = ref(null),
        o = ref('swiper-slide')
      function s(e, t, i) {
        t === a.value && (o.value = i)
      }
      onMounted(function () {
        n.value && (n.value.on('_slideClass', s), (r = !0))
      }),
        onBeforeUpdate(function () {
          !r && n && n.value && (n.value.on('_slideClass', s), (r = !0))
        }),
        onUpdated(function () {
          a.value &&
            n &&
            n.value &&
            n.value.destroyed &&
            'swiper-slide' !== o.value &&
            (o.value = 'swiper-slide')
        }),
        onBeforeUnmount(function () {
          n && n.value && n.value.off('_slideClass', s)
        })
      var l = computed(function () {
        return {
          isActive:
            o.value.indexOf('swiper-slide-active') >= 0 ||
            o.value.indexOf('swiper-slide-duplicate-active') >= 0,
          isVisible: o.value.indexOf('swiper-slide-visible') >= 0,
          isDuplicate: o.value.indexOf('swiper-slide-duplicate') >= 0,
          isPrev:
            o.value.indexOf('swiper-slide-prev') >= 0 ||
            o.value.indexOf('swiper-slide-duplicate-prev') >= 0,
          isNext:
            o.value.indexOf('swiper-slide-next') >= 0 ||
            o.value.indexOf('swiper-slide-duplicate-next') >= 0
        }
      })
      return function () {
        return h(
          e.tag,
          { class: uniqueClasses('' + o.value), ref: a, 'data-swiper-slide-index': e.virtualIndex },
          e.zoom
            ? h(
                'div',
                {
                  class: 'swiper-zoom-container',
                  'data-swiper-zoom': 'number' == typeof e.zoom ? e.zoom : void 0
                },
                i.default && i.default(l.value)
              )
            : i.default && i.default(l.value)
        )
      }
    }
  },
  swiper =
    "@font-face {\n  font-family: 'swiper-icons';\n  src: url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA') format('woff');\n  font-weight: 400;\n  font-style: normal;\n}\n:root {\n  --swiper-theme-color: #007aff;\n}\n.swiper-container {\n  margin-left: auto;\n  margin-right: auto;\n  position: relative;\n  overflow: hidden;\n  list-style: none;\n  padding: 0;\n  /* Fix of Webkit flickering */\n  z-index: 1;\n}\n.swiper-container-vertical > .swiper-wrapper {\n  flex-direction: column;\n}\n.swiper-wrapper {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  z-index: 1;\n  display: flex;\n  transition-property: transform;\n  box-sizing: content-box;\n}\n.swiper-container-android .swiper-slide,\n.swiper-wrapper {\n  transform: translate3d(0, 0, 0);\n}\n.swiper-container-multirow > .swiper-wrapper {\n  flex-wrap: wrap;\n}\n.swiper-container-multirow-column > .swiper-wrapper {\n  flex-wrap: wrap;\n  flex-direction: column;\n}\n.swiper-container-free-mode > .swiper-wrapper {\n  transition-timing-function: ease-out;\n  margin: 0 auto;\n}\n.swiper-container-pointer-events {\n  touch-action: pan-y;\n}\n.swiper-container-pointer-events.swiper-container-vertical {\n  touch-action: pan-x;\n}\n.swiper-slide {\n  flex-shrink: 0;\n  width: 100%;\n  height: 100%;\n  position: relative;\n  transition-property: transform;\n}\n.swiper-slide-invisible-blank {\n  visibility: hidden;\n}\n/* Auto Height */\n.swiper-container-autoheight,\n.swiper-container-autoheight .swiper-slide {\n  height: auto;\n}\n.swiper-container-autoheight .swiper-wrapper {\n  align-items: flex-start;\n  transition-property: transform, height;\n}\n/* 3D Effects */\n.swiper-container-3d {\n  perspective: 32rem;\n}\n.swiper-container-3d .swiper-wrapper,\n.swiper-container-3d .swiper-slide,\n.swiper-container-3d .swiper-slide-shadow-left,\n.swiper-container-3d .swiper-slide-shadow-right,\n.swiper-container-3d .swiper-slide-shadow-top,\n.swiper-container-3d .swiper-slide-shadow-bottom,\n.swiper-container-3d .swiper-cube-shadow {\n  transform-style: preserve-3d;\n}\n.swiper-container-3d .swiper-slide-shadow-left,\n.swiper-container-3d .swiper-slide-shadow-right,\n.swiper-container-3d .swiper-slide-shadow-top,\n.swiper-container-3d .swiper-slide-shadow-bottom {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  z-index: 10;\n}\n.swiper-container-3d .swiper-slide-shadow-left {\n  background-image: linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n}\n.swiper-container-3d .swiper-slide-shadow-right {\n  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n}\n.swiper-container-3d .swiper-slide-shadow-top {\n  background-image: linear-gradient(to top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n}\n.swiper-container-3d .swiper-slide-shadow-bottom {\n  background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n}\n/* CSS Mode */\n.swiper-container-css-mode > .swiper-wrapper {\n  overflow: auto;\n  scrollbar-width: none;\n  /* For Firefox */\n  -ms-overflow-style: none;\n  /* For Internet Explorer and Edge */\n}\n.swiper-container-css-mode > .swiper-wrapper::-webkit-scrollbar {\n  display: none;\n}\n.swiper-container-css-mode > .swiper-wrapper > .swiper-slide {\n  scroll-snap-align: start start;\n}\n.swiper-container-horizontal.swiper-container-css-mode > .swiper-wrapper {\n  scroll-snap-type: x mandatory;\n}\n.swiper-container-vertical.swiper-container-css-mode > .swiper-wrapper {\n  scroll-snap-type: y mandatory;\n}\n",
  _sfc_main = defineComponent({
    components: { Lottie: _sfc_main$1, Swiper: Swiper, SwiperSlide: SwiperSlide },
    setup() {
      let e = useRouter(),
        t = [],
        i = {},
        r = window.lib.flexible.rem / 37.5,
        n = ref(''),
        a = computed(() => 'data/' + n.value + '/'),
        o = reactive({ myData: {} })
      const s = useRoute()
      ;(() => {
        console.log(s)
        let e = s.query.defName
        ;(n.value = e || 'default'),
          (() => {
            let e = 'data/' + n.value + '/txt/resume_cn.json'
            http.get(e).then((e) => {
              ;(o.myData = e.data),
                nextTick$1(() => {
                  console.log(2323), m()
                })
            })
          })()
      })()
      let l,
        h,
        u = ref(!1),
        p = (e, t) => {
          let i = document.getElementById('radarChartbox')
          if (!i) return
          l = init$1(i)
          let n = {
            title: {
              text: '',
              left: 'center',
              textStyle: { color: '#FFFFFF' },
              top: 8 * r
            },
            color: [
              '#FF3333',
              '#5470c6',
              '#fac858',
              '#ee6666',
              '#73c0de',
              '#3ba272',
              '#fc8452',
              '#9a60b4',
              '#ea7ccc'
            ],
            radar: {
              indicator: e,
              name: { textStyle: { color: '#FFA953', padding: [3, 5], fontSize: 16 * r } },
              center: ['50%', '55%'],
              radius: 105 * r
            },
            series: [
              {
                name: '',
                type: 'radar',
                label: {
                  show: !0,
                  fontSize: 16 * r,
                  color: '#FFFFFF',
                  position: 'right',
                  formatter: function (e) {
                    return console.log(e), e.value
                  }
                },
                data: [
                  {
                    value: t,
                    name: '',
                    areaStyle: {
                      color: new RadialGradient(0.1, 0.6, 1, [
                        { color: 'rgba(255, 145, 124, 0.1)', offset: 0 },
                        { color: 'rgba(255, 145, 124, 0.9)', offset: 1 }
                      ])
                    }
                  }
                ]
              }
            ]
          }
          l.setOption(n)
        },
        c = (e, t) => {
          let i = document.getElementById('barChartbox')
          if (!i) return
          h = init$1(i)
          let n = [
            '#5470c6',
            '#91cc75',
            '#fac858',
            '#ee6666',
            '#73c0de',
            '#3ba272',
            '#fc8452',
            '#9a60b4',
            '#ea7ccc'
          ]
          var a = {
            title: {
              text: '',
              left: 'center',
              textStyle: { color: '#FFFFFF' },
              top: 8 * r
            },
            grid: { left: 60 * r },
            yAxis: { data: e, axisLabel: { color: '#FFFFFF', fontSize: 14 * r } },
            xAxis: { axisLabel: { color: '#FFFFFF' } },
            series: [
              {
                name: '',
                type: 'bar',
                data: t,
                itemStyle: {
                  color: function (e) {
                    return n[e.dataIndex]
                  }
                }
              }
            ]
          }
          h.setOption(a)
        },
        d = reactive({ list: [] }),
        f = ref([]),
        m = () => {
          for (let e in i) {
            console.log(33)
            let t = i[e]
            swiperAnimateCache(t), swiperAnimate(t)
          }
          for (let e = 0; e < t.length; e++) {
            console.log(22)
            let i = t[e]
            swiperAnimateCache(i), swiperAnimate(i)
          }
        }
      onMounted(() => {}),
        onBeforeUnmount(() => {
          try {
            h && (h.dispose(), (h = null)), l && (l.dispose(), (h = null))
          } catch (e) {}
        })
      return __assign2(__assign2({ cSpan: 3 }, toRefs(o)), {
        imgPath: a,
        qrShow: u,
        myAni: f,
        r: d,
        onInt(e, r) {
          console.log('init', e), r ? (i[r] = e) : t.push(e)
        },
        onBack() {
          console.log(e), e.back()
        },
        test1(e) {
          console.log(23232), swiperAnimateCache(e)
        },
        slideChangeTransitionEnd(e) {
          i[e.activeIndex] ? swiperAnimate(i[e.activeIndex]) : swiperAnimate(e),
            1 == e.activeIndex &&
              ((() => {
                if (l) return
                let e = o.myData.ability,
                  t = [],
                  i = []
                Object.keys(e).forEach((r) => {
                  let n = { name: r, max: 100 }
                  t.push(n), i.push(e[r])
                }),
                  p(t, i)
              })(),
              (() => {
                if (h) return
                let e = o.myData.code,
                  t = [],
                  i = []
                Object.keys(e).forEach((r) => {
                  t.push(r),
                    i.push({
                      value: e[r],
                      label: { show: !0, position: 'right', color: '#FFFFFF' }
                    })
                }),
                  c(t, i)
              })())
        },
        slideChangeTransitionEnd_inner(e) {
          swiperAnimate(e)
        },
        onSlideChange(e) {
          console.log('slide change', e),
            ((e) => {
              for (let t = 0; t < f.value.length; t++)
                t != e && f.value[t] && f.value[t].aniObj.pause()
              f.value[e] && f.value[e].aniObj.play()
            })(e.activeIndex)
        }
      })
    }
  }),
  _imports_0 = './assets/back.2fe4c110.png',
  _imports_1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEcAAABACAYAAABItWqnAAAKkUlEQVR4Xu1ba2wc1RX+zqwJJYR4Z5OUNhS1wTubhIcKfUg8ilSKkECoFaUiir1eA30k2VljoLRACYVQaFMIEEgys3FDoOTBq7ShQKtSUAWCIkBBNBUR8c6GBhBtgXhnbd72zpzqro1ZO+u5dyZrOz86P32/8/p858w9554l/P8ZlwE60LiJ51/5Ujm7cM+B4NcBQ46eLy4G8y0A5hLz9aVc6pqpJuiAICeeL15AzHeNJoNXuWbq8qkkaMrJ0fNOFgy7Pgm81jVTXVNF0JSSk7CcS5lwa2DwhA1u1lgyFQRNGTm67fwMwK+Ugiba7GaTHUrYBoKmhJyE7VzHQKiEy4wHy03JNiylwQbGL9m0k2Vp2I6eL94I5qiJ9lGqIF3qMvonw+1J3TkJq3g7E+9XgmXQExVC+r1s8u2JJmjSyNHtYjfAKon1ZQDHBgdOzyBGaXdpy+sTSdCkkKPbzt0AVBLqco15G4M2MeFrksBfjDVpbXuXtBQmiqCJJad7+0G637wFjEWyAAi4rGQa1c9689pd87RY0yaAvyGR28kVP13umr9Dpj/K+oSRM3vjrsO8j2NbAXxb6hgj5+aMUQfB2d17Pu9XBjYz0ekS+d2az+neztTzUjshARNCzow1zpymGLYS4QyZP8T4YSlnbKyHm3nrzkTsMweLHXS2RM+bDKTLpvGUzF6Y9YaTk7CKRzJhK8CnShxhMDJuzhC7a9xnbvf26R95Mzcz6FyJvl4ipEtZ47EwBARhG0rOzPW7jSbPv0chmX5IxJlSNvV7pUBWsKZ/trgZQJsE/wHDT5fN+Q8p6ZWAGkaO3r37OHj+PQqfYRegjGu2/ClsAPG8s5EY35fI+SA/7Wbn3xdW/1h8Q8iZZe3+uk9VYpISh/6rgTO9ZuqJqI7rtiMSd1Ymz8wXlnOp38pwE/pa6farpwLevQCOCHaE9oC9jJub/8z+OCxk43nnVmJcKtfDWddMrZfj6iP2a+ck1r96BvtVYmYFOkDY5ZOW6VvWsj2qo2PldMtZCcKVMn0M7dKy2XKbDFdvPTI5cdv5DgGCmOnBhnkHSGt3s0lRFjT0ieeda4mxQkHpVa5prFTAjYJEIiexzlnEWpUYTWLweU/TMv3LWpywjqnidcu5EgRp4AT8omQa16rqFbjQ5MStYgcRi1pJ9jxFTJlSLvmGDLi/63HbuYSA1VI9RDe52eQVUtwwIBQ5ul1cAnC3XDn/dbBC7e91Ge/IsY1B6HZhGUB5mTZiWlPKJS+W4ULtnLhVuJiIVBLbw1RBJnRDagVr8TmFawjaHGLYpU5jp0oAtZj6txh1tDA2uDl5X1pp5+i2I7bir6XOMh5w3xnIYMUxA1JsDWBu97+nf+i9L8qIc4b+zD0+tHSfmXwxjB6BHb7/2gIgJpHd7JpGYBtFSo76F4E2uWby/LDBzLzjjURs4CNBzJmjZek1sNce5VwUt4vnEFgQdGiQPwz8rjz7pVYsWuTVwwWSo9uO2C3yBKa4Tcc6MHvt63O92MeCmG/Wc46J3oqx3x7lRK3bPWcBmqjHgs9gwCPT3v+g9a2ffvn9sT6MS04iX7yNmRUSV7SLt2b7taM0DAhiTpTstn4Qp91s6tGwuzJuFU8jqu6guYE7iPC451Va3+1c2FuLq0uObhe6AVLo99Iq10yGvklIrHeOZl+0NXC8YsADpCFdWmY8qIgfgSXWOSexBkHQUcGy/IxGhyzuzR755ie4fchR7fcS+IaSmfp5WGeb7Ve+qlGTaJ0uCCvLvt9R7pwvXpVQTzzvnEDMWwFaGCRIjO0VUGt/LlkUuFHk6HnnfpV+L5iudnPJX4bysPol2XUKuNo6/WJY2ZH/JtOSUi65Iaz8LKuw0CcStk+QyL7sV3BOX5exe4ScuNWzgkiTHq+J6CelbFKMioR6mtf1nE6kidbp4aEE64AZ1FU2k2vD6mnesGeeVhncCsZJwTuIt5VyqXNHyNHt4jaAh88Z44p2uqZhhXVKtwtnA9X/WrNE9h8MbCPgOrkNutw1k6vkuNEI0bj3vEHhy2kBsv2uaTTXkBOchAn4Uck07gjrTCJf+B4ziUbYNInsc56mdYgiVbcKl4PoRpktJrqmnE1eL8ONXR9u3G8B+Ky6soTdbtZI1rxWhQuIaMwA0YhoxjUNkfFDPXreSYOrXwrZ8yQxddQWqfF8sYuYb5cJAljpmsZVCrhRENG4/9BrrjmV1ywz3+TmUleMTshWsRNUveQ/chj6dwZuKpvGw2GNJyznB0xQ2WmPDVaQqVek6lZhKYiknTxmrC7njB+H9RHVxr1jAbRsRLamct/nU374qh2HVqbPOLpCXm+fmXo1tEHxVbKdHIB1UlnGH8lDR1CRGreL5xNYpRecd03DlNqsA5iV7znCq2iGN81/+d2l8/d+ApHWVmGNJfLFy5j5ZgW5+923BzpUilQ937MYrG0CcFCQXgLuKpmG7HZCwbUhSEPJ0fPF5WC+QWadQHeXzOQFMlzterWYJN4ExmHBcnyfa6Zaw+geD9swcnSrcAOIlsud4t+4ZmqpHLcvIrG+eCb7LE7IsyXyDzUf0tS658J5H0Wx09DXKm45NxPhMpkjxLymlEspFLPja6oWk1p1B31BYu8vfEhTa/nCeWWZXxO2c3TbEYlXJODgJ2T/NkjZcDEpdlCLxOqTsdhg296lR/9H5l699f16reKWs5FIej0rElvozr8smKFiEoKgYyTY53zPa+u7aMG/ZDrHrkcmR7cdcYCSXewLe8td01AbqQ3pfbWYBG0B4SuSJL1DY7T25lKvhDERnpw1zsGJJrqHwbKRELFjRqa1wjgVBlstJgcHxSn8ZAlBPUzUWs4aL6nqD0VOfPVLcTp4hqiT6tcktVbrTGupOhUWV50C8ypbGPwtSeJ7jXiwrZRb+KyKDWVy5lg7P1ehaYKYoGq2ajNoWkvFqSiYoWJymthBgf840ZdmoK0vm/ybzI4SOeI3UMRN4vpX1u8FGO2yaS2ZU1HXq1NglfgWJv6uREc/NK3VXdby5yCclJxZa3sW+DFNECPr935MxGnlaa2oDMjkhopJ0RJdLIEOMGut5VzLH8bDBZITtwrHk0b3KvR7+wAtHWVaSxZr1PWEVbiLiRRKlKrfIl3s84x/NWM7JzIgRscC+71MeCvGHOluKWrgqnK6XcwD/Gk7YhzB8XJkXXLEER3gexX6va+D/XSUW0nVAPcXl7Cd1QxcoqBnnxZwnauZ4lmCGFm/l4ECa1q6kdNaCgFEguh5ZyVYPgU29vJgFDlxq3AuEQliJP1e+icI6YmY1ooUvYKQ6u0KiK52s0PXTiPkJKziyUwsBpxnBNliwgs+ae0TOa2lEGskiOoUGKBlXbNl/ae3D3lnLRidwVb5aWItPRnTWpGiVxBSnALb6ZrGsTVXM45ooo/7Iw5mPF7xkJ7MaS2FWCNBFKbA3nNN47BacoLGTR6hCtpDT2tFcn1yhCRTYM+6pnHK6IRsOw8QcF6te9Ufnr4zkFZphE9OWI2zMjwFJu7da/PsXvZwXvki48l9PuUiq2sUOw6EfoCfLmWNOxvnzoGnaehD5GcAWgCiF2Ks3bnXPKpn1NfqwHN76j2SFp5T7+LUefA/oSTtbov1hHgAAAAASUVORK5CYII=',
  _imports_2 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEcAAABACAYAAABItWqnAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozRjFERjc4OUQ0QjcxMUVCQjY5NUREREE0MEYxOUU5OSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozRjFERjc4QUQ0QjcxMUVCQjY5NUREREE0MEYxOUU5OSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjNGMURGNzg3RDRCNzExRUJCNjk1REREQTQwRjE5RTk5IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjNGMURGNzg4RDRCNzExRUJCNjk1REREQTQwRjE5RTk5Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+yd0S7wAACrNJREFUeNrMWw2MVNUVPufeN7O7LAG2CFRNxFawbSRFAlHTQqQNrbVRqxUq7MwuUIKi1r9aQGpphWgLRLQYVKCIurMLxISfNCE0aSxN2mqTajXRCg3U2lRtZXEBBXZ29r17eu7bSQqz9+ft7Mwsd3P27c79mfu+d+453zn3PiQiMJULNr0PQ1AuJpXfSwjTTJWhVGP4cszWOaWkb/wH+X4fN9Ygrutactnysz8KbKMUolO1BmZ0IOROnuQ0WwNZEJP48ntbPUlyjX83y+PWWqKrSj+ygjOsu1BLYBp7hg/bAQTTXY1koA5b700J/mXtuoi1caN7CnQoMTgfjf97rYCRTcem7ECCb3gmv0kRfmAZgpeFtWMzgNrqmcMpJJFLDM6oY1NqBc4Olhs9bfYePzrxbutcx7xrq/ouourwzgBxMWvWK4nBwdoA08YyxzPz/Q3yRKbhwteVqbabmmwdvw1K7fBNgBAX8mWnqS6w96o6MFv4CbR42hyI8j3ZU9BwxghbQ51tol8XRBqYtAeaO5HoBVutQ3OqqjsbCGmxW2HgVSlSGdmY6jJVq7Cbf/Waqr6iRGo7X0c4YQF4gL9kk6uNFRwSVQNmLbvNez1t3lBBKsPr6D9G3EIGRRinPgUJt7M2jHMrDKzgR/9L30TtmkNVWVereNRlHlU/KAgyolD45wDH/pLC2LiPd45OahVf1iQZMKihyVnB8lNPm3fZQGYihIPGOYWRrd/nhBQMDH7Bs1TXIIpHkk7YAU5F19X9COrnnjYfooIsq/sbpkqR6rWZ1wujKLYxk9248DKi+AHBoMFBiCoFzBIe7UlPm4+JMMtc41UzXZegzFMdhd2hBuYaDx3Y1GeAB1bsmlOZdbUAEZ/1tDnNbqcFEQ6YKkc2WL1x/cnuUNuYmU5YYldNd5YzebvmiEGjM5dd3vOeNhEBZpn+7zdrLwED4GLW3/IY952sjQvLvYFqac7NCCIJbdc2Zq8lkvSEHHizW2NwT1fnhMxgbsIKjsCyDfJ1DKwGRpRL20X8ZKwkdBtprXSX/fXBiexFlpDDXqYmA0eVpznX8i1pYIaVT9vRRSOeYVno9kr4u9ARclREc+TA0blaCdTAjC6btru/8gk22j7D+oqQQTbdGHRVwptYwYkGBs5kDGIbc3HZtB2dqQDNkR7wjP1XlU5lbSFHRcEJ6oOkY1wehXHO5DK3jYFHNEMtI0Gykpegj7z9TQBlywg5ytScZIpzCauYJmFXeJ7qGiRYZfFYrp5LufNqzxz+wcC3RIgHKx3vWMHp9S+rsak+rzTVozFPsmKssFU6yj1smtd5YqX3MYIWW8hRNXDSvU5wRqhAG1+a7hn/WdaYH1p4iKvfYkJ6yjP2MVLYag05qglOV90EW1WqKTrSwU91lkdjtvHlLou1dzmmFhRii0djPuWwRGvMAahisSfYwyO2qu08uRs8425njVlkDkv0t1r54Wwmxm2esXs5SG1lnvgbqHJxxFZGtW/juGK2+6HS7q6jE6254aZx1q2nG1jdEoQcqtUactQKHAMj28IfeRLiuK9enmyx0faeaISN6M1SEAOTdjs9XAAkd0KNimP34Zy7YOOIiz2pgZfDnkKrjbbLusBGgaeTkO3cf4SbDtAS1soXoYYlCdNjd4r3eDTmjyJItaSDtJG290YhWCLAqWx92n0JcQ5S72M+tBlqXBwJ9viymie21K0x8FqkwlYVhUbaLlGC5ezDFSSIlxKO92jMcgbvKRiCYo/KRXQpUrDS0/9tVvXWQAgjbVfuCPsuX0Kc+/5MHw2BISoOzQne48uHLBc5+k9SiLfw1bxb4E5YdaInic9e6ZZI6F0FOHxegVOMeR6Evm1VV3mMW+Z1SqH/EAK6jlrJ5OqmsUf0joEro3elVKqN2fT3+O9/nzfgFJeDPkxUz2v+eY/6r+df+WIy6lxeM+YINASN5lUHjZnu6PQucOeCr+FQoq03BA1Q5/mxrP5vLV7gfxr432c8a+BpNs49/NdzpVX58DSEdfWmXmdA1mdkIa8BmukYfWYqgBz2AfTJ0INzrrnQ2yv1HC894YmnthY1qB/TlT15kKrOGMYB1GUi2aMBcu0/XUcS2o53FjRAhaFdVv2jB70xV1/Myrk0KIdIGqBd/T1gHiIyAsSGP50RUNB9rnSM/Z2msWkde80d4mVlLL+INci9580mCnMAQgO0r7RSQMhxm9GL6eNZGSbmu1j7vugY/zYE1GMvqDY4wsFKbZKEezTwCDkB0SwWKBVUBEwcTfKOojDL/f/ldgA0n0BtZoFKSmJwtM1xCLNW9LBWamISmFNE01mgVAQJEAy2QV4HjLQGfeQJWW5nB7BBM/lKyWBsTmm5j4dkG0S3O9p8FlDmlEB97u81Y4vQuN37J7ZQGeZJ2gaNdGj3vazFeoktr+my6mM6XrkDwJecoksFqZwgmiRijSkRKUEINMnL3Dfj9UxEy9jIrdKHrQYrycHBxDKf5SX3DbCBJdUeIU5kgX4iZEzIDbKPPV+z7wlrB8HyY0r6SC2SeFkdFycHooHZpmgkG2HXeWKczKFAjm3VHHMoIIDMJzt2MfhZnn17uWFMxV35BcHwgYzTC0GUCfNyFz9t10n0qzkUyHEoMMcYCkTMdsz5jY4iCd1abhhTUXDyp+VAx/pU85RUgGxEaYaj3bWpgNoxjDXoExNAZJ7Vc0USurHcMKZi4KRlWeeQO/nJaSO62/ZaUPEOvskA5I4fLcyxGdzPjDMy6adjDbK9FpQgjKkIOKEs+5A22xNsZvuyW+d7HO1uahqT1i9j3ObICpjKep0pYC/1qEeD2m1hzKDBkYM7wH4YpGhmyqsBmuC4AQ4iY54y38wkrMmyx2IWjviw28vrHQ1zGDMoniPCQctbzIK1G/7A44hb+S62xLsdpRInTqzyE26y3nN/vDZVhy2MKZXE4Ch2OxWQv7AOzuPhPvYsgcWg98YNnB5jAZv8qGiHXGUkc6l2WxhztiSPrUTF5A8oYoA8x9D09o9Y1zelUkGjYhXlByzbnCMTjOOJdCgZTGMBmyTffVAVO6Sty29Z5vHD3uMJWZYyDNoNrzSltMl+yGlR0c272PQlqFQHIt7Kf789OJujKi6/5mh+nj8U0LZEPMwCpaJ9tOMnw7Lbs5txOX9Bhy2MSa45WJX3rV7iydWzHXFv6yI9in3RttHgdtnPDjU3BbF2Xu+A/8sc8LYLhbN9Oxr2TGD13kVrK6Y6NrvdcEz08iaDywDw4jO+2t1DETRj3XCtQV9z2KCrCFVHbxgvsc6B55BJQRWLPpzUwNrheyFsIz8jbYP6xVQMAEgykusTQIXmENN73Al7nBFI6BARzLbtaNi9FatOlWUDf81DCdIRv2LJmlIMDAD0CmGS/xKG2r696Vy9HCRzGNPe1VVIswwkh1wTWRsfwfWXHINxkzEHw3cnQ2GS90Sk5rEVPuQZ+8ZRY9IdLAPQHKqZ6CO4a33oMJbLbPm2SKBNDpGieb6EPWvQbFa4759Py+pseai4zFzlqwro86Z9A62FlmS9lje5em6ChP2M88Ugm8r9fVs6aE3YByRHF/e3jCWyx/J/1iSU72qPNWFP/V+1DpyKXPtyR5HptppSIcGZU++4OqvGRlf1Ab4nDZA+bNnPwCiK3ir97H8CDACHdTcaoLpwBgAAAABJRU5ErkJggg==',
  plus_vue_vue_type_style_index_0_lang =
    '.c-plus-con {\n  background: #000000;\n  color: #ffffff;\n}\n.c-img-me {\n  width: 12.8rem;\n  height: 12.8rem;\n  position: absolute;\n  right: -3.2rem;\n  bottom: -1.33333rem;\n}\n.c-sw-box {\n  width: 100%;\n  height: 100%;\n}\n.c-sw-item {\n  height: 100%;\n}\n.c-img-work-exp {\n  position: absolute;\n  bottom: 0.53333rem;\n  left: 50%;\n  transform: translate(-50%, 0);\n  width: 10rem;\n}\n.c-plus-me {\n  position: absolute;\n  top: 1.33333rem;\n  right: 0.8rem;\n  width: 2.02667rem;\n}\n.c-plus-me span {\n  display: block;\n  text-align: center;\n  font-size: 0.42667rem;\n}\n.c-plus-me span i {\n  font-weight: bold;\n  margin-left: 0.13333rem;\n  display: inline-block;\n}\n.c-plus-me img {\n  width: 2.02667rem;\n  height: 2.02667rem;\n  display: block;\n  border-radius: 50%;\n}\n.c-plus-infobox {\n  position: absolute;\n  z-index: 9999;\n  top: 1.06667rem;\n  left: 0.4rem;\n  width: 9.06667rem;\n}\n.c-plus-infobox table {\n  width: 100%;\n  table-layout: fixed;\n}\n.c-plus-infobox table td {\n  width: 33.33%;\n  height: 0.8rem;\n}\n.c-plus-infobox table td.intro {\n  width: 100%;\n  word-break: break-all;\n  word-wrap: break-word;\n  line-height: 0.8rem;\n}\n.c-plus-chartbox {\n  width: 100%;\n  height: 100vh;\n}\n.c-plus-chartbox > div {\n  height: 50vh;\n}\n.c-sw-title {\n  font-size: 0.53333rem;\n  position: absolute;\n  top: 0.26667rem;\n  left: 50%;\n  transform: translate(-50%, 0);\n}\n.c-sw-subtitle {\n  color: #CCCCCC;\n}\n.c-sw-itembox {\n  margin-top: 2.13333rem;\n  padding: 0.8rem;\n  font-size: 0.42667rem;\n  line-height: 0.8rem;\n}\n.c-sw-flexbox {\n  display: flex;\n  flex-direction: row;\n}\n.c-sw-flexbox > div {\n  flex: 1;\n}\n.c-sw-flexbox .c-sw-flexitem-end {\n  text-align: right;\n}\n@keyframes arrow_move {\nfrom {\n    transform: translateY(0.26667rem);\n    opacity: 1;\n}\nto {\n    transform: translateY(0);\n    opacity: 0;\n}\n}\nimg.arrow {\n  position: absolute;\n  bottom: 0.32rem;\n  right: 0.26667rem;\n  width: 0.8rem;\n  z-index: 99;\n  animation: arrow_move 2s infinite ease-out;\n}\n@keyframes arrow_move_h {\nfrom {\n    transform: translateX(0.26667rem);\n    opacity: 1;\n}\nto {\n    transform: translateX(0);\n    opacity: 0;\n}\n}\nimg.arrow-h {\n  position: absolute;\n  top: 1.33333rem;\n  right: 0.32rem;\n  width: 0.8rem;\n  z-index: 99;\n  animation: arrow_move_h 2s infinite ease-out;\n}\n.c-back {\n  position: fixed;\n  top: 0.16rem;\n  left: 0.16rem;\n  width: 1.06667rem;\n  z-index: 9999;\n}\n'
const _hoisted_1 = { class: 'c-plus-con' },
  _hoisted_2 = {
    class: 'ani c-plus-me',
    'swiper-animate-effect': 'bounceIn',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '0.3s'
  },
  _hoisted_3 = { key: 0, class: 'male' },
  _hoisted_4 = { key: 1, class: 'female' },
  _hoisted_5 = { class: 'c-plus-infobox' },
  _hoisted_6 = {
    class: 'ani',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '0.3s'
  },
  _hoisted_7 = {
    class: 'ani',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '0.6s'
  },
  _hoisted_8 = createVNode('td', null, null, -1),
  _hoisted_9 = {
    class: 'ani',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '1.2s'
  },
  _hoisted_10 = createVNode('td', null, null, -1),
  _hoisted_11 = {
    class: 'ani',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '0.9s'
  },
  _hoisted_12 = {
    class: 'ani',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '1.2s'
  },
  _hoisted_13 = createVNode('td', null, null, -1),
  _hoisted_14 = {
    class: 'ani',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '1.5s'
  },
  _hoisted_15 = createVNode('td', null, '', -1),
  _hoisted_16 = createVNode('td', null, null, -1),
  _hoisted_17 = {
    class: 'ani',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '1.8s'
  },
  _hoisted_18 = createVNode('td', null, '', -1),
  _hoisted_19 = createVNode('td', null, null, -1),
  _hoisted_20 = createVNode('img', { class: 'arrow', src: _imports_1 }, null, -1),
  _hoisted_21 = createVNode(
    'div',
    { class: 'c-plus-chartbox' },
    [
      createVNode('div', { class: 'c-radar-chartbox', id: 'radarChartbox' }),
      createVNode('div', { class: 'c-bar-chartbox', id: 'barChartbox' })
    ],
    -1
  ),
  _hoisted_22 = createVNode('img', { class: 'arrow', src: _imports_1 }, null, -1),
  _hoisted_23 = createVNode('div', { class: 'c-sw-title' }, '', -1),
  _hoisted_24 = createVNode('img', { class: 'arrow-h', src: _imports_2 }, null, -1),
  _hoisted_25 = { class: 'c-sw-itembox' },
  _hoisted_26 = createVNode('div', { class: 'c-sw-subtitle' }, ':', -1),
  _hoisted_27 = {
    class: 'ani',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '0.3s'
  },
  _hoisted_28 = createVNode('div', { class: 'c-sw-subtitle' }, ' / :', -1),
  _hoisted_29 = {
    class: 'ani c-sw-flexbox',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '0.4s'
  },
  _hoisted_30 = { class: 'c-sw-flexitem-start' },
  _hoisted_31 = { class: 'c-sw-flexitem-end' },
  _hoisted_32 = createVNode('div', { class: 'c-sw-subtitle' }, ':', -1),
  _hoisted_33 = {
    class: 'ani',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '0.5s'
  },
  _hoisted_34 = createVNode('img', { class: 'arrow', src: _imports_1 }, null, -1),
  _hoisted_35 = createVNode('div', { class: 'c-sw-title' }, '', -1),
  _hoisted_36 = createVNode('img', { class: 'arrow-h', src: _imports_2 }, null, -1),
  _hoisted_37 = { class: 'c-sw-itembox' },
  _hoisted_38 = createVNode('div', { class: 'c-sw-subtitle' }, ':', -1),
  _hoisted_39 = {
    class: 'ani',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '0.3s'
  },
  _hoisted_40 = createVNode('div', { class: 'c-sw-subtitle' }, ' / :', -1),
  _hoisted_41 = {
    class: 'ani c-sw-flexbox',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '0.4s'
  },
  _hoisted_42 = { class: 'c-sw-flexitem-start' },
  _hoisted_43 = { class: 'c-sw-flexitem-end' },
  _hoisted_44 = createVNode('div', { class: 'c-sw-subtitle' }, ':', -1),
  _hoisted_45 = {
    class: 'ani',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '0.5s'
  },
  _hoisted_46 = createVNode('img', { class: 'arrow', src: _imports_1 }, null, -1),
  _hoisted_47 = createVNode('div', { class: 'c-sw-title' }, '', -1),
  _hoisted_48 = createVNode('img', { class: 'arrow-h', src: _imports_2 }, null, -1),
  _hoisted_49 = { class: 'c-sw-itembox' },
  _hoisted_50 = createVNode('div', { class: 'c-sw-subtitle' }, ':', -1),
  _hoisted_51 = {
    class: 'ani',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '0.3s'
  },
  _hoisted_52 = createVNode('div', { class: 'c-sw-subtitle' }, ':', -1),
  _hoisted_53 = {
    class: 'ani c-sw-flexbox',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '0.4s'
  },
  _hoisted_54 = { class: 'c-sw-flexitem-start' },
  _hoisted_55 = createVNode('div', { class: 'c-sw-subtitle' }, '/:', -1),
  _hoisted_56 = {
    class: 'ani',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '0.5s'
  },
  _hoisted_57 = createVNode('img', { class: 'arrow', src: _imports_1 }, null, -1),
  _hoisted_58 = createVNode('div', { class: 'c-sw-title' }, '', -1),
  _hoisted_59 = createVNode('img', { class: 'arrow-h', src: _imports_2 }, null, -1),
  _hoisted_60 = { class: 'c-sw-itembox' },
  _hoisted_61 = createVNode('div', { class: 'c-sw-subtitle' }, ':', -1),
  _hoisted_62 = {
    class: 'ani',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '0.3s'
  },
  _hoisted_63 = createVNode('div', { class: 'c-sw-subtitle' }, ':', -1),
  _hoisted_64 = {
    class: 'ani c-sw-flexbox',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '0.4s'
  },
  _hoisted_65 = { class: 'c-sw-flexitem-start' },
  _hoisted_66 = createVNode('div', { class: 'c-sw-subtitle' }, ':', -1),
  _hoisted_67 = {
    class: 'ani',
    'swiper-animate-effect': 'fadeInUp',
    'swiper-animate-duration': '0.5s',
    'swiper-animate-delay': '0.5s'
  }
function _sfc_render(e, t, i, r, n, a) {
  const o = resolveComponent('lottie'),
    s = resolveComponent('swiper-slide'),
    l = resolveComponent('swiper'),
    h = resolveComponent('van-dialog')
  return (
    openBlock(),
    createBlock('div', _hoisted_1, [
      createVNode('img', {
        class: 'c-back',
        onClick: t[1] || (t[1] = (...t) => e.onBack && e.onBack(...t)),
        src: _imports_0
      }),
      createVNode(
        l,
        {
          class: 'c-sw-box',
          direction: 'vertical',
          onInit: e.onInt,
          onSlideChange: e.onSlideChange,
          onSlideChangeTransitionEnd: e.slideChangeTransitionEnd
        },
        {
          default: withCtx(() => [
            createVNode(
              s,
              { class: 'c-sw-item' },
              {
                default: withCtx(() => [
                  createVNode('div', _hoisted_2, [
                    createVNode('img', { src: e.imgPath + '/img/avatar.jpg' }, null, 8, ['src']),
                    createVNode('span', null, [
                      createTextVNode(toDisplayString(e.myData.name), 1),
                      '' == e.myData.gender
                        ? (openBlock(), createBlock('i', _hoisted_3, ''))
                        : createCommentVNode('', !0),
                      '' == e.myData.gender
                        ? (openBlock(), createBlock('i', _hoisted_4, ''))
                        : createCommentVNode('', !0)
                    ])
                  ]),
                  createVNode('div', _hoisted_5, [
                    createVNode('table', null, [
                      createVNode('tr', null, [
                        createVNode('td', null, [
                          createVNode('span', _hoisted_6, toDisplayString(e.myData.jobIntension), 1)
                        ]),
                        createVNode('td', null, [
                          createVNode('span', _hoisted_7, toDisplayString(e.myData.currentCity), 1)
                        ]),
                        _hoisted_8
                      ]),
                      createVNode('tr', null, [
                        createVNode('td', null, [
                          createVNode(
                            'span',
                            {
                              class: 'ani',
                              'swiper-animate-effect': 'fadeInUp',
                              'swiper-animate-duration': '0.5s',
                              'swiper-animate-delay': '0.9s',
                              onClick: t[2] || (t[2] = (t) => (e.qrShow = !0))
                            },
                            ''
                          )
                        ]),
                        createVNode('td', null, [
                          createVNode('span', _hoisted_9, toDisplayString(e.myData.phone), 1)
                        ]),
                        _hoisted_10
                      ]),
                      createVNode('tr', null, [
                        createVNode('td', null, [
                          createVNode('span', _hoisted_11, toDisplayString(e.myData.education), 1)
                        ]),
                        createVNode('td', null, [
                          createVNode('span', _hoisted_12, toDisplayString(e.myData.birth), 1)
                        ]),
                        _hoisted_13
                      ]),
                      createVNode('tr', null, [
                        createVNode('td', null, [
                          createVNode('span', _hoisted_14, toDisplayString(e.myData.email), 1)
                        ]),
                        _hoisted_15,
                        _hoisted_16
                      ]),
                      createVNode('tr', null, [
                        createVNode('td', null, [
                          createVNode('span', _hoisted_17, toDisplayString(e.myData.page), 1)
                        ]),
                        _hoisted_18,
                        _hoisted_19
                      ]),
                      createVNode('tr', null, [
                        createVNode(
                          'td',
                          { class: 'intro', colspan: e.cSpan },
                          [
                            createVNode(
                              'div',
                              {
                                class: 'ani',
                                'swiper-animate-effect': 'fadeIn',
                                'swiper-animate-duration': '1.5s',
                                'swiper-animate-delay': '1.6s',
                                innerHTML: e.myData.selfAssessment
                              },
                              null,
                              8,
                              ['innerHTML']
                            )
                          ],
                          8,
                          ['colspan']
                        )
                      ])
                    ])
                  ]),
                  createVNode(
                    o,
                    {
                      class: 'c-img-me',
                      ref: (t) => (e.myAni[0] = t),
                      path: 'data/default/img/me.json',
                      autoplay: !0
                    },
                    null,
                    512
                  ),
                  _hoisted_20
                ]),
                _: 1
              }
            ),
            createVNode(
              s,
              { class: 'c-sw-item' },
              { default: withCtx(() => [_hoisted_21, _hoisted_22]), _: 1 }
            ),
            createVNode(
              s,
              { class: 'c-sw-item' },
              {
                default: withCtx(() => [
                  createVNode(
                    l,
                    {
                      class: 'c-sw-box',
                      onSlideChangeTransitionEnd: e.slideChangeTransitionEnd_inner,
                      onInit:
                        t[3] ||
                        (t[3] = (t) => {
                          e.onInt(t, 2)
                        })
                    },
                    {
                      default: withCtx(() => [
                        createVNode(
                          o,
                          {
                            class: 'c-img-work-exp',
                            ref: (t) => (e.myAni[2] = t),
                            path: 'data/default/img/project.js'
                          },
                          null,
                          512
                        ),
                        _hoisted_23,
                        _hoisted_24,
                        (openBlock(!0),
                        createBlock(
                          Fragment,
                          null,
                          renderList(
                            e.myData.project,
                            (e, t) => (
                              openBlock(),
                              createBlock(
                                s,
                                { class: 'c-sw-item', key: t },
                                {
                                  default: withCtx(() => [
                                    createVNode('div', _hoisted_25, [
                                      _hoisted_26,
                                      createVNode('p', _hoisted_27, toDisplayString(e.name), 1),
                                      _hoisted_28,
                                      createVNode('div', _hoisted_29, [
                                        createVNode('div', _hoisted_30, toDisplayString(e.time), 1),
                                        createVNode(
                                          'div',
                                          _hoisted_31,
                                          toDisplayString(e.tecnology),
                                          1
                                        )
                                      ]),
                                      _hoisted_32,
                                      createVNode('p', _hoisted_33, toDisplayString(e.desc), 1)
                                    ])
                                  ]),
                                  _: 2
                                },
                                1024
                              )
                            )
                          ),
                          128
                        ))
                      ]),
                      _: 1
                    },
                    8,
                    ['onSlideChangeTransitionEnd']
                  ),
                  _hoisted_34
                ]),
                _: 1
              }
            ),
            createVNode(
              s,
              { class: 'c-sw-item' },
              {
                default: withCtx(() => [
                  createVNode(
                    l,
                    {
                      class: 'c-sw-box',
                      onSlideChangeTransitionEnd: e.slideChangeTransitionEnd_inner,
                      onInit:
                        t[4] ||
                        (t[4] = (t) => {
                          e.onInt(t, 3)
                        })
                    },
                    {
                      default: withCtx(() => [
                        createVNode(
                          o,
                          {
                            class: 'c-img-work-exp',
                            ref: (t) => (e.myAni[3] = t),
                            path: 'data/default/img/work_exp.js'
                          },
                          null,
                          512
                        ),
                        _hoisted_35,
                        _hoisted_36,
                        (openBlock(!0),
                        createBlock(
                          Fragment,
                          null,
                          renderList(
                            e.myData.experience,
                            (e, t) => (
                              openBlock(),
                              createBlock(
                                s,
                                { class: 'c-sw-item', key: t },
                                {
                                  default: withCtx(() => [
                                    createVNode('div', _hoisted_37, [
                                      _hoisted_38,
                                      createVNode('p', _hoisted_39, toDisplayString(e.name), 1),
                                      _hoisted_40,
                                      createVNode('div', _hoisted_41, [
                                        createVNode('div', _hoisted_42, toDisplayString(e.time), 1),
                                        createVNode(
                                          'div',
                                          _hoisted_43,
                                          toDisplayString(e.number),
                                          1
                                        )
                                      ]),
                                      _hoisted_44,
                                      createVNode('p', _hoisted_45, toDisplayString(e.desc), 1)
                                    ])
                                  ]),
                                  _: 2
                                },
                                1024
                              )
                            )
                          ),
                          128
                        ))
                      ]),
                      _: 1
                    },
                    8,
                    ['onSlideChangeTransitionEnd']
                  ),
                  _hoisted_46
                ]),
                _: 1
              }
            ),
            createVNode(
              s,
              { class: 'c-sw-item' },
              {
                default: withCtx(() => [
                  createVNode(
                    l,
                    {
                      class: 'c-sw-box',
                      onSlideChangeTransitionEnd: e.slideChangeTransitionEnd_inner,
                      onInit:
                        t[5] ||
                        (t[5] = (t) => {
                          e.onInt(t, 4)
                        })
                    },
                    {
                      default: withCtx(() => [
                        createVNode(
                          o,
                          {
                            class: 'c-img-work-exp',
                            ref: (t) => (e.myAni[4] = t),
                            path: 'data/default/img/growth.js'
                          },
                          null,
                          512
                        ),
                        _hoisted_47,
                        _hoisted_48,
                        (openBlock(!0),
                        createBlock(
                          Fragment,
                          null,
                          renderList(
                            e.myData.eduExp,
                            (e, t) => (
                              openBlock(),
                              createBlock(
                                s,
                                { class: 'c-sw-item', key: t },
                                {
                                  default: withCtx(() => [
                                    createVNode('div', _hoisted_49, [
                                      _hoisted_50,
                                      createVNode('p', _hoisted_51, toDisplayString(e.school), 1),
                                      _hoisted_52,
                                      createVNode('div', _hoisted_53, [
                                        createVNode('div', _hoisted_54, toDisplayString(e.time), 1)
                                      ]),
                                      _hoisted_55,
                                      createVNode('p', _hoisted_56, toDisplayString(e.name), 1)
                                    ])
                                  ]),
                                  _: 2
                                },
                                1024
                              )
                            )
                          ),
                          128
                        ))
                      ]),
                      _: 1
                    },
                    8,
                    ['onSlideChangeTransitionEnd']
                  ),
                  _hoisted_57
                ]),
                _: 1
              }
            ),
            createVNode(
              s,
              { class: 'c-sw-item' },
              {
                default: withCtx(() => [
                  createVNode(
                    l,
                    {
                      class: 'c-sw-box',
                      onSlideChangeTransitionEnd: e.slideChangeTransitionEnd_inner,
                      onInit:
                        t[6] ||
                        (t[6] = (t) => {
                          e.onInt(t, 5)
                        })
                    },
                    {
                      default: withCtx(() => [
                        createVNode(
                          o,
                          {
                            class: 'c-img-work-exp',
                            ref: (t) => (e.myAni[5] = t),
                            path: 'data/default/img/cert.json'
                          },
                          null,
                          512
                        ),
                        _hoisted_58,
                        _hoisted_59,
                        (openBlock(!0),
                        createBlock(
                          Fragment,
                          null,
                          renderList(
                            e.myData.certificate,
                            (e, t) => (
                              openBlock(),
                              createBlock(
                                s,
                                { class: 'c-sw-item', key: t },
                                {
                                  default: withCtx(() => [
                                    createVNode('div', _hoisted_60, [
                                      _hoisted_61,
                                      createVNode('p', _hoisted_62, toDisplayString(e.name), 1),
                                      _hoisted_63,
                                      createVNode('div', _hoisted_64, [
                                        createVNode('div', _hoisted_65, toDisplayString(e.time), 1)
                                      ]),
                                      _hoisted_66,
                                      createVNode('p', _hoisted_67, toDisplayString(e.desc), 1)
                                    ])
                                  ]),
                                  _: 2
                                },
                                1024
                              )
                            )
                          ),
                          128
                        ))
                      ]),
                      _: 1
                    },
                    8,
                    ['onSlideChangeTransitionEnd']
                  )
                ]),
                _: 1
              }
            )
          ]),
          _: 1
        },
        8,
        ['onInit', 'onSlideChange', 'onSlideChangeTransitionEnd']
      ),
      createVNode(
        h,
        {
          show: e.qrShow,
          'onUpdate:show': t[7] || (t[7] = (t) => (e.qrShow = t)),
          title: ' ',
          onConfirm: t[8] || (t[8] = (t) => (e.qrShow = !1))
        },
        {
          default: withCtx(() => [
            createVNode('img', { class: 'c-n-qrWx', src: e.imgPath + e.myData.wechat }, null, 8, [
              'src'
            ])
          ]),
          _: 1
        },
        8,
        ['show']
      )
    ])
  )
}
_sfc_main.render = _sfc_render
export default _sfc_main
